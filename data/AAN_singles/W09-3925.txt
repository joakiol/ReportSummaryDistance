Proceedings of SIGDIAL 2009: the 10th Annual Meeting of the Special Interest Group in Discourse and Dialogue, pages 160?169,Queen Mary University of London, September 2009. c?2009 Association for Computational LinguisticsSpeeding Up the Design of Dialogue Applications by Using DatabaseContents and Structure InformationL.
F. D?Haro, R. Cordoba, J. M. Lucas, R. Barra-Chicote, R. San-SegundoSpeech Technology GroupDept.
of Electronic EngineeringUniversidad Polit?cnica de Madrid, Spain{lfdharo, cordoba, juanmak, barra, lapiz}@die.upm.esAbstractNowadays, most commercial and researchdialogue applications for call centers arecreated using sophisticated and fully-feature development platforms.
Surpris-ingly, most of them lack of some kind ofacceleration strategy based on an automaticanalysis of the contents or structure of thebackend database.
This paper describes ourefforts to incorporate this kind of informa-tion which continues the work done in(D?Haro et al 2006).
Our main proposedstrategies are: the generation of automaticstate proposals for defining the dialogueflow network, the automatic selection ofslots to be requested using mixed-initiative,the semi-automatic generation of SQLstatements, and the quick generation of thedata model of the application and the con-nection with the database fields.
Subjectiveand objective evaluations demonstrate theadvantages of using the accelerations andtheir high acceptance, both in our currentproposals and in previous work.1 IntroductionCurrently, the growing demand of automatic dia-logue services for different domains, user profiles,and languages has led to the development of alarge number of sophisticated commercial and re-search platforms that provide all the necessarycomponents for designing, executing, deployingand maintaining such services with minimum ef-fort and with innovative functions that make theminteresting for developers and final users.In their effort for accelerating the design, mostcommercial platforms provide several high-leveltools to build multimodal and multilingual dia-logue applications using widespread standardssuch as VoiceXML, CCXML, J2EE, RCP, SRGS,etc.
In addition, they include state-of-the-art mod-ules such as speech recognizers, high qualityspeech synthesizers, language identification capa-bilities, etc., that guarantees user satisfaction andinteraction.
In addition, they present a very user-friendly graphical interface that makes easy thedevelopment of very complex dialogues, besidesthe incorporation of predefined libraries for typicaldialogues states such as requesting card or socialsecurity numbers, etc., and additional assistants fordebugging, logging and simulate the service.In contrast to commercial platforms, research oracademic platforms (e.g.
CSLU-RAD 1 , Dialog-Designer2, Olympus3, Trindi-kit 4, etc.)
do not nec-essary incorporate all the above-mentioned fea-tures; especially because they are limited to thenumber of standards that they are able to handleand to the integration level with other platforms, aswell as the number of capabilities that they canoffer to the users and programmers.
However, theyallow more complex dialogue interactions, most ofthem are freely available as open source, and usingthird party modules it is possible to extend theirfunctionalities.Surprisingly, these platforms do not include anykind of acceleration strategies based on the con-tents or in the structure of the backend databasethat, as we will show, can provide important in-formation for the design.
Next, we will describesome examples of applications or dialogue systemsthat use data mining techniques or heuristic infor-1 http://cslu.cse.ogi.edu/toolkit/2 http://spokendialogue.dk/3 http://www.ravenclaw-olympus.org/4 http://www.ling.gu.se/projekt/trindi/trindikit/160mation extracted from the database contents in or-der to create automatic dialogue services.In (Polifroni and Walker, 2006), different datamining techniques are used to automate the selec-tion of content data to be used in system initiativequeries and to provide summarized answers.
Atruntime, the system automatically selects the at-tributes to constrain the prompt queries that narrowdown best the interaction flow with the final users.In (Chung, 2004), the database is used togetherwith a simulation system in order to generate thou-sands of unique dialogues that can be used to trainthe speech recognizer and the understanding mod-ule, as well as to diagnose the system behaviouragainst problematic user?s interactions or answers.In (Pargellis et al 2004), a complete platform tobuild voice services where the database contentschange constantly is described.
At runtime, thesystem retrieves information that the user is inter-ested in according to his personal profile.
In addi-tion, the system is able to create automatically dy-namic speech grammars and prompts, as well asthe dialogue flow for presenting information to theuser, or for solving some interaction errors throughpredefined dialogue templates.Finally, (Feng et al 2003) proposes a very dif-ferent approach, not using a database but miningthe content of corporate websites for automaticallycreating spoken and text-based dialogue applica-tions for custom care.
Although the dialogue flowis predefined, it is interesting to see that importantknowledge, for the different modules of the dia-logue system, can also be extracted and used froma well-designed content.In this work, we have solved some of the limita-tions of current platforms by incorporating suc-cessfully heuristic information into the differentassistants of the platform and allowing them tocollaborate between each other in several ways, asthey collect the information already provided in thefirst stages of the design to improve and acceleratethe design in the last stages.
This way, the platformassistants classify which fields of the databasecould be relevant for the design, generate differentkinds of automatic proposals according to the de-sign step, reduce the information displayed to thedesigner, and accelerate different typical proce-dures required to define the application.The paper is organized as follows: section 2provides an overview of the overall architecture ofthe platform, including a brief description of themain assistants and layers that makes it up.
Section3 describes previous accelerations in the platformrelated with the current work; Sections 4, 5, and 6describe in detail the new strategies and the assis-tants that include them.
Section 7 describes thesubjective and objective evaluations, and section 8outlines some conclusions and future work.2 Platform ArchitectureThe Application Generation Platform (AGP), cre-ated during the European project GEMINI, is anopen and modular architecture made up of differ-ent assistants and tools that simplifies the genera-tion of multimodal and multilingual dialogue ap-plications with a high adaptability to differentkinds of services (see Figure 4 in Appendix A).The platform consists of three main layers inte-grated into a common graphical user interface(GUI) that guides the designer step-by-step andlets him go back and forth.In the first layer, called Framework Layer, thedesigner specifies global aspects related to the ap-plication and the data.
This layer includes the DataModel Assistant (DMA), where the database struc-ture is created, and the Data Connector Model As-sistant (DCMA), where the application specificdatabase access functions are created.The next layer, called Retrieval layer, includesthe State Flow Model Assistant (SFMA) and theRetrieval Model Assistant (RMA).
The former isused to create the dialogue flow at an abstractlevel, by specifying the high-level states of the dia-logue, plus the slots to ask to the user and the tran-sitions among states.
Then, the later is used to in-clude all the actions (e.g., variables, loops, if-conditions, math or string operations, conditionsfor making transitions between states, calls to dia-logs to provide/obtain information to/from theuser) to be done in each state defined previously.Finally, the third layer, called Dialogs Layer,contains the assistants that complete the generalflow specifying for each dialogue the details thatare modality and language dependent.
For instance,the prompts and grammars for each language andmodality, the definition of user profiles, the ap-pearance and contents of the Web pages, the errortreatment for speech recognition errors or Internetaccess, the presentation of information on screen orusing speech, etc., are defined.
Furthermore, the161VoiceXML and xHTML scripts used by the real-time system are automatically generated.3 Previous Acceleration StrategiesIn (D?Haro et al 2006) and (D?Haro et al 2004),we described several acceleration strategies basedon using the data model structure and applied themsuccessfully to different assistants of the platform,with a special emphasis in the assistant for definingthe actions to be done in each dialogue (i.e.
RMA).The data model information was used to:a.)
Create configurable and generic dialogueproposals for obtaining (called DGet) and forshowing (called DSay) information from/to theuser.
In this case, the assistant creates a DGet orDSay dialogue for each class and attribute defined.b.)
Automatically propose the actions requiredfor completing the information for each state of thedialogue flow; basically, the assistant proposes thedialogues to ask information to the user, the data-base access functions, and the dialogues to showinformation to the user.
Figure 1 shows an exampleof the proposals for a banking application.
In thisexample, the designer is editing a dialogue wheregiven a currency name the system provides its spe-cific information (buy and sell price, general in-formation, etc.).
Using the proposal window, allthe designer would need to do is to select the cor-responding DGet in the window(DGet_CurrencyName_IN_CLASS_Currency),then the database access function GetCurrencyBy-Name, and finally the DSays that provide the de-sired attributes from the currency.
In order to pro-vide these proposals, we use the information of therelationships between slots and arguments of thedatabase functions and the attributes and classes inthe data model (section 5 and 6).
When there is norelationship specified, we apply relaxed filters suchas matching in types, similarity in names, or samenumber of arguments and slots in the state.c.)
Automate the process of passing informationamong actions/dialogues by proposing the vari-ables that best match the connections or allowingthe creation of new variables when no match ex-ists.
This is a critical aspect of dialogue applica-tions design.
Several actions and states have to be?connected?
as they use the information from thepreceding dialogues.
In general, most current de-sign platforms allow the same kind of functional-ity, offering the user a selectable list of all theavailable variables in the dialogue.
In other cases,especially considering the connections with data-base access functions, some platforms only allowthe designer to define the matching by modifyingby hand the script code.
In this acceleration, wehave tried to provide a better solution by automat-ing the connection through automatic proposals.The assistant detects the input/output variables re-quired in each action and offers the most suitablealready defined variable of a compatible type; ifthere are more than one variable to show, the assis-tant sorts them according to the name similaritybetween variable and dialogue.
If there is no com-patible variable already defined in the system orthe name proposed is not desired, the assistant al-lows the creation of a new local/global variable.Additionally, the assistant includes a windowwhere all this matching can be edited.Other accelerations included in this assistantwere the quick creation of mixed-initiative dia-logues, dialogues with over-answering (that do notexist in any current dialogue platform) and thequick definition of dialogue variables.Figure 1.
Example of automatic dialogues anddatabase access function proposalsIn the present work, the new accelerations addi-tionally exploit the database contents and havebeen incorporated into the assistant to define thedata model structure (section 4), into the assistantfor defining the database access functions (section1625), and into the assistant to define the states of thedialogue flow (section 6).
The next sections de-scribe in detail these assistants and accelerations.4 Strategies Applied to the Data ModelAssistant (DMA)This assistant helps in the creation of the datamodel structure of the service through a visual rep-resentation of all possible fields to be requestedand presented to the user, which consists of objectoriented classes and attributes.
The goal with theseclasses and attributes is to provide information tothe next assistants in the platform about whichfields in the database are relevant for the serviceand the relationships between tables and fields.Figure 2.
Example of class and attributesEach class, see Figure 2, can be characterized bya list of attributes, a description, and optionally alist of base classes (inheriting their attributes).
Theattributes may be: a) of atomic types (e.g., string,Boolean, float, date, etc., e.g., AvailableBalance),b) complex objects, obtained by embedding or re-ferring to an existing class (e.g., AccountHolder),or c) lists of either atomic type items or complexobjects (e.g., LastTransactionList).The main acceleration strategies, previously in-cluded in this assistant, are: a) re-utilization of li-braries with models created beforehand, which canbe copied totally or partially, or used to create anew class by mixing them, b) automatic creation ofa class when it is referenced as an attribute insideanother one, and c) definition of classes inheritingthe attributes of a base class.
Since this is one ofthe first assistants of the platform, a significanteffort was done to accelerate the creation of thedatabase structure and to include information aboutthe relationships between the class attributes andthe fields and tables in the database.
To start with,the system generates and analyzes automaticallyheuristic information from the database contents.Then, with this information, the system proposesfull custom classes and attributes that the designercan use when creating the data structure.4.1 Extraction of heuristic informationThe process is done using an open SQL query toretrieve information of every table, field and recordin the database.
This information includes thename and number of the tables and fields, and thenumber of records for every table.
In addition, thefollowing features for each field are also gener-ated: a) field type, b) average length, c) number ofempty records, d) language dependent fields, ande) the proportion of records that are different.
Thisinformation is shared among the assistants in orderto simplify the design or to improve the presenta-tion of information in the posterior assistants.
Forinstance, they are used for: (a) to accelerate thecreation of the data model structure (section 4.2),(b) and (e) to unify slots as mixed initiative or not(see section 6.1), (c) to sort by relevance the attrib-utes displayed by the wizard when creating the da-tabase structure (section 4.2), and (d) to not gener-ate states for these fields in the SFMA since thedialogue flow in this assistant is language inde-pendent (section 6.1).An important issue we found when retrievingthe field type was that sometimes the metadata in-formation provided by the SQL function was in-correct due to: a) the driver for accessing the data-base was only able to return a limited number oftypes, e.g.
Boolean or dates were mapped as inte-ger or string types respectively, b) the designer ofthe database defined the field using a generic typesuch as string or float when the visual inspection ofthe records showed that they actually correspondedto dates or integers, c) there were problems to mapspecial types such as hyperlinks, binary, etc.
intothe types supported by our platform.In order to solve these problems, we imple-mented a post-processing step based on using regu-lar expressions to detect the following types: inte-gers, floats, dates, strings, Boolean, mixed orempty fields.
In general, the process is to analyzeall non-empty records in a given field and to selectas field type the one with more than the 90% ofoccurrences.
Exceptions to this rule are: a) a nu-meric field is considered integer if all its recordsare classified as such, if not it is classified as float,163b) the empty type is assigned to fields with morethan 95% of empty records.In order to analyse the performance of the post-processing step, an objective evaluation was car-ried out.
In this evaluation, twenty-one databases,most of them available online, were retrieved andvisually inspected field by field.
In total, therewere 109 tables (an average of 5 tables per data-base), 767 fields and 610.506 records, which wereclassified by a human evaluator.In our results, the average recognition was89.6%, obtaining the best rates for dates, strings,and numeric quantities, which are the most com-mon types in most databases.
Analyzing in detailthe misrecognitions, 0.9% of floats were incor-rectly detected as integers due to values such as2.0, 30.0, etc.
which were automatically returnedby the database driver without the decimal part.Another source of errors was detecting some nu-meric quantities due to special symbols such asdashes, percentages, or the euro symbol, whichwere incorrectly interpreted as a string type (3.3%and 1.6%).
The major problems occurred for dis-tinguishing between the String type and what wecalled Mixed type (i.e.
fields containing: URLs,emails, long strings, etc.)
since they are, in prac-tice, the same.
However, we wanted to separatethem since for a speech recognizer they may behandled using different strategies (e.g.
spelling,general grammars, etc.).
The importance of theseresults is that they mean a reduction in the numberof times the designer will need to change the pro-posed type for a given attribute when creating theclasses (section 4.2).4.2 Semi-automatic classes proposalsAfter collecting all the heuristics, the assistant pro-vides a wizard window that allows the designer tocreate the attributes for a new class from the tablesand fields of the database or from already existingclasses in the model.
The information of the se-lected field and table is saved in the definition ofthe class attribute allowing future assistants in theplatform to access this information easily (section5.1 and 6.1).
The heuristic information is used toset automatically the field types in the wizard, al-though it can be edited by the designer.
Besides,the wizard also proposes automatic alternativenames for the new class and attributes when it de-tects duplicated names with already defined ones.Finally, if the number of tables in the database istoo high the designer can select those that will bereally needed during the design, this way reducingthe information displayed on the screen.
In addi-tion, it is also possible to customize the name ofthe tables in the database in order to make themmore intuitive to the dialogue designer.5 Strategies Applied to the Data Connec-tor Model Assistant (DCMA)This assistant allows the definition of the proto-types (i.e.
only the input and output parameters) ofthe database access functions used in the runtimesystem.
The advantage of using prototypes is thattheir actual implementation is not required duringthe design of the dialogue flow.The main acceleration strategy, previously in-cluded in this assistant, was the possibility of relat-ing the input/output arguments to the attributes andclasses of the data model.
This information is usedby the retrieval model assistant to create dialogueproposals and to automatically propose databaseaccess functions for a given dialogue in the design(section 3).
In this work, we have introduced a newacceleration by incorporating a wizard window thatallows the creation and debugging of the SQLstatements used at run-time.5.1 Semi-automatic generation of SQL que-riesThe main motivation behind this wizard windowwas to simplify the process of creating the functionprototypes (API), reducing the necessity of learn-ing a new programming language (SQL), and tosimplify the process of adding the query into thereal-time modules and scripts.
The new wizardsemi-automatically creates the SQL statements forthe given prototype and provides a pre-view of theresults that the system would retrieve in the real-time system (see Figure 5 in Appendix A).
Thisnew acceleration is interesting since currently fewdevelopment platforms include such kind of wizardforcing the designer to use third party software.Besides, current wizards only provide debuggingtools, nice GUI features or support for many DBstandards, but no automatic query proposals.In order to automatically create the SQL state-ment, the assistant uses the input arguments (de-fined in the function prototype) as constraints forthe WHERE clause, and the information of the164output arguments as returned fields for the SE-LECT clause.
The assistant allows the inclusion ofnew input or output arguments if the function pro-totype is not complete or if the designer wants totest new combinations of arguments.Finally, the wizard allows the designer to pre-view the records that the proposed SQL statementwill retrieve at real-time.
In order to debug thequery, the designer specifies, using a pop-up win-dow, the values for the input arguments of thefunction to test the query (as acceleration, the wiz-ard automatically proposes real values retrievedfrom the database).6 Strategies Applied to the State FlowModel Assistant (SFMA)This assistant is used to define the dialogue flow atan abstract level, i.e.
specifying only the high-levelstates of the dialogue, the slots to be asked to theuser, and the transitions between states, but not thespecific details of each state.
The flow is specifiedusing a state transition network representation thatis common in this kind of platforms and dialoguemodelling.
The GUI allows the definition of newstates using wizard-driven steps and a drag-and-drop interface.
An important acceleration strategyfrom the previous version is the possibility ofspecifying the slots through attributes offeredautomatically from the data model.
The new accel-erations are the automatic proposal of the slots tobe requested using system or mixed initiative dia-logues (section 6.1) and the automatic generationof proposals of states for defining the dialogueflow (section 6.2).6.1 Automatic unification of slots for mixedinitiativeThe idea of this acceleration is to allow the systemto propose automatically when two or more slotsmust be requested one by one (using directedforms) or at the same time (using mixed initiativeforms) according to the VoiceXML standard.This functionality is only available when theslots to be analyzed have been defined from a tableand field in the backend database.
In this case, theassistant uses the heuristics obtained for the givenfields and applies a set of customizable rules usedto decide which slots can be unified and whichones cannot.
Some examples of the rules applied tonot propose the unification are: a) one of the slotsis defined as a string with an average length greaterthan 20 characters, an average number of wordsper record greater than 3, and the other slot is aninteger/float number greater than 5 characters.
Inthis case, the rule avoids the recognition of longstrings, e.g.
an address or name, plus the recogni-tion of long numeric quantities, e.g.
phone or ac-count numbers, b) when two slots are defined asstrings and the sum of the average length of both isgreater than 20 characters; in this case, the systemtries to avoid the recognition of very long sen-tences.
c) there are two numeric slots with a pro-portion of different values close to one, and thetotal number of records of both fields is high (con-figurable value), then the system determines thatthese slots have a large vocabulary and a highprobability of misrecognition.
So, in all thesecases, the system decides that it is better to ask oneslot at a time (system initiative).
In case there aremore than two slots, the system checks differentcombinations of the slots in order to find those thatcan be requested at the same time and leaving theother one to be requested alone.6.2 Automatic statesIn this strategy, the assistant creates automaticallydialogue states that include the slots to be re-quested to the user.
Using the information of thedatabase structure and the database access func-tions, the wizard allows the designer to access tothe following state proposals:Empty states and already created states: Thefirst one allows the creation of a new empty state,with no defined slots inside, that the designer candefine completely afterwards.
This way, we allowa top-down design.
The second one allows the de-signer to re-use already defined states.From attributes with database dependency:This kind of states is created from any attributedefined in the database model (DMA) that refers toa database field only if the attribute has been usedas an input argument of any database access func-tion.
The proposed states contain only one slot andits name corresponds to the name of the attribute inthe data model.
However, the designer can selectseveral states to create states with multiple slots.From the database access functions: In thiscase, the system analyzes all the defined databasefunctions containing input arguments defined asatomic types.
Then, the system uses the name ofthe function as proposal for the name of the state,165and the input arguments as slots for that state.
Theassistant allows the designer to select several ofthese proposals in order to create more complexstates.
For instance, in case there is a database ac-cess function called convertCurrencies, which re-ceives three input arguments (i.e.
fromCurrency,toCurrency, and Amount), the system automati-cally creates a new state proposal called convert-Currencies that includes these three slots.
Apply-ing similar rules to the ones described in section6.1 the system would propose to request the firsttwo at the same time (mixed-initiative) and theAmount separately (directed forms).From classes defined in the data model struc-ture: In this case, the assistant creates a templatethat the designer can drag and drop into the work-space (see Figure 6 in Appendix A).
Then, a pop-up window allows the designer to select the attrib-utes to be used as slots.
The assistant expandscomplex attributes (with inheritance and objects)allowing only the selection of atomic attributes.7 EvaluationWith the objective of evaluating the performanceof each of the acceleration strategies and assistantsdescribed above, we carried out a subjective andobjective evaluation with 9 developers with differ-ent experience levels and profiles (4 novices, 3intermediates, and 2 experts) on designing dia-logue services.
They were requested to fulfil dif-ferent typical tasks covering each of the proposedaccelerations and assistants to evaluate.
Furtherdetails can be obtained in (D?Haro, 2009).For the subjective evaluation, the participantswere asked to answer a questionnaire that consistsof four questions per assistant and seventeen forthe overall platform, with a range between 1 and10.
This subjective evaluation confirms the de-signer-friendliness of the assistants, as well as theirusability, since all the assistants obtained a globalscore higher than 8.0, which is a nice result.
In de-tail, the DMA and DCMA obtained an 8.3, theSFMA a 9.0, the RMA an 8.6, and Diagen a 4.5.Regarding the acceleration strategies, see Figure3a, the evaluators scored the automatic states with9.3, the SQL generation and the unification of slotsfor mixed initiative with 9.0, and the class propos-als with 8.9.
Regarding the RMA and the accelera-tions related with the information extracted fromthe database (see section 3), the passing of argu-ments between actions and the proposal of dia-logue actions obtained a 9.8 and 8.6 respectively.For the objective evaluation, we collected themetrics proposed in (Jung et al 2008): elapsedtime, number of clicks, number of keystrokes, andnumber of corrections using the keyboard (key-stroke errors).
We compared our assistants with abuilt-in editor called Diagen, created during theGEMINI project and improved later on by(Hamerich, 2008), which features fewer accelera-tions but generates the same information specifiedby our assistants.
As accelerations, Diagen onlyprovides default templates that the designer has tocomplete and a guided procedure using differentpop-up windows to fulfil the templates.
The resultsconfirm that the design time can be reduced, inaverage for all the assistants and tasks, in morethan 45%, the number of keystrokes in 81%, andthe number of clicks in 40%.
Especially relevant isthe high reduction (85%) obtained in the RMAconsidering that it is the main task in the design.8 Conclusions and Future WorkIn this paper, we have described the main accelera-tions incorporated into a complete platform fordesigning multimodal and multilingual dialogueapplications.
The proposed accelerations strategiesare based on using information extracted from thecontents of the backend database.
The proposedaccelerations include the creation of automaticstate proposals, the unification of slots to be re-quested using mixed-initiative dialogues, and thesemi-automatic creation and debugging of SQLstatements for accessing the database, among oth-ers.
Subjective and objective evaluations confirmthat the proposed strategies are useful and contrib-ute to simplify and accelerate the design.As future work, we propose the extraction ofnew heuristic information, the creation of newrules for unifying slots for mixed-initiative dia-logues.
Considering the negative values in Figure3b, we propose to improve the GUI for definingthe connections among states in the SFMA, and toimprove the DCMA by offering new automatedmethods for creating the prototypes.9 AcknowledgementsThis work has been supported by ROBONAUTA(DPI2007-66846-c02-02) and SD-TEAM(TIN2008-06856-C05-03).166Figure 3.
Average result for the: a) subjective evaluation for the accelerations, b) objective resultsReferencesChung, G. 2004.
Developing a Flexible Spoken DialogSystem Using Simulation.
ACL 2004.D?Haro.
L. F. 2009.
Speed Up Strategies for the Crea-tion of Multimodal and Multilingual Dialogue Sys-tems.
PhD Thesis.
Univ.
Polit?cnica de Madrid.D?Haro, L. F., Cordoba, R., et al 2008.
LanguageModel Adaptation for a Speech to Sign LanguageTranslation System Using Web Frequencies and aMAP framework.
Interspeech 2008, pp.
2119-2202.D?Haro, L. F., Cordoba, R., et al 2006.
An advancedplatform to speed up the design of multilingual dia-logue applications for multiple modalities SpeechCommunication Vol.
48, Issue 8, pp.
863-887.D?Haro, L. F., Cordoba, R., et al 2004.
Strategies toreduce design time in multimodal/multilingual dialogapplications.
ICSLP 2004, pp IV-3057?3060.Feng, J., Bangalore, S., Rahim, M. 2003.
WEBTALK:Mining Websites for Automatically Building DialogSystems.
ASRU 2003, pp.
168-173.Hamerich, S. 2008.
From GEMINI to DiaGen: Improv-ing Development of Speech Dialogues for EmbeddedSystems.
9th SIGDIAL, pp.
92-95.Jung, S., Lee, C., et.
al.
2008.
DialogStudio : A Work-bench for Data-driven Spoken Dialogue System De-velopment and Management.
Speech Communica-tions, 50 (8-9), pp.
683-697.Pargellis, A. N., Kuo, H. J., Lee, C. 2004.
An automaticdialogue generation platform for personalized dia-logue applications.
Speech Communication Vol.
42,pp.
329-351.Polifroni, J. and Walker, M. 2006.
Learning DatabaseContent for Spoken Dialogue System Design.
LREC2006, pp.
143-148.San-Segundo et al 2008.
Speech to sign language trans-lation system for Spanish.
Speech CommunicationVol.
50, pp.1009?1020.167Appendix A.
Additional FiguresFigure 4.
Platform architecture.
In yellow colour the assistants with the new accelerations described inthis paper.
In pink colour assistants with previous accelerations (section 3)Figure 5.
Wizard for creating and debugging the SQL statements for accessing the backend database.In the example, the proposed query allows the selection of all account numbers for a given customer(using his/her authentication code) and type of account (i.e.
passbook saving accounts)168Figure 6.
Workspace for creating the state transition network and pop up window with state proposals.In the example, the designer creates the state Transaction from the Class_Transaction template (cre-ated in the DMA, see Figure 2) and selects as slots the TransactionAmount, CreditAccountNumber andDebitAccountNumber (not shown)169
