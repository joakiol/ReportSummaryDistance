Computing Story TreesAl f red  Cor re i raDepar tment  of Computer  Sc ienceThe Univers i ty  of Texas at Aust inAust in ,  Texas 78712A theory of understanding (parsing) texts as a process of collecting simple textualpropositions into thematically and causally related units is described, based on the conceptof macrostructures as proposed by Kintsch and van Dijk.
These macrostructures areorganized into tree hierarchies, and their interrelationships are described in rule-basedstory grammars related to the Kowalski logic based on Horn clauses.
A procedure forconstructing and synthesizing such trees from semantic network forms is detailed.
Theimplementation of this procedure is capable of understanding and summarizing any story itcan generate using the same basic control structure.1.
IntroductionOne of the most difficult tasks in the field of com-putational linguistics is that of processing (parsing orunderstanding) bodies of connected textual material,from simple narratives like fairy tales and children'sstories, to complex technical articles like textbooksand encyclopedia rticles.
When effective parserswere created capable of processing single sentences(Woods, 1970), (Schank, 1975b), (Norman and Ru-melhart, 1975), (Winograd, 1972), it was quickly real-ized that these same techniques were not in themselvesadequate for the larger task of processing sequences ofsentences.
The understanding of paragraphs involvesmore knowledge than and different knowledge fromthat necessary for sentences, and the structures prod-uced by a text parser need not look like the structuresof the sentences parsed individually.However, the original impetus for current rends intext processing was the effort to solve problems ofreference at the sentential level, in particular anaphoraand ellipsis (Charniak, 19722).
For example, in theparagraphJohn wanted to marry Mary.
He askedher if she would marry him, but she refused.John threatened to foreclose the mortgage onthe house where Mary's old sick father lived.They were married in June.Simple-minded syntactic techniques are generally in-sufficient to resolve referents of the form of the"they" in the last sentence above.
The human under-stander - and potentially the computer understander aswell - requires real-world knowledge about threats,familial ties and marriage to realize that "they" refersto John and Mary.Experiments with text processing led to such proce-dural constructs as frames (Minsky, 1975; Charniakand Wilks, 1976; Bobrow and Winograd, 1977),scripts and plans (Schank and Abelson, 1977), focusspaces (Grosz, 1977), and partitioned networks(Hendrix, 1976), among others.
These efforts in-volved conceptual structures consisting of large, cogni-tively unified sets of propositions.
They modelledunderstanding as a process of filling in or matching theslots in a particular structure with appropriate ntitiesderived from input text.There have also been rule-based approaches to thetext processing problem, most notably thetemplate/paraplate notion of Wilks (1975), and thestory grammars of Rumelhart (1975).
Although bothapproaches (procedures and rules) have their merits, itis a rule-based approach which will be presented here.This paper describes a rule-based computationalmodel for text comprehension, patterned after thetheory of macrostructures proposed by Kintsch andvan Dijk (1978).
The rules are notationally and con-ceptually derived from the Horn clause, especially asdescribed by Kowalski (1979).
Each rule consists ofsets of thematically, causally, or temporally relatedpropositions.
The rules are organized into a networkwith the macrostructures becoming more generalizedapproaching the root.
The resulting structure, calledthe Story Tree, represents a set of textual structures.Copyright 1980 by the Association for Computational  Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires a fee and/or  specific permission.0362-613X/80/030135-15501.00American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 135Alfred Correira Computing Story TreesThe process of generating from this network con-sists of choosing one of the rules to serve as the rootof a particular story tree and recursively instantiatingits descendants until terminal proposit ions are prod-uced (Simmons and Correira, 1979).
These proposi-tions form the text of the generated story, requiringonly a final phase to produce English sentences fromthe propositions.
Conversely, a text is understood ifits input sentences, parsed into proposit ions, can bemapped onto rules and these rules recursively mappedonto more abstract rules until a single node (the root)is achieved.
Parsing and generating use the same rulesin a similar manner for performing their respectivetasks, and the rules lend themselves to a uniform treestructure possessing an inherent summarizing property.2.
Macrost ructures  and Story Grammar  RulesIn this section the fundamental notion of macro-structure, as proposed and used by Kintsch and vanDijk, is presented and then analyzed from a computa-tional, rather than a psychological, standpoint.
Aneffective representat ion for macrostructures, derivedfrom Horn clauses and organized into story trees, isdescribed, as well as a data base for the representa-tion.2.1 Macrost ructuresKintsch and van Dijk (1975) present a system fororganizing an entire discourse into a hierarchy of ma-crostructures, which are essentially metaproposit ions.The lowest level of a discourse textual representationis the set of input propositions that corresponds e-mantically to the text sentences, clauses and/or  phras-es.
Propositions are conjoined by links of implication:if proposition A implies proposition B, then A and Bare connected, and the link is marked with thestrength of the connection, ranging from (barely) pos-sible to (absolutely) necessary.
The propositions andtheir connections reside in a text base.
A text basecan be either explicit, if all the implied informationnecessary for coherence is made explicit, or implicit, ifpropositions that can be assumed to be known or im-plied are omitted, m text is an explicit data base byitself, and all summaries of that text are implicit databases.
A college physics text would have a much moreexplicit text base than after-dinner conversation.
Thesimple narrative texts examined in this paper have atext base between these two "extremes.
"The sense in which "coherence" is used above isnot defined precisely.
Kintsch and van Dijk argue thatcoherence, or "semantic wel l - formedness",  in a textrequires, for each proposition in the text, that it belinked with one or more preceding propositions.
Thisconnection must exist for some reader in some contextconstrained by conventions for knowledge-sharing andassumption-sharing valid for that person in that con-text.The result of this linking is a linear text base whichis then mapped into a hierarchical structure in whichpropositions high in the structure are more likely to berecalled (via summaries) than those low in the struc-ture.
At the top of the hierarchy can be found propo-sitions corresponding to rhetorical categories, such as"problem" and "solution," or narrative categories,such as " introduct ion,"  "compl icat ion,"  and"re solution.
"Kintsch and van Dijk introduce a number of rulesfor relating these macrostructures to sets of input tex-tual proposit ions: information reduction (general iza-tion), deletion (of less important propositions), inte-gration (combining events with their pre- and post-conditions), and construction (which relates complexpropositions to their component sub-propositions).There are two conditions that are always true re-garding these macrostructures: a macrostructure mustbe implied by its subordinate proposit ions (i.e.
en-countering the subordinate proposit ions implies theexistence of the macrostructure), and ordered sets ofmacrostructures collected together form a meaningfulsummary of the text.
Kintsch and van Dijk believethat it is primarily macrostructures that are retainedwhen a text is understood by a human reader and thatthe macrostructures are created as the text is beingprocessed.2.2 Macros t ruc tures  as Computat iona l  ConstructsAs evidence in support of their theory, Kintsch andvan Dijk present a number of psychological experi-ments in recall and summary with human subjectsusing as a text a 1600-word narrative taken fromBoccaccio's Decameron (the Rufolo story).
As a com-putational entity, a macrostructure is a node in a storytree whose immediate descendants consist of the sub-ordinate proposit ions by which the node is implied,and is itself a descendant of the macrostructure it(partially) implies.
Every macrostructure in this tree isthe root of a derivation tree whose terminals are sim-ple propositions.Each level of the tree shares the attribute of sum-marizabil ity, i.e.
a summary of the text may be ex-tracted from any level of the tree, becoming less spe-cific as the summary level approaches the root.
Thelowest level summary is the original text itself; thehighest level (the root) is a title for the text.The ability to give meaningful (coherent) summar-ies for a text is one attr ibute of comprehension forthat text, and any procedure yielding trees possessingthe summary property can be said to partially under-stand the text.
Consideration must also be given toclassification schemas and rules for paraphrase, ana-136 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story Treesphora, and question-answering.
Furthermore, given anappropriate data base internalizing the relationshipsbetween a macrostructure and its subordinate macros-tructures or simple propositions (microstructures) anda summary derived from a story tree, it is possible fora procedure to reconstruct to a certain degree of detailthe original text from which the tree was derived.
Thedegree of detail recovered is directly dependent on therelative distance from the nodes forming the summaryto the original input propositions (the leaves) of thetext tree.How is this subordinate relationship among propo-sitions to be described formally to a computationalprocess?
One simple formulation is in the form of aruleA <= B,C,Dmeaning "you may assert the truth (presence) of ma-crostructure A if you can find the (nearly) contiguouspropositions B, C, and D present in the input text.
""Near ly"  means that an allowable level of "noise,"perhaps in the form of irrelevant side information, maybe present between the specified propositions (a prob-lem not addressed here).This rule form closely resembles in structure andmeaning the Horn clause notation.
The general clausehas the formatC\[1\] ..... C\[m\] <= A\[1\] ..... A\[n\]where C\[1\] ..... C\[m\] are elementary propositions form-ing the consequent, and A\[1\] ..... A\[n\] are elementarypropositions forming the antecedent.
If the proposi-tions in a clause contain the variables x\[1\] ..... x\[i\], thenthe clause has the interpretationfor all x\[1\] ..... x\[i\],A\[1\] and ... A\[n\] impliesC\[1\ ]  or  ... C \ [m\ ]If the subscript m for a clause is zero or one, then thatclause is referred to as a Horn clause.
If m=l  andn=0,  the Horn clause is called an assertion.There are several differences between the Kowalskilogic and the logic adopted here.
One of these has todo with the ordering of the antecedent propositions.In a true Horn clause, the ordering is irrelevant andA <= B,C,D is as good a rule as A <= C,D,B, etc.,i.e.
the antecedents can be proved in any order.
Theordering in the system described here is governed byrules of coherence.
For example, the rule:(TRADINGVOYAGE A RUFOLO WITH GOODSIN SHIP TO CYPRUS)<= (BUY A RUFOLO TH SHIP)(BUY A RUFOLO TH GOODS)(LOAD A RUFOLO TH SHIP  WITH GOODS)(SAIL A RUFOLO TO CYPRUS MEANS SHIP)is a meaningful rule.
(Here case notation is used: Afor Agent, TH for THeme,  etc.)
On the other hand,(TRADINGVOYAGE A RUFOLO WITH GOODSIN SHIP TO CYPRUS)<: (SAIL A RUFOLO TO CYPRUS MEANS SHIP)(LOAD A RUFOLO TH SHIP WITH GOODS)(BUY A RUFOLO TH GOODS)(BUY A RUFOLO TH SHIP)is nonsensical.
The rules of coherence that order theantecedent proposit ions may involve several criteria:causal connectedness (B causes/ is  the result of C,which causes/is the result of D), or temporal ordering(B happens be fore /a f te r  C, which happens be fore /after D), etc.
Note that the ordering of antecedentproposit ions can be tied to textual order within theframework of ordinary Horn clauses by adding extraarguments to the propositions.
This has been done inthe theory of definite clause grammars (Colmerauer,1978; Pereira and Warren, 1980).The above TRADINGVOYAGE rule can be inter-preted in either of two ways.
If we are given theproposition(TRADINGVOYAGE A RUFOLO WITH GOODSIN SHIP TO CYPRUS)in a text, or a summary of a text, we may infer thechain of events(BUY A RUFOLO TH SHIP)(BUY A RUFOLO TH GOODS)(LOAD A RUFOLO TH SHIP WITH GOODS)(SAIL A RUFOLO TO CYPRUS MEANS SHIP)and, if given these events in order in a text, we mayinfer that Rufolo was performing a TRADINGVOY-AGE.Because of this capability for use in two directions,this rule form can be used both in parsing and generat-ing tasks.
A parser can avail itself of these rules togroup sets of propositions in a text into units headedby macrostructures (which are the consequents of therules).
These can be further grouped into more gener-alized macrostructures recursively to yield a story tree.A generator can proceed in the other direction, start-ing with the top node of a tree and expanding it andits constituents downward recursively (by using therules that operate on the precondition propositions) toarrive at a tree whose terminals form a coherent ext.American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 137Alfred Correira Computing Story Trees2.3 Extended Horn ClausesAfter several early experiments with this rule formon a simple text (the Margie story - Rumelhart, 1975)it was discovered that this simple rule form, althoughcapable of handling the computations necessary for thetext at hand, did not bring out several inherent attrib-utes that macrostructures generally have in common.For example, in a TRADINGVOYAGE rule, severaldivisions can be recognized.
In order to go on aTRADINGVOYAGE,  Rufolo must have the moneyfor a ship and goods and the necessary knowledgeabout competit ion to make a profit.
Given these, Ru-folo will follow a certain sequence of actions; he willobtain a ship and goods, load the goods onto the shipand then sail to Cyprus.
The result of this effort willbe that Rufolo is in a posit ion to sell or trade hisgoods (and perhaps make a profit).
Therefore, we canbreak the TRADINGVOYAGE rule into several natu-ral groupings:TRADINGVOYAGE RULE :HEAD :(TRADINGVOYAGE A RUFOLO WITH GOODSIN SHIP  TO CYPRUS)PRE :(POSSESS A RUFOLO TH WEALTH)EXP :(MAKE A RUFOLO TH(CALCULAT IONS MOD MERCHANTSTYPE USUAL) )(BUY A RUFOLO A SHIP)(BUY A RUFOLO TH GOODS)(LOAD A RUFOLO TH SHIP  WITH GOODS)(SAIL A RUFOLO TH SHIP  TO CYPRUS)POST :(MAKE A RUFOLO TH PROFIT)Structurally, this rule form will be referred to as an"extended" Horn clause (EHC).
The first part of therule is the HEAD of the rule, and represents the ma-crostructure pattern.
The second part is the PREcon-dition for the rule.
The propositions in the precondi-tion are the conditions which must be true, or can bemade true, before Rufolo can embark on an episode ofTRADINGVOYAGE.
The third part is the EXPan-sion of the rule.
If Rufolo goes on a TRADING-VOYAGE,  then these are the (probable) actions hewill take in doing so.
The final part of the rule is thePOSTconditic~n of the rule, which consists of the prop-ositions that 'w i l l  become true upon the successfulcompletion (instantiation) of the TRADINGVOYAGErule.The resulting rule form is related conceptually andhistorically to the notion of a script as developed bySchank and Abelson (1977) (el.
Norman and Rumel-hart, 1975).
The precondition sets the stage for theinvocation of a rule.
It describes the setting and theroles of the characters involved in the rule.
The ex-pansion consists of the actions normally taken duringthe invocation of the rule.
The postcondition is theresult of these actions.
When used in a script-l ikerole, a rule is activated when its precondition has beensatisfied, and its expansion can then be sequential lyinstantiated.A rule can also be used as a plan.
A plan is a datastructure that suggests actions to be taken in pursuit ofsome goal.
This corresponds to activating a rule ac-cording to its postcondition, i.e.
employing a rule be-cause its postcondition contains the desired effect.
Ifone has the goal "make money"  one might wish toemploy the TRADINGVOYAGE rule to achieve it.This extension of the Horn clause structure servestwo purposes.
First, by separating the propositionssubsumed under a macrostructure into three parts, theEHC rule form renders it unnecessary to label theroles that the individual propositions play in the ma-crostructure.
A macrostructure will usually have pre-conditions, expansion(s),  and a postcondit ion set,which would have to be labeled (probably functional-ly) in a simple Horn clause system.
Secondly, it servesas a means of separating those proposit ions whichmust be true before a rule can be invoked(precondit ions) f rom those whose success or failurefollows the invocation of the rule.A rule may have multiple preconditions if there areseveral sets of circumstances under which the rule canbe invoked.
Thus a rule for watching a drive-in moviecould have the formWATCH DRIVE- IN  MOVIE  RULE:HEAD :(WATCH A PERSON TH DRIVE- IN  MOVIE)PRE :(OR ( (PERSON IN CAR) (CAR IN DRIVE- IN) )((SEE A PERSON TH SCREEN)(CAN A PERSON TH(READ A PERSON TH L IPS)) ) )A rule may also have several expansions attachedto it, one for each potential instantiation of the rule.Thus if a couple want a child they could employ arule:POSSESS RULE :HEAD :(POSSESS A COUPLE TH CHILD)EXP :(OR (CONCEIVE A COUPLE TH CHILD)(ADOPT A COUPLE TH CHILD)(STEAL A COUPLE TH CHILD)(BUY A COUPLE TH CHILD))where each of the propositions, CONCEIVE ,  ADOPT,STEAL, BUY expands by a complex rule of the sameform as the POSSESS rule.138 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story TreesA rule can have but a single postcondition, com-posed of simple propositions, since by definition thepostcondition is the set of propositions that are true ifthe rule succeeds.
If a postcondition could contain anexpandable proposition, then that proposition couldfail independently of the rule for which it is part of thepostcondition - since it could have its own precondi-tions - thus contradicting the definition of the post-condition.2.4 Indexed Rule Network of Extended Horn ClausesThe rules are stored in memory in a semantic net-work.
However, unlike the usual semantic networksfor case predicates, where the individual nodes(tokens) are connected by case relations (Simmonsand Chester, 1977), the semantic links in the EHCrule network are based on the story tree structure.Each rule node (or instantiation of one) in thenetwork may have an arc for each part of an EHCrule: precondition, expansion, and postcondition.
Allthe case relations in the head of the proposition arekept in a single list attached to the node as arc-valuepairs.
Negation is marked by embedding the node in a(NOT OF ...) proposition form.
For example, if apoint is reached in a narrative where John is expectedto kiss Mary but he does not, then the story treewould contain at that point a node that would print as(NOT OF (KISS A JOHN TH MARY)).Each node in the database represents either a classobject or an instance of a class object.
Every classobject points to all of the tokens subsumed by it in thenetwork.
For example, the class object representingDOG would have pointers to each of its tokens,DOG1, DOG2, DOG3, etc., which represent individualobjects of the class DOG.The database retrieval functions utilize a kind of"fuzzy" partial matching to retrieve potential rules tobe applied to a proposition.
Partial matching allowsthe rule-writer to combine rules that only differ in oneor two minor arc names, but which all share the samemajor arc names; only one rule need be written, speci-fying the major case relations and ignoring the minorones (which can be checked for in the preconditions ofthe rules).
Partial matching allows the generator tobring more operators to bear at a given point in thestory construction.
However, the parser pays the pricefor this flexibility by having to examine more alterna-tives at each point in its parsing where rules apply.The function which queries the database for theexistence of facts (instantiatcd propositions), uses a"complete" pattern-matching algorithm, since " Johnate cake last night" is not deemed a sufficient answerto the question "Who ate all the cake last night atMary's place?".3.
Story Analysis Using Extended Horn ClausesThis section describes the use of the ExtendedHorn Clause rule form and illustrates the process ofrule-writing using several paragraphs from the Rufolostory as an example.
The notion of rule failure is alsopresented as an integral feature of parsing and gener-ating narrative texts.3.1 Writing Rules Using Extended Horn ClausesThe EHC rule form divides the propositions ub-sumed by a macrostructure into three categories: thepreconditions, the expansions, and the postconditions.The preconditions define the applicability of a particu-lar ru le .
When a precondition has been satisfied, thena rule's expansions and postcondition correspondroughly to the traditional add/delete sets of problem-solving systems.
The add set consists of the orderedlist of actions to be taken as a result of the rule's invo-cation plus the postcondition states of the actions.Members of the delete set are propositions of the form(NOT OF NODE)  appearing in the expansion andpostcondition of a rule.The question then becomes one of mapping a textinto rules of this structure.
To illustrate this processconsider the following streamlined version of two par-agraphs from the Rufolo story:Rufolo made the usual calculations that mer-chants make.
He purchased a ship and loaded itwith a cargo of goods that he paid for out of hisown pocket.
He sailed to Cyprus.
When he gotthere he discovered other ships docked carryingthe same goods as he had.
Therefore he had tosell his goods at bargain prices.
He was thusbrought o the verge of ruin.He found a buyer for his ship.
He bought alight pirate vessel.
He fitted it out with theequipment best suited for his purpose.
He thenapplied himself to the systematic looting of otherpeople's property, especially that of the Turks.After a year he seized and raided many Turkishships and he had doubled his fortune.At the top level of the story we have two complexactions taking place: a trading voyage and a piratevoyage.
A TRADINGVOYAGE requires a merchant,a ship, some trade goods and a destination on a sea-coast (for example, an island).
So we embody this inthe ruleTRADINGVOYAGE RULE :HEAD :(TRADINGVOYAGE**  A X TH Y TO Z)PRE  :(X ISA  MERCHANT)(Z ISA  ISLAND)(Y ISA  GOODS)(W ISA  SHIP)American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 139Alfred Correira Computing Story TreesGiven that these conditions are true, then Rufolo planshis strategy, obtains both ship and goods and sails toCyprus with them (the function of the asterisks isnotational only and is used to distinguish those predi-cates that have rule expansions from those that donot):TRADINGVOYAGE RULE :HEAD :(TRADINGVOYAGE**  A X TH Y TO Z)PRE :(POSSESS*  A X TH U)EXP  :(MAKE*  A X TH(CALCULAT IONS MOD MERCHANTNBR PL  TYPE  USUAL) )(PURCHASE**  A X RI W R2 Y)(LOAD* A X TH W WITH Y)(SA IL*  A X TH W TO Z)(TRADE**  A X TH Y FOR(PROF IT  MODAL EXPEC) )POST:(NOT OF (WANT*  A X TH(DOUBLE*  A X TH U)))PURCHASE RULE :HEAD :(PURCHASE**  A X RI Y R2 Z)PRE :(POSSESS*  A X TH (W ISA  WEALTH) )EXP  :(POSSESS**  A X TH Y ) (POSSESS**  A X TH Z)POST :(NOT OF (POSSESS*  A X TH W))POSSESS RULE:HEAD :(POSSESS**  A X TH Y)PRE :(POSSESS*  A X TH WEALTH)EXP  :(BUY* A X TH Y)One might consider doing without the PURCHASErule.
Its precondition could have been pushed into theprecondition for the TRADINGVOYAGE rule and itsexpansion inserted into TRADINGVOYAGE at thesame point where the PURCHASE is now.
But thisrule-splitting is not just a stylistic choice; there areseveral advantages to this strategy.
First, keeping rulesize small makes the rule easier to read and write.Experience with writing rules showed that an averagerule size of three to five propositions proved to bemost efficient in this respect.
Second, smaller rule sizecuts down on the number of permutations of a rulethat need to be recognized by the parser, due to miss-ing propositions or the transposition of propositionsthat describe more or less contemporaneous events.Finally, smaller rules make for more conciseness insummaries generated from the rules.The postcondition of the PURCHASE rule is thatthe wealth used to buy the ship and goods is no longerin the possession of its original owner.
This wouldhave been inserted into the postcondit ion of TRA-D INGVOYAGE if the PURCHASE rule had beenincorporated into it directly.The difference between the POSSESS* andPOSSESS** propositions in the PURCHASE rule isilluminating.
The POSSESS* in the precondition doesnot have a rule attached to it, so it cannot be expand-ed.
If a merchant does not already possess wealthwhen he reaches this point, he cannot go about obtain-ing it through rule expansion (although the generatorcan fudge and assert that he does have wealth at thispoint to move the story generation along).
If the pre-condit ion of the PURCHASE rule had contained aPOSSESS** instead, then the merchant would be ableto apply the POSSESS rule above to acquire wealth ifhe did not have any.
The convention, as illustratedabove, is for the expandable propositions to be suffix-ed with two asterisks, and for terminal elements to besuffixed with a single asterisk.
This feature is only anotational device.The TRADE rule describes a trading scenario un-der conditions of heavy competition:TRADE RULE :HEAD :(TRADE**  A X TH Y FOR Z)PRE  :(Z ISA  PR ICE  MOD GOOD)EXP  :(ADVERSE-TRADE**  A X TH Y)(SELL*  A X TH Y FOR Z)(NOT OF (POSSESS**  A X TH Y))POST :(MAKE* A X TH (PROF IT  MOD GREAT) )ADVERSE-TRADE RULE :HEAD :(ADVERSE-TRADE**  A X TH Y)PRE  :(X ISA  MERCHANT)EXP  :(D ISCOVER*  A X TH(SHIP NBR MANY MOD DOCKED POSSBY(MERCHANT NBR SOME MOD OTHER) ) )(CARRY*  INSTR SHIP  TH (GOODS SAMEAS Y))It should be noted that the postcondit ion of theTRADE rule, the MAKE**, will fail because Rufolodoes not SELL* his goods for a profit.
Failure in arule is covered in the next section, and will not befurther discussed here.140 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story TreesBecause of his failure at trading, Rufolo attemptsanother scheme to double his wealth (which is hisoriginal goal in the story); he turns pirate.P IRATEVOYAGE RULE :HEAD :(P IRATEVOYAGE**  A X TH Y MEANS Z)PRE :(Z ISA SHIP TYPE P IRATE MUD LIGHT)(POSSESS** A X TH Z)(Y ISA WEALTH)(W ISA WEALTH VAL  (TWICE* RI W R2 Y))(U ISA NAT IONAL ITY)EXP :(FITOUT* A X TH Z WITH(EQUIPMENT MOD BESTSUITED) )(SEIZE* A X TH(SHIP NBR MANY POSSBY U DURATION YEAR))POST:(NOT OF (WANT* A X TH(DOUBLE* A X TH Y)))DOUBLE*  A X TH Y)POSSESS*  A X TH W)The first thing that Rufolo must do is to come topossess a pirate ship, which he does by selling his mer-chant vessel and using the funds to buy a light vessel:POSSESS RULE :HEAD :(POSSESS** A X TH Y)PRE :(NOT OF (POSSESS* A X TH WEALTH))(POSSESS** A X TH Z)EXP :(SELL* A X TH Z) (BUY* A X TH Y)POST:(NOT OF (POSSESS* A X TH Z))Note that the two POSSESS** rules above would becombined into a single rule in the database.Rufolo outfits his newly purchased ship as a piratevessel and then over the course of a year uses it toseize the ships of many Turks, until at the end he hasdoubled his wealth.
The postcondition of this activityis that he no longer wishes to double the amount ofhis (old) wealth and that he now possesses twice asmuch wealth as before.These rules do not thoroughly map the exact mean-ing of the two paragraphs above, but they do give aflavor for the process of rule-writing, and linguisticprecision is easy to ensure by use of additional rules topin down precisely every nuance in the text, particu-larly with respect to selling and buying and change ofownership.Rule-writing using EHCs  follows standard top-down programming practice.
At the top level are therules that describe the narrative structure of the text.For the Rufolo story, we have:STORY RULE :HEAD :(RUFOLO-STORY**  A X)EXP :(SETTING A X) (EPISODE)POST :( INTEREST* A X TH COMMERCEMODAL NOLONGER)(LIVE* A X MANNER SPLENDOR DURING(REMAINDER OF (DAYS OF X)))EP ISODE RULE :HEAD :(EPISODE)EXP:(OR (( INTERLUDE) (EPISODE))( (COMPLICATION)  (EPISODE))( (COMPLICATION)  (RESOLUTION))  )The Rufolo story is basically a SETT ING followedby an EPISODE,  where EP ISODE is defined recur-sively as either an INTERLUDE,  which leads into anepisode followed by a new EPISODE,  a COMPL ICA-T ION followed by a new EPISODE,  or a COMPL I -CAT ION and a RESOLUTION if the COMPL ICA-T ION does not cause any new problems to arise (dueto rule failure - see next section).The SETT ING ruleSETT ING RULE :HEAD :(SETTING A X)PRE :(LIVE* A X LOC Y DURING Z)(W ISA WEALTH VAL CERTAINAMOUNT)(POSSESS* A X TH W)(NOT OF (SATISFY* A X WITH W))POST:(WANT* A X TH (DOUBLE* A X TH W))will create a character and his environment - theL IVE*  and  POSSESS*  - and give the character a goal- the WANT*.Experience with simple narrative text leads to thebelief that it is relatively easy to learn to programusing EHC rules, and that their expressive power islimited only by the ingenuity of the rule-writer.
Ex-periments with other text forms - encyclopedia rti-cles, magazine articles, dialogues, etc.
- need to beperformed before a final judgement can be made con-cerning the fitness of the EHC as a general form forprocessing.American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 141Alfred Correira Computing Story Trees3.2 Success  and Failure in EHC RulesThe idea of rule success or failure in the EHC ruleform is tied to the domain the rules attempt o model -real life motivated behavior (actions) where thingscan, and do, go wrong, and actors fail to achieve theirgoals.
In real life, Rufolo's decision to go on a TRA-D INGVOYAGE does not guarantee that the voyagewill be successful, or even begun.
For a given rule,one of three conditions may arise.
First the rule'spreconditions may fail to be true and the rule cannotbe applied.
In the TRADINGVOYAGE rule, if Rufo-1o does not have the money necessary for trading inCyprus or does not possess the knowledge to success-fully compete,  then the TRADINGVOYAGE cannotbe completed espite Rufolo's best intentions.
A ruleis not invoked until one of its precondition sets hasbeen successfully processed (i.e.
each precondition inthe set has been successfully fuzzy-matched).Once this condition is satisfied then the rule can beinvoked and Rufolo can start his TRADINGVOY-AGE.
At each point of expanding the macrostructure,i.e as Rufolo performs each step in the expansion ofthe rule, he is subject to success or failure.
He maysucceed in buying the goods, or he may fail, and thesame is true for buying the ship and the loading of theship with goods, etc.
If he does manage to perform allthe actions in an expansion, then the rule is said tosucceed, and its postcondit ion proposit ions can beasserted as being true.
In the TRADINGVOYAGErule, an-assertion that Rufolo makes a profit would beinstantiated.But if an expansion fails, a different logic applies.If Rufolo has loaded the ship with his goods, but theship burns in the harbor, then the last expansion prop-osition, sailing to Cyprus, cannot be performed.
Therule is said to fail, and the postcondition propositionsare negated.
In the TRADINGVOYAGE rule, anassertion that Rufolo does not make a profit would beinstantiated because no other expansion options re-main.Rule failure is an important concept with respect onarratives.
Many narratives consist of a series of epi-sodes in pursuit of a goal; often each episode, exceptthe last, represents an instance of a failed rule.
If arule prior to the last succeeded, then the goal wouldhave been achieved and no further episodes wouldhave been forthcoming, (unless a new goal were cho-sen).
The mechanism of rule failure is a natural onefor analyzing this type of narrative pattern.4.
Generat ion and ParsingIn this section a procedure for using ma'crostruc-tures, embodied in the EHC rule-form, to generateand parse stories, and a program, BUILDTALE/TELLTALE ,  that implements it are discussed.4.1 GenerationThe paradigm used by TELLTALE  for story gener-ation is similar to that used by Meehan (1976) in hisTALESPIN program, which wrote "metanovels" con-cerning the interrelationships, both physical and men-tal, of the motives and actions of anthropomorphizedanimals possessing simple behavior patterns.
Meehandescribed a story as an exposition of events that occurwhen a motivated creature attempts to achieve somegoal or fulfill some purpose, such as satisfying a needor desire, solving a problem, doing a job, etc.TALESP IN was basically a problem-solver that oper-ated on a database consisting of living entities, inani-mate objects, and a set of assertions (rules) typifyingthe relationships among them, and describing opera-tions for affecting those relationships.
The rules wereorganized into plans based on conceptual relatedness,which aided in retrieval of specific rules.Meehan emphasized the use of plans as a mecha-nism for generating stories.
Plan activation was aprocess of assigning a goal to a character and thencalling up any relevant plans that were indexed by thisgoal.In the EHC rule form the precondition governs theability of a rule to be invoked.
If  a rule is consideredto be a plan in the Meehan sense above, then insteadof indexing the rule by its postcondition propositions,it can be indexed by its precondition if the precondi-tion contains information relating to motivation.
Forexample, the rule,MARRY RULE :HEAD :(ASK-MARRY**  A X TH Y)PRE :(X ISA MAN)(Y ISA WOMAN)(WANT* A X TH (MARRY* A Y TH X))EXP :(GO* A X TO Y)(ASK* A X TH Y IF (MARRY* A Y TH X))(ACCEPT* A Y TH X)POST:(MARRY* A Y TH X)is a rule that can be activated if some X, who must bea man, WANTs Y, who must be a woman, to marry X.Each rule could contain propositions in its precondi-tions that restrict the set of objects that can instantiatethe variables of the rule.The last proposit ion in the precondit ion, theWANT*,  is a goal statement; it states that the MAR-RY rule can be invoked when one person wants tomarry another.
In the process of generating a story, ifa point is reached where a man develops the goal ofwanting to marry a woman, the MARRY rule can be142 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story Treesinvoked to attempt o satisfy that want.
Of course, ifthe ASK* or ACCEPT* fails, then the postconditionbecomes (NOT OF (MARRY* ...)) instead.The main advantage of inserting the WANT* intothe preconditions i that the generator need not, as aresult, contain special logic to examine the postcondi-tions of a rule to ascertain which rules to apply at apoint in the story.
The normal rule activation mecha-nism (a rule can only be applied if one of its precondi-tion sets succeeds) will automatically weed out un-wanted rules because of the information relating tomotivation.TELLTALE generates tories (sequences of propo-sitions) based on such rules contained in its database,either under user control or directed by the programitself.
The database is a semantic network of nodescreated by building a network of the case-predicaterules supplied by the user.
The input to TELLTALEis the root of a story tree, which informs TELLTALEas to the type of story which is to be generated (fairytale, etc.).
The output from TELLTALE is an instan-tiated story tree whose terminals are the propositionsof the text.
The program SUMMARIZE computessummaries from the story tree.
An annotated examplerule-base can be found in Appendix A for generating aset of fairy tales.
A sequence of propositions for astory generated from that rule-base is shown in Ap-pendix B.
Two summaries of the story are shown inAppendix C.Starting with the root, TELLTALE executes untilno nodes remain to be expanded, because all havebeen reduced to terminal propositions or some depthlimit has been reached.
A traversal of the terminals ofthe resulting story will yield the proposition text of thestory; any higher level traversal will yield a summaryof the story.4.2  Pars ingThis section describes a procedure, BUILDTALE,for using macrostructures to parse stories.
The goal inwriting the generator-parser system has been to createa program capable of understanding those texts that itcan generate from a rule-base.
DiagrammaticallyRULEI I ISUMITEXTIPARI ISUMITEXTBASEIGENITREEIMARIPROPISERITREEIMARIPROP- - ->1 I - - -> l lZE I - - -> l  I - - -> I IZE I  .
.
.
.
>I I I IOSITI I I IOSITI A I I B IIONSl C I I D lIONSthe diagram above should be the same as the outputfrom part D. The story trees might or might not beidentical, depending on whether the story grammar isambiguous.The philosophy of the understander can be summa-rized by recalling a concluding statement by Rumel-hart (1975):"It is my suspicion that any automatic 'storyparser' would require ... 'top-down' global struc-tures .... but would to a large degree discoverthem, in any given story, by the procedures devel-oped by Schank (1975).
"The procedures developed by Schank emphasize the"bottom-up" approach to story parsing.
Starting withthe raw input data, emphasis is placed on integratingeach sentence into the developing narrative structure.The structures used are scripts (and plans), and pars-ing integrates propositions into scripts.
The scriptsform an implicit episodic structure, but the higher or-der relationships among the scripts are not generallymade specific (i.e.
what structures form episodes, set-ting information, complications, resolutions, etc).BUILDTALE is a program that combines the top-down and bottom-up approaches.
As the parse pro-gresses, BUILDTALE attempts to integrate the termi-nal propositions into the context of a story tree.
Itmanipulates the terminals bottom-up, integrating theminto macrostructures, while it is building story struc-ture nodes (STORY, SETTING, EPISODE, etc.)
top-down.
If BUILDTALE successfully parses the text,these two processes will converge to instantiate a com-plete story tree.Starting with the root of a story tree and an un-marked string of text propositions, BUILDTALE exec-utes, by an algorithm described in Section 4.4, untilone of three conditions occurs:1) If the procedure xhausts the propositionlist before the STORY node has beenbuilt, then it fails.2) If the procedure builds an instance ofSTORY but there still remain unmarkedpropositions, then it fails.3) If an instance of STORY is built and thetext stream is empty, the the procedurereturns the instantiated root.A terminal-level traversal of the resulting tree willyield the original input text proposition stream; higherlevel traversals will yield summaries of the text.The tree that results from the story generator shouldyield the same bottom-level terminal propositions asthe tree that results from the parsing of the terminalpropositions of the story, i.e.
the output from part B in4.3 The Relationship Between Generating and ParsingThere are several differences between the BUILD-TALE and TELLTALE procedures.
First, whereasthe parser is restricted to propositions from the inputAmerican Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 143Alfred Correira Computing Story Treestext for its terminals, the generator is free to build aterminal any time one can be generated.
Second, thegenerator is free at each step to choose any rule thatwill match a proposit ion it is trying to expand, andalso to use any of a rule's preconditions or expansionsin any order.
The parser must be careful in its choiceof rules and in how it examines the preconditions andexpansions in a rule, always examining them in orderof decreasing length, to ensure that it does not build astory tree and find left-over unmarked text proposi-tions when done.The generator builds a proposition by first instanti-ating its precondition, expansion, and postcondit ion,and then attaching them to the instantiated head.
Thegenerator knows at all times the father of the proposi-tion it is instantiating; in fact it knows every ancestorof that proposition between it and the root, since itoperates trictly top-down.The parser operates primarily as a left-cornerbottom-up procedure, with overall direction suppliedby some top-down processing.
When the parser buildsa structure, it cannot be sure at that time that thestructure is indeed the correct one to be integratedinto the tree at that point, i.e.
it does not yet know thecorrect path to the root.
The parser must, therefore,save the context information of its build decisions, sothat they can be undone (or at least ignored) if theyare later found to be in error.
In fact, the final struc-ture of the tree can only be assigned after all the tex-tual propositions have been analyzed.
This is in agree-ment with the statement of van Dijk (1975, pg.
11):"Strictly speaking, a definite hierarchical structuremay be assigned to a discourse sequence of prop-ositions only after processing of the last proposi-tions.
For long discourses this would mean thatall other propositions are kept in some memorystore.
"Structures are built as the parse progresses, and somemight be discarded or rearranged.
Their final positionin the tree cannot be determined until all the proposi-tions have been examined.Some previous parsers solved this problem by re-sorting to higher-level languages like CONNIVER andPLANNER,  paying the price in higher computationalcosts.
A conscious effort was made with this projectto avoid the expense of resorting to a higher-levellanguage by having LISP perform the necessary book-keeping to handle the backtracking involved in undo-ing an incorrect choice (build).
In BUILDTALE,  thebookkeeping is accomplished by pushing context infor-mation onto the LISP control stack.
Usually, when abuild is performed , instead of returning (popping theLISP stack), a further descent is made in order tointegrate the next proposition.
If a build is later foundto be in error, then a FA IL  function automatical lycauses LISP to back up in its stack to the point wherethe build was made and undo it, since all the informa-tion that was around when the first decision was madeto build is still present on the stack.These differences hould not obscure the very realsimilarities between the two processes.
TELLTALEand BUILDTALE use the same functions to analyzethe preconditions, expansions and the postcondition ofa rule.
In fact, the "basic" control structure of TELL-TALE  is a special case of the control structure ofBUILDTALE.
The difference between the two occursat build time.
In BUILDTALE,  when a node in thetree is built, a check is made to see if this nodematches the root of the derivation tree being built.This may not be the case since the node may be manylevels lower in the tree than the root in question, andthese levels will need to be built before the derivationtree is complete.
Of course, if the node should matchthe root, then it is returned.TELLTALE ,  on the other hand, never descendsmore than a single level in the tree at a time.
When abuild is performed, it will always derive from the de-rivation tree being processed.
The node and the rootalways match, and the node is returned.
At buildtime, when BUILDTALE decides whether to call itselfrecursively (to add the next higher level in the tree) orto pop the stack (returning the derivation tree root),TELLTALE  will always pop the stack.Generat ion and parsing use the same grammar withdifferent terminating conditions to define the controlpaths through the grammar.
They resemble ach otherin computing as output a derivation tree whose termi-nals are the propositions of the text.
This fact wasborne out during the implementat ion of the system.TELLTALE  was coded first, and the eventualTELLTALE/BUILDTALE control structure for proc-essing preconditions, expansions, and postcondit ionswas debugged and tested by generating many storytrees.
BU ILDTALE grew out of TELLTALE  by add-ing the build-time recurs ion/backup mechanism to thecontrol structure.The symmetric relationship between generation andparsing with respect to the computation of derivationtrees is one significant feature of the EHC rule system.4.4 The  Basic Contro l  St ructureBUILDTALE and TELLTALE  are essentially largeseparate PROG-def ined LISP functions that effectdifferent initialization conditions, and then execute thesame set of underlying functions.
Below is a descrip-tion of the basic control structure shared by TELL -TALE  and BUILDTALE:144 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story TreesI: For each proposition being examined:1) If it exists instantiated in the data base,then return the instantiation,whether it is found negated or not;2) if there are no rules for the node,then it can be asserted;3) otherwise, for each rule until one succeeds:a) for each precondition in the ruleuntil one succeeds,do I for each proposition in theprecondition;b) if no precondition succeeds,then fail;c) otherwise, for each expansionuntil one succeeds,do I for each proposition in theexpansion;d) if an expansion succeeds, then foreach proposition in thepostcondition,do I and return the instantiatednode (rule success);e) otherwise, for each propositionin the postcondition,do I for the negation of theproposition and generatea (rule) failure.
"Do I" means "follow the procedure labelled ' I '"which is the entire basic control structure outlined above.Since postcondition propositions do not have rule ex-pansions, they never perform step 3 above.
Also, rulefailure is not marked by negation (another mechanismis used) so, if a negated node is encountered, it willnever fall through to step 3.
Finally, it should be no-ticed that, although it is possible for the algorithm togenerate rroneous propositions in step 2 if exploringan incorrect path during parsing (BUILDTALE),  thesepropositions will be undone during backup when thepath has been recognized as incorrect.5.
Extracting Summaries From Story TreesOne of the principal reasons for choosing theKintsch and van Dijk macrostructure theory was theresulting property of summarizability; the ability toproduce coherent summaries is one mark of intelli-gence in a parser.
The summarizer produces variousstrings of propositions from the story tree which formsummaries of a text.
One such string is composed ofthe terminals and represents the complete story.
Anysequence of propositions output by the summarizer isa well-formed input to the parser.
The system is thusable to parse all proposition sequences it can generate.Since the summary feature is inherent in the treesas they are given to the summarizer, a simple level-traversal algorithm would have been sufficient to gen-erate useful output.
However, this would have result-ed in needless redundancy of propositions (since someare checked repeatedly by the preconditions of therules and have pointers to them at many places in thetree).
Therefore, the summarizer emembers what ithas already output in the summary, so as never torepeat itself.Another area of repetition concerns attributes forobjects in the story.
To avoid repeating an object'sattributes, the summarizer keeps a list of objects thathave already appeared in at least one proposition, andwhenever it encounters in a new proposition an objectnot on this list, it outputs it with all of its propertiesand then places it on the list of expanded objects.Since no time-markers are put on an object's proper-ties, they are all printed out at once, even if some ofthose properties are not attached to the object untilmuch later in the story; this reveals a weakness in theprocedure that can be corrected by the introduction oftime-markers for objects (actions already possess time-markers).One attribute of story trees is that, at their highernodes, one can read off the syntactic structure of thestory.
For example suppose a story consists of a set-ting followed by three episodes.
As a summary,"setting plus three episodes" is usually not very inter-esting; therefore the summarizer has the ability torecognize and descend below these story structurenodes in the final summary.
These nodes are treatedlike all other nodes to the tree building procedures,but the summarizer descends below the nodes to printtheir descendants, no matter what level summary isbeing computed.There is also the question of summarizing the ma-crostructures (rules).
By definition, these nodes areexpandable, i.e., they have a rule for expanding themin the rule-base.
Maerostructures are not marked witha NOT if they fail; only simple propositions - termi-nals - are.
However, whether a script achieves its goalor not is vital information to be included in any rea-sonable summary produced from the tree.
Therefore,when summarizing a macrostructure, the summarizeroutputs both the head (the macrostructure pattern)and its postcondition (if the script fails to achieve itsgoal, the postcondition will have been negated).Finally, the summarizer outputs only those proposi-tions it recognizes as non-stative descriptions; it neveroutputs state descriptions.
The reason for this is thata stative always describes the attribute(s) of someobject, and can therefore be output the first time thatthat object appears in an active proposition.The summarizer is an algorithm that, given a storytree and a level indicator, scans the nodes of the treeat that level, and applies the following rules to eachnode:American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 145Alfred Correira Computing Story Trees1) If the node is a story structure node, thensummarize its sons.2) If the node has already been processed,then skip it.3) If the node is marked as a script, returnits head followed by its postconditionpropositions.4) If the node is a stative, then skip it.For each case value in a proposition to be output (forexample, RUFOLO1,  DOUBLE* l ,  and WEALTH1 in(WANT*I  A RUFOLO1 TH (DOUBLE* I  ARUFOLO1 TH WEALTH1) ) ) ,  the following rule isapplied:5) If the case value has not appeared in apreviously accepted proposition, print itand all its attributes; otherwise, just printthe case value itself.For example, if RUFOLO1 has been mentioned ina proposition prior to WANT*I  in a summary, thenonly RUFOLO1 will be present in the WANT*I  prop-osition, and not the fact that RUFOLO1 is aMERCHANT1 from RAVELLO1,  etc.An initial version of an English language generatorwas written that applies a set of rules to the output ofthe summarizer to produce well-formed English texts(Hare and Correira, 1978).
This generator uses ruleforms and the summarizer output to solve some of theproblems involved in: reasonable paragraphing andsentence connectivity, elision of noun groups andverbs, and pronominalization of nouns.
The decisionsare based, in part, on the structure of the story treeand the positions of individual propositions in thattree.6.
Discuss ion and Conc lus ionsThe task of text processing requires solutions toseveral important problems.
The computational theoryfor macrostructures u ing Extended Horn Clauses wasdesigned with the following goals in mind.
A compu-tational model should have some degree of psychologi-cal validity, both to provide a humanly useful repre-sentation of textual content and organization and toensure that the task of rule-writing is as natural aspossible for the human grammar producer.
It shouldbe conceptually simple, in both design and implemen-tation, taking advantage of similarities between gener-ation and parsing, and it should offer a rigorous datastructure that is uniform and avoids the growth of adhoe large-scale structures.The computational macrostructures realized by theExtended Horn Clause notation succeed in many waysin satisfying these goals.
They appear to resemble thestructures humans build mentally when reading narra-tive texts.
The story tree is a logical way to organizethese macrostructures, with the terminals of a particu-lar story tree comprising the actual textual proposi-tions, and the interior nodes containing the instantiat-ed heads of rules (corresponding to macrostructures).The story tree has the summary property: if the tree istruncated at any level, then a "meaningful" (coherent)summary of the original text can be read off directly.The generality of the macrostructure propositions in-creases as one nears the level of the root (going fromthe level of specific actions to the rules that containthem, to the story categories that contain these rules),which can be considered as the title for the text at itsterminals.The concept of rule failure takes the EHC out ofthe strictly logical system of the normal (Kowalski-type) Horn clause logic, since failure in a normal logicsystem means something different from failure here.In narratives, failure needs to be recorded, since it isone source of "interest" in the resulting story; striving,failing, and striving again is a common occurrence insimple narratives.
These failure points, and their con-sequences, have to be recorded in the story tree(whereas, in normal logic systems, failure points areinvisible to the final result) and, furthermore, theyrestrict the choice of paths that can reasonably beexpected to emanate from the point of failure.
Thefailure mechanism is tailored for narratives involvingentities exhibiting motivated behavior.
Other textforms, such as technical or encyclopedia articles,would probably not require the failure mechanism.The underlying approach in BUILDTALE/TELLTALE is that of a problem-solver, as was alsotrue of Meehan's story-writer.
A rule-base, organizedas a hierarchy of story trees, is used to generate aparticular, instantiated, story tree by an inference pro-cedure augmented via the rule failure mechanism de-tailed in Section 3.2.
Each instantiated tree is treatedas a context, consisting of the events, objects, andtheir relationships, relating to a particular story.
Thefacts and rules in the rule-base serve as a model forthe possible states in the microworld formed by thatstory tree.
These states are categorized using linguis-tic entities, such as SETTING, EPISODE, COMPLI-CATION, and RESOLUTION.The problem-solving approach, coupled with thestory grammar concept, is a natural one for processingmost forms of narratives.
Analogous systems of rulescould be used for processing other large text forms,although the categories involved would be different.Notes  on the Append icesThe rules are all written in a case predicate nota-tion (Fillmore, 1968).
The general form for such apredicate is(HEAD ARC1 VALUEq .
.
.
ARC In\] VALUE \[n\] )The HEAD of a case predicate is either a verb or anoun form; because no formal lexicon was maintainedfor the TELLTALE/BUILDTALE program, verbforms were marked with an asterisk and objects wereleft unmarked.
The ARCs are standard case relations,146 American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980Alfred Correira Computing Story Treessuch as Agent, THeme, LOCation, INSTance, etc.,although no attempt was made to be strictly correctlinguistically with their every use, and a few relationswere created for the sake of convenience.
When agood arc name did not suggest itself, then an arbitraryarc name - R1, R2, etc.
- was used instead.
TheVALUE can be either a verb form, an object, or an-other case predicate.The case predicates used in the program were writ-ten to enhance readability.
For example, in the fairy-tale story (Appendix B), the case predicate(WANT*I TO POSSESSI  A GEORGEI  TH MARYI)can be rendered into English as "George wants topossess Mary".
The sequence(GO*3 A GEORGEI  TO IRVINGI)(SLAY*I A GEORGEI  TH IRVINGI)(RESCUE*I A GEORGEI  TH MARYI )can be rendered as "George goes to Irving.
Georgeslays Irving.
George rescues Mary.
".Append ix  A - Rule-base for FairytaleFA IRYTALE RULE:HEAD:(FAIRYTALE*)EXP:(FA IRYSTORY**  A X TH Y)FA IRYSTORY RULE:HEAD:(FA IRYSTORY**  A X TH Y)EXP:(SETTING A X)(EPISODE A X TH Y)POST:(LIVE* A X TH Y MANNERHAPP ILY_EVER_AFTER)SETT ING RULE:HEAD:(SETTING A X)PRE:(LIVE* A X LOC Y DURING Z)L IVE RULE:HEAD:(LIVE* A X LOC Y DURING Z)PRE:(CHAR INST X) (Y ISA PLACE) (Z ISA TIME)CHAR RULE:HEAD:(CHAR INST X)PRE:(OR (X ISA KNIGHT SEX MALE PERSON T)(X ISA PR INCE SEX MALE PERSON T))EXP:(OR (X MOD BRAVE) (X MOD HANDSOME))EP ISODE RULE:HEAD:(EPISODE A X TH Y)EXP:(MOTIVE A X TH Y) (ACTION A X TH Y)MOTIVE  RULE:HEAD:(MOTIVE A X TH Y)PRE:(DESIRE* A X TH Y)EXP:(WANT* TO POSSESS A X TH Y)DES IRE  RULE:HEAD:(DESIRE A X TH Y)PRE:(CHAR INST X)EXP:(OR (Y ISA PR INCESS SEX FEMALEPERSON T MOD BEAUTIFUL)(Y ISA HOLY OBJECT MOD LOST))ACT ION RULE:HEAD:(ACTION A X TH Y)EXP:(OR (ASK-MARRY**  A X TH Y)(RESCUE** A X TH Y FROM Z)(QUEST** A X TH Y)(PRAY** PART FOR A X TH Y))ASK RULE:HEAD:(ASK-MARRY**  A X TH Y)PRE:(WANT* TO POSSESS A X TH Y)(Y ISA PRINCESS)EXP:(GO* A X TO Y)(ASK* A X TH Y IF (MARRY* A Y TH X))(ACCEPT* A Y TH X)POST:(MARRY* A Y TH X)RESCUE RULE:HEAD:(RESCUE** A X TH Y FROM Z)PRE:(WANT* TO POSSESS A X TH Y)(Y ISA PRINCESS)(THREATEN**  A Z TH Y)EXP:(GO* A X TO Z)(SLAY* A X TH Z)(RESCUE* A X TH Y)POST:(MARRY* A Y TH X)American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 147Alfred Correira Computing Story TreesTHREATEN RULE:HEAD:(THREATENSS A X TH Y)PRE:(X ISA DRAGON ANIMATE T)(X SOD EVIL)(Y ISA PRINCESS)(WANT ?
TO POSSESS A X TH Y)EXP:(CARRY s~ PART OFF A X TH Y TO Z)CARRY RULE:HEAD:(CARRY ss PART OFF A X TH Y TO Z)PRE:(X ISA DRAGON)(Y ISA PRINCESS)(Z ISA DEN POBJ  T)EXP:(GO~ A X TO Y)(CAPTURE ?
A X TH Y)(FLYS A X TH Y TO Z)QUEST RULE:HEAD:(QUEST s~ A X TH Y)PRE:(CHAR INST X)(Y ISA HOLY OBJECT MOD LOST)(WANT ?
TO POSSESS A X TH Y)EXP:(GO ?
A X TO ORACLE)(REVEAL ?
A ORACLE TH PLACE OF Y)(GO s A X TO PLACE)(F IND s A X TH Y)POST:(POSSESS s A X TH Y)PRAY RULE:HEAD:(pRAyss PART FOR A X TH Y)PRE:(CHAR INST X)(WANT s TO POSSESS A X TH Y)(Z ISA GOD) (W ISA CHURCH POBJ  T)EXP:(OR ((GOS A X TO W)(KNEEL s A X PREP (IN TH(FRONT PREP (OF TH ALTER)) ) )(pRAys A X PREP (TO TH Z)PREP (FOR TH Y))((U ISA PR IEST  SEX MALE PERSON T)(GO ?
A X TO U)(PAY ?
A X TH U EXPECT( INTERCEDE s A U PREP (WITH TH Z)PREP (FOR TH Y)))(pRAys A U TO Z FOR Y)(GRANT s A Z TH (PRAYER POSSBY U))))POST:(POSSESSS A X TH Y)JOHN ISA PR INCE SEX MALE PERSON T)GEORGE ISA KNIGHT SEX MALE PERSON T)LANCELOT ISA KNIGHT SEX MALE PERSON T)PARSIFAL  ISA KNIGHT SEX MALE PERSON T)MARY ISA PR INCESS SEX FEMALE PERSON T)GUENEVIERE ISA PR INCESSSEX FEMALE PERSON T)(HOLY_GRAIL  ISA HOLY_OBJECT POBJ  T)(SACRED_CROSS ISA HOLY_OBJECT POBJ  T)(CAMELOT ISA PLACE)(MONTSALVAT ISA PLACE)(ONCE_UPON A T IME ISA TIME)( IRVING ISA DRAGON ANIMATE T)(CARMEN ISA DRAGON ANIMATE T)Append ix  B - Text  of  Fairytale(FAIRYTALE*I )( L IVES2 A (GEORGEI ISA KNIGHTI  SEX MALE2PERSON T MOD BRAVEI)  LOC (CAMELOTI ISAPLACEI)  DURING (ONCE_UPON A TIMEI ISATIMEI))DES IRES2 A GEORGEI  TH (MARYI ISAPRINCESSI  SEX FEMALEI  PERSON TMOD BEAUTIFUL I ) )(WANT~I TO POSSESSI  A GEORGEI  TH MARYI)(GOal PART TOI A GEORGEI  TO MARYI) )(ASKSl A GEORGEI  TH MARYI IF(MARRY~I A MARYI TH GEORGEI ) )(NOT OF (ACCEPTSl A MARYI TH GEORGEI ) )(NOT OF (MARRYS2 A MARYI TH GEORGEI ) )(WANTS2 TO POSSESS2 A(IRVINGI ISA DRAGONI  ANIMATE TMOD EVILI)  TH MARYI)(GOS2 PART TO2 A IRVINGI TO MARYI)(CAPTURESl  A IRVINGI TH MARYI)(FLYSl A IRVINGI TH MARYI PREP(TO TH DENI))(GO~3 PART TO3 A GEORGEI  TO IRVINGI)(SLAYSl A GEORGEI  TH IRVINGI(RESCUESl A GEORGEI  TH MARYI(MARRYS4 A MARYI TH GEORGEI)(LIVES3 A GEORGEI  TH MARYIMANNER HAPP ILY  EVER AFTERI)Append ix  C - Summar ies  of  Fairytale(FAIRYTALESl)( (L IVES2 A (GEORGEI ISA KNIGHTI  SEX MALE2PERSON T MOD BRAVEI)  LOC (CAMELOTI ISAPLACEI)  DURING (ONCE_UPON_T IMEI  ISATIMEI))(DESIRES2 A GEORGEI  TH (MARYI ISAPRINCESSI  SEX FEMALEI  PERSON TMOD BEAUTIFUL I ) )148 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1980Alfred Correira Computing Story TreesWANT*\]  TO POSSESS* I  A GEORGEI  TH MARYI)GO*I PART TO1 A GEORGEI  TO MARYI)ASK*I A GEORGEI  TH MARYJ IFMARRY*I  A MARYI TH GEORGEI  ) )NOT OF (ACCEPT*I A MARYI TH GEORGEI) )NOT OF (MARRY*2 A MARYI TH GEORGE1))TO POSSESS2 AIRVINGI ISA DRAGONI MOD EVILI)TH MARY I )CARRY**2  PART OFFI A IRVINGITH MARYI TO DEN\])(GO*3 PART TO3 A GEORGEI  TO IRVINGI)(SLAY*I A GEORGEI  TH IRVINGI(RESCUE*I A GEORGEI  TH MARYI(MARRY*4 A MARYI TH GEORGEI  )(LIVE*3 A GEORGEq TH MARYIMANNER HAPP ILY  EVER AFTERI)(FAIRYTALE* I )( (LIVE*2 A (GEORGEI ISA KNIGHTI  SEX MALE2PERSON T MOD BRAVEI)  LOC (CAMELOTI ISAPLACEq) DURING (ONCE_UPON A TIME1 ISATIMEI ) )(DESIRE*2 A GEORGE1 TH (MARYI ISAPRINCESSI  SEX FEMALEI  PERSON TMOD BEAUTIFUL I  ) )(WANT*I TO POSSESSI  A GEORGEI  TH MARYI)(ASK-MARRY**2 A GEORGEI  TH MARYI)(NOT OF (MARRY*2 A MARYI TH GEORGE\] ) )(RESCUE**2 A GEORGE\]  TH MARYIFROM (IRVINGI ISA DRAGONI ANIMATE TMOD EVILq ) )MARRY*4  A MARYI TH GEORGEI  )L IVE*3 A GEORGEI  TH MARYIMANNER HAPP ILY  EVER AFTER\]  ))ReferencesBobrow, D. G. and Collins, A.
1975.
Representation andUnderstanding.
New York: Academic Press.Bobrow, D. G. and Raphael, B.
1974.
"New programming lan-guages for AI research".
Computing Surveys, Vol.
6, No.
3, pp.155-174.Bobrow, D. and Winograd, T. 1977.
"An overview of KRL, aknowledge representation language."
Cognitive Science, Vol.
1,No.
1, pp.
3-46.Charniak, E. 1972.
"Toward a model of children's tory compre-hension."
AI-TR-266.
Cambridge, Mass.
: M.I.T.A.I.
Lab.Charniak, E. and Wilks, Y.
1976.
Computational Semantics.
NewYork: North-Holland.Colmerauer, A.
1978.
"Metamorphosis grammars" in NaturalLanguage Communication with Computers, ed.
L. Bole, NewYork: Springer Verlag.Fillmore, C. 1968.
"The case for case" in Universals in LinguisticTheory, eds.
E. Bach and R. Harms, New York: Holt, Rhinehartand Winston.Grosz, B.
1977.
"The representation a d use of focus in dialogueunderstanding."
Technical Note No.
151.
Menlo Park, Califor-nia: Stanford Research Institute.Hare, D. and Correira, A.
1978.
"Generating connected naturallanguage from case predicate story trees."
unpublished manu-script.Hendrix, G. G. 1976.
"Partitioned networks for modelling naturallanguage semantics."
Dissertation.
Austin, Texas: Departmentof Computer Sciences, The University of Texas.Kintsch, W. and van Dijk, T. 1978.
"Recalling and summarizingstories."
in Current Trends in Textlinguistics, ed.
Wolfgang Dres-sier, de Gruyter.Kowalski, R. 1979.
Logic for Problem Solving, New York: ElsevierNorth-Holland.Lehnert, W. 1977.
"Question answering in a story understandingsystem."
Cognitive Science, Vol.
1, pp.
47-73.Meehan, J.
1976.
"The metanovel: writing stories by computer."Dissertation.
New Haven, Connecticut: Department of Comput-er Sciences, Yale University.Meyer, B.
1975.
The Organization of Prose and its Effects on Recall.Amsterdam: North-Holland.Minsky, M. 1975.
"A framework for representing knowledge."
InThe Psychology of Computer Vision.
P. Winston ed.
New York:McGraw-Hill.Norman, D. A. and Rumelhart, D. E. 1975.
Explorations inCognition.
San Francisco: W. H. Freeman and Company.Pereira, F. and Warren, D. 1980.
"Definite clause grammars forlanguage analysis - a survey of the formalism and a comparisonwith augmented transition etworks".
Artificial Intelligence 13,pp.
231-278.Rumelhart, D. E. 1975.
"Notes on a schema for stories."
in Repre-sentation and Understanding, eds.
D. Bobrow and A. Collins,New York: Academic Press.Schank, R. C. 1975.
"The structure of episodes in memory."
inRepresentation a d Understanding, eds.
D. Bobrow and A. Col-lins, New York: Academic Press.Sehank, R. C. 1975b.
Conceptual Information Processing.
New York:North-Holland.Schank, R. and Abelson, R. 1977.
Scripts, Plans, Goals andUnderstanding.
New York: Wiley.Simmons, R. F. 1978.
"Rule-based computations on English."
inPattern-Directed Inference Systems.
Hayes-Roth, R. and Water-man, D. eds.
New York: Academic Press.Simmons, R. F. and Correira, A.
1979.
"Rule forms for verse,sentences and story trees."
in Associative Networks - Representa-tion and Use of Knowledge by Computers, ed.
N. Findler, NewYork: Academic Press.Simmons, R. F. and Chester, D. 1977.
"Inferences in quantifiedsemantic networks".
Proceedings of Fifth IJCAI, pp.
267-274.van Dijk, T. A.
1975.
"Recalling and summarizing complex dis-course."
unpublished manuscript.
Amsterdam: Department ofGeneral Literary Studies, University of Amsterdam.Wilks, Y.
1975.
"A preferential, pattern-matching semantics fornatural language understanding".
Artificial Intelligence 6, pp.53-74.Winograd, T. 1972.
Understanding Natural Language.
New York:Academic Press.Woods, W. A.
1970.
"Transition networks grammars for naturallanguage analysis".
Comm.
ACM, Vol.
13, pp.
591-602.Young, R. 1977.
"Text Understanding: a survey."
American Journalof Computational Linguistics, Vol.
4, No.
4, Microfiche 70.Al f red Correira is a Systems Analyst fo r  the Compu-tation Center o f  the University o f  Texas at Austin.
Hereceived the M.A.
degree in computer science f rom theUniversity o f  Texas in 1979.American Journal of Computational Linguistics, Volume 6, Number 3-4, July-December 1980 149
