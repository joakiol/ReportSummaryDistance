Translating Spanish into Logic through LogicVeronica DahlDepar tment  of  Mathemat icsUn ivers i ty  of  Buenos  A i resBuenos  Ai res,  ARGENTINAWe discuss the use of logic for natural language (NL) processing, both as an internalquery language and as a programming tool.
Some extensions of standard predicate calculusare motivated by the first of these roles.
A logical system including these extensions isinformally described.
It incorporates semantic as well as syntactic NL features, and itssemantics in a given interpretation (or data base) determines the answer-extraction process.We also present a logic-programmed analyser that translates Spanish into this system.
Itequates semantic agreement with syntactic weil-formedness, and can detect certainpresuppositions, resolve certain ambiguities and reflect relations among sets.1.
IntroductionThe idea of using logic as a conceptual frameworkin question-answering systems is not new.
The factthat it can formally deal with the notion of logicalconsequence makes it particularly attractive for repre-senting meaning.
Standard predicate calculus, howev-er, does not seem adequate for representing all thesemantic features of natural language (NL), e.g.
pre-suppositions and the subtleties of meaning involved inNL quantifiers.
Nevertheless, some recent develop-ments indicate that logic can play an important role inNL processing.In the first place, recent linguistic research \[15,18\]has arrived at interesting results concerning the exten-sion of standard predicate calculus in order to providea better formal model of language.Secondly, programming in logic \[19,29\] has becomepossible since the development of the PROLOG pro-gramming language at Marseille \[3,5,27\].
Logic cannow be used both as the underlying formalism and asthe programming tool.
As has been shown in \[30\], noloss in efficiency need be involved with respect tolanguages uch as LISP, even though higher level fea-tures are supported in PROLOG (e.g.
non-deter-minism).Thirdly, most PROLOG implementations include aversion of metamorphosis grammars (MGs), a logic-based formalism useful in particular for describing NLprocessors in terms of very powerful rewriting rules\[5\].Finally, the evolution in data base technology hasbeen tending more and more towards the use of logic,both for data description and for queries \[14\].Drawing on these developments, we have imple-mented (starting in 1976) successive xperimental database query systems, each written entirely in PROLOG.The first system \[6\] represented the hardware andsoftware catalogues for the Solar 16 series of comput-ers.
The user could ask it to build up a computer con-figuration satisfying his particular needs.
We thendeveloped a simpler but more general system whichaccepts different data bases to be consulted in Spanishor in French \[7\].
This system was later adapted toPortuguese consultation by H. Coelho and L. Pereira(personal communication, 1978), and to English con-sultation by D. Warren and F. Pereira (personal com-munication, 1980).
In both cases, notably few modifi-cations were needed.The data base querying features that evolved fromthe development of these successive systems werecoupled with NL representation features into a singlelogical formalism.
Its linguistic motivation and generaloutline has been described by A. Colmerauer in \[4\],and its motivation from the data base querying view-point has been studied in \[10\].
The formal definitioncorresponding precisely to our multilingual system canbe found in \[11\].In this paper we present a thorough description ofthe main principles underlying'these NL processors.There is some overlap with previous work of the au-thor \[9\], to make this paper self-contained.Copyright 1981 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial advantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires a fee and/or  specific permission.0362-613X/81/030149-16501.00American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 149Veronica Dahl Translating Spanish into Logic through LogicWe first discuss what features are convenient in acomputational ly useful logical representation of NLsentences.
Then we present an informal definition ofthe logical system possessing these features whichserves as our internal query language.
Finally, weshow a step-by-step development of a PROLOG ana-lyser for Spanish, after an informal description of ourprogramming tools.A complete listing of our PROLOG Spanish gram-mar is given in the Appendix in the Microfiche Supple-ment to this issue of the Journal.The discussion of our analyzer is not intended to benormative: alternative solutions for the problems weencountered are certainly conceivable.
Moreover,many of our choices were constrained by the hardwareand software tools available to us.
We merely showone way of using logic throughout a NL query system,which has proved feasible within modest computation-al environments.
(Our system was first implementedon a 32K, T-1600 minicomputer, using a 1975 versionof PROLOG.
)The research reported here has motivated furtherwork on logic-programmed NL processors for databases (e.g.
\[2,22,32\], and on the need of extending theoriginal MG formalism \[24\].
On the other hand, thedata base component of this system, together with thatof the SOLAR 16 system \[6\], has also influenced otherresearchers (cf.
\[2,31\]).A comprehensive description of the data base com-ponent of our system can be found in \[13\].
The SO-LAR 16 system has only been reported in \[6\].2.
Mapping Natural Language into LogicThis section discusses several NL processing prob-lems and suggests ways of solving them, through care-ful choices for the internal language's features.
Wearrive at a typed, three-valued, set-oriented logicalsystem, which we shall call L3.
Its role is a doubleone.
On the one hand, its syntax serves as a morerigorous and informative alternative to NL, makingsemantic features of NL sentences explicit.
On theother hand, its semantics provides a clear definition ofthe answer-extraction process: the evaluation of anL3 formula yields either a truth value (correspondingto a yes-no question) or the representation of a set(corresponding to a wh-question).
Spanish is used asthe concrete point of reference.
Related work forFrench is \[4\].2.1 Meaningfulness, Ambiguity and Semantic TypesA NL processing system must have a means forchecking semantic as well as syntactic well-formedness, in order to reject semantically anomaloussentences.A widespread solution to this problem consists infirst generating a "deep structure" of the sentence,taking only syntax into account, and then performingall the necessary semantic operations and checks on it.As has already been observed \[26\], this often im-plies a tradeoff between syntactic and semantic com-plexity.
But it should be emphasized that it is overallsimplicity and efficiency that are important.
It seemslikely, at least for limited computational resources anda given coverage of NL, that a several-pass analyserwill take more space and time than a one-pass analys-er.Mtrreover~ linguists themselves are not unanimousas to whether the semantic omponent should be sepa-rate or intermingled with the syntactic component\[21\].While taking no sides in this discussion, we shalldescribe a framework in which syntactic and semanticanalysis take place during a one-pass, non-deterministic process, and which, as we have said, hasproved sufficient even on small machines.Where logic is concerned, there is a simple andelegant way of dealing with meaningfulness: by usingtypes.
Types, by the way, are also a useful means forassociating the universe of predicate calculus to therelations in a particular data base.They are also useful for improving efficiency: a)by narrowing the search space, as only those values ina variable's associated omain (or type) need be con-sidered, and b) by avoiding futile access to the database, as absurd queries can be rejected by the analyseron the grounds of domain incompatibility.Another interest in using types is that they providean efficient means for discarding readings that aresyntactically acceptable but semantically incorrect.Take for instance the query:Cu~l es el salario del empleado que vive en Lomas?What is the salary of the employee who lives in Lomas?From syntax alone, there is no way to decidewhether the antecedent of the relative clause is "thesalary of the employee" or "the employee".
But in atype-checking system in which the first argument ofthe relation "live" is associated with the human do-main, and in which employees- -and not salar ies--areknown to belong to this same domain, the first readingis not even possible.Ambiguities concerning different meanings of aword can often be resolved through domain checking.Types can also be used to place modifiers otherthan relative clauses.
Our system, however, does notexploit them in this way, although it does check thatthe modifiers it encounters are of the expected type.150 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981Veronica Dahl Translating Spanish into Logic through LogicFinally, let us mention that types in a finite worldcan contribute to solving an important problem arisingin PROLOG programs in which negation is defined byproof failure (i.e., the failure to prove a given fact istaken as proof of its negative counterpart).
This is thecase for most practical data bases.
As a discussion ofthis problem falls outside the scope of this paper, theinterested reader is referred to \[12\].2.1.1 Contextual  TypingThe use of variable typing to constrain the parseand aid in disambiguation is not new.
Many languageprocessors- -such as LUNAR \[34\], CO-OP \[17\], LAD-DER \[16\], PHL IQA1 \ [1\ ] - - resort  to some kind oftyping to provide these capabilities.In our particular approach, the selection of a se-mantic interpretation is dynamically made on a syntac-tic basis.
This takes place automatically, in the stand-ard PROLOG matching of terms.
A simplified expla-nation follows, and more precise details are given in alater section.Briefly, referential words (nouns, verbs and adjec-tives) parse into predicates whose arguments aretyped.
For instance, the verb "to paint" might inducepredicates of the form:paint (person-x,object-y)The expected types of a predicate's arguments aregiven in lexical entries.
Ambiguous referential wordshave a lexical entry for each possible combination ofmeaning and syntactic role they can accept.
For in-stance, the word "blue" can designate an object's col-our or a person's mood, giving rise to the followingentries:Adjective (sad(person-x)) = blueAdjective(blue (object-x)) = bluewhere the function terms act as internal representa-tions of the word.
During the parsing process, whichis non-deterministic, the correct parse is automaticallychosen by matching appropriate terms.
For instance,"Which blue door is John painting?"
" " would generate aformula containing predicates of the form "door(t -z)" ,, I  ?
paint(person- John,t -z)"  and "p(t -z )" ,  where p iseither "sad" or "blue".
Only those lexical rules allow-ing t to take a value (namely, t=object)  that is com-patible with its three occurrences will result in a suc-cessful parse.
Thus, the "sad" interpretation is ruledout by type requirements.As we shall see later, types are actually representedby expressions that reflect subcategorizations and al-low for domain intersections to be found automaticallysimply by leaving the PROLOG interpreter to matchthese expressions.2.2 Presupposit ions, Quantif iers and aThree-Valued LogicTyped calculus in itself is not enough to make allsentences meaningful.
A third logical truth valuewould be useful, because in NL there are two ways inwhich a statement may fail to be true: either becauseits negation holds, or because something presupposedby the statement fails to be satisfied.
In the lattercase, the statement is felt to be pointless rather thanfalse.There is another reason why it must not be consid-ered false.
Take for instance the statement:El sombrerero loco odia a Alicia.The mad hatter hates Alice.In a context in which no hatter is mad, it is obviouslynot true.
However, we cannot consider it false either,since then the statementEl sombrerero loco no odia a Alicia.The mad hatter does not hate Alice.would have to be considered true.The nonexistence of a referent for the definitenoun phrase makes the whole sentence pointless.
Theexistence of more than one referent would also makeit pointless.
This is because the Spanish singular defi-nite article induces a presupposition of existence anduniqueness on the noun phrase's referent.Our treatment of quantification has been devised toaccount for those presupposit ions induced by NLquantifiers.
We prefer to call them "determiners" ", asthey include all articles, cardinal numbers and wordsl '  '1 I I  '1 such as some , many , etc.If a sentence contains a determiner, a quantifica-tion of the form "those(x,p)" is introduced, where x isa typed variable and p is a logical formula in our sys-tem.
Its evaluation yields the set of all x's in x's asso-ciated domain which satisfy p. According to thedeterminer's meaning, presuppositions about the cardi-nality of such a set are represented within the outputformula.
For instance, "Three blind mice run" is rep-resented asequal(card(those(x,and(mice(x),and(blind(x) ,run(x) ) ) ),3 )which says that the cardinality of the set of those blindmice that run is 3.Definite articles introduce the formula " i f ( f l , f2)" ,the value of which is "pointless" whenever f l  fails tobe satisfied, and has the same value as f2 if f l  is true.Figure 1 shows an example, using the easier-to-picture tree representation.
The formula representedin Figure 1 will evaluate to "pointless" if the set ofmad hatters does not contain exactly one element.American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 151Veronica Dahl Translating Spanish into Logic through Logici fIequal hateI I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I l l Icard !
those A l i ceI Ithose .
.
.
.
.
.
.
.
.
.I I I. .
.
.
.
.
.
.
.
.
x andI I Ix and .
.
.
.
.
.
.
.
.
.
.I I I. .
.
.
.
.
.
.
.
.
.
.
hat ter  madI l I Ihat ter  mad x xL IX XFigure 1.
Representation f "The mad hatter hates Alice".Examples of pragmatical ly based systems arePHL IQA1 \[1\] and CO-OP \[17\].
The semantic ap-proach is taken for instance in \[23\], where it serves inparticular to check presupposit ions induced by pro-nouns.2.2 .1  Span ish  Determiners  and  The i r  T rans la t ionsWe can now examine the general process by whicha determiner introduces a "those" formula.
Let usconsider a sentence consisting of a noun phrase fol-lowed by a verb phrase, in which the noun phrasecontains a noun introduced by a determiner.
We canfirst represent he sentence through a three-branchedquantification of the form:q(x,f l ,f2)where q is a quantif ier into which the determinertranslates, f l  is the noun phrase's translation, and f2 isthe verb phrase's translation.
Intuitively, f l  specifiesthe domain of quantification, and q states what por-tion of the domain f2 holds for.
Our previous exam-ple, for instance, can first be represented as in Figure2.Notice that the "if" formula could be used for rep-resenting other types of presuppositions as well (e.g.,those of factive predicates), although our system onlyuses it for the presuppositions of definite articles.An alternative approach to false presupposit iondetection is the pragmatic one, in which false presup-positions are caught by noting their empty extensionsin the data base, and a two-valued logic is preserved.The question of whether a pragmatic or a semanticanalysis of presuppositions i  best is far from settled,and we shall not attempt to solve it here.
Let usmerely note the following:a) The pragmatic and semantic approachesare not incompatible: one can both reportpragmatically detected failed assumptions,and assign non-traditional truth values tothe sentences containing them.b) Subtler truth-value assignments facil itatelow-cost overall responses of the system.For instance, a given presupposition's fail-ure can both be pointed out during itslocal evaluation, and carried on (via truth-values) to upper levels, for the system it-self to see and to possibly take furtheraction of its own (such as trying alterna-tive ways of complying with the request).Although not exploited in this sense in our system,this feature would allow a more flexible treatment ofpresuppositions, as it would enable the system to de-cide, for instance, in which cases they can be safelyand usefully ignored.theI.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I Iand hate.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.l I I that ter  mad x A l i cel lX XFigure 2.
A first representation f "The mad hatter hates Alice".In our implementation, a variable's associated o-main depends both on f l  and f2 in the following man-ner: each predicate known to the data base systemhas a domain associated with each of its arguments.For instance, "mad" and "hatter" could require theirarguments to belong to the human domain, whereas"hate" could require its first argument o belong to theanimal domain.When a three-branched quantification is generated,the variable it creates is typed by the intersection ofall those domains it has been associated with by thepredicates appearing in either f l  or f2.
In our exam-ple, x's type would be human (the intersection of thehuman and the animal domains).Instead of generating a different quantifier for eachdeterminer, it is useful to represent all quantificationsthrough a single one of the form:152 Amer ican  Journa l  o f  Computat iona l  L ingu is t i cs ,  Vo lume 7, Number  3, Ju ly -September  1981Veronica Dab!
Translating Spanish into Logic through Logicfor(x,p,c)the intuitive meaning of which is: "c holds for the setE of all x's in x's domain which satisfy p".
In theformula c, the set E will be represented simply by thevariable x, so that x plays a double role.Each quantification is thus assigned an equivalent"for" expression, in which the determiner's meaning isrepresented.
Here are the representations of some ofour Spanish quantifiers.
The rest are considered inSection 2.2.1.2.un(x,f l , f2) = for(x,and(f l , f2) ,greater-than(card(x),0))atodo(x,f 1 ,f2) = for(x,and(f l  ,not(f2)),equal(card(x),0))everyel(x,f 1 ,f2) = for(x,f l  , if(equal(card(x), 1 ),f2))singular thelos (x,f 1 ,f2) = for(x,f 1 , i f(greater-than(card(x), 1 ),f2))plural theningfin(x,fl,f2) = for(x,and(f l , f2) ,equal(card(x),0))noi (x,f l , f2) = for(x,and(f l , f2),equal(card(x), i ))any cardinal numberunos(x,f l , f2) = algunos(x,f l , f2) =some for(x,and(f l , f2) ,greater-than(card(x) , l ) )Notice that we have chosen to translate "un" (a) as"at least one" (a frequent sense for "un").
In orderto avoid ambiguity, "1" should be used to mean"exactly one".
This convention is particularly usefulwhen negation is involved.
For instance, "No tengoun centavo" (I have not a cent) would be wrongly rep-resented in the "exactly one" interpretation: it wouldstate that the number of cents I possess is notone,which means it can either be 0,2,3, etc.Finally, any formula of the form "for(x,p,c)" canbe replaced by just the formula c, in which all occur-rences of x have been replaced by the formula:those(x,p)representing the subset of x's domain whose elementssatisfy p. This replacement takes place in the database component of our system.The reader can now verify that the representationsshown in Figures 1 and 2 are equivalent.2.2 .1 .1  Quant i f ie r  H ie rarchyIn our NL subset, quantif ier hierarchy obeys thefollowing three rules, which perhaps are too simplistic,but have proved useful.
A more thorough descriptioncan be found in \[4\].Rule 1: A determiner in a verb's subject intro-duces a quantification which dominates all quantifica-tions introduced by the verb's complement(s) .
Forinstance, "Toda rosa tiene (algunas) espinas" (Everyrose has (some) thorns) is represented:toda(x,rosa(x),algunas(y,espinas(y),t iene(x,y)))every rose some thorns hasNotice that the representationsome(y,thorn(y),every(x,rose(x),has(x,y)))would be incorrect, as it means instead: "there existsa particular set of thorns which every rose has".- Rule 2: Whenever a noun has a complement, thequantification introduced by the complement's deter-miner dominates the one introduced by the noun'sdeterminer.
For instance, "Sfibato autografia el librode cada visitante" (Sizbato autographs the book of eachvisitor) is represented:cada(x,visitante(x),el(y,l ibro-de(x,y),autografia(Sabato,y)))each visitor the book-of autographs- Rule 3: When a referential word (a verb, a nounor an adjective) has more than one complement, quan-tification takes place from right to left: the rightmostcomplement generates a quantif ication which domi-nates the quantification(s) introduced by the leftmostcomplement(s).
For instance, "Rafil regala un espejoa cada nifio" (Raid gives a mirror to each child) is rep-resented:cada(x,nino(x),un(y,espejo(y),regala(Raul,y,x)))each child a mirror gives2.2.1.2 Determiners with a Negative ImplicationAs a general rule, the negation introduced by "no"in a sentence is translated by placing the operator"no" (not) right after the quantification introduced bythe subject.
For instance, "La indemnizaci6n o com-pensa el despido de Martin" (The indemnity does notcompensate for Martin's dismissal) is represented:la(x, indemnizacion(x),no(el(y,despido-de(Martin,y),compensa(x,y))))the indemnity not the dismissal-of compensateBut negation is not always explicit.
The Spanishdeterminer "ningfin" (no) can be regarded as an im-plicit negation, since it expresses that no portion ofthe domain of quantif ication satisfies the statementinvolved.In a non-inverted subject position (e.g., "Ningfinelefante vuela" -No elephant flies), it generates a spe-cial quantifier called "ningfin", the representation ofwhich takes this fact into account, as we have seen.There are two other cases, however, in which thedeterminer "ningfin" coexists with an explicit negation.These cases require a different quantifier, as otherwiseAmerican Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 153Veronica Dahl Translating Spanish into Logic through Logicthe negation would be represented twice.
These casesare:- In a subject position, with subject-verb inversion:the "ningfln" determiner is assimilated to the "every"quantifier.
For instance, "No vino ningfln alumno"(No student came) is represented:todo(x,alumno(x),no(vino(x)))every student not came- In a position other than the subject: the "ningfln"determiner is assimilated to the indefinite article'squantifier.
For instance, "Carlos no tiene ningflnhijo" (Carlos has not any chiM) is represented:no(un(x,hijo (x),tiene (Carlos,x)))not a child hasAnother special case is the negation preceding the"todo" (every) determiner, e.g.
"No todo p~jaro can-ta" (Not every bird sings).
The analyser considers "notodo" as a single determiner generating its own associ-ated quantifier:no-todo(x,f l ,f2) =for(x,and(fl ,not (f2)),greater-than(card(x),0))2.3 Distributive, Collective, and Respective PluralSemantically, different kinds of plurals can be dis-tinguished.
For instance, the sentence "Ana y Juanhablan espafiol y franc6s" (Ann and John speak Span-ish and French), which translates roughly intospeak({Ann,John\],  {Spanish,French\]),introduces a distributive plural and must therefore eval-uate to true (false) if the following formulas are alltrue (false):speak(Ann,Spanish)speak(John,Spanish)speak(Ann,French)speak(John,French)On the other hand, the sentence "A y B son paralelas"(A and B are parallel), which translates intoparallel({A,B\]),introduces a collective plural and must evaluate to ei-ther true or false as a result of testing the whole set{A,B} for the property of being parallel.Finally, the sentence "Ana y Juan ganan respecti-vamente 1000 y 800 dolares" (Ann and John respec-tively earn 1000 and 800 dollars), which translates intoearn({Ann,John\],  {$1000,$800}),introduces a respective plural and must evaluate to true(false) if the following formulas are both true (false):earn(Ann,$1000)earn(John,S800)Notice that both distributive and respective pluralspresuppose that the set of formulas to be tested allhave the same truth value.
Whenever such a presup-position is not satisfied, the plural predication is nei-ther true nor false.
In the logic L3, the predication isassigned the "pointless" truth value; but in an im-provement of this system, we are proposing the use ofa fourth truth value, called "mixed", for this situation.It seems more appropriate to differentiate "pointless"and "mixed", so that the system has easy access tolocally detected semantic information, in case it needsto take further action.Distributive and collective plurals are distinguishedin the lexicon by syntactically marking the relationthey translate into.Respective plurals are not handled in our imple-mentation: they were introduced (although with onlytwo logical values) in the Portuguese version of oursystem, where the analyser recognizes them throughthe words "respective" and "respectively".2.4 SetsRelations must be allowed to apply on sets if weare to deal with collective relations.
Sets are moreovernatural enough in data base applications, as retrievaloften concerns sets of objects satisfying certain prop-erties.
They can also be useful for defining types.
Werepresent hem either extensionally (through lists) orintensionally (through "those" formulas).Set operations are implicit while pars ing- -as  dy-namic type checking involves intersecting variousdomains - -and also during formula evaluation (i.e., inthe data base component  of our system).
In bothcases they are kept invisible to the user.In particular, the user can refer to either sets orindividuals when defining a new relation, and rely onthe system to make appropriate inferences from hisdefinitions.2.5 Linguistic CoverageOur NL subset is extendible in the sense that theuser can define those referential words (nouns, verbsand adjectives) associated with his particular database.
This includes the definition of synonyms, alwaysuseful regarding different users' views of a data base.The analyser uses a syntactic variant of PROLOG,called (normalized) metamorphosis  grammars (MGs)\[5\].
As such, MGs share a most useful feature of logicprograms: a problem's description and the programwhich solves it are one and the same.
This is due tothe existence of an operational as well as a declarativeinterpretation for logic programs \[19\].154 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981Veronica Dahl Translating Spanish into Logic through LogicThus, the grammar shown in the Appendix (in theMicrofiche Supplement) both provides a formal defini-tion of our linguistic coverage (in its declarative read-ing) and is the analyser itself (in its procedural read-ing, which the PROLOG interpreter gives it).An informal description of its coverage follows.- Fixed vocabularyDeterminers:el la los las un una unos unasthe a someningfm todo ino every any cardinal numberPrepositions: all Spanish prepositionsConjunction: y andRelative pronouns: que quien donde cuyo cual(es)~: which who where whoseInterrogative pronouns:qu6 cu~nto(s) d6nde qui6n cu~lwhich how much/many where who whichNegative particle: noVariable vocabulary.
Each particular data baseincludes a definition of its associated proper names,nouns, adjectives and verbs.
Only simple verbal formsin the third person are allowed.- Structure.
Sentences are either declarative or inter-rogative, in the active voice.
A declarative sentenceconsists of a subject, an optional negation particle, averb and its modifiers (in the restricted sense de-scribed below).A subject consists of a noun phrase.
A nounphrase is either a series of proper names or a kernelfollowed by noun modifiers and relative clauses (bothoptional).A noun phrase's kernel consists of an optional det-erminer, an optional series of adjectives, a noun, andpossibly a series of adjectival groups.
Mass nouns arenot dealt with.
An adjectival group is an adjectivewith modifiers.A modifier (of a noun, an adjective or a verb) isjust a noun phrase as described above, possibly intro-duced by a preposition.Both relative and interrogative clauses are modifiedversions of a declarative sentence, where some ele-ments have changed places and some have been re-placed by a relative or an interrogative pronoun.Figure 3 gives a sample consultation session withthe system.
The data base being consulted concernsindividuals grouped as either salesmen, administrativeemployees, managers, sites, departments or salaries.The first two sets are grouped to form the employeedomain, which together with the manager domainforms the human domain.
The data base contains the1.
Hola.
(Hello.)Diga.
(I am listening.)2.
Con qui6n est~ casada Eva?
(Who is Eva married to?
)Con Adhn.
(To Adhn.)3.
Aden y Eva viven en Lanfis?
(Do Adhn and Eva live in Lanits?)No.4.
D6nde viven Eva y Aden?
(Where do Eva and Aditn live?
)En Montechingolo.
(In Montechingolo.)5.
Los departamentos viven en Lanfls?
(Do departments live in Lanus?
)No entiendo su frase.
(I cannot understand your sentence.)6.
Cu~ntos vendedores no trabajan en Dep- l?
(How many salesmen do not work in Dep-l ?)2.7.
Qu~ vendedores no trabajan en Dep- l?
(Which salesmen do not work in Dep-l ?
)Aden y Beatriz.
(Adan and Beatriz.)8.
Con qui6n est~ casada la empleada cuyo salario es3 millones?
(Who is the employee (+fern.)
whose salary is 3 mil-lion married to?
)Con Zoilo.
(To Zoilo.)9.
Curies son las empleadas con cuya jefa trabajaQuintin?
(Which are the employees (+fern.)
whose manager(+fern.)
Quintin works with?
)Beatriz y Eva.
(Beatriz and Eva.)10.
No todos los empleados viven en Lanfls.
(Not every employee lives in Lanlts.
)Muy cierto.
(Quite true.)11.
Ningfln empleado vive en Lanfis.
(No employee lives in Lanits.
)No es cierto!
(It is not true.t)12.
El vendedor que vive en T6mperley gana 4 mil-lones.
(The salesman who lives in Tbmperley earns 4million.
)Hay alguna presuposici6n falsa en su afirmaci6n.
(There is a false presupposition i your statement.)13.
Cu~l es el lugar donde no vive ningfln empleado?
(Which is the place where no employee lives?)T6mperley.14.
Cu~ntas personas viven en T6mperley?
(How many people live in Tbmperley?)Ninguna.
(None.)15.
Con qui6n est~ casado Daniel?
(Who is Daniel married to?
)Con nadie.
(To nobody.
)Figure 3.
A sample consultation session.American Journal of Computational Linguistics, Volume 7, Number 3, Ju ly-September 1981 155Veronica Dahl Translating Spanish into Logic through Logicrelations live-in, earn, married, married-to, work-at,work-with and manager-of.
Unary relations namedafter each domain are implicit in any data base.3.
The Internal Query Language: L3Informally, three kinds of L3 formulas can be dis-tinguished: typed formulas t, statement formulas s, andinteger formulas n.- a typed formula  t denotes a subset of a given do-main.
It can be either a list of constants, a variable oran expression of the form "those(x,s)".- a statement formula  s evaluates to either true, false,or pointless.
It can take any of the forms:r(t l  .
.
.
.
.
tn) where r is an n-ary predicate symbolcorresponding to a distributive, col-lective or respective relation.and(sl ,s2)if(s 1,s2)not(s)equal(nl ,n2)greater-than(nl ,n2)- an integer formula  nl  denotes an integer number,and can take one of the forms:j where j is an integer such that j>0card(t)Further details can be found in \[11\].4.
Tools for Wr i t ing the AnalyserA brief and informal introduction to logic programsand metamorphosis  grammars is given here, for thesake of completeness.
Fuller accounts can be found in\[5,19,20,29\].4.1 On Logic ProgrammingLogic programs are essentially sets of clauses of theform:B <--  A1,A2 ..... Ancalled Horn clauses, where B and Ai are atomic formu-las, and all variables in the atomic formulas are under-stood to be universally quantified.
"<- - "  is read "if",and the commas stand for conjunction.
An emptyright-hand side denotes a non-conditional assertion offact.
For example,1) l ikes(mother(x),x) <- -every x is l iked by his-her-its mother2) l ikes(Rover,y) <- -  l ikes(y,Rover)Rover l ikes every y who likes himIn the rest of the paper (except for the figures),variables appear in italics in order to distinguish themfrom constants.With respect to a given set of clauses (i.e., a pro-gram), the user can ask for relations to be computed,by stating procedure calls, i.e., clauses of the form:<--  A1,A2,...,AnThis triggers an automatic demonstrat ion process,during which the variables in the call take values forwhich "A1 and A2 and ... and An" holds.
Here"<- - "  can be interpreted as a question mark.
Anunsuccessful termination implies that no such valuesexist.Thus, with respect to clauses 1 and 2 above, thefollowing call:3) <- -  l ikes(z,Rover)Who likes Rover?results in z being unified (bound) to "mother(Rover)" .The same result would have been obtained from thecall:4) <- -  l ikes(z,Rover), l ikes(Rover,z)Who likes and is l iked by Rover?Alternative results for the same call may be ob-tained within non-determinist ic programs.
For in-stance, if we add the clause:likes(Sweetie,Rover) <- -then call 3 can alternatively result in z being bound to"Sweetie".Practical logic program interpreters, such as PRO-LOG,  also include some extra-logical features forinput/output and control functions.4.2 On Metamorphos is  GrammarsMGs are a powerful formalism for describing andprocessing languages, in which:- context-sensitive r writing rules can be described.- any substring of any length can be rewritten intoany other string.- grammar symbols may include arguments.- conditions on rule application may be specified.- sentence generation and parsing are providedby the processor.MGs can be regarded as a convenient alternativenotation for logic programs.
Rather than definingthem precisely, we shall exhibit some sample grammarrules and show informally one way of translating theminto Horn classes, that basically follows A.Colmerauer 's  PROLOG axiomatization of MGs.
Aformal and comprehensive description can be found in\[5\].156 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981Veronica Dahl Translating Spanish into Logic through Logic4.2.1 Context -F ree  Ru lesGrammar rules can be graphically represented byconsidering non-terminals as labeled arcs connectingphrase boundaries.
A rule such as S - -> A B is repre-sented assI II A B v0 .
.
.
.
.
.
.
>0 .
.
.
.
.
.
.
>0xO x l  x2or, in Horn-clause terms:arrow(S,xO,x2 ) <-- arrow(A,xO,xl ), arrow(B,xl ,x2 )which can be read, for every xO, x l  and x2, there is anarrow labeled S between points xO and x2 i f  there is anarrow labeled A between xO and x l  and another onelabeled B between x l  and x2.Terminals in a rule are included as part of anedge's name and do not give rise to extra atoms.
If aterminal symbol "a" labels an arc leading to point "x",the starting point is named "a.x" (where .... is a bina-ry operator in infix notation).
Thus, the rule S - -> aB S c can be represented:s. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I II a B S c v0 .
.
.
.
.
.
.
>0 .
.
.
.
.
.
.
.
>0 .
.
.
.
.
.
.
.
>0 .
.
.
.
.
.
.
.
>0a .xO xO x l  c .x2  x2arrow(S,a.x0,x2 ) <--  arrow(B,x,xl ), arrow(S,xl ,c.x2 )Strings of consecutive terminals are treated as asingle one named after their concatenation.4.2.2 Genera l  Rewr i t ing  Ru lesWhen the left-hand side of a rule contains morethan one symbol, a single arrow is not enough to de-pict it: we need another path between the extremepoints.
For instance, the rule B a - -> a B can begraphed as:B a .x  a. .
.
.
.
.
.
.
.
.
>0  .
.
.
.
.
.
.
.
.
.
.I II a B v0 .
.
.
.
.
.
.
.
.
.
>0 .
.
.
.
.
.
.
.
.
.
>0a.xO xO xwhere the lower path represents the right-hand side, asusual, and the upper path represents the left-hand sideof the rule.
In terms of Horn clauses, this gives:arrow(B,a.xO,a.x) <-- arrow(B,xO,x)Notice that no restrictions need be imposed on thelength of the strings on either side of the rule.4.2.3 A Full ExampleCompleting the last two rules, we obtain an MGgrammar for the language {anbncn}:1) S --> a B S c2) S --> a b c3) B a --> a B4) B b --> b bwhere rules 2) and 4) translate respectively into:2') arrow(S,a.b.c.x,x) <--4') arrow(B,b.b.x,b.x) <--In the Horn-clause formulation of this grammar,recognition and parsing of a given string (e.g.
"a.a.b.b.c.c.nil") is automatically obtained through therespective PROLOG calls:5') <-- arrow(S,a.a.b.b.c.c.nil,x)6') <-- arrow~,a.a.b.b.c.c.nil,x)where the value of x is of no interest to the user.
Inorder that he need not specify it, a PROLOG predi-cate called "syn" (for "synthesize") is made available.Its general form issyn(x,y)where x stands for the internal representation of thesurface sentence y.
The above commands are there-fore actually written:5) <--  syn(S,a.a.b.b.c.c.nil)6) <--  syn(y,a.a.b.b.c.c.nil)4.2.4 Pars ing and Generat ingMGs can also be written for the purpose ofgenerating sentences.
The same syn command is usedfor this purpose, except that this time the second argu-ment is the one represented by a variable, e.g.
:<-- syn(S,x)In some cases, it is even possible for the samegrammar to work in both ways, although this requiresa very careful design.
In the rest of this paper, weshall only be concerned with parsing.4.2.5 Arguments  Wi th in  Grammar  Symbo lsWe might normally want the parser to retrievemore information than mere recognition.
The gram-mar shown above, for instance, can be also used toretrieve the substring of a's, if it is modified as fol-lows:1) S(a.x) - -> a B S(x) c2) S(a) --> a b cCall 6 would now bind y to S(a.a).American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 157Veronica Dahl Translating Spanish into Logic through Logic4.2.6 Conditions and CalculationsRight-hand sides of rules may contain PROLOGcalls (which we shall note between square brackets).They must be successfully evaluated for the rule toapply.
For instance, retrieval of the number of a's canbe obtained in the above grammar by changing thefirst two rules into:1) S(n) - -> a B S(m) c \[plus(m,l,n)\]2) S(1) - -> a b cwhere "plus" is a PROLOG predicate defining addi-tion of integers.
PROLOG calls can also be used toenforce conditions on rule applications.4.2.7 Normalized MGsPROLOG only accepts normalized G rules, i.e., ofthe formA x - -> yThe derivation graph for " John laughs" is shown inFigure 4.
The numbers identify the rule applied.
Thesubstitutions needed for applying the rule appear asright-hand side labels.
Through them we can recon-struct the deep structure " laugh(john)".Sentence(x)I11 x<-s. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I IProper-noun(k) Verb(k,s)3 I k <- john 4 I s <- laugh(john)I Ijohn laughsFigure 4.
Derivation graph for "John laughs".where A is a non-terminal symbol, x is a string ofterminals and y is any sequence of grammar symbols.This restriction is necessary, within the schema shown,for translating rules into Horn clauses (also calleddefinite clauses), in which at most one left-hand sideatomic formula is allowed.
For this reason, they havealso been called "definite clause grammars "t, in arecent article \[24\] which compares them favourablyagainst the Augmented Transition Network formalism,introduced by Woods \[39\].As has been shown in \[5\], non-normalized rules canbe easily replaced by an equivalent set of normalizedones.
For instance, B a C b - -> f g can be replacedby B a c b - -> f g and C - -> c, where c is a "dummy"terminal.
From the parsing point of view, the resultsare equivalent.We can therefore safely ignore this restriction in allthat follows, for the sake of clarity.4.2 .8  Der ivat ion  GraphsAlthough MGs can be understood declaratively, itis sometimes useful to follow a sentence's completederivation, by constructing a graph which depicts thetop-down, left-to-right history of rule applications.We illustrate this through the grammar:1) Sentence(s) - -> Proper-noun(k) Verb(k,s) .2) Proper-noun(tom) - -> tom3) Proper-noun(john) - -> john4) Verb(k, laugh(k)) - -> laughs1 In a restricted sense, DCGs only allow a single non-terminalon the left hand side, and are therefore an even more restrictedform of MGs.
A more accurate synonym for "normalized MG"might be "full DCG"- -an  expression suggested by D. Warren andF.
Pereira in the first draft of \[24\].Notice that, once a variable takes a value, this val-ue is propagated to each of its occurrences in thegraph.
Thus, when applying rule 4, we use the knownvalue of k=john.
Also, variable renaming must takeplace whenever necessary in order to ensure that therule applied and the string it applies to share no varia-bles.5.
Step-by-Step Development of a Spanish AnalyserWe now develop a small Spanish parsing grammar,step by step.
Although oversimplif ied, it il lustratespractically all of the techniques used to develop thegrammar shown in the Appendix (in the MicroficheSupplement).
Deep structures and non-terminal sym-bols are in English, for the convenience of most read-ers.5.1 Elementary StatementsThe following grammar describes some simplestatements constructed around proper nouns, verbsand adjectives.S) Statement(s) - -> Proper-noun(k)  Verb(k,l,s)Complements(l ,s)V1) Verb(k,l,s) - -> Verb 1 (be) Adjective(k,l,s)V2) Verb(kl ,list(arg(in,k2 ),nil),live-in(kl,k2 ) ) -->Verb 1 (live)A1) Adjective(k,nil, intell igent(k)) - ->Adj 1 (intelligent)A2) Adjective(k l ,list( arg(with,k2 ),nil),angry-with(k/ ,k2))  - -> Adj 1 (angry)158 American Journal of Computational Linguistics, Volume 7, Number 3, Ju ly -September  1981Veronica Dahl Translating Spanish into Logic through LogicC 1) Complements(nil,s) - ->C2) Complements(list( arg(p,k ),l),s) -->Complements(l ,s) Preposition(p) Proper-noun(k)Lexicon:L1) Adj 1 (intelligent) - -> inteligenteL2) Adj l  (angry) - -> enojadoL3) Verb l (be)  - -> esL4) Verb l (be)  - -> estAL5) Verbl( l ive) - -> viveL6) Preposition(in) - -> enL7) Preposition(with) - -> conL8) Proper-noun(joan) - -> juanaL9) Proper-noun(tom) - -> tomAsL10) Proper-noun(london) - -> londresetc.Figure 5 shows the derivation graph for "TomAsestA enojado con Juana" (Tom is angry with Joan).Most of the substitutions shown concern the deepstructure, x.
The empty string is denoted by a lambda.Some non-terminal symbols are abbreviated.
From thesubstitutions hown, we can see that x takes the value"angry- with (tom,j oan)".Statement(x)IS Ix<-s. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.IPr-noun(k)IL9 1 k<-tomItomasIVerb(k,l ,s)ICompls(nil ,s)IVI C1 IIXI ICompls(l,s)IC2 I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I IPrep(with) Pr-noun(k2)I IL7 1 L8 I k2<-I I joancon juanaI IVerb1(be) Adj ( tom, l ,s)I IL4 I A2 I kl <- tomI I 1 <- l i s t (a rg(w i th ,k2) ,n i l )esta I s <- angry-with(tom,k2)IAdj1(angry)IL2 1IenojadoFigure 5.
Derivation graph for "Tom~s est~ enojado con Juana".5.2 Syntact ic  and Semant ic  AgreementSyntactic agreement can be enforced by manipulat-ing features such as gender and number within everyrule concerned with syntactic checks.
For instance,the modified rules:L2) Adj l  (fern-angry) - -> enojadaL2')  Adj l  (mas-angry) - -> enojadoL8) Proper-noun(fem-joan) - -> juanaL9) Proper-noun(mas-tom) - -> tomAsA2) Adj(g l -k l ,list(arg(with,g2-k2 ),nil),angry-with(k/ ,k2)  - -> Adj 1 (gl-angry)make it impossible to accept a sentence such as:TomAs estA enojada con Juana.Tom is angry (+fem.)
with Joan.Semantic constraints can be enforced similarly.For a referential word to induce a distributive relation,for instance, we add a prefix such as 'dr'  in the corre-sponding rule, e.g.
:A1) Adj(g-k,nil,dr(intelligent(k))) - -> Adj(intelligent)and establish the convention that unmarked predicatesare assumed to be collective.
The data base compo-nent of our system can thus distinguish each kind ofrelation and ensure an appropriate interpretation ineach case.Types can be represented in the same way as syn-tactic information.
But we want them to be built upduring the parse, as a function of the various typesinvolved in a given sentence.
A quick way to achievethis is through unification.
We can represent a type tin a manner that reflects set inclusion relations to oth-er types, e.g.
:nil&t&t l&...&tnwhere the ti are types such that E ( t )cE( t l ) c .
.
.
cE ( tn ) ,and & is a binary operator in infix notation.Such representations may be partially specified, asinv&employee&humanwhich can be matched with all those type representa-tions for types contained in or equal to the"employee" type.
For instance, v can take the values:nilnil&salesmannil&manageretc., according to the context.In general, noun definitions will have the mostweight in determining types: since it is nouns thatintroduce data base domains, their associated types areusually completely specified.
Although this conventionAmerican Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 159Veron ica  Dahl  T rans la t ing  Span ish  into Logic  th rough Logicmight result in rejecting as semantically anomaloussentences that might deserve closer inspection (e.g.
"Do all the animals speak Latin?
"), it would seem areasonable compromise between speed and coverage.5.3  Noun PhrasesWe now modify our grammar so as to handle quan-tified noun phrases.
Agreement, both syntactic andsemantic, is now left out for the sake of clarity.For explanatory purposes, let us imagine a NLquantifier as a device which creates a variable k andconstructs a 'for' formula s out of k and of two givenformulas sl and s2 (respectively standing for the nounphrase's and the verb phrase's translations).
In termsof MG rules, this can be expressed as:Determiner(k,sl,s2,s) - -> detwhere "det" is a given NL determiner.
Two samplerules follow:D 1) Determiner(k,sl ,s2,for(k,sl,if(equal(card(k,1),s2 ) ) - -> el (singular the)D2) Determiner( k,s l ,s2 ,for( k,and( sl ,not(s2 ) ),equal(card(k),0)) - -> todo (every)A noun, in turn, can be imagined as a device thattakes the variable created by the quantification andconstructs a relation, as in the following example:NO1) Noun(k,friend(k)) - -> amigoWe can now relate a noun phrase to a verb phrase,through the rules:N1) Noun-phrase(k,s2,s) -->Determiner(k,sl ,s2,s) Noun(k,sl )N2) Noun-phrase(k,s,s) - -> Proper-noun(k)S) Statement(s) - ->Noun-phrase( k,s2,s) Verb( k,l,s2 ) Compls( l,s2 )Thus, a noun phrase can be regarded as a devicetaking a formula s2 (the verb phrase's representation),and producing a variable k and a formula s that repre-sents the whole statement.
In the case of a propernoun, s merely takes the same value as s2.Notice that the order in which these devices areimagined to work is unimportant.
They can be regard-ed as term (i.e., tree) constructors which fill in differ-ent gaps in those trees they share.
For instance, thevariable s2 in rule S, which stands for a term of theformr(tl ..... tn),is given such a form by the Verb device, while theCompls device fills in the values of its arguments.
TheNoun-phrase device, on the other hand, can be consid-ered a consumer of s2: it uses s2 in order to build ups.
It does not need s2 to be completely specified,however.
It merely fits s2 into its place in s, expectingthat sooner or later it will become completely speci-fied.We can now modify our rules for complements sothat they will allow quantified noun phrases as well asproper nouns:C1) Compls(nil,s,s) - ->C2) Compls(list( arg(p,k ),l),s l ,s ) -->Compls(l,sl,s2) Prep(p) Noun-phrase(k,s2,s)Notice that these two simple rules are enough to han-dle verb, adjective, and noun complements.
All wehave to do is modify rules S and N2 as follows:S) Statement(s) - -> Noun-phrase(k,s2,s)Verb( k,l,s l ) Compls( l,s l ,s2 )N2) Noun-phrase(k,s2,s) -->Determiner( k,s l ,s2 ,s )Noun(k,l,s3) Compls(l,s3,s)and add extra rules for nouns, adjectives, or verbs thataccept complements, e.g.
:NO2) Noun(k l ,list(arg(of,k2),nil),friend-of(k l ,k2 ) )- -> amigoFor uniformity, we rewrite NO1 into:NO1) Noun(k,nil,friend(k)) - -> amigoThe reader can now make a derivation graph for,for instance, "El amigo de Juana ester enojado conTom~s" (Joan's friend is angry with Tom).
The deepstructure shown in Figure 6 should be obtained.forl.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.k f r iend-o f  i fI t. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.l lk JoanI Iequal angry-wi thi Il l I icard 1 k TomIkFigure 6.
Internal representation for "El amigo de Juana est~enojado con Tom~s".160 Amer ican  Journa l  of  Computat iona l  L inguist ics ,  Vo lume 7, Number  3, Ju ly -September  1981Veronica Dahl Translating Spanish into Logic through Logic5.4 Negative SentencesTo handle negation, we can replace rule S by:S) Statement(s) - -> Kernel(l,sl,s2,s) Compls(l,sl,s2)K) Kernel(l,sl,s2,s) --> Noun-phrase(k,s3,s)Neg(s2,s3) Verb(k,l,sl)G1) Neg(s,s) - ->G2) Neg(s,not(s)) - -> nowhere the Neg "device" takes a formula s and prod-uces either s itself or not(s), according to whether thenegation particle "no" is absent or present.In sentences like "No vino ningfln alumno" (Nostudent came), there is subject-verb inversion, andnegation is represented twice.
The deep structureshould read: "For every student, it is stated that hedid not come".
To handle this situation, we take ad-vantage of a non-terminal Case(c) which can explicitlyrecord the role of a given noun phrase as subject.
Ourrules are augmented as follows:K) Kernel(l,sl,s2,s) --> Modifier(subject-k,s3,s)Neg(s2,s3 ) Verb( k,l,s l )M) Modifier(c-k,sl,s2)-->Case(c) Noun-phrase( k,s l ,s2 )The subject-verb inversion rule is as follows.
Itsapplication leaves a symbol " Inv" as a marker.I) Modifier(k,s3,s) Neg(s2,s3) Verb(k,l,sl) -->Neg(s2,s3 ) Verb( k,l,s l ) Inv Modifier( k,s3 ,s)This marker is used to transform a surface 'ningfin'quantifier into ' todo'  (every), provided it occurs in aninverted subject.
Otherwise, the markers are erased:T) Inv Case(subject)M1) Case(subject) - ->M2) Inv - ->todo - -> ningflnThese rules implement our general treatment of nega-tion described earlier.The non-terminal Case(c) is important also inhandling complement noun phrases.
Such noun phras-es introduced by a preposition p will have associatedcase prep(p).
Direct object noun phrases will havecase "dir", and so on.
We generalize rule C2 toC2) Compls(list(arg(c,k),l),sl,s) - ->Compls(l,sl,s2) Modifier(c-k,s2,s)and addM2) Case(prep(p)) - -> Prep(p)etc.5.5 Interrogative and Relative ClausesAs subject-verb inversion has already been defined,we can handle Spanish yes-no questions simply byadding:SE1) Sentence(fact(s)) - -> Statement(s).SE2) Sentence(yes-no(s)) - -> Statement(s) ?
(Notice, by the way, that the analyser actually prod-uces more information than the L3 formula s. Thedata base component uses this extra information todetermine the form of the answer, to identify the setto be retrieved (as in rule SE3 below), etc.
).Wh-questions, on the other hand, often requiremodifiers to be moved around and replaced by pro-nouns.
For instance, "D6nde vive Tomfis?"
(Wheredoes Tom live?)
can be considered as a variant for"Tomfis vive en k" (Tom lives in k), in which "en k"has been moved to the beginning of the sentence andreplaced by "D6nde".Relative clauses usually undergo similar transforma-tions.
For instance, "El empleado cuya jefa es Juana"(The employee whose manager is Joan) can be consid-ered as a variant of "El empleado \[la jefa del emplea-do\] es Juana" (the employee \[the manager of the em-ployee\] is Joan), where "del empleado" has shifted tojust before " jefa" to be subsumed, together with "la",by the relative pronoun "cuya".
To handle theseclauses, we use markers in the form of grammar sym-bols; we move the concerned modifiers and then weuse context-sensitive rules to replace the appropriateconstituents by a pronoun.
We illustrate this for inter-rogative sentences uch as the above example.
Firstwe add an interrogative marker:SE3) Sentence(wh(k,s)) - -> Wh- l (k )  Statement(s) ?A modifier to be moved can be handled by the extrarule:C3) Compls(list(arg(c,k),l),sl,s)-->Moved-mod( k,s2 ,s ) Compls( l,s l ,s2 )which places it as the first complement.
It must nowskip the kernel so as to become the head of the sen-tence:SK) Wh- l (k )  Kernel(l,sl,s2,s) Moved-mod(k,s3,s4)- -> Wh-2(k) Modifier(k,s3,s4) Kernel(l,sl,s2,s)Finally, it can be replaced by a pronoun:PR) Wh-2(k) Modifier(k,sl,s2) - -> d6ndeFigure 7 shows a simplified derivation graph for"D6nde vive Tomfis?
", from which the internal repre-sentation wh(k, l ive- in(Tom,k))  is obtained.
Argu-ments and substitutions are left out in order to empha-size the structure of the derivation.American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 161Veron ica  Dahl  Translating Spanish into Logic through LogicSentenceSE31.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I IWh- 1 Statement ?s I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I IKernel Compl sI c31I .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I II Moved-mod Compl sl I c1 J. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1SKI  ~.. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I IWh-2 Modifier KernelI i KIPR Id6ndeNegG1 III i iModifier Neg VerbI I I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I l iVerb Inv ModifierL5 I M2 I M II I .
.
.
.
.
.
.
.
.
.
.
.
.
.
.vive ~ I ICase Noun-phraseM1 I N1 IProper-nounL91tomasSentenceSE3 J. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I I LWh-1 Statement ?S l. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.I IKernel Compl sKI C21.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.l I l I IModi f i  er Neg Verb Compl s Modi f i  erI I I C1 I / /.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
~ jI I / //.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
fPR' Id6ndeI t I / INeg Verb Inv / Modifier /GI I L51 M21 / M II l / I  .
.
.
.
.
.
.
.
.
.
.
.
.
.
.vive / ~ I I // Case Noun-phraseMI i NILProper-nounL91tomasFigure 8.
XG skeleton derivation graph for "D6nde vive Tom~s?
"Here "..." stands for any intermediate string ofsymbols, which the rule's application leaves untouchedto the right of "D6nde".
Thus, the skeleton derivationgraph would now be as shown in Figure 8.
Two rules(C3 and SK) have been eliminated, and the resultinggraph is clearer.Figure 7.
MG skeleton derivation graph for "Donde vive Tomas?
".An alternative way of moving modifiers withinMGs is by adding extra arguments to each non-terminal possibly dominating a modifier to be sub-sumed by a pronoun, as has been observed in \[25\].
Itis however useful to be able to picture transformationsthrough argument-stripped derivation graphs, as in thetechnique just exemplified.
This leads naturally toways of extending the MG formalism: Figure 7 sug-gests that movements might be achieved more easily ifunidentified substrings can be referred to, so thatwhatever appears in between the expected pronounand the mobile modifier can be skipped by the latterthrough a single rule.
Such syntactic liberty is allowedin extraposition grammars (XGs) \[25\], where, for in-stance, rule PR cn be replaced by:PR') Wh- l (k ) .
.
.
Modifier(k,sl,s2) - -> D6nde6.
Extens ionsSome of the limitations of our system are quiteobvious from our discussion; e.g., pronoun referencesare not dealt with, other than for relative and interro-gative pronouns.
Possible extensions and related workinclude the following:More flexible modifier scoping rules.
The ones de-scribed here were adopted as a compromise betweenlinguistic power and computational speed.
Our choicewas constrained by the inconvenience of resorting tofrequent ests within grammar ules.
Although allowedin PROLOG,  this facility was too costly in the mini-computer version available to us.
Meaning distortionsresulting from too rigid quantifier scoping were, how-ever, partly compensated for by using contextual infor-mation available through unification to choose be-tween alternative meanings of a given determiner.
Aninteresting treatment of modifiers in logic grammarshas been recently proposed in \[22\].
It involves a162 Amer ican  Journa l  of Computational Linguistics, Vo lume 7, Number  3, Ju ly -September  1981Veronica Dahl Translating Spanish into Logic through Logicthree-pass analyser, developed within a particularlymodular framework, in which all syntactic structuresare represented through a single format.,4 subtler treatment of presupposition detection.
Al-though the treatment discussed here allows for a quickdetection of failed presuppositions, it fails to indicatetheir nature.
More helpful answers should make ex-plicit the user's wrong assumptions, and possibly cor-rect them.
The latest version of our system includesthe former capability.
These problems have been ex-tensively addressed in \[17\], although not in the contextof logic programs.Dialogue extensions, e.g.
for data base creation andupdating in natural language, for clarification of theuser's intended meaning, etc.
Some conversationalfacilities have been developed recently within a logic-programmed system for consulting library informationin Portuguese \[2\]..4 wider linguistic output coverage.
In its currentversion, our system only handles a few answer for-mats, constructed around the sets it retrieves and thetruth values it assigns to the questions.
A synthesizinggrammar would be useful, particularly regarding moreinformative answers.
Ideally, a single grammar shouldwork both for sentence generation and parsing.Application to other language processing problems.Notice that our choice of using English words for thedeep structures in Section 5 gives the parser a translat-ing flavour.
The fact that our system has been adapt-ed to consultation in various natural languages withoutsubstantial modifications to either the parser or theinternal language's features suggests that it might bepossible to use a similar framework for language trans-lation.
Another possibility is to develop a single, mul-tilingual grammar capable of switching to the user'smother tongue as soon as the dialogue opens.Finally, let us point out that the evolution inPROLOG's  features is likely to make it possible toimprove on the implementation, at least, of the ideaspresented here.
For instance, our set evaluation primi-tives rely too much upon exhaustive domain enumera-tion.
While solving PROLOG's  negation problemsatisfactorily for small domains, this is inefficient forvery large data bases.Our previous solut ion--query reordering \ [6 \ ] - -wason the whole more adequate, but incurred the over-head of filtering each query through a coroutininginterface.
A recent DEC-10 PROLOG implementa-tion of this solution \[31,32\], however, has proved veryefficient in the Chat-80 system, which also sharesother features with SOLAR 16 (namely, the minimiza-tion of the search space through query reordering andthe addition of a set constructor predicate).
Some ofthese features have actually been incorporated asstandard into recent PROLOG versions (cf.
in \[28\]),making it possible to develop more powerful systemsat a low cost.Similarly, further MG extensions could make possi-ble a wider linguistic coverage with no loss in efficien-cy.
Provisions for right as well as left extraposition,for instance, would facilitate a full treatment of coor-dination.7.
Concluding RemarksSimilar ideas to the ones discussed in this paper (inparticular, those on quantif ication (cf.
\[35\])) haveinfluenced other NL data base systems, namely LU-NAR \[30\] and PHL IQA1 \[1\].
But in spite of thepoints in common, our general approach is markedlydifferent.
We have tried to incorporate all relevantsemantic as well as syntactic NL features into a singleformalism, in order to do without intermediate sublan-guages and have a single process perform the analysisof an input sentence.
LUNAR,  on the contrary, firstgenerates deep structures and then maps them into asemantic representation.
PHLIQA1 has several suc-cessive levels of semantic analysis, each requiring aspecial formal language.
Some of them are meant todeal with ambiguity, which in our approach, as wehave seen, is dealt with through the contextual typingof variables during the quantification process.A common disadvantage of this integratedapproach- -namely,  that the syntact ic/semantic gram-mar obtained is too domain-specific and therefore lesst ransportable- - is  avoided by relegating all domain-specific knowledge to the domain-dependent part ofthe lexicon (i.e., noun, verb, and adjective definitions).Furthermore,  the fact that semantic agreement isequated with syntactic well-formedness evens the rela-tive costs of doing semantic versus syntactic tests.The use of logic as the single formalism underlyingall aspects of our system's development is a distinctivefeature of the approach.
Logic serves both as thetheoretical f ramework and as the implementationmeans, In particular, this gives our system a definitelynon-procedural  flavour: our programs, as we haveseen, can be understood in purely declarative terms.The main strengths of our approach are, we feel:Uniformity.
Within our data base system, pro-grams, parser, data, semantic interpretation and queryevaluation are uniformly represented.Formalization.
Due to the generalized use of logic,important heoretical aspects- -such as a rigorous char-acterization of our natural language subset and of thesyntax and semantics of our internal querylanguage--need not be dissociated from those practi-cal aspects concerning the implementation.Conciseness.
We have shown how a fairly compact,one-pass analyser can suffice to process a useful andextendible natural language subset.American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981 163Veronica Dahl Translating Spanish into Logic through LogicClarity.
The parser is modular, in the sense thateach rule can be understood declaratively by itself.Problem-independent concerns (e.g.
backtracking,pattern-matching, etc.)
are all left to PROLOG.Performance.
These assets do not imply sacrificingefficiency.
Parsing times have been shown to comparefavourably against those of the LUNAR system \[30\],by using an adaptation of our Spanish analyser to Eng-lish \[24, p.276\].As we have also seen, many improvements remainto be made.
With the present study we hope to moti-vate further research into the uses of logic for naturallanguage processing.AcknowledgementsThe author  w ishes  to thank  A la in  Co lmerauer ,  un -der  whose  superv is ion  the  research  par t ia l ly  repor tedhere  was  deve loped;  M ichae l  McCord ,  fo r  his encour -agement  to get  th is  paper  f in i shed;  and  the  rev iewers ,fo r  the i r  usefu l  suggest ions .References1.
BrC3nnenberg W.J.H.J.
et al "The question-answering systemPHLIQAI."
In: Natural Language Communication withComputers, vol.
II.
L. Bole (ed.).
Carl Hanser Verlag, MunchenWien, Macmillan, London, 1979, pp.
217-305.2.
Coelho H.M.F.
"A program conversing in Portuguese providinga library service."
Ph.D. Thesis, Univ.
of Edinburgh, 1979.3.
Colmerauer A. et al "Un syst~me de communication homme-machine n franeais."
Univ.
Aix-Marseille, 1973.4.
Colmerauer A.
"Un sous-ensemble int6ressant du francais."R.A.1.R.O.
vol.
13, N 4, 1979.5.
Colmerauer A.
"Metamorphosis grammars."
In: Natural Lan-guage Communication with Computers, vol.
I. Springer Verlag,1978, pp.
133-189.6.
Dahl V. and Sambuc R. "Un syst6me de banque de donn~es enlogique du premier ordre, en vue de sa consultation en languenaturelle."
D.E.A.
Report, Univ.
Aix-Marseille, 1976.7.
Dahl V. "Un syst~me d~ductif d'interrogation de banques dedonn~es en espagnol."
Thbse de Doctorat de Spdcialitd, Univ.Aix-Marseille, 1977.8.
Dahl V. "Some experiences on natural language question-answering systems."
Proc.
Workshop on Logic and Data Bases,Toulouse, 1977.9.
Dahl V. "Quantification in a three-valued logic for naturallanguage question-answering systems."
Proc.
6th 1JCAI, Tokyo,1979.10.
Dahl V. "Logical design of deductive, natural anguage consult-able data bases."
Proc.
V International Conference on Very LargeData Bases, Rio de Janeiro, 1979.11.
Dahl V. "A three-valued logic for natural language computerapplications."
Proc.
Tenth International Symposium on MultipleValued Logic, Illinois, 1980.12.
Dahl V. "Two solutions for the negation problem."
Proc.Logic Programming Workshop, Hungary, 1980.13.
Dahl V. On database systems development through logic.
Toappear in: ACM Transactions on Database Systems.14.
Gallaire H. and Minker J.
(eds.)
Logic and Data Bases.
PlenumPubl.
Co., 1978.15.
Hausser R. "Quantification in an extended Montague gram-mar."
Dissertation, Univ.
of Texas at Austin, 1974.16.
Hendrix G.G.
et al "Developing a natural anguage interface tocomplex data."
ACM Transactions on Database Systems, vol.
3,No.
2, June 1978.17.
Kaplan J.
"Cooperative responses from a portable naturallanguage data base query system."
MS-C1S-79-26.
Univ.
ofPennsylvania, 1979.18.
Keenan E. L. "On semantically based grammars."
LinguisticInquiry, 1972.19.
Kowalski R. "Predicate logic as a programming language."
Proc.IF1P 74, North-Holland Publishing Co., Amsterdam, pp.
569-574.20.
Kowalski R. Logic for problem solving.
North-Holland, 1979.21.
Lakoff G. and Ross J.R. " Es necesaria la estructura profun-da?"
In: Semantica y sintaxis en la linguistica transformatoria.Alianza Editorial de Madrid, 1974.22.
McCord M. "Using slots and modifiers in logic grammars fornatural anguage."
Technical Report N 69-80, Univ.
of Kentuc-ky, 1980.
To appear in Artificial Intelligence.23.
Pasero R. "Un essai de communication sens6e en langue natu-relle."
Univ.
Aix-Marseille, 1976.24.
Pereira F. and Warren D. "Definite clause grammars for lan-guage analysis - -  A survey of the formalism and a comparisonwith augmented transition etworks."
Artificial Intelligence 13,1980.25.
Pereira F. "Extraposition grammars."
Proc.
Logic ProgrammingWorkshop, Hungary, 1980, pp.
231-242.26.
Petrick S.R.
"On natural language based computer systems.
"IBM Journal of Research and Development, July 1976.27.
Roussel Ph.
"PROLOG: manuel de r6f6rence t d'utilisation."Univ.
Aix-Marseille, 1975.28.
T~irnlund S-A.
(Ed.)
Logic Programming Workshop Proceedings.Debrecen, Hungary, July 1980.29. van Emden M.H.
"Programming with resolution logic."
In:Machine Intelligence 8, Elcock E. & Michie D.
(eds.).
Chiches-ter: Ellis Horwood, 1977, pp.
266-299.30.
Warren D. et al "PROLOG: the language and its implementa-tion compared with LISP."
Proc.
ACM Symposium on AI andProgramming Languages, SIGPLAN, S1GART Newsletter, Roch-ester, NY, 1977, pp.
109-115.31.
Warren D.H.D.
"Efficient processing of interactive relationaldatabase queries expressed in logic."
Dept.
of Artificial Intelli-gence, Univ.
of Edinburgh, 1981.32.
Warren D.H.D.
and Pereira F.C.N.
"An efficient easily adapta-ble system for interpreting natural anguage queries."
Dept.
ofArtificial Intelligence, Univ.
of Edinburgh, 1981.33.
Woods W.A.
"Transition network grammars for natural lan-guage analysis."
Comm.
ACM, vol.
1, N 10, October, 1970.34.
Woods W.A.
et al "The lunar sciences natural anguage infor-mation system: Final report."
BBN Rep. 2378, Bolt Beranek &Newman, Cambridge, Mass., 1972.35.
Woods W.A.
"Semantics and quantification i natural anguagequestion answering."
Advances in Computers, vol.
17, 1978, pp.1-87.Veronica Dahl is a Researcher in Computer Sciencefor the Argentine National Council for Scientific andTechnical Investigations and an Adjunct Professor in theMathematics Department at the University of  BuenosAires.
She received the Doctorat de Sp~cialit~ in Artifi-cial Intelligence at the University of  Aix-Marseille in1977.164 American Journal of Computational Linguistics, Volume 7, Number 3, July-September 1981
