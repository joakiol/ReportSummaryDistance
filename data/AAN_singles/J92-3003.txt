A Practical Approach to Multiple DefaultInheritance for Unification-Based LexiconsGraham Russell* Afzal Ballim*ISSCO ISSCOJohn Carroll tCambridge University ComputerLaboratorySusan Warwick-Armstrong*ISSCOThis paper describes a unification-based lexicon system for NLP applications that incorporatesmechanisms for multiple default inheritance.
Such systems are intractable in the general case--the approach adopted here places a number of restrictions on the inheritance hierarchy in order toremove some of the sources of complexity while retaining more desirable properties.
Implicationsof the design choices are discussed, comparisons are drawn with related work in computationallinguistics and AI, and illustrative xamples from the lexicons of German and English are given.1.
IntroductionIn essence, the primary task of a computational lexicon is to associate character stringsrepresenting word forms with various types of information, able to account for theirdistribution within a sentence and for their contribution to the meaning of a text.Economical exical organization appears to require the ability, on the one hand, tomake general statements about classes of words, and, on the other, to express excep-tions to such statements affecting both individual words and subclasses of words.These considerations have provoked interest in applying to the domain of the lexi-con AI knowledge representation techniques involving the notions of inheritance anddefaults.
~Unfortunately, many of the schemes that have been proposed are highly com-plex; departing from simple tree-form taxonomies dramatically increases the problemsof dealing in a systematic fashion with default inheritance.
Not only are the intuitionsunderlying the behavior of systems uch as those of Touretzky (1986) and Sandewall(1986) unstable (as Touretzky et al \[1987\] show), Selman and Levesque (1989) demon-strate that certain of them are NP-hard and thus effectively intractable.In a well-defined omain such as the lexicon there remains the possibility of miti-gating these problems by adopting a principled compromise; it may be advantageousto surrender some of the generality of an inheritance system, if the more restrictedversion that results retains sufficient expressive power for the domain in question.
Weexpand on this below and propose a number of simplifications that are motivated bythe particular task that the system is intended to perform.
* ISSCO, 54 route des Acacias, 1227 Geneva, Switzerland.J- Cambridge University Computer Laboratory, New Museums Site, Pembroke Street, Cambridge CB23QG, UK.1 See, e.g., Evans and Gazdar 1990, Gazdar 1990 (especially the References), much of the material inDaelernans and Gazdar 1990, and the contributions to Briscoe et al 1991.
We discuss some of this workbelow.
(~ 1992 Association for Computational LinguisticsComputational Linguistics Volume 18, Number 3The system described here has been implemented as part of the ELU 2 unificationgrammar development environment for research in machine translation, made up ofparser, generator, lexicon, and transfer mechanism.
The user language resembles thatof PATR-II (Shieber 1986a), but provides a larger range of data types and more pow-erful means of stating relations between them.
Among the requirements imposed bythe context within which this system is used are (i) the ability to both analyze andgenerate complex word forms, (ii) full integration with existing parts of the ELU en-vironment, and (iii) the ability to accommodate a relatively large number of words.In particular, an important objective is to preserve as far as possible the flavor of thistype of environment: a specialized programming language for linguistic descriptions,suitable for interpretation by a variety of programs performing tasks such as anal-ysis and generation of sentences and phrases, lexical lookup, etc., which associateswith natural anguage xpressions representations defined by the writer of a linguis-tic description and employs unification as the method of combining information andenforcing constraints.
The intention is that the ELU language should be as generalas possible, in the sense of imposing minimal restrictions on the form of linguisticanalyses and descriptions.Unification is an attractive choice as the basic computational mechanism of sucha system, for well-known reasons: its algebraic properties permit a declarative, mono-tonic semantics for the language that is independent of whatever programs interpret it.However, it does not always meet the requirements of practical linguistic descriptions.The treatment of exceptions i a case in point; negation and conditional statements ofthe kind excluded by pure unification frequently play a large part in accounts of nat-ural language phenomena, and the best-motivated area for the application of theseideas appears to be the lexicon.
It is this problem that the current work seeks to ad-dress.
We would hope that the interest of the system presented here extends beyondthe particular environment for which it has been developed; as an attempt to reconciletwo apparently disparate paradigms, the combination of inheritance and unificationmay be of interest in quite different contexts.The remainder of the paper is organized as follows.
Section 2 discusses generalissues concerning the organization of the system: the basic formalism is introduced,together with the notions of multiple inheritance, default inheritance, and class prece-dence.
Section 3 describes the system in greater detail, showing how the form of theinheritance hierarchy determines how information in lexical specifications is combined,and Section 4 provides ome comparisons with related work.
Some more extended lin-guistic examples appear in Section 5; these serve to illustrate the various mechanismsdescribed earlier and suggest methods that might be adopted in formulating otheranalyses.
Finally, in Section 6, the current implementation is discussed.2.
The Lexicon as a Hierarchy2.1 An Overview of the FormalismAn ELU lexicon consists of a number of 'classes," each of which is a structured collec-tion of constraint equations encoding information common to a set of words, togetherwith links to other more general "superclasses.'
For example, if an 'intransitive" classis used to express the common syntactic properties hared by all intransitive verbs,then particular instances of intransitive verbs can be made to inherit this informa-2 "Environnernent Linguistique d'Unification" (Estival 1990).
See also Johnson and Rosner (1989) for adescription of the earlier UD system on which ELU is based.312Graham Russell et al A Practical Approach to Multiple Default Inheritancetion by specifying the 'intransitive' class as one of their superclasses--it then becomesunnecessary to specify the relevant properties individually for each such verb.
Sim-ilarly, the 'intransitive' class need not express any of the more general properties ofthe 'verb' class.
The lexicon may be thought of as a tangled hierarchy of classes linkedby inheritance paths, with, at the most specific level, lexical classes and, at the mostgeneral, classes for which no superclasses have been defined; these therefore inheritno information from elsewhere.
Basic lexical entries are themselves classes, 3 and anyinformation they contain is standardly specific to an individual word; lexical and non-lexical classes differ in that analysis and generation take only the former as entrypoints to the lexicon.It is possible to define certain properties of a class as defeasible.
Such a propertywill be inherited from a superclass only if it is consistent with all properties con-tributed by more specific classes; if it is not consistent, hen it is ignored.
Defeasibleconstraints imposed on a class of words may thus be overridden by information asso-ciated with individual members or subclasses of that class; this is the notion of defaultthat underlies the system.
It is possible, for example, to place in the class expressinggeneral properties of verbs an equation such as '<aux> = no' (i.e.
"typical verbs arenot auxiliaries"), while placing the contradictory specification '<aux> = yes' in a sub-class from which only auxiliaries inherit.
The ability to encode xceptional propertiesof lexical items is extremely attractive from the linguistic point of view; the lower theposition in the hierarchy at which the property appears, the more exceptional it maybe considered.Like other parts of an ELU description, a lexicon consists of a set of statements thatare compiled into an internal format for use in analysis and generation of linguisticexpressions.
Section 2.6 describes ome relevant aspects of the lexical compilationprocess.2.1.1 Class Definition.
A class definition consists of the compiler directive '#Class'(for a nonlexical class) or '#Word' (for a lexical class), 4followed by:(i) the name of the class(ii) a (possibly empty) list of its direct superclasses(iii) a (possibly empty) 'main' equation set(iv) zero or more (possibly empty) 'variant' equation sets.2.1.2 Superclass Declaration.
The superclass declaration is a list of the names of anydirect superclass of the current class.
This is used in computing the relative precedenceof classes in the lexicon for the purpose of default inheritance (see Section 2.5); itmay be empty if the class has no superclasses, i.e., if it is one of the most generalin the lexicon, and thus inherits no information.
Precedence of direct superclasses is3 Thus no distinction is made between classes and 'instances,' as in, e.g., KL-ONE (Schmolze and Lipkis1983) and much more recent work.
One reason for this is that instances of the kind appealed to bysome KR researchers do not exist within a unification-based linguistic description.
What would countas an instance in this context is an occurrence of a word in the analysis of some text; in general,information associated with one particular occurrence of a word will originate partly in its lexicalspecification and partly through unifications with other items.A second, related reason for not enforcing a class/instance distinction is that lexical classes maythemselves usefully be inherited from; examples of this behavior are discussed in Section 5.2.4 Both lexical and nonlexical classes have the same form and interpretation.
The distinction becomesrelevant for lexical access; only lexical classes are taken as entry points to the lexicon.313Computational Linguistics Volume 18, Number 3determined by the order in which they appear in the list--more specific classes appearto the left of more general ones.
Precedence of nondirect superclasses i derived bytopologically sorting the hierarchy in a manner described in Section 2.6.2.1.3 Main Equation Set.
Following the superclass declaration are zero or more equa-tions representing default information, which we refer to as the 'main' equation set.These may be overridden by conflicting information in a more specific class.
Eachequation in a main set functions as an independent constraint, in a manner that willbe clarified in Section 3 below.2.1.4 Variant Equation Sets.
Following the (possibly empty) main equation set arezero or more sets of equations representing variants within the class, which looselyspeaking correspond to alternatives at the same 'conceptual level' in the hierarchy.Equations within a variant set are absolute constraints, in contrast o those in themain set; if they conflict with information in a more specific class, failure of unificationoccurs in the normal way.
Also, unlike the main set, each variant set functions as asingle, possibly complex, constraint (see Section 3.2).
A feature structure is created foreach variant set that successfully unifies with the single structure resulting from themain set.
Each variant set is preceded by the vertical bar ' l ' .2.1.5 String Concatenation.
Construction and decomposition of complex words arecarried out by the string concatenation perator '~ . '
An equation of the formStr ing = Pref ix  ~ Suff ixunifies Str ing with the result of concatenating Pre f ix  and Suff ix.
The unification isnondeterministic, n the sense that if St r ing is abe, and Pre f ix  and Suf f ix  are oth-erwise uninstantiated unification variables, the equation has the four solutions hownbelow, where ...... indicates the empty string:(i) Pref ix  : " "  Suff ix  :abc(ii) Pref ix  : a Suff ix  : bc(iii) P re f ix  : ab Suf f ix  : c(iv) Pref ix  :abc  Suff ix  : ""2.2 Other Aspects of the ELU LanguageWe introduce here a variety of notational conventions used in the examples below.2.2.1 Lists.
Values of attributes may take the form of lists of feature structures, notatedin grammar ules and lexical entries as ' \[ F1 ...~ Fn \]'.2.2.2 Disjunction.
Disjunction is defined over atomic feature structures.
A value de-fined as 'a/b/c '  represents a set of atoms D = {a, b, c}, which unifies with: (i) any d E D(result: d); (ii) any other disjunction representing a set D' such that D N D' = I (result:I if nonempty, otherwise failure); and (iii) the negation (see below) of a disjunctionrepresenting a set D' (result: D - D' if nonempty, otherwise failure).2.2.3 Negation.
Negation is defined over atomic feature structures and disjunctions ofatomic feature structures; a value defined as '~a' unifies with any feature structure Fthat does not unify with a, the result being F.314Graham Russell et al A Practical Approach to Multiple Default Inheritance2.2.4 Path Specifications.
Attribute value paths are notated in the form '<al .
.
.
,  an>.
'2.2.5 Variables.
Unification variables have an initial uppercase letter; quoted expres-sions beginning with uppercase letters are interpreted as constants.
Thus, Var is avariable, and both atom and 'Var'  are atomic FSs.2.3 An ExampleThe following example illus~ates the form and interaction of class definitions.#Word  wa lk  ( In t rans i t i ve  Verb)<stem> = wa lk#Class Intransi t ive ()<subcat> = \[Subj\] <Subj cat> =np#Class Verb ()<aux> = nol<tense> = pastl<agr> = sg3<form> = <stem> ~ sl<agr> = non_sg3<form> = <stem><cat> = v<form> = <stem> &~ ed<tense> = present<tense> = presentThe lexical class walk is declared as having two direct superclasses, Verb and In t rans i -t ive ;  its main set contains just one equation, which sets the value of the feature <stem>to be walk.
In t rans i t ive  has no direct superclasses, and its main equation set assignsto the value of <subcat> a list with one element, a feature structure in which the valueof <cat> is np.
Neither walk nor In t rans i t ive  has any variant equation sets.
Verb,by contrast, has three, in addition to two main set equations assigning default valuesfor <cat> and <aux>.
The three variants accounted for by this example are:?
the past tense verb, in which the value of <form> unifies with the resultof concatenating the value of <stem> with the string 'ed,'?
the third person singular form of the present ense, in which the suffixstring is 's,' and?
the form representing other combinations of person and number in thepresent ense; in the last case, the <form> value is simply identical to the<stem> value.2.4 Multiple InheritanceAs we have just seen, a class may inherit from more than one direct superclass.
In-stead of a simple, tree-form taxonomic structure, therefore, the lexical hierarchy takesthe form of a directed (acyclic) graph.
In general, multiple inheritance of this kindnecessitates more complex methods of searching a hierarchy; in the worst case, thenumber of paths to be traversed grows exponentially with the depth of the hierarchy.Moreover, since it then becomes possible to reach a node by more than one path, thepresence of exceptions (via default assignments or negative links) permits incompatible315Computational Linguistics Volume 18, Number 3conclusions to be drawn--forks leading to such inconsistencies must be detected andsuitable records kept.
Much of the complexity of inheritance reasoners lies in findingand determining what to do in these cases of ambiguity, s Multiple inheritance is notan a priori necessity for lexical specification, so it is worth considering whether anyphenomena occur in this domain that might make multiple inheritance preferable tothe simpler tree-structured hierarchy.
If it proved possible to eliminate this source ofcomplexity, the goal of a practical inheritance system would be nearer.However, natural language lexicons do appear to require description in termsof 'tangled hierarchies,' at least if certain types of generalization are not to go un-expressed.
It has often been observed, for example, that syntactic and morphologicalproperties are in many respects disjoint; the subcategorization class of a verb cannot bepredicted from its conjugation class, and vice versa.
A French lexicon will distinguishthree basic verb conjugations, exemplified by the transitive aimer ('love'), hai'r ('hate'),and voir ('see').
Each of these three classes, not surprisingly, also contains intransitiveverbs; in a tree-form hierarchy, nodes must be created for first conjugation transitiveand first conjugation intransitive verbs, and similarly for the other cases, with infor-mation relevant o transitive verbs in general, or first conjugation verbs in general,repeated at each appropriate node.
When the many subclasses and special cases ofinflectional behavior are taken into account, together with a more adequate analysisof subcategorization patterns, the number of nodes required, and the redundancy ofthe specifications, increases considerably.Multiple inheritance permits the two types of information to be kept separateby isolating them in distinct sub-hierarchies.
This compartmentalization s implicitlyrelated to the independence of the sub-hierarchies; if constraints relevant o differenttypes of information are always disjoint, then the system as a whole is 'orthogonal"(Touretzky 1986: 73ff).
The significance of this point lies in the fact that, if superclassesB and C of some class A are independent in this way, no conflict can arise when Ainherits from both B and C, and the result of inheriting default information from thesuperclasses will not vary according to the order in which the defaults apply.The organization of a lexicon must reflect wo types of relation between classes ofwords.
Clearly, certain classes tand in the subset/superset r lation--'words' in gen-eral, 'verbs,' present tense verbs,' present tense verbs agreeing with a plural subject,''present tense verbs agreeing with a second person plural subject,' and so on.
Equallyclearly, within many of these classes there exist disjoint subsets--'present tense verbs,"'past tense verbs,' infinitive verbs,' verbs agreeing with second person plural subject,''verbs agreeing with third person plural subject,' and so on.
Word classes within thelexicon must encode both types of relation, and, in broad terms, it is the latter thatone might wish to represent by means of unordered multiple inheritance.The design of such a system presents a three-way choice: (i) to accept ambiguity ofinheritance; (ii) to enforce orthogonality in the hierarchy; (iii) to eliminate unorderedmultiple inheritance.
The present system takes the third option; ambiguity of inheri-tance is eliminated by enforcing a total ordering on the superclasses of any given classor word, and by making it clear to users how this ordering is derived so that theymay more accurately control and exploit it in the organization of the hierarchy.As a substitute for unordered multiple inheritance, the variant set mechanism isintroduced; this allows variants to be represented directly within a class rather thanby creating alternate, unordered superclasses, and corresponds to a strong element5 Cf.
examples ofcascaded ambiguity and On-Path versus Off-Path preemption in Touretzky et al(1987).316Graham Russell et al A Practical Approach to Multiple Default Inheritancein traditional grammatical description, that such mutually exclusive variant classesshould nevertheless be grouped together in a single compound statement or paradigm.A concrete version of this may be seen in the inflection tables to be found in referenceand pedagogical grammars of foreign languages.
Users are able to simulate ambiguityjudiciously when required, but are responsible for determining when this should occur.In effect, we are giving away some of the generality of an inheritance reasoner (that itreasons correctly over arbitrary inheritance networks according to certain "intuitions")by making creators of lexicons perform the "intuitive" work themselves.
This is no badthing, since the creator of the lexicon is then forced to consider the desired relations,rather than relying on the semantics of the inheritance system to produce them.2.5 Default InheritanceThe use of default information in a unification-based system raises the question of howthe two types of operation are to interact.
If unification is employed in its conventionalfo rm,  then combining conflicting information from different classes will produce fail-ure and a null result.
While this is reasonable behavior elsewhere, it prevents thedesired treatment of exceptions to generalizations in word classes.
One step towarda solution is to define default inheritance of constraints to be such that if A is a FSassociated with a class C and B is a default FS associated with a superclass of C, thenthe result of applying B to A is R = A t3 B, if R # T, and A otherwise.
6 This is notyet sufficient, since a failure of one subpart of B causes all other, possibly compati-ble, information in B to be discarded.
What is needed is a scheme in which A unifieswith as many as possible of the individual constraints embodied in B.
We shall see inSection 3.2 how the casual "as many as possible" can be made precise.2.6 Class PrecedenceA system such as the E~u lexicon, which permits the defeasible inheritance of infor-mation from more than one superclass, must provide a way of resolving the conflictsthat arise when information present in two or more superclasses i mutually incom-patible, e.g., when the result obtained when A inherits from one superclass B beforeinheriting from another, C, differs from that obtained by inheriting first from C andthen from B.
It is in such cases that the notion of "precedence" comes into play; if thesystem is constrained so that information is inherited first from B, we say that B "hasprecedence over," or "is more specific than" C.A familiar example of this type of situation from the AI literature is the so-called'Nixon diamond' (Touretzky 1986).
Nixon is both a Quaker and a Republican; Quak-ers are (typically) pacifists, while Republicans are (typically) not; the question to beanswered is whether Nixon is a pacifist.
In a conventional inheritance network, thisproblem might be represented by the configuration shown in Figure 1.
If the links tothe 'Pacifist' class are both defeasible, which should take precedence, the positive linkfrom 'Quaker,' or the negative link from 'Republican'?
7Within the ELu lexicon, a natural way of representing the same information is todispense with a 'Pacifist' class, and instead to make (non) pacifisthood a defeasible6 Throughout this paper, 'A U B' denotes the unification of A and B, 'T' denotes the inconsistent featurestructure quated with failure of unification, and '3_" denotes the empty or most general featurestructure, which subsumes all others.7 If the links in question are strict rather than defeasible, a system may resolve the ambiguity by'skeptical' or 'credulous' reasoning, yielding no answer or both answers, respectively.
A mixture ofstrict and defeasible inks (i.e., a "heterogeneous' inheritance system) isargued by Ballim et al (1988;1990) to be more capable than a homogeneous system (one with only strict or only defeasible inks) ofexpressing the intuitions underlying networks uch as the "Nixon diamond."
See also Section 4.3.317Computational Linguistics Volume 18, Number 3Figure 1The Nixon diamond.PacifistQuakerNixonRepublicanproperty of Quakers and Republicans, as shown in the example below:#Word Nixon (Quaker Republ ican)I<name> = 'Nixon'#Class Quaker ()<pacif ist> = yesi<denominat ion> = 'Quaker'#Class Kepubl ican ()<pacif ist> = noJ<party> = 'Republican'Here, the 'lexical class' Nixon has two direct superclasses, Quaker and Republican--as we shall see below, the order in which these are declared is significant.
It alsocontains the constraint that the value of the <name> attribute must be Nixon.
Quakerimposes two constraints; the value of <denomination> must be Quaker, and the valueof <pacif ist> must be yes, unless that would conflict with a value assigned in somemore specific class.
The constraints embodied in Republican are that the value of<party> must be Republican, while, again unless differently assigned in a more spe-cific class, <pacif ist> has the value no.What will be the result of looking up 'Nixon' in this lexicon?
The attributes<name>, <party>, and <denomination> areunproblematic; the only conflict arises with<pacif ist>.
As indicated above, its value will depend on which of the two super-classes of Nixon is the more specific, i.e., in this simple case, on the order in which theyappear in the superclass declaration; the declaration (Quaker Republican) states notonly what the direct superclasses of Nixon are, but also that Quaker is to be regardedas more specific than Republican.
Thus it is Quaker that will provide the value for<pacif ist>.
If the opposite answer were required, the appropriate declaration wouldbe (Republ ican Quaker).A frequent approach to such matters in the AI community is to arrange for aresult where neither of the conflicting properties is inherited, so that, in the case ofthe present example, the value of <pacif ist> is unspecified.
A trivial implementationof this solution in the ELu lexicon would be to omit from the class definitions allmention of pacifisthood; the semantics of graph unification is such that an absence ofinformation concerning some attribute is compatible with any possible value.
If the318Graham Russell et alFigure 2A partially ordered set of classes.CBA Practical Approach to Multiple Default InheritanceFAintention were to permit either of the values yes and no, but no other, then the valueof <pac i f i s t> could be supplied as a disjunction: 'yes/no.
'Consider now a situation in which conflicting information occurs in nondirectsuperclasses, ay C and D in the lexicon below.
No superclass declaration containsboth of these, and so the type of local ordering constraint imposed by the declarationsin the 'Nixon' example is not available.#Word A (B D) #Class B (C) #Class C (F)#Class D (E) #Class E (F) #Class F ()The ELU lexicon employs the class precedence algorithm of the Common Lisp ObjectSystem (CLOS) to derive a total order on the superclasses of each lexical class; weadopt some of the CLOS terminology here.
8The resulting 'class precedence list' (CPL)contains the lexical class itself and all of its superclasses, from most specific to mostgeneral, consistent with the local order given by class declarations.
Informally, theCPL is created by performing a topological sort on the partial order: the effect canbe seen most clearly in connection with a graphical representation such as that inFigure 2, which represents the partial order generated by the local superclass orderingconstraints of the lexicon above.Note that the left-to-right order of the two "branches' in Figure 2 reflects the orderin which B and D appear in the superclass declaration of A.
The CPL is constructed bytraversing the graph in a depth-first, left-to-right manner, at any joins (such as F in thiscase) splicing in the next leftmost path before continuing with depth-first computation.The CPL of A in Figure 2 is therefore (A, B, C, D, E, F ), with A being the most specificand F the most general.
9 This procedure deterministically selects one total orderingfrom the set of orderings compatible with the superclass declarations; if none can bederived, the system gives an error during compilation.A given CPL can be derived from several sets of class definitions; the lexiconsshown below are some of those which, when compiled, will result in the same CPL8 See Steele (1990: 782ff) for details of the algorithm, and Keene (1989:118ff) for discussion.9 The ordering relation of specificity on classes hould not be confused with the subsumption relation onfeature structures; the former is determined by superclass declarations and is independent oftheinformation content of any constraints within the classes.
Typically, more specific lasses describesmaller sets of words.319Computational Linguistics Volume 18, Number 3Figure 3An impossible hierarchy.CBA<A,B,C,D,E,F>, as the example above:#Word A (B) #Class B (C) #Class C (D)#Class D (E) #Class E (F) #Class F ()#Word A (B) #Class B (C) #Class C (D)#Class D (E F) #Class E () #Class F ()#Word A (B) #Class B (C) #Class C (D E F)#Class D (E) #Class E (F) #Class F ()#Word A (B C D) #Class B (F) #Class C ()#Class D (E F) #Class E () #Class F ()The class precedence algorithm may thus be seen as defining an equivalence relationon lexical specifications.Patterns of inheritance between superclasses of a lexical class are determined solelyby the CPL.
Note that this scheme excludes a number of configurations that havefigured in the AI literature.
Dual paths from one class to another, of the sort shown inFigure 3, cannot arise in the compiled lexicon; given a CPL <Cl,... Cn>, the only pathfrom ci to Ck is through every cj, 1 < i < j < k G n. However, there is no prohibition onexpressing the same information in two classes--this type of redundancy is harmlessin that it does not complicate the process of searching the hierarchy.Another consequence is that cyclic hierarchies are precluded--no total order canbe constructed in which A < B and B < A.
Intuitively, there is no reason for defining anetwork with cyclic paths, when traversing the same portion of the network repeatedlycan add no more information and may introduce paradoxes.Nor is there any means of expressing negative links of the kind shown in Figure 1.
'?The ELU lexicon is thus what Touretzky et al (1987) term a unipolar system.
Thesignificance of this point is that the presence of exception links is another factor inthe complexity of a hierarchy; moreover, this type of negation is of dubious utility inthe present context, for two reasons.
First, the precedence of default information fromsubclasses appears to enable exceptionality o be expressed without explicit negationof inheritance.
The second reason is connected with the nature of graph unification.The absence of a path-value pair P = < p, v > in a FS F cannot be interpreted as apositive constraint that (some extension of) F does not have the property represented10 Negated inheritance links should not be confused with the negation i troduced inSection 2.2, which isdefined over the unification of atomic feature structures.320Graham Russell et al A Practical Approach to Multiple Default Inheritanceby P; a later unification may lead to P being added to F. The desired effect can onlybe achieved by the presence in F of a distinct path-value pair < p, v' >, where v and v'do not unify.
Conflicting information of this type can be introduced by means of thestandard positive inheritance link.In comparison with inheritance systems in general, then, the ELU lexicon is ratherrestrictive.
Hierarchies are constrained to be acyclic, unipolar, and unambiguous, theselimitations reflecting the desire not only to reduce the complexity of the system but alsoto eliminate from it inessential or redundant aspects.
Finally, the defaulting behavior ofthe lexicon as a whole is determined by the CPLs of each lexical class, and these are inturn derived from the superclass declarations within class definitions.
This impositionof a global organization by a collection of local constraints is attractively consistentwith the spirit of unification-based formalisms.3.
In fo rmat ion  in the Hierarchical  LexiconHaving discussed the form and organization of the lexicon, we continue with anaccount of the manner in which information distributed among its classes combinesto characterize a set of lexical items.3.1 An  In formal  Account  of  Lexical  AccessLookup of a lexical item with CPL (cl , .
.
.cn/ proceeds as follows: starting with anempty FS, the system first applies any default equations in Cl, then applies any variantsets in cl to the result.
The system then repeats this process on each resulting FS, forthe classes ci+l to cn in turn.
The result of lookup is the set of FSs produced by themost general class Cn; this set we term the global extension of the lexical class Cl.A set of default equations D = {dl, .
.
.
d,} applies to a FS F as follows: each di thatdoes not conflict with some existing information in F is unified with F, subject o thecondition that any reentrant substructure of F should be compatible with D, and thatany reentrant subset of D should be compatible with F. The purpose of this conditionis to preserve declarativeness; a set of equations that satisfy it may be applied withoutregard to order.
11 Any variant sets that exist in the current class are then applied tothe resulting FS F'.The result of applying variant sets {vl , .
.
.
vn} to a FS F is the set of FSs 0Cl,...fro},where each fi is the result of successfully unifying F with some different vj.
Unificationfailure in variant sets produces a null result, so m G n. Variant sets have two effects:they enforce strict constraints that cannot be overridden, and multiple variant sets'multiply' FSs, e.g., to produce different members of an inflectional paradigm.The lexicon below provides a simple nonlinguistic illustration of how defeasibleinheritance and nondefeasible inheritance interact in the lexicon.#Word A (B)<p i> = af <q i> = ri <q  I> = s#Class B (C)<p i> = b<p 2> = bI <q 1> = s11 See Section 4.2 for an example of the interaction ofreentrancy and default unification.321Computational Linguistics Volume 18, Number 3#Class C ( )<p 1> = C<p 2> = c<p 3> = cI <q  2> = tI <q  2> = uThe CPL of A is (A, B, C ).
Applying the single default equation of class A to the emptyFS 3_ produces the FS shown as (1) below; the result of applying the two variant setsto this is the pair of FSs (2) and (3).
(1)\[P \ [ la \ ] \ ]  (2)\[  pq \[l\[la\]\]r\] (3 ) \ [~ \[la\]\]\[1 s\]Since there is no conflict between 3_ and the information in class A the situation isstraightforward; two FSs are created, one for each of A's variant sets.
Class B thenapplies to each of these, but in this case conflicts do arise.
The first is between thevalues of P: I  present in (2) and (3) and that specified in the default set of B. Thedefault constraint is overridden by the information contributed by the more specificclass A, while the equation providing the value of P:2 succeeds, producing the FSs(4) and (5).\[ \ [1 !
!
\ ]  \[ \ [ la \ ] \ ](4) P 2 (5) P 2 bQ \[1 Q \[1 slThe second conflict in class B arises from the single variant set, which permits onlythe value s for Q : 1.
This is a strict constraint, and, while (5) satisfies it, (4) does not.Only (5), therefore, is considered by class C.As before, the default set of C contains constraints (those involving P : 1 and P : 2)that are overridden by existing information; the third default equation succeeds, andyields (6).
The two variant classes each add a value for Q:2, producing the FSs (7)and (8).\[ IiIill (6) P (7)q \[1 s\] \[2(8) Ii a Ip bcq 2uIntuitively, (7) and (8) represent two alternative sets of information that the lexiconassociates with the lexical class A.It is useful to have some terminology for the various steps we have just followed.We shall refer to the result of applying to some FS F the set of default equations ina class C as the default extension of F with respect o C. (1) above is thus the defaultextension of _1_ with respect to A, and (5) the default extension of (2) with respect to B,for example.
Similarly, we refer to the result of applying both default and variant setinformation in a class C to some FS F as the superclass extension of F with respect to C.The set containing (2) and (3) is then the superclass extension of (1) with respect to A,that consisting of just (5) is the superclass extension of (2) with respect o B, and theset containing (7) and (8) is the superclass extension of (5) with respect o C. Finally,since C is the most general superclass of A, (7) and (8) together comprise the globalextension of the lexical class A.Figure 4 shows the pattern of inheritance arising from this lexicon; classes arelabeled 'A,' 'B,' and 'C,' and within each the defaultand variant sets are identified as'd' and 'v,' respectively.
Arcs are labeled with the names of FSs shown above.322Graham Russell et al A Practical Approach to Multiple Default InheritanceBA 23_ 3 C ~  7~ 8Figure 4Feature structures characterized by the lexicon.3.2 Definit ionsFollowing the relatively informal presentation i  the previous ection, we continue byrefining some of the notions introduced there.
We define the global extension ofa lexicalclass in terms of the auxiliary notions default extension and superclass extension.3.2.1 Default Extension.
Let ?
be a FS, and R(d;) the restriction of ?
to reentrant paths,i.e., the most general FS such that Vp, q \[4(P) -= ?
(q) -+ R(?
)(p) = R(?
)(q)\]) 2 Then thedefault extension of a FS ?
with respect o a set of FSs ?
isif both R(?)
u LJ ~ # T and ?
U R(L j ~) # T, and T otherwise.Each of the FSs in @ that can unify with ?
does so--those that cannot, becausethey conflict with information already present, are ignored.
This is the basis of thedefaulting behavior of the lexicon.The condition referring to reentrancy takes account of the potential order-sensitivityof the defaulting operation--only those main sets having this property can be appliedwithout regard to the relative order of the individual constraints within them.
If thecondition is met then the application of defaults always succeeds, producing a featurestructure which, if no member of the set is applicable, is unchanged, i.e., identical to?
; otherwise the lookup fails.
133.2.2 Superclass Extension.
The superclass extension S of a FS ~ with respect to a classC having a main equation set M and variant sets vl , .
.
,  vn isS(0,C) = {?
l l  < i<  n A v; U ?'
= thA!h # T} ,where M r is the smallest set of FSs such that each m E M describes some m ~ E M r, ~' isthe default extension of ~ with respect o M', and v I is the feature structure describedby vi.S(?, C) is formed by applying to ?
any default equations in the main set of C,and then applying to the result each variant set in C; for variant sets vl , .
.
,  v,, theresult of this second stage is the set of FSs {1bl,.. ?~m}, where each ~i is the result ofsuccessfully unifying ~ with some different vj.12 Here, '?
(p)' denotes the value of the attribute-value path p in the FS ?, and '~ '  denotes token identityof its operands.13 See Section 4.1 for a different approach to order sensitivity proposed by Carpenter (1991).323Computational Linguistics Volume 18, Number 33.2.3 Global Extension.
The global extension of a lexical class L having the CPL C =(cl,... Cn > is Gn, where Go -- {?
}, andGi>0 = \[..J I v4 c ?i-1, --- s (?
ci)}.To speak in procedural terms, ?
is the empty FS that is input to C; each ci in C yields asits superclass extension a set of FSs, each member of which is input to the remainderof C, (ci+1~... cnl.
The global extension of L is then the yield of the most general classin its CPL--expressed in a slightly different way, the global extension of L is the resultof applying to A_ the CPL of n. 14The set of lexical items admitted by a lexicon consists of the union of the globalextensions of all lexical classes in the lexicon.3.3 Variant Sets--DiscussionVariant sets may be thought of as representing a restricted form of disjunction overcomplex FSs.
Kasper and Rounds (1986) show general disjunctive unification to be in-tractable, since it involves an exponentially complex step of expansion to disjunctivenormal form.
Note, however, that the alternation embodied in variant sets is guaran-teed to be at the 'top level' of FSs only; that is to say, the FSs described by multiplevariant sets are already in disjunctive normal form, apart from any atomic disjunctionsthey may contain.
For this reason, multiple variant sets impose no mutual constraints;regardless of whether the information they contain is orthogonal, complementary, orconflicting, the crucial factor is the unifiability of each variant set individually withthe single candidate FS.The variant set mechanism tends to suggest a close connection between strictconstraints and multiple realizations of class membership.
Clearly, a class may havea single variant set, so nondefeasible information does not entail alternation.
On theother hand, it may at first appear that the system forces a style of analysis in which, forexample, all members of an inflectional paradigm have equal status.
In many cases, thiswill be undesirable.
Consider once more the class of regular English verbs; instead ofencoding their inflectional behavior by means of class Keg_Verb_Present below, onemight well wish to express the generalization that five out of the six present enseforms are identical, and treat the sixth as an exception.#Glass  Keg_VerbPresent  (Verb)<agr> = sgl  <form> = <stem><agr> = sg2 <form> = <stem><agr> = sg3 <form> = <stem> ~ s<agr> = p l l  <form> = <stem><agr> = p12 <form> = <stem><agr> = p13 <form> = <stem>14 The fact that Gi is defined here recursively in terms of Gi-1 should not be misinterpreted as reflectinga "top-down" view of inheritance--the d fault unification performed in order to compute the defaultextension of a FS requires a bottom-up view, in which more specific lasses are inherited from beforemore general ones.324Graham Russell et al A Practical Approach to Multiple Default InheritanceA more attractive analysis would involve the use of a class that encodes in one variantset just the exceptional case, and in a second provides ufficient information to excludethat exception from a default stated in a more general class.#Class Reg_Verb_Present_Except ion  (Verb)<agr> = sg3 <form> = <stem> ~ sI<agr> = sg l /sg2/p l l /p l2 /p l3#Class Verb ()<form> = <stem>The lexicon will generally be called upon to establish a pairing of morphosyn-tactic information (tense, case, agreement, etc.)
and phonological or graphological in-formation (the form taken by the variant of a word that expresses a particular mor-phosyntactic property).
The two kinds of information will normally be expressed asthe values of distinct attributes, in which case the semantics of default unification setout in Section 3.2 will not enforce the intended pairing.
The strict unification apply-ing within variant sets causes equations to be interpreted in the conventional wayfor unification-based linguistic descriptions, i.e., as conjunctive constraints on featurestructures.
In practice, it is tempting to think of the lexicon as operating in a direc-tional manner.
Looking up a word involves retrieving from the lexicon the collectionof morphosyntactic properties expressed by a given word form, and here the naturalinformal interpretation will be that the existence of that wordform implies the pres-ence of those properties.
Generating a word, on the other hand, involves retrievingthe word form that expresses a given set of morphosyntactic properties, and here thenatural informal interpretation will be the reverse.
Nevertheless, the system retainsthe nondirectionality of unification, and this informal view of its operation is no morethan a convenient approximation to its underlying semantics.Since strict constraints are able to filter out unwanted intermediate solutions, com-puting the global extension of a lexical class will in general involve creation of a largernumber of FSs than appear in the result.
If v(c) is the number of variant sets in the classc, and f is the function in the natural numbers uch that f(0) = 1 and f(k) = k if k > 0,15the maximum number of FSs constructed for a lexical class with the CPL (cl,... cn) isgiven byHIIf(v(ci)).i=1This maximum arises when no failures of strict unification occur.Finally, while the variant set mechanism provides some of the functionality ofthe lexical rules proposed by Flickinger et al (1985), Calder (1989), and others, thestructure of the ELU lexicon does not admit the full range of capabilities of these morepowerful devices; cyclic rule applications cannot be simulated, for example.4.
Some ComparisonsAs we mentioned briefly in Section 1, the idea of applying inheritance to the lexicon,and indeed to linguistic descriptions in general, is not a new one.
Here we consider afew of the proposals that have appeared in recent years.15 Classes with one or no variant set yield at most a singleton superclass extension for each FS they applyto, while others mult iply a FS by a factor of no more than their total number  of variant sets.325Computational Linguistics Volume 18, Number 34.1 Defaults and ReentrancyThe notion of 'default extension' employed here resembles the 'priority union' ofKaplan (1987: 180f) and the 'conservative addition' of Shieber (1986b).
As Bouma (1990)points out, the result of defaulting under this approach may depend on order ofapplication.
To take Bouma's (p. 166) simple example, default unification of the FSswith a re-entrant structure(1) \[F a\] (2) \[C b\](3)produces different, nonunifying, results:\[F \ [ \ ]a \ ](4) c \[\]l c \[\]IF \ [ \ ]b \ ]  (5) c \[\] "(4) results when (1) applies before (2), and (5) when (2) applies before (1).Similarly, defaulting the FSs(6) \ [~ \[\]\]\[\]onto a FSproduces one of(7) \[G b\](8) \[ a \]according to whether (6) applies before (7), in which case the result is (9), or (7) appliesbefore (6), to produce (10).Both situations are avoided in the ELU system by making applicability of defaultsconditional on the unifiability of reentrant subsets of the default information andcandidate structure (see Section 3).
The first case, where the candidate FS (3) containsa reentrancy that has nonunifying extensions in the default information (1 and 2), isexcluded by the requirement that R(3) U \[\[{1,2} ~ T, and the second case, where areentrancy in a default FS (6) has nonunifying extensions in the candidate FS (8) andother default FSs (7), is excluded by the requirement that (8) tJ R(U{(6), (7)}) ~ T.Carpenter (1991) proposes a more permissive view of default unification in whichconflicts of this type are resolved in one of two modes, 'credulous' and 'skeptical.
'Credulous default unification preserves the maximum possible default information,and is defined so as to produce a (nonempty) set of solutions.
For example, the resultof credulously defaulting (11) (the unification of 6 and 7 above) onto (8) is the set ofsolutions (12) (i.e., 9 and 10).
(11) \ [~ \[ \ ]b 1 \ [ \ ]  (12){\[~c \[\]a\]\[\] ' \ [~ bal}Skeptical default unification retains only consistent information, and is defined as thegeneralization of such a set of solutions.
16 Skeptically defaulting (11) onto (8) produces16 The generalization f two FSs corresponds totheir greatest lower bound in the subsumption lattice.
SeeKarttunen (1984).326Graham Russell et al A Practical Approach to Multiple Default Inheritancethe FS (13), in which the only default information to have been preserved is thatconcerning the presence of an attribute G, whose value, since it conflicts with that in(8), is unspecified:IF a \ ]  (13) G ?Neither of these proposals for the treatment of inconsistent default informationis equivalent to ours.
Of the various properties of skeptical and credulous defaultunification oted by Carpenter, the ELu lexicon shares the following.
(i) Strict information is preserved--i.e., default unification is monotonic (seeSection 4.2).
(ii) Default unification reduces to standard unification if the two FSsinvolved are consistent.
(iii) Default unification is finite.The fourth property, that skeptical and credulous default unification are both welldefined in all cases, is not shared by the present system--as we have seen above, thedefinition of default extension (Section 3.2) produces no solution for unifications ofthe type illustrated here.4.2 MonotonicityThe 'template' facility of PATR-II (Shieber 1986a: 55ff) allows inheritance within thelexicon.
Lexical entries may be defined by means of templates that have other templatesin their definitions.
Thus, if the definition of a template T1 mentions the templates T2and T3, any entry in which T1 appears also receives the contents of T2 and T3.
This is aform of strict multiple inheritance, since, if T2 and T3 contain conflicting information,unification fails and no corresponding lexical item is created.
Shieber (1986a: 59ff) alsodescribes a type of default inheritance implemented in terms of a noncommutative'overwriting' operation, in which constraint equations may be formulated so as totake precedence over existing structures.
These devices permit the construction ofheterogeneous systems like that of ELU; one difference between the two would bethat, in Shieber's cheme, the statements exhibiting default behavior are ones thathave the ability to override others over which they have precedence, whereas in theapproach described above the default statements are ones that can be overridden byothers that have precedence over them.In the D-PATR environment presented by Karttunen (1986), all templates engagein defaulting: "... templates and other specifications that occur \[in lexical entries\] areprocessed sequentially from left to right.
Each item is compiled to a directed graphand superimposed on the graph previously compiled" (p. 76).
Here, then, defaultingoccurs as standard; any sequence of statements in a lexical entry may be such that alater statement conceals the effect of an earlier one.
Again, the fact that defaulting isinterpreted as the overwriting of one structure by another means that structures maybe modified in a nonmonotonic fashion.The implementation f defaults in ELu contrasts with these approaches in thatthe system ensures the monotonicity of structure-building--given a CPL /cl,... Cn},any FS F admitted by a class ci subsumes every FS that can be created by applyingto F the classes ~ci+l,.
.
.Cm}, i < m ~ n. 17 This follows directly from the definition of17 'Apply' here is used in the sense introduced in Section 3.2.327Computational Linguistics Volume 18, Number 3"default extension" given in Section 3.2.
Each individual constraint in a default setcontributes information to a FS F if and only if that information is consistent (i.e.,unifies) with the existing contents of F. Inconsistent information is ignored, but sinceit is only inconsistent information that would be capable of destructively modifyingF, by removing or replacing some of its content, the consequence is that F subsumesits default extension with respect o any set of constraints; moreover, since the otheroperations involved in determining superclass extension employ only conventional'strict' unification, these are equally unable to introduce into the system any elementof nonmonotonicity.4.3 Other  I ssuesInheritance hierarchies are frequently employed in object-oriented programming lan-guages and environments.
Some work in computational linguistics has been explicitlyobject-oriented in nature (Daelemans 1990; De Smedt 1984; De Smedt and de Graaf1990) but, as Gazdar (1990) observes, this has tended to adapt existing eneral-purposetechniques and languages, rather than attempt o devise specialized linguistic for-malisms.
Daelemans (1990) suggests that inheritance can replace unification as a basicmechanism for linguistic description, but his proposals remain relatively undeveloped.In some ways, the use of typed FSs and other data structures in ELu represents astep toward a rapprochement of unification and object-oriented techniques.
However,object-oriented programming involves much more than the use of inheritance, and thelack of mechanisms in ELU implementing encapsulation of data or message-passingprotocols means that it would be a mistake to classify the work presented here as avariety of object-oriented linguistic description.DATR (Evans and Gazdar 1990) is a language designed for the definition of in-heritance networks for use in lexical specification.
Its syntax is similar to ELU'S inthat paths and their values are grouped together into compound statements, in DATRcalled 'nodes,' but at a less superficial level the two systems are quite different.
Anexample will make some of the differences clear.
The theory below defines two nodes,A and B:A: <p l> == vl<p2a p2b> == v2<p3> == B.B: <p3> == v3.The values of <pi> and <p2a p2b> in A are set locally, while the value of <p3> isinherited from B. Inheritance ofvalues is thus specialized to individual paths in DATR,rather than applying uniformly to entire classes as in ELU.
Moreover, the defaultingmechanism of DATR is independent of the inheritance mechanism, and based on pathextension; an equation of the form '<al, ?
?
?
ai> == v' allows v to be inferred as the valueof all paths <al,.. ?ak>, 1 < i < k, such that no initial subpath <al,.
?
?
aj>, i < j <__ k, hasexplicitly been assigned a different value.
As a consequence, the objects manipulatedby DATR are strictly linear, in contrast o the more general feature structures thatform the basis of the ELU lexiconlS--in practice, path-value quations in DATR tendto correspond to variant sets in ELU.Flickinger et al (1985) present a model of the lexicon based on multiple defaultinheritance in the frame language HPRL (Rosenberg 1983).
Two inheritance modes18 This is not to say that he two are not interconvertible--see Kilbury et al (1991).328Graham Russell et al A Practical Approach to Multiple Default Inheritanceexist: 'normal,' a conventional shortest-path default method in which a slot is filled byinformation from the most specific accessible node in the hierarchy, and 'complete,' bywhich multiple values for a slot are obtained from a number of more general frames.Values for the FEATURES slot for the word has thus include (AUX PLUS) inheritedfrom AUXILIARY, (AGREEMENT 3RD-SING) from THIRD-SING, and (CONTROL SSR) fromSUBJECT-RAISE.
The values in this example are compatible; the question of contradic-tions in complete-mode inheritance is raised, but it is not stated whether any that dooccur are resolved, produce inconsistent results, or cause the search to fail.
Flickinger(1987: 60) refers to constraining the hierarchy "in such a way that each single-valuedattribute of some given class or member \[is\] assigned a value by at most one of theimmediate superclasses, or its parents, so conflicting values \[cannot\] occur," but doesnot indicate whether this constraint is to be imposed automatically aspart of a com-pilation or consistency checking process, or is simply to take the form of advice tousers.
He considers as an alternative a rule of inheritance "which for each attributeassigns priority to some one of the parent classes," and a convention similar to thatof the ELU lexicon, whereby precedence of direct superclasses is encoded in the orderof elements in a list.The system described by Padgham (1988) resembles the ELU lexicon in taking theobjects in the hierarchy as being sets of properties, partitioned into strict and defeasiblesubsets: "The type core includes those characteristics which we regard as always presentin objects of this type .
.
.
.
The type default contains the information for typical objects ofthat type."
Padgham's types may also be partially specified, and thus bear quite a closeresemblance to ELU classes with single variant sets.
Where this arrangement differsfrom the ELU lexicon is in permitting inheritance links between types to involve justthese substructures; to represent the fact that instances of type T1 are always typicalinstances of type T2, a link connects the core of T1 and the default of T2, and so on.Negative relations between core and default substructures may also be expressed.Inheritance hierarchies have chiefly been studied within two overlapping but con-ceptually distinguishable subareas of artificial intelligence: knowledge representationand commonsense reasoning.
The latter of these domains is characterized by concernsthat extend beyond those of the present work.
For example, problems of reasoningwith possibly incomplete knowledge do not arise in the context of lexical organiza-tion, since for any query the writer of a lexicon can be assumed to have envisaged theentire conclusion space and all factors required for computing it.5.
Example AnalysesThis section contains ome longer linguistic examples illustrating aspects of the ELUlexicon introduced above.
While these analyses are correct in the sense that they char-acterize sets of feature structures that achieve the desired pairing of word forms andmorphosyntactic properties, it should of course be borne in mind that each representsjust one treatment among the many possible.5.1 English Irregular VerbsIn most cases, lexical items that realize certain morphosyntactic properties in irregularforms do not also have regular ealizations of those properties; thus *sinked, on theanalogy of, e.g., walked, is not a well-formed alternative to sank or sunk.
This phe-nomenon has frequently been discussed in both theoretical nd computational mor-phology, under the title of 'blocking,' and it appears to provide clear motivation for a329Computational Linguistics Volume 18, Number 3default-based hierarchical approach to lexical organization.
19 There are exceptions tothe general rule, however, and inheritance mechanisms must be sufficiently flexible topermit deviation from this pattern.Consider the small class of English verbs including dream, lean, learn, and burn;these have, for many speakers, alternate past finite and past participle forms: e.g.,dreamed and dreamt.
The following fragment produces the correct analyses, in whichthe value of <morph> expresses inflectional information, and that of <form> is thecorresponding word form.
R?#Word  wa lk  (Verb)<stem> = wa lk#Word  s ink  (Verb)<stem> = s ink<p_ f in_ fo rm> = sank  <psp_ form> = sunk#Word  dream (Dua lPas t  Verb)<stem> = dream#Class  Dua lPas t  ()i<psp_ form> = <stem> aa t<p f in  fo rm> = <stem> ~ t<morph> = past f in i te /pastnonf in i tel#Class  Verb  ()<cat> = v<p_ f in_ fo rm> = <stem> ~& ed<psp_ form> = <stem> ~ edI<morph> = present_sg3i<morph> = present_nonsg3i<morph> = past f in i tel<morph> = pastnonf in i te<form> = <stem> ~ s<form> = <stem><form> = <p f in_ fo rm><form> = <psp_ form>The lexical class of a regular verb such as walk contains a minimum of idiosyncraticinformation, the value of the feature <stem>.
Its direct superclass, Verb, contributes theinformation that the value of <cat> is v, and that the values of both <p_fin_form> and<psp_form> are the result of concatenating the <stem> value and ed.
In addition to thisdefault information, Verb has four variant sets, corresponding to the four combinationsof <morph> and <form> values admitted by the fragment.
Finite and nonfinite pastforms are both associated via the values of <p_fin_form> and <psp_form> with thestring walked, the third person singular present ense variant is assigned the stringwalks, and the word form representing the other present ense variants is walk.Irregular verbs differ in having the two past forms specified in their lexical class.The defeasible constraints providing values for <psp_form> and <p_fin_form> in Verb19 Blocking is a consequence of the architecture proposed by Calder (1989) and of the DATR language.20 The analysis ketched here is simplified in the sense that several variants within the Verb class havebeen omitted, all inflectional information isembodied as the value of the single feature <morph>, andno account is given of the various pelling alternations that accompany suffixation.330Graham Russell et al A Practical Approach to Multiple Default Inheritanceare overridden by this more specific information, so that while sink behaves like regularverbs in its present ense, the values of <form> for the past finite and past nonfinitevariants are sank and sunk.Verbs like dream have DualPast as a direct superclass, with higher precedence thanVerb.
DualPast has two variant sets, the first of which assigns as values of <psp_form>and <p_fin_form> the concatenation of the <stem> value and t, giving dreamt, etc.The second variant set is empty (recall that variant sets are preceded by the verticalbar 'f ') and the absence of contradictory specifications in this second variant permitsthe equations in the main set of Verb to apply.
In addition to specifying exceptionalproperties, therefore, the definition of DualPast also permits inheritance of propertiesfrom more general classes; among these properties i  that shared by verbs like walk offorming the two past forms by suffixing ed to the stem, which produces the regular(dreamed, etc.)
past forms.5.2 German Separable VerbsTwo large classes of German verbs are the separable- and inseparable-prefixed com-pound verbs; their analysis involves some quite intricate interactions of morphologi-cal, syntactic, and semantic information.
Separable verbs are of interest syntacticallybecause, as their name suggests, the prefix is a bound morpheme only in certain syn-tactic environments, namely when the verb is untensed or head of a verb-final clause.
21Members of both classes hare morphological, but not necessarily syntactic or seman-tic, properties of the verb that corresponds in form to their stem.
The separable-prefixverb weglaufen ('run away') and inseparable verlaufen ('elapse') are two such verbsthat the lexicon should be able to relate to their apparent stem laufen ('run'), assigningthem similar morphological properties--laufen then becomes the model for a familyof verbs.
Morphosyntactic peculiarities of the separable verbs include the form of thepast participle, in which the normal past participle prefix ge- is preceded by the sep-arable prefix (e.g., weggelaufen), and the existence of an infinitive form, in which theseparable prefix is followed by zu (e.g., wegzulaufen); the infinitive of other verbs isformed phrasally (from the perspective of written language, at least) with the particlezu as a separate word.
Past participles of inseparable-prefix verbs omit the ge- prefix.As in the example of Section 5.1, lexical classes encode just the idiosyncratic prop-erties of verbs.
Here, for compound verbs related to laufen, only their semantics isspecified at this level; other properties are inherited from classes associated with theprefix and stem.
The class laufen, in addition, specifies that the form of the past tensestem for this family of verbs is lief.#Word laufen (VStem Strong)<sem> = lauf en<morph past_stem> = lief#Word weglaufen (Weg laufen)<sem> = weglaufen#Word ver laufen (Ver laufen)<sem> = ver laufenThe class Ver inherits from NonSeparable, where values for <morph psp prefix> (theform of prefix for the past participle) and <morph prefix> (the form of prefix for other21 Within the syntactic analysis assumed here, their distribution is controlled by a binary feature<syn ?nv>, whose value in these contexts i  no, and elsewhere is yes.331Computational Linguistics Volume 18, Number 3variants)areinstantiated to the value of<prefix> provided in Ver--the past participleof verlaufen is thus verlaufen, etc.#Class Ver (NonSeparable)<pref ix> = ver#Class NonSeparable ()<morph pref ix> = <pref ix><morph psp pref ix> = <pref ix>The behavior of separable verbs is more complex, and involves anumber of variantsets in the Separable class.
The first of these accounts for the prefix occurring in thepast participle, which is the result of concatenating the value of <morph prefix> andge--the past participle of weglaufen is thus weggelaufen.
The second variant set accountssimilarly for the infinitive form wegzulaufen.
The third accounts for all other forms ofa separable verb in which the prefix is attached; these are just the forms for which thesentence grammar assigns the value no to the <syn inv> attribute, with the exceptionof the past participle and infinitive, which receive special treatment.
The fourth variantaccounts for the other cases, i.e., those finite verbs in which the prefix is detached, andfor which the sentence grammar assigns to <syn inv> the value yes.
Here, the <synprefix> attribute ncodes the form of the detached prefix for use by the sentencegrammar.#Class Weg (Separable)<pref ix> = weg#Class Separable ()I<syn infl> = psp<morph psp pref ix> = <prefix> ~ geI<syn infl> = inf<merph pref ix> = <prefix> &~ zu<syn infl> = "psp/inf<syn inv> = no<morph pref ix> = <prefix>t<syn infl> = pres_sg_3/past_sg_3<syn inv> = yes<syn pref ix> = <pref ix>The r61e of the class VStem is rather different; it serves to identify the substring ofa verb's citation form that corresponds to its "base stem."
For the majority of verbs,whose citation form ends in -en, this is what results when any prefix (with the emptystring as default) and the final -en are detached.
For the minority of verbs whosecitation form ends in -eln or -ern, only the final -n is detached.
Recall that the citationform of verbs in this lexicon coincides with the value of the <sere> attribute.#Class VStem (Verb)<pref ix> = ''i<sem> = <prefix> ~ <morph bse stem> ~ enI<sem> = <pref ix> ~ <morph bse stem> && n<sem> = _ aa In/rn332Graham Russell et al A Practical Approach to Multiple Default InheritanceThe lexical class laufen inherits directly, and weglaufen, etc., indirectly, from theStrong class.
Some strong verbs undergo a stem alternation known as 'Umlaut' incertain parts of their paradigm--the third person singular of the present ense forlaufen is 14uft, for example.
This modification is performed here by the macro call inthe main set of the Strong class; Umlaut is defined elsewhere as a macro that employsthe string concatenation perator described in Section 2.1 to segment the string passedas its first argument, change the vowel, and reassemble the components o produceits second argument.
Strong verbs form their past participle with the suffix -en, whereweak verbs have -t. Their second and third person singular present ense forms mayundergo vowel modification as described above, and the past tense forms are irregular,with a zero suffix for the first and third person singular.#Class Strong (Vlnfl Verb)i<syn infl> = psp<morph psp suff ix> = ent!Umlaut (<morph bse stem>,<morph stem>)<syn infl> = pres_sg_3i<syn infl> = past_sg_3<morph suff ix> = ''<morph stem> = <morph past stem>i<syn infl> = ~psp/pres_sg_3/past_sg_3Other members of the paradigm are described by the fourth variant set of Strong, thefunction of which is not to add information, but rather to permit hem to inherit fromVInfl properties common to weak verbs.
VInfl contains default statements concerningthe past participle form: unless contradicted by more specific information, this is tobe constructed from the prefix ge-, the suffix -t, and the value of <morph bse stem>provided in VStem.
The weak verb warten, for example, has the past participle gewartet.The 'base' or 'bare infinitive' form is constructed similarly, and the suffix for the thirdperson singular of the present ense is stated to be -t, to give lduft, etc.
As before, thefourth variant set permits members of the paradigm not treated explicitly in this classto inherit from Verb.#Class VInfl  (Verb)<morph psp pref ix> = ge<morph psp suff ix> = t<morph psp stem> = <morph bse stem><syn infl> = psp/bse/pres_sg_3/past_sg_3i<syn infl> = psp<form> = <morph psp pref ix> ~&<morph psp stem> ~& <morph psp suff ix>f<syn infl> = bse<form> = <morph pref ix> ~&<morph bse stem> ~& eni<syn infl> = pres_sg_3<morph suff ix> = tI<syn infl> = "psp/bse/pres_sg_3333Computational Linguistics Volume 18, Number 3The most general class, Verb, establishes default values for prefix, stem, and suf-fix attributes, and states that the default <form> value is the result of concatenatingwhatever values these attributes have been assigned, either in this class or in morespecific ones.
It also states that, by default, a verb has no detached separable prefix;tensed separable verbs are exceptions to this, and receive their <syn prefix> valuein the Separable class.
The two variant sets in Verb serve to restrict he syntacticallyrelevant <syn inv> attribute to a no value for the base, past participle, and infinitiveforms, while leaving tensed verbs able to take either value.#Class  Verb  ()<cat> = v<syn pre f ix> = none<morph  stem> = <morph bse stem><morph pre f ix> = ' '<morph  su f f i x> = en<form> =<morph pre f ix> ~ <morph  stem> ~ <morph su f f i x>I<syn inf l> = bse /psp / in f<syn inv> = noI<syn inf l> = ~bse/psp / in f6.
Implementational and Practical IssuesThe introduction stated three main requirements imposed by the context within whichthe ELu lexicon system is used: the ability to both analyze and generate word forms,good integration with other components that interface to the lexicon system (for ex-ample parsers and generators), and the ability to accommodate a large number ofwords.
Our implementation, though relatively straightforward, achieves these goals,making the system genuinely useful in practice; this section briefly discusses ome ofthe implementational issues involved.6.1 Analysis and Generation of Word FormsIn Section 3, the set of lexical items admitted by a lexicon was defined formally asthe union of the global extensions of all lexical classes in the lexicon.
This definitionsuggests an obvious (bottom-up) implementation of the analysis and generation ofword forms: collecting up all the lexical classes in the lexicon, and computing theunion of their global extensions, in analysis returning only the FSs with wordformattribute the same as the word form being analyzed, and in generation returning onlythe word forms whose FSs unify with the structure being generated from.This form of exhaustive search is computationally expensive for all but the smallestlexicons--however, it does allow all unification and defaulting operations to be traced,so that when developing a lexicon (and working with only a representative sample oflexical classes) the user can precisely monitor the effects of adding new classes andmodifying old ones.
The tracing information is presented in an order and a mannerthat appears natural to a user who understands global extension.6.2 EfficiencyWhile a lexicon is being debugged, all the words and classes in it are held in mainmemory, and analysis and generation are performed using exhaustive search, as de-scribed above.
Once the lexicon is fully debugged, this approach has three majordrawbacks: since they are ordinary text files, large lexicons take a long time to load334Graham Russell et al A Practical Approach to Multiple Default Inheritanceinto the system, once in memory the representations of the classes in them occupya lot of space (increasing process size and swapping and garbage collection time),and exhaustive search over all the lexical classes on every lookup is too inefficient forpractical purposes.To solve these problems, we have implemented a facility that indexes a lexicon,storing all the information in it in a machine-oriented format in files on disc.
Theformat is such that the information can be retrieved quickly with minimal processing.One index file holds all the classes in the lexicon, each superclass in a class's CPL beingstored as an integer epresenting the byte position in the file at which its definitionstarts.
During the indexing process, for each lexical class, all the lexical items admit-ted by the class are generated.
The index file byte position of the class is associatedwith each distinct word form in the lexical items.
22 This position is also associatedwith the name of each semantic relation occurring in the lexical items.
At the endof indexing these pairings are lexicographically sorted and written out to index files.Analysis works by searching for the word form (using a binary chop on the wordform index file), retrieving the byte positions associated with the form, fetching thelexical classes at these positions together with their superclasses, and performing anexhaustive lookup (as described above) using just these lexical classes.
Generation issimilar but instead uses the semantic relation index.If there are n possible word forms implicit in a lexicon, then analyzing one formwill take time proportional to c. log2(n) where c is a small constant, plus in the averagecase a constant time for lookup with the candidate l xical classes.
Generation similarlywill take time proportional to log2 of the total number of semantic relations in thelexicon plus a constant.
In practice, the size of the lexicon makes little difference tolookup time; what really matters is the number of classes in the CPLs of lexical classesand their complexity.6.3 IntegrationThe ELU lexicon system is fully integrated with the rest of ELU.
The fact that the lexiconis based on multiple default inheritance is transparent to the analyzer and generator(and even to the casual user).
Indeed, Ecu supports another type of lexicon based onfinite state morphology; lexicons of this type are accessed via the same interface, andone may be loaded and available for use at the same time as an inheritance-basedlexicon.One of the characteristics of the ELU lexicon system that has allowed it to be sowell integrated with the other components in the system is that it represents featurestructures in exactly the same way that they do.
In particular, ELU does not have toconvert from one representation to another at the interface to the lexicon, as doesDATR when used within a unification grammar system (Kilbury et al 1991).7.
SummaryThe popularity of unification as a tool for computational linguistics tems from itsdeclarative, monotonic semantics; however, the price to be paid for the benefits of apure unification framework is the lack of a satisfactory treatment of exceptions (nega-tion, defaults, etc.).
The popularity of default inheritance as a tool for knowledgerepresentation stems from its ability to encode, in a straightforward manner, the type22 In theory, the system can deal with lexicons admitting up to around 4,000,000 word forms, but thelargest lexicon tested to date contains lightly more than 30,000 entries.335Computational Linguistics Volume 18, Number 3of nested generalization with exceptions that natural anguage lexicons exhibit; how-ever, in achieving this expressive power one introduces a degree of order-dependenceinto the system.
The approach presented here attempts to combine the advantages ofunification and default inheritance while minimizing the disadvantages arising fromtheir interaction.Properties of general default systems that lead to intractability are absent; thetotal ordering imposed on superclasses by the CPL eliminates cycles, ambiguity, andthe redundancy of multiple paths, while the suppression of negative inheritance linksremoves a further source of complexity.
Facilities have been dispensed with not onlybecause they are computationally problematic, but also as a result of the applicationin question--as we observe in Section 2, ambiguity and negation are not essential inthe context of a unification-based lexicon.AcknowledgmentsThis paper is an expanded version ofRussell et al (1990).
We are indebted toMark Johnson for valuable comments onthat earlier work, and to ComputationalLinguistics referees for their suggestions.Participants at the ACQUILEX workshop ondefault inheritance held in Cambridge inApril 1991 also made useful suggestions.ReferencesBallim, A.; Candelaria de Ram, S.; and Fass,D.
(1990).
"Reasoning using inheritancefrom a mixture of knowledge andbeliefs."
In Knowledge Based ComputerSystems: Proceedings ofKBCS '89 (LectureNotes in Artificial Intelligence no.
444),edited by S. Ramani, R. Chandrasekar,and K. S. R. Anjaneyulu, 387-396.Springer-Verlag.Ballim, A.; Fass, D.; and Candelaria de Ram,S.
(1988).
"Resolving a clash of intuitions:Utilizing strict and defeasible informationin an inheritance system."
CRLMemoranda MCCS-88-119, ComputingResearch Laboratory, New Mexico StateUniversity.Bouma, G. (1990).
"Defaults in unificationgrammar."
In: Proceedings, 28th AnnualMeeting of the Association for ComputationalLinguistics.
165-172.Briscoe, T.; Copestake, A.; and de Paiva V.,eds.
(1991).
Proceedings ofthe AeQU~LEXWorkshop on Default Inheritance in theLexicon.
Technical Report No.
238,Cambridge University ComputerLaboratory.Calder, J.
(1989).
"Paradigmaticmorphology."
In Proceedings, FourthConference ofthe European Chapter of theAssociation for Computational Linguistics.58-65.Carpenter, B.
(1991).
"Skeptical andcredulous default unification withapplications to templates andinheritance."
In Proceedings, ACQUILEXWorkshop on Default Inheritance in theLexicon, edited by T. Briscoe,A.
Copestake, and V. de Paiva.
TechnicalReport No.
238, Cambridge UniversityComputer Laboratory.Daelemans, W. (1990).
"Inheritance inobject-oriented natural languageprocessing."
In Proceedings ofthe Workshopon Inheritance and Natural LanguageProcessing, edited by W. Daelemans andG.
Gazdar, 30-38.
Tilburg University.Daelemans, W., and Gazdar, G., eds.
(1990).Proceedings ofthe Workshop on Inheritance inNatural Language Processing.
ITK, TilburgUniversity.De Smedt, K. (1984).
"Using object-orientedknowledge-representation techniques inmorphology and syntax programming.
"In Proceedings, 3rd European Conference onArtificial Intelligence (ECAI84).
181-184.De Smedt, K. and de Graaf, J.
(1990).
"Structured inheritance in frame-basedrepresentation f linguistic ategories."
InProceedings ofthe Workshop on Inheritanceand Natural Language Processing, edited byW.
Daelemans and G. Gazdar, 39-47.Tilburg University.Estival, D. (1990).
ELU User Manual.Technical Report 1, ISSCO, Geneva.Evans, R., and Gazdar, G., eds.
(1990).
TheDATR Papers: February 1990.
CognitiveScience Research Paper CSRP 139, Schoolof Cognitive and Computing Sciences,University of Sussex, Falmer.Flickinger, D. P. (1987).
Lexical rules in thehierarchical lexicon.
Doctoral dissertation,Stanford University, Palo Alto, CA.Flickinger, D. P.; Pollard, C.; and Wasow, T.(1985).
"Structure-sharing  lexicalrepresentation."
In Proceedings, 23rdAnnual Meeting of the Association forComputational Linguistics.
262-267.Gazdar, G. (1990).
"An introduction to336Graham Russell et al A Practical Approach to Multiple Default InheritanceDATR."
In The DATR Papers: February1990, edited by R. Evans and G. Gazdar,1-14, Cognitive Science Research PaperCSRP 139, University of Sussex.Johnson, R., and Rosner, M. (1989).
"A richenvironment for experimentation withunification grammars."
In Proceedings,Fourth Conference ofthe European Chapter ofthe Association for Computational Linguistics.182-189.Kaplan, R. M. (1987).
"Three Seductions ofComputational Psycholinguistics."
InLinguistic Theory and Computer Applications,edited by P. Whitelock, M. M. Wood,H.
L. Somers, R. Johnson, and P. Bennett,149-188.
Academic Press.Karttunen, L. (1984).
"Features and values.
"In Proceedings, l Oth International Conferenceon Computational Linguistics and the 22ndAnnual Meeting of the Association forComputational Linguistics.
28-33.Karttunen, L. (1986).
"D-PATR: Adevelopment environment forunification-based grammars."
InProceedings, 11 th International Conference onComputational Linguistics.
74-80.Kasper, R. T., and Rounds, W. C. (1986).
"Alogical semantics for feature structures.
"In Proceedings, 24th Annual Meeting of theAssociation for Computational Linguistics.257-266.Keene, S. (1989).
Object-OrientedProgramming inCommon Lisp.Addison-Wesley.Kilbury, J.; Naerger, P.; and Renz, I., (1991).
"DATR as a lexical component for PATR.
"In Proceedings, Fifth Conference oftheEuropean Chapter of the Association forComputational Linguistics.
137-142.Padgham, L. (1988).
"A model andrepresentation for type information andits use in reasoning with defaults."
InProceedings, Seventh National Conference onArtificial Intelligence.
409-414.Rosenberg, S. (1983).
"HPRL: A languagefor building expert systems."
InProceedings, Eighth International JointConference on Artificial Intelligence.
215--217.Russell, G.; Carroll, J.; and Warwick, S.(1990).
"Multiple default inheritance in aunification-based lexicon."
In Proceedingsof the Workshop on Inheritance and NaturalLanguage Processing, edited byW.
Daelemans and G. Gazdar.
93-102.Tilburg University.Sandewall, E. (1986).
"Nonmonotonicinference rules for multiple inheritancewith exceptions."
In Proceedings, IEEE 74.1345-1353.Schmolze, J. G., and Lipkis, T. A.
(1983).
"Classification i  the KL-ONE knowledgerepresentation system."
In Proceedings,Eighth International Joint Conference onArtificial Intelligence.
330-332.Selrnan, B., and Levesque, H. J.
(1989).
"Thetractability of path-based inheritance."
InProceedings, i1th International JointConference on Artificial Intelligence.1140-1145.Shieber, S. M. (1986a).
An Introduction toUnification-Based Approaches toGrammar.CSLI.Shieber, S. M. (1986b).
"A simplereconstruction of GPSG."
In Proceedings,11th International Conference onComputational Linguistics.
211-215.Steele, G. L. (1990).
Common Lisp: TheLanguage, Second Edition.
Digital Press.Touretzky, D. S. (1986).
The Mathematics ofInheritance Systems.
Pitman Publishing.Touretzky, D. S.; Horty, J. E; and Thomason,R.
H. (1987).
"A clash of intuitions: Thecurrent state of nonmonotonic multipleinheritance systems."
In Proceedings, TenthInternational Joint Conference on ArtificialIntelligence.
476-482.337
