Tree-Local Multicomponent Tree-AdjoiningGrammars with Shared NodesLaura Kallmeyer?TALaNa/Lattice, Universite?
Paris 7This article addresses the problem that the expressive power of tree-adjoining grammars (TAGs)is too limited to deal with certain syntactic phenomena, in particular, with scrambling in free-word-order languages.
The TAG variants proposed so far in order to account for scrambling arenot entirely satisfying.
Therefore, the article introduces an alternative extension of TAG thatis based on the notion of node sharing, so-called (restricted) tree-local multicomponent TAGwith shared nodes (RSN-MCTAG).
The analysis of some German scrambling data is sketchedin order to show that this TAG extension can deal with scrambling.
Then it is shown thatfor RSN-MCTAGs of a specific type, equivalent simple range concatenation grammars canbe constructed.
As a consequence, these RSN-MCTAGs are mildly context-sensitive and inparticular polynomially parsable.
These specific RSN-MCTAGs probably can deal not with allscrambling phenomena, but with an arbitrarily large subset.1.
Introduction: LTAG and Scrambling1.1 Lexicalized Tree-Adjoining GrammarsTree-adjoining grammar (TAG) is a tree-rewriting formalism originally defined by Joshi,Levy, and Takahashi (1975).
A TAG (see Joshi and Schabes 1997 for an introduction)consists of a finite set of trees (elementary trees).
The nodes of these trees are labeledwith nonterminals and terminals (terminals label only leaf nodes).
Starting from theelementary trees, larger trees are derived using composition operations of substitution(replacing a leaf with a new tree) and adjunction (replacing an internal node with a newtree).
In the case of an adjunction, the tree being adjoined has exactly one leaf node thatis marked as the foot node (marked with an asterisk).
Such a tree is called an auxiliarytree.
When such a tree is adjoined to a node ?, in the resulting tree, the subtree with rootnode ?
from the old tree is put below the foot node of the new auxiliary tree.
Elementarytrees that are not auxiliary trees are called initial trees.
Each derivation starts with aninitial tree.
In the final derived tree, all leaves must have terminal labels.1?
UFR de Linguistique, Case 7003, 2 Place Jussiec, 75005 Paris.
E-mail: Laura.Kallmeyer@linguist.jussieu.fr.1 Additionally, TAG allows for each internal node to specify the set of auxiliary trees that can be adjoinedusing so-called adjunction constraints and, furthermore, to specify whether adjunction at that node isobligatory.
This is an important feature of TAG, since it influences the generative capacity of theformalism: {anbncndn |n ?
0}, for example, is a language that can be generated by a TAG with adjunctionconstraints but not by a TAG without adjunction constraints (Joshi 1985).
For this article, however,adjunction constraints do not play any important role.Submission received: 1st September 2003; Revised submission received: 4th May 2004; Accepted forpublication: 17th June 2004?
2005 Association for Computational LinguisticsComputational Linguistics Volume 31, Number 2Figure 1TAG derivation for John always laughs.Figure 1 shows a sample TAG derivation.
Here, the three elementary trees for laughs,John, and always are combined: Starting from the elementary tree for laughs, the tree forJohn is substituted for the noun phrase (NP) leaf and the tree for always is adjoined atthe verb phrase (VP) node.TAG derivations are represented by derivation trees that record the history of howthe elementary trees are put together.
A derivation tree is the result of carrying outsubstitutions and adjunctions.
Each edge in the derivation tree stands for an adjunctionor a substitution.
The edges are labeled with Gorn addresses of the nodes where thesubstitutions and adjunctions have taken place: The root has the address , and the jthchild of the node with address p has address pj.
In Figure 1, for example, the derivationtree indicates that the elementary tree for John is substituted for the node at address 1and always is adjoined at node address 2.What we have sketched so far are the mathematical aspects of the TAG formal-ism.
For natural languages, TAGs with specific properties are used.
These propertiesare not part of the formalism itself, but they are additional linguistic principles thatare respected when a TAG is constructed for a natural language.
First, a TAG fornatural languages is lexicalized (Schabes 1990), which means that each elementarytree has a lexical anchor (usually unique, but in some cases, there is more than oneanchor).
Second, the elementary trees of a lexicalized TAG (LTAG) represent extendedprojections of lexical items (the anchors) and encapsulate all syntactic arguments ofthe lexical anchor; that is, they contain slots (nonterminal leaves) for all arguments.Furthermore, elementary trees are minimal in the sense that only the arguments of theanchor are encapsulated; all recursion is factored away.
This amounts to the conditionon elementary tree minimality (CETM) from Frank (1992) (see also Frank [2002] forfurther discussions of the linguistic principles underlying TAG).2 The tree for laughs inFigure 1, for example, contains only a nonterminal leaf for the subject NP (a substitutionnode), and there is no slot for a VP adjunct.
The adverb always is added by adjunctionat an internal node.Because of these principles, in linguistic applications, combining two elementarytrees by substitution or adjunction corresponds to the application of a predicate toan argument.
The derivation tree then reflects the predicate-argument structure of thesentence.
This is why most approaches to semantics in TAG use the derivation tree as aninterface between syntax and semantics (see, e.g., Candito and Kahane 1998; Joshi andVijay-Shanker 1999; Kallmeyer and Joshi 2003).
In this article, we are not particularlyconcerned with semantics, but one of the goals of the article is to obtain analyses withderivation trees representing the correct predicate-argument dependencies.2 This minimality is actually the reason that the substitution operation is needed; formally TAGs withoutsubstitution and TAGs as introduced above have the same weak and strong generative capacity.188Kallmeyer Multicomponent TAGs with Shared NodesAn extension of TAG that has been shown to be useful for several linguistic ap-plications is multicomponent TAG (MCTAG) (Joshi 1987; Weir 1988).
Instead of singleelementary trees, an MCTAG has sets of elementary trees.
In each derivation step, oneof these sets is chosen, and all trees from the set are added simultaneously.
Dependingon the nodes to which the different trees from the set attach, different kinds of MCTAGsare distinguished: If all nodes are required to be part of the same elementary tree, theMCTAG is called tree-local; if all nodes are required to be part of the same tree set, thegrammar is set-local; and otherwise the grammar is nonlocal.1.2 Scrambling in TAGRoughly, scrambling can be described as the permutation of elements (arguments andadjuncts) of a sentence (we use the term scrambling in a purely descriptive sense withoutimplying any theory involving actual movement).
A special case of scrambling is so-called long-distance scrambling, in which arguments or adjuncts of an embeddedinfinitive are ?moved?
out of the embedded VP.
This occurs, for instance, in languagessuch as German, Hindi, Japanese, and Korean.
As an example of long-distance scram-bling in German, consider example (1):(1) .
.
.
dass [es]1 der Mechaniker [t1 zu reparieren] verspricht.
.
.
that it the mechanic to repair promises?.
.
.
that the mechanic promises to repair it?In example (1), the accusative NP es is an argument of the embedded infinitive zureparieren, but it precedes der Mechaniker, the subject of the main verb verspricht, andit is not part of the embedded VP.It has been argued (see Rambow 1994a) that in German, there is no bound on thenumber of scrambled elements and no bound on the depth of scrambling (i.e., in termsof movement, the number of VP borders crossed by the moved element).TAGs are not powerful enough to describe scrambling in German in an adequateway (Becker, Joshi, and Rambow 1991).
By this we mean that a TAG analysis ofscrambling respecting the CETM and therefore giving the correct predicate-argumentstructure (i.e., an analysis with each argument attaching to the verb it depends on) isnot possible.Let us consider the TAG analysis of example (1) in order to see why scram-bling poses a problem for TAG.
If we leave aside the complementizer dass, standardTAG elementary trees for verspricht and reparieren in the style of the XTAG grammar(XTAG Research Group 1998) might look as shown in Figure 2.
In the derivation, theFigure 2Standard TAG combination of der Mechaniker, zu reparieren, and verspricht in example (1).189Computational Linguistics Volume 31, Number 2verspricht-tree adjoins to the root node of the reparieren-tree, and the nominative NP derMechaniker is substituted for the subject node in the verspricht-tree.
This leads to the treeon the right in Figure 2.When es is added, there is a problem: It should be added to reparieren, since it isone of its arguments.
But at the same time, it should precede der Mechaniker; that is,it must be adjoined either to the root or to the NPnom node.
The root node belongs toverspricht, and the NPnom node belongs to der Mechaniker.
Consequently, an adjunctionto one of them would not give the desired predicate-argument structure.
If one wantedto analyze only example (1), one could add a tree to the grammar for reparieren with ascrambled NP that allows adjunction of verspricht between the NP and the verb.
But assoon as there are several scrambled elements that are arguments of different verbs, thisno longer works.This example has given an idea of why scrambling is problematic for TAG.
How-ever, adopting specific elementary trees, it is possible to deal with a part of the difficultscrambling data: It has been shown (see Joshi, Becker, and Rambow 2000) that TAG candescribe scrambling up to depth two (two crossed VP borders).
But this is not sufficient.Even though examples of scrambling of depth greater than two are rare, they can occur.An example is example (2), taken from Kulick (2000):(2) .
.
.
dass [den Ku?hlschrank]1 niemand [[[t1 zu reparieren] zu versuchen].
.
.
that the refrigerator nobody to repair to tryzu versprechen] bereit istto promise willing is?.
.
.
that nobody is willing to promise to try to repair the refrigerator?Consequently, TAG is not powerful enough to account for scrambling.3Becker, Rambow, and Niv (1992) argue that even linear context-free rewriting sys-tems (LCFRSs) (Weir 1988) are not powerful enough to describe scrambling.
(LCFRSsare weakly equivalent to set-local MCTAGs and therefore more powerful than TAGs.
)Although we think that the language Becker, Rambow, and Niv define as a kind of testlanguage for scrambling is not exactly what one needs (see section 2.3), we still suspectthat they are right in claiming that LCFRSs cannot describe scrambling.1.3 TAG Variants Proposed for ScramblingThe problem with long-distance scrambling and TAG is that the trees representingthe syntax of scrambled German subordinate clauses do not have the simple nestedstructure that ordinary TAG generates.
The CETM requires that (positions for) all ofthe arguments of the lexical anchor of an elementary tree be included in that tree.
Butin a scrambled tree, the arguments of several verbs are interleaved freely.
All TAGextensions that have been proposed to accommodate this interleaving involve factoringthe elementary structures into multiple components and inserting these components atmultiple positions in the course of the derivation.One of the first proposals made was an analysis of German scrambling data usingnonlocal MCTAG with additional dominance constraints (Becker, Joshi, and Rambow1991).
However, the formal properties of nonlocal MCTAG are not well understood, and3 See also Gerdes (2002) for a discussion of the limitation of TAG with respect to scrambling in German.190Kallmeyer Multicomponent TAGs with Shared Nodesit is assumed that the formalism is not polynomially parsable.
Therefore this approachis no longer pursued, but it has influenced the different subsequent proposals.An alternative formalism for scrambling is V-TAG (Rambow 1994a, 1994b; Rambowand Lee 1994), a formalism that has nicer formal properties than nonlocal MCTAG.V-TAG also uses multicomponent sets (vectors) for scrambled elements; in this it isa variant of MCTAG.
Additionally, there are dominance links among the trees of thesame vector.
In contrast to MCTAG, the trees of a vector in V-TAG are not required to beadded simultaneously.
The lexicalized V-TAGs that are of interest for natural languagesare polynomially parsable.
Rambow (1994a) proposes detailed analyses of a large rangeof different word order phenomena in German using V-TAG and thereby shows thelinguistic usefulness of V-TAG.Even though V-TAG does not pose the problems of nonlocal MCTAG in termsof parsing complexity, it is still a nonlocal formalism in the sense that, as long asthe dominance links are respected, arbitrary nodes can be chosen to attach the singlecomponents of a vector.
Therefore, in order to formulate certain locality restrictions(e.g., for wh-movement and also for scrambling), one needs an additional means ofputting constraints on what can interleave with the different trees of a vector, or inother words, constraints on how far a dominance link can be stretched.
V-TAG allowsus to put integrity constraints on certain nodes that disallow the occurrence of thesenodes between two trees linked by a dominance link.
This has the effect of making thesenodes act as barriers.
With integrity constraints, constructions involving long-distancemovements can be correctly analyzed.
But the explicit marking of barriers is somewhatagainst the original appealing TAG idea that such constraints result from impositionof the CETM, according to which the position of the moved element and the verb itdepends on must be in the same elementary structure, and from the further combinationpossibilities of this structure.
In other words, in local formalisms with an extendeddomain of locality such as TAG or tree-local and set-local MCTAG, such constraintsresult from the form of the elementary structures and from the locality of the derivationoperation.
That is, they follow from general properties of the grammar, and they neednot be stated explicitly.
This is one of the aspects that make TAG so attractive from alinguistic point of view, and it gets lost in nonlocal TAG variants.D-tree substitution grammars (DSGs) (Rambow, Vijay-Shanker, and Weir 2001) areanother TAG variant one could use for scrambling.
DSGs are a description-based for-malism; that is, the objects a DSG deals with are tree descriptions.
A problem with DSGis that the expressive power of the formalism is probably too limited to deal with allnatural language phenomena: According to Rambow, Vijay-Shanker, and Weir (2001)it ?does not appear to be possible for DSG to generate the copy language?
(page 101).This means that the formalism is probably not able to describe cross-serial dependenciesin Swiss German.
Furthermore, DSG is nonlocal and therefore, as in the case of V-TAG,additional constraints (path constraints) have to be placed on material interleaving withthe different parts of an elementary structure.Another TAG variant using tree descriptions is local tree description grammar(TDG) (Kallmeyer 2001).
Local TDG can be used for scrambling in a way similar to DSGor V-TAG.
The languages generated by local TDGs are semilinear.
However, the formal-ism allows one to generate tree descriptions with underspecified dominance relations,and the process of resolving the remaining dominance links is nonlocal.
Therefore onemay have the same problem as in the case of DSG and V-TAG.
Furthermore, so far ithas not been shown that the formalism is polynomially parsable, and it is not clearwhether such parsing is possible without any additional constraint or limitation on theunderspecified tree descriptions.191Computational Linguistics Volume 31, Number 2A further TAG variant proposed in order to deal with scrambling is segmented tree-adjoining grammar (SegTAG) (Kulick 2000).
SegTAG uses an operation on trees calledsegmented adjunction that consists partly of a standard TAG adjunction and partly ofa kind of tree merging or tree unification.
In this operation, two different things getmixed up, the more or less resource-sensitive adjoining operation of standard TAG, inwhich subtrees cannot be identified,4 and the completely different unification operation.Perhaps using tree descriptions instead of trees, a more coherent definition of SegTAGcan be achieved.
But we will not pursue this here.The formal properties of SegTAG are not clear.
Kulick (2000) suggests that SegTAGsare probably in the class of LCFRSs, but there is no actual proof of this.
However, ifSegTAG is in LCFRS, the generative power of the formalism is probably too limitedto deal with scrambling in a general way.
But it seems that the limit imposed by thegrammar on the complexity of the scrambling data is fixed but arbitrarily high.
(Withincreasing complexity, the elementary trees, however, get larger and larger.)
This meansthat one can probably define a SegTAG that can analyze scrambling up to some com-plexity level n for any n ?
IN.
(A definition of what a complexity level is, is not given;it is perhaps the depth of scrambling.)
In this sense, a general treatment of scramblingmight be possible.
We follow a similar approach in this article by proposing a mildlycontext-sensitive formalism that can deal with scrambling up to some fixed complexitylimit n that can be chosen arbitrarily high.All these TAG variants are interesting with respect to scrambling, and they givea great deal of insight into what kind of structures are needed for scrambling.
But asexplained above, none of them is entirely satisfying.
The most convincing one is V-TAG, since this formalism can deal with scrambling, lexicalized V-TAG is polynomiallyparsable, and the set of languages V-TAG generates contains the set of all tree-adjoininglanguages (TALs) (in particular, the copy language).
Furthermore, a large range of wordorder phenomena has been treated with V-TAG, and thereby the usefulness of V-TAGfor linguistic applications has been shown.
But as already mentioned, V-TAG has theinconvenience of being a nonlocal formalism.
For the reasons explained above, it isdesireable to find a local TAG extension for scrambling (as opposed to the nonlocalityof derivations in V-TAG, DSG, and nonlocal MCTAG) such that locality constraintsfor movements follow only from the form of the elementary structures and from thelocal character of derivations.
This article proposes a local TAG variant that can dealwith scrambling (at least with an arbitrarily large set of scrambling phenomena), thatis polynomially parsable, and that properly extends TAG in the sense that the set of allTALs is a proper subset of the languages it generates.In section 2, tree-local MCTAG with shared nodes (SN-MCTAG) and in particularrestricted SN-MCTAG (RSN-MCTAG) are introduced, formalisms that extend TAG inthe sense mentioned above.
Section 3 shows linguistic applications of RSN-MCTAG, inparticular, an analysis of scrambling.
In section 4, a relation between RSN-MCTAG andrange concatenation grammar (RCG) (Boullier 1999, 2000) is established.
This relationallows us to show that certain subclasses of RSN-MCTAG are mildly context-sensitiveand therefore in particular polynomially parsable.
These subclasses do not cover allcases of long-distance scrambling but, in contrast to TAG, they cover an arbitrarily large4 More precisely, only the root of the new elementary tree and eventually (i.e., in the case of an adjunction)the foot node get identified with the node the new tree attaches to.
But there is no unification of wholesubtrees.
Consequently, every edge occurring in the derived tree comes from exactly one edge in anelementary tree, and every edge from the elementary trees used in the derivation occurs exactly once inthe derived tree.
In this sense the operation is resource-sensitive.192Kallmeyer Multicomponent TAGs with Shared Nodesset, providing scrambling analyses that respect the CETM.
This means that the limit theyimpose on the complexity of the scrambling data one can analyze is variable.
Based onempirical studies, it can be chosen sufficiently great such that the grammar covers allscrambling cases that one assumes to occur.2.
The FormalismAn informal introduction of (restricted) tree-local MCTAG with shared nodes can alsobe found in Kallmeyer and Yoon (2004).2.1 Motivation: The Idea of Shared NodesLet us consider again example (1) in order to illustrate the general idea of shared nodes.In standard TAG, nodes to which new elementary trees are adjoined or substituteddisappear; that is, they are replaced by the new elementary tree.
For example, afterhaving performed the derivation steps shown in Figure 2, the root node of the reparierentree does not exist any longer.
It is replaced by the verspricht tree, and its daughters havebecome daughters of the foot node of the verspricht tree.
That is, the root node of thederived tree is considered to belong only to the verspricht tree.
Therefore, an adjunctionat that node is an adjunction at the verspricht tree.However, this standard TAG view is not completely justified: In the derived tree,the root node and the lower S node might as well be considered to belong to reparieren,since they are results of identifying the root node of reparieren with the root and the footnode of verspricht.5 Therefore, we propose that the two nodes in question belong to bothverspricht and reparieren.
In other words, these nodes are shared by the two elementarytrees.
Consequently, they can be used to add new elementary trees to verspricht and (incontrast to standard TAG) also to reparieren.In the following, we use an MCTAG, and we assume tree-locality; that is, the nodesto which the trees of such a set are added must all belong to the same elementary tree.Standard tree-local MCTAGs are weakly and even strongly equivalent to TAGs, but theyallow us to generate a richer set of derivation structures.
In combination with sharednodes, tree-local multicomponent derivation extends the weak generative power of thegrammar (see Figure 4 for a sample tree-local MCTAG with shared nodes that generatesa language that is not a tree-adjoining language).6Let us go back to example (1).
Assume the tree set in Figure 3 for the scrambled NPes.
If the idea of shared nodes is adopted, this tree set can be added to reparieren usingthe root of the derived tree for adjunction of the first tree and the NPacc substitutionnode for substitution of the second tree.
The operation is tree-local, since both nodes arepart of the reparieren tree.5 Actually, in a feature-structure based TAG (FTAG) (Vijay-Shanker and Joshi 1988), the top featurestructure of the root of the derived tree is the unification of the top of the root of verspricht and the top ofthe root of reparieren.
The bottom feature structure of the lower S node is the unification of the bottom ofthe foot of verspricht and the bottom of the root of reparieren.
In this sense, the root of the reparieren treegets split into two parts.
The upper part merges with the root node of the verspricht tree, and the lowerpart merges with the foot node of the verspricht tree.6 In a way, the idea of node sharing is already present in description-based definitions of TAG-relatedformalisms (see Vijay-Shanker 1992; Rogers 1994; Kallmeyer 2001).
This is why these formalisms aremonotonic with respect to the node properties described in the tree descriptions.
However, the possibilityof exploiting this in order to obtain multiple adjunctions combined with multicomponent treedescriptions has not been pursued so far.193Computational Linguistics Volume 31, Number 2Figure 3Derivation of (1) dass es der Mechaniker zu reparieren verspricht (?that the mechanic promises torepair it?)
using shared nodes.The notion of shared nodes means in particular that a node can be used for morethan one adjunction.
(E.g., in Figure 3, two trees were adjoined at the root of thereparieren tree.)
A similar idea has led to the definition of extended derivation in Schabesand Shieber (1994).
For certain auxiliary trees, Schabes and Shieber allow more than oneadjunction at the same node.
However, the definition of the derived tree in Schabes andShieber (1994) is such that if first ?1 and then ?2 are adjoined at some node ?
(i.e., inthe derivation tree there are edges from some ?
to ?1 and ?2, both with the positionp of the node ?
in ?
), then first the whole tree derived from ?1 is added to position p,and afterwards the whole tree derived from ?2 is added to position p. In other words,before ?2 is adjoined, all the trees to be added by adjunction or substitution to ?1 mustbe added.
This is different in the case of shared nodes: After ?1 and then ?2 have beenadjoined, the root node of ?2 in the derived tree is shared by ?1 and ?2 and consequentlycan be used for adjunctions at ?1.7 In other words, trees to be adjoined at the roots of?1 and ?2 can be adjoined in any order.
This is important for obtaining all the possiblepermutations of scrambled elements.2.2 Formal Definition of Tree-Local MCTAG with Shared NodesAs already mentioned, the idea of tree-local MCTAG with shared nodes is the following:In the case of a substitution of an elementary tree ?
into an elementary tree ?, inthe resulting tree, the root node of the subtree ?
is considered to be part of ?
andof ?.
Similarly, when an elementary tree ?
is adjoined at a node that is part of theelementary trees ?1, .
.
.
,?n, then in the resulting tree, the root and foot node of ?
areboth considered to be part of ?1, .
.
.
,?n and ?.
Consequently, if an elementary tree ?
?is added to an elementary tree ?, and if there is then a sequence of adjunctions at root7 In this case, one obtains crossed dotted edges in the SN-derivation structure defined later (see Figure 14for an example).194Kallmeyer Multicomponent TAGs with Shared Nodesor foot nodes starting from ?
?, then each of these adjunctions can be considered anadjunction at ?, since it takes place at a node shared by ?,?
?, and all the subsequentlyadjoined trees.Therefore, one way to define SN-MCTAG refers to the standard TAG derivation treein the following way.
Define the grammar as an MCTAG and then allow only derivationtrees that satisfy the following tree-locality condition: For each instance {?1, .
.
.
,?k} ofan elementary tree set in the derivation tree, there is a ?
such that each of the ?i is eithera daughter of ?
or is linked to one of the daughters of ?
by a chain of adjunctions at rootor foot nodes.As an example, consider the derivation tree for (1) in Figure 3.
It shows that the treesused in the derivation are the reparieren tree, the verspricht tree, the Mechaniker tree, andthe two trees es and -es from the tree set in Figure 3.
-es is substituted into reparierenat position 21, and verspricht is adjoined to reparieren at position .
Then, Mechaniker issubstituted into verspricht at position 1, and es is adjoined to verspricht at position .
Thederivation is tree-local in the node-sharing sense, since for the tree set {-es, es}, -esis a daughter of reparieren in the derivation tree and es is linked to reparieren by a firstadjunction of verspricht to reparieren and a further adjunction of es to the root of verspricht.In the following, we adopt this way of viewing derivations in SN-MCTAG asspecific multicomponent TAG derivations; that is, we define SN-MCTAG as a variantof MCTAG.
This avoids formalizing a notion of shared nodes, even though this was thestarting motivation for the formalism.We assume a definition of TAG as a tuple G = ?I, A, N, T?
with I being the set ofinitial trees, A the set of auxiliary trees, and N and T the nonterminal and terminalnode labels, respectively (see, for example, Vijay-Shanker [1987] for a formal definitionof TAG).
Now we formally introduce multicomponent tree-adjoining grammars (Joshi1987; Weir 1988):Definition 1A multicomponent tree-adjoining grammar is a tuple G = ?I, A, N, T,A?
such that GTAG := ?I, A, N, T?
is a TAG; A ?
P(I ?
A) is a set of subsets of I ?
A, the set of elementary tree sets.8?
?
??
is a multicomponent derivation step in G iff there is an instance {?1, .
.
.
,?n}of an elementary tree set in A and there are pairwise different node addresses p1, .
.
.
, pnsuch that ??
= ?
[p1,?1] .
.
.
[pn,?n], where ?
[p1,?1] .
.
.
[pn,?n] is the result of adding the?i (1 ?
i ?
n) at node positions pi in ?.9As in TAG, a derivation starts from an initial tree, and in the end, in the final derivedtree, there must not be any obligatory adjunction constraint, and all leaves must belabeled by a terminal or by the empty word.In each MCTAG derivation step, an elementary tree set is chosen, and the trees fromthis set are added to the already derived tree.
Since they are added to pairwise different8 P(X) is the set of subsets of some set X.9 As usual (see Vijay-Shanker 1987; Weir 1988), ?[p,??]
is defined as follows: If ??
is (derived from) aninitial tree and the node at position p in ?
is a substitution node, then ?[p,??]
is the tree one obtains bysubstitution of ??
into ?
at node position p. If ??
is (derived from) an auxiliary tree and the node atposition p in ?
is an internal node, then ?[p,??]
is the tree one obtains by adjunction of ??
to ?
at nodeposition p. Otherwise ?[p,??]
is undefined.195Computational Linguistics Volume 31, Number 2nodes, one can just as well add them one after the other; that is, each multicomponentderivation in an MCTAG G = ?I, A, N, T,A?
corresponds to a derivation in the TAGGTAG := ?I, A, N, T?.
Let us define the TAG derivation tree of such a multicomponentderivation as the corresponding derivation tree in GTAG.
We can then define tree-local,set-local, and nonlocal MCTAG and also the different variants of SN-MCTAG this articledeals with by putting different constraints on this derivation tree.10 Note that for eachoperation ?
[p,?i], the node address p in the derived tree ?
points at a node that isat some address p?
in some elementary tree ??
that was already added (??
and p?
areunique).
In the TAG derivation tree, there will be in this case an edge from ??
to ?i withposition p?.A TAG derivation tree can be considered a tuple of nodes and edges.
As usualin finite trees, the edges are directed from the mother node to the daughter.
Linearprecedence is not needed in a derivation tree, since it does not influence the result of thederivation.
So a derivation tree is a tuple ?N , E?, with N being a finite set of instances ofelementary trees and with E ?
N ?N ?
IN?, where IN?
is the set of Gorn addresses.
Wedefine the parent relation as the relation between mothers and daughters in a derivationtree, the dominance relation as the reflexive transitive closure of the parent relation,and the node-sharing relation as the relation between nodes that either are mother anddaughter or are linked first by a substitution/adjunction and then a chain of adjunctionsat root or foot nodes:Definition 2Let D = ?N , E?
be a derivation tree in a TAG. PD := {?n1, n2?
|n1, n2 ?
N , and there is a p ?
IN?
such that ?n1, n2, p?
?
E}is the parent relation in D. DD := {?n1, n2?
|n1, n2 ?
N , and either n1 = n2, or there is a n3 such that?n1, n3?
?
PD and ?n3, n2?
?
DD} is the dominance relation in D. SND := {?n1, n2?
| either ?n1, n2?
?
PD or there are t1, .
.
.
, tk ?
N , such that?n1, t1?
?
PD, n2 = tk and for all j, 1 ?
j ?
k ?
1: ?ti, ti+1, p??
?
E with eitherp?
=  or ti being an auxiliary tree with foot node address p?}
is thenode-sharing relation in D.A node-sharing relation ??1,?2?
that corresponds to an actual parent relation iscalled a primary node-sharing relation, and ?2 is called a primary SN-daughter of ?1,whereas any other node-sharing relation ??1,?2?
is called secondary and in this case ?2is called a secondary SN-daughter of ?1.The TAG derivation trees for MCTAG derivations have certain properties resultingfrom the requirement that the elements of instances of elementary tree sets must beadded simultaneously to the already derived tree: First, if an elementary tree set is used,then all trees from this set must occur in the derivation tree.
Secondly, one tree from anelementary tree set cannot be substituted or adjoined into another tree from the sameset, and, thirdly, two tree sets cannot be interleaved.
For nonlocal MCTAG, these are allconstraints the TAG derivation tree needs to satisfy.10 This TAG derivation tree is not the MCTAG derivation tree defined in Weir (1988).
The nodes of Weir?sMCTAG derivation trees are labeled by sequences of elementary trees (i.e., by elementary tree sets), andeach edge stands for simultaneous adjunctions/substitutions of all elements of such a set.196Kallmeyer Multicomponent TAGs with Shared NodesLemma 1Let G = ?I, A, N, T,A?
be an MCTAG, GTAG := ?I, A, N, T?.
Let D = ?N , E?
be a derivationtree in GTAG with the corresponding derived tree t being in L(GTAG).D is a possible TAG derivation tree in G with t ?
L(G) iff D is such that (MC1) The root of D is an instance of an initial tree ?
?
I and all othernodes are instances of trees from tree sets in A such that for all instances ?of elementary tree sets from A and for all ?1,?2 ?
?, if ?1 ?
N , then?2 ?
N . (MC2) For all instances ?
of elementary tree sets from A and for all?1,?2 ?
?, ?1 = ?2: ??1,?2?
?
DD. (MC3) For all pairwise different instances ?1,?2, .
.
.
,?n, n ?
2, ofelementary tree sets from A, there are no ?
(i)1 ,?
(i)2 ?
?i, 1 ?
i ?
n, such that??
(1)1 ,?
(n)2 ?
?
DD and ??
(i)1 ,?
(i?1)2 ?
?
DD for 2 ?
i ?
n.The proof of this lemma is given in the appendix.
The lemma gives us a wayto characterize nonlocal MCTAG via the properties of the TAG derivation trees thegrammar licenses.
With this characterization we get rid of the original simultaneityrequirement: The corresponding properties are now captured in the three constraints(MC1)?(MC3).
But since these constraints need to hold only for the TAG derivationtrees that correspond to derived trees in the tree language, subderivation trees need notsatisfy them.
In other words, ?1 and ?2 from the same elementary tree set can be addedat different moments of the derivation as long as the final complete TAG derivation treesatisfies (MC1)?
(MC3).We now define tree-local, set-local, SN-tree-local, and SN-set-local TAG derivationtrees by imposing further conditions.
Basically, the difference between the first two andtheir SN variants is that in the first two, the definition refers to the parent relation,whereas in the second two, it refers to the node-sharing relation.Definition 3Let G = ?I, A, N, T,A?
be an MCTAG.
Let D = ?N , E?
be a TAG derivation tree for somet ?
L(?I, A, N, T?
). D is a multicomponent derivation tree iff it satisfies (MC1)?
(MC3). D is tree-local iff for all instances {?1, .
.
.
,?n} of elementary tree setswith ?1, .
.
.
,?n ?
N , there is one ?
such that ?
?,?1?, .
.
.
, ??,?n?
?
PD. D is set-local iff for all instances {?1, .
.
.
,?n} of elementary tree sets with?1, .
.
.
,?n ?
N , there is an instance ?
of an elementary tree set such thatfor all 1 ?
i ?
n, there is a ti ?
?
with ?ti,?i?
?
PD. D is SN-tree-local iff for all instances {?1, .
.
.
,?n} of elementary treesets with ?1, .
.
.
,?n ?
N , there is one ?
such that ?
?,?1?, .
.
.
, ??,?n??
SND. D is SN-set-local iff for all instances {?1, .
.
.
,?n} of elementary tree setswith ?1, .
.
.
,?n ?
N , there is an instance ?
of an elementary tree set suchthat for all 1 ?
i ?
n, there is a ti ?
?
with ?ti,?i?
?
SND.197Computational Linguistics Volume 31, Number 2Figure 4SN-MCTAG for {w3 |w ?
T?
}.The formalism we are proposing for scrambling is MCTAG with SN-tree-local TAGderivation trees.
We call these grammars tree-local MCTAGs with shared nodes:Definition 4Let G be an MCTAG.
G is a tree-local MCTAG with shared nodes iff the set of treesgenerated by G, LT(G), is defined as the set of those trees that can be derived with anSN-tree-local multicomponent TAG derivation tree in G.As usual, the string language LS(G) is then defined as the set of strings yielded by thetrees in LT(G).All tree-adjoining languages can be generated by SN-MCTAGs, since a TAG cor-responds to an MCTAG with unary multicomponent sets.
For such an MCTAG, eachTAG derivation tree is trivially SN-tree-local.
In other words, in this case the tree setsare the same, whether the grammar is considered a TAG, a tree-local MCTAG, or anSN-MCTAG.11 In particular, all TAG analyses proposed so far can be maintained, sinceeach TAG is trivially also an instance of SN-MCTAG.SN-MCTAG is a proper extension of TAG (and of tree-local MCTAG) in the sensethat there are languages that can be generated by an SN-MCTAG but not by a TAG.As an example, consider Figure 4, which shows an SN-MCTAG for {www |w ?
T?
}.12Similar to the grammar in Figure 4, for all copy languages {wn |w ?
T?}
for some n ?
IN,an SN-MCTAG can be found.
Other languages that can be generated by SN-MCTAGand that are not TALs are the counting languages {an1 .
.
.
ank |n ?
1} for any k > 4 (fork ?
4, these languages are tree-adjoining languages).There are two crucial differences between V-TAG and SN-MCTAG: First, in V-TAG, the adjunctions of auxiliary trees from the same set need not be simultaneous.In this respect, V-TAG differs not only from SN-MCTAG, but from any of the different11 However, viewing a TAG as an SN-MCTAG allows us to obtain a richer set of SN-derivation structures,as introduced in the next section.
This is exploited in Kallmeyer (2002) for semantics.12 The subscript NA in the figure stands for null adjunction; that is, it disallows adjunctions at the node inquestion.198Kallmeyer Multicomponent TAGs with Shared NodesMCTAGs mentioned above.
Secondly, V-TAG is nonlocal in the sense of nonlocal MC-TAG, whereas SN-MCTAG is local, even though the locality is not based on the parentrelation in the derivation tree, as is the case in standard local MCTAG, but on the SN-dominance relation in the derivation tree.
As a consequence of the locality, we do notneed dominance links (i.e., dominance constraints that have to be satisfied by the de-rived tree) in SN-MCTAG, in contrast to other TAG variants for scrambling.
The localitycondition put on the derivation sufficiently constrains the possibilities for attachingthe trees from elementary tree sets: Different trees from a tree set attach to differentnodes of the same elementary tree.
Consequently, the dominance relations among thesedifferent nodes determine the dominance relations among the different trees from thetree set.
Therefore extra dominance links are not necessary.
This is different for nonlocalTAG variants such as V-TAG or DSG, in which one can in principle attach the differentcomponents of an elementary structure at arbitrary nodes in the derived tree.2.3 SN-MCTAG and Scrambling: Formal ConsiderationsFigure 5 shows an SN-MCTAG generating a language that cannot even be generated bylinear context-free rewriting systems (see Becker, Rambow, and Niv [1992] for a proof),and therefore not by set-local MCTAG.
This example, however, concerns neither weaknor strong generative capacity, but something that Becker, Rambow, and Niv (1992) callderivational capacity: the derivation of nkvk must be such that the ?
(i)th n and the ith vcome from the same elementary tree set in the grammar.The grammar in Figure 5 works in the following way: Each derivation starts with ?.Then a first instance of the tree set (yielding n1 and v1) is added to the N and V nodes in?.
For each further instance of the tree set (yielding ni and vi), ?v is adjoined to the rootnode of the ?v tree of vi?1.
Therefore all ?v adjunctions except the first are occurringat root nodes, and consequently all ?v are (primary or secondary) SN-daughters of ?.The ?n tree of ni can be adjoined to any of the root or foot nodes of the ?n that havealready been added, since in this way all adjunctions of ?n except the first one occurat root or foot nodes, and therefore all these ?n are SN-daughters of ?.
This allows usto place ni at any position in the string already containing {n1, .
.
.
, ni?1}, and therebyany permutation of the ns can be obtained.
Since all nodes in the derivation tree are SN-daughters of ?, the derivation is SN-tree-local.
Note that in the grammar in Figure 5,there is no NA constraint on the foot node of the first auxiliary tree in the tree set.
Thisis crucial for allowing all permutations of the n1, .
.
.
, nk.
In this respect, the elementarytrees differ from what is usually done in TAG.Becker, Rambow, and Niv (1992) argue that a formalism that cannot generate thelanguage in Figure 5 is not able to analyze scrambling in an adequate way.
We think,Figure 5SN-MCTAG for {n?
(k) .
.
.n?
(1)vk .
.
.
v1 | k ?
0, ni = n, vi = v, and ni and vi are in the sameelementary tree set and they were added in the ith derivation step for all i, 1 ?
i ?
k, and ?
is apermutation of (1, .
.
.
, k)}.199Computational Linguistics Volume 31, Number 2Figure 6Predicate argument structure for SCR.however, that this language is not exactly what one needs for scrambling.
The assump-tion underlying the language in Figure 5 is that ni is an argument of vi.
But in this case,instead of adding ni and vi at the same time, ni should be added to vi.
If one makesthe additional assumption that argument NPs are added by substitution, then one canrequire that the argument NPs have already been substituted (this is what Joshi, Becker,and Rambow [2000] call the weak co-occurrence constraint), that is, that the tree forvi contain ni.
In this case, the language in Figure 5 is an appropriate test language forscrambling.
But we do not want to make this assumption.Furthermore, there are more predicate-argument dependencies: vi is also an argu-ment of vi?1 for i ?
2.
This is what Joshi, Becker, and Rambow (2000) call the strongco-occurrence constraint.
In other words, the dependency tree should be as in Figure 6.Additionally to the permutation of the n1, .
.
.
, nk, also the vi can be moved leftward,as long as they do not permute among themselves.
Consequently, for scrambling data(without extraposition), one rather wants to generate the following language: SCR :={w = ?
(n1 .
.
.
nkv1 .
.
.
vk) | k ?
1, ni = n, vi = v, for all 1 ?
i ?
k, and ?
is a permutation ofn1 .
.
.
nkv1 .
.
.
vk such that ni precedes vi in w for all 1 ?
i ?
k and vi precedes vi?1 in wfor all 1 < i ?
k} with the derivation structure in Figure 6.
An SN-MCTAG generatingthis language is shown in Figure 7.The SN-MCTAG in Figure 7 yields the following derivations: Either start with ?2, inwhich case an instance of {?n,?n} must be added and nv is obtained with n dependingon v, or start with ?1 for v1, in which case, for all v except the leftmost one, the set{?v1,?v1} is added, for the leftmost v, a set {?v2,?v2} is added, and for all the ns, sets{?n,?n} are added.
These sets can be added in any order; the auxiliary tree is alwaysadjoined to the root node of the already derived tree that is shared by all auxiliary treesthat have been used so far and by the first ?1.
The initial tree is primarily substitutedFigure 7SN-MCTAG for SCR.200Kallmeyer Multicomponent TAGs with Shared Nodesinto the argument slot it fills.
So the only condition for adding such a tree set is thatthe verb it depends on has already been added, since the tree of this verb provides thesubstitution node for the initial tree.
Therefore, since the lexical material is always leftof the foot node, one obtains that vi precedes vi?1 for all 1 < i ?
k and ni precedes vi forall 1 ?
i ?
k.Note that in Figure 7, for a scrambled ni, the substitution node is filled with anempty node, while the n is adjoined higher at a node that is not yet available in theelementary structure of vi.
So the combination of ni and vi cannot be precompiled here.2.4 Restricted SN-MCTAGWhen the formal properties of SN-MCTAG are examined, it becomes clear that the for-malism is hard to compare to other local TAG-related formalisms, since in the derivationtree, arbitrarily many trees can be secondary SN-daughters of a single elementary tree,such that these secondary links are considered to be adjunctions to that tree.
This meansthat these secondary links are relevant for the SN-tree-locality of the derivation.
Anexample is the grammar in Figure 5, in which in each derivation step, the relevant node-sharing relations are the links between ?
and the two auxiliary trees of the new set.This means that for a word of length k, there are k SN-daughters of ?
that are relevantfor the SN-tree-locality of the derivation.
The grammar in Figure 5 indicates that thisproperty of SN-MCTAG is at least partly responsible for the fact that SN-MCTAGallows us to generate languages that are not even mildly context-sensitive (i.e., thatare not in the class of languages that can be generated by LCFRS).
However, it wouldbe desirable to stay inside the class of mildly context-sensitive languages.
Therefore, inthe following, we define a restricted version, RSN-MCTAG, that limits the number ofrelevant secondary SN-daughters of an elementary tree.
The restriction is obtained asfollows: We require that in each derivation step, among the SN-relations between the old?
and the new set ?, there be at least one primary SN-relation.
The number of primarySN-daughters of a specific elementary tree is limited, since the primary SN-daughterscorrespond to substitutions/adjunctions at pairwise different nodes and the number ofnodes in an elementary tree is limited.
Consequently, the number of relevant secondarySN-daughters for a node is limited as well.An example of a derivation satisfying the new constraint is that in Figure 3, in whiches is a secondary SN-daughter of reparieren, while the second element of the tree set, -es,is a primary SN-daughter of reparieren.Definition 5 Let G = ?I, A, N, T,A?
be an MCTAG.
Let D = ?N , E?
be the TAG derivationtree of a tree t ?
LT(?I, A, N, T?).
D is RSN-tree-local iff for all instances{?1, .
.
.
,?n} of an elementary tree set with ?1, .
.
.
,?n ?
N , there is one ?such that1.
?
?,?1?, .
.
.
, ??,?n?
?
SND;2. there is one i, 1 ?
i ?
n, with ??,?i?
?
PD. An MCTAG G is called a restricted SN-MCTAG iff the set of treesgenerated by G, LT(G), is defined as the set of those trees that can bederived with an RSN-tree-local multicomponent TAG derivation tree in G.201Computational Linguistics Volume 31, Number 2The first condition of the definition says that the grammar is SN-tree-local, and thesecond condition ensures that at least one of the relevant SN-daughters of ?
is a primarySN-daughter, that is, an actual daughter of ?.As for SN-MCTAG, all tree-adjoining languages can also be generated by RSN-MCTAGs.
The sample grammars in Figures 4 and 5 are not RSN-MCTAGs.
We suspectthat there is no RSN-MCTAG that generates the language in Figure 5.
But the grammarin Figure 7 for the language SCR is an RSN-MCTAG.It can be shown that for the TAG derivation trees of an RSN-MCTAG, the followingholds: For each instance of an elementary tree set ?, the ?
to which all elements of ?are linked by node-sharing relations with at least one primary link is unique (which isnot necessarily the case for general SN-MCTAG).
This is formulated in the followinglemma:Lemma 2Let G = ?I, A, N, T,A?
be an RSN-MCTAG.
Let D = ?N , E?
be a TAG derivation treein G.Then for all instances {?1, .
.
.
,?n} of elementary tree sets with ?1, .
.
.
,?n ?
N , thereis exactly one ?
such that ?
?,?1?, .
.
.
, ??,?n?
?
SND, and there is one i, 1 ?
i ?
n, with??,?i?
?
PD.For such an elementary tree set {?1, .
.
.
,?n}, with ?
being the unique elementarytree as described in the lemma, all ??,?i?
?
SND \ PD, 1 ?
i ?
n, are called secondaryadjunction links in D. The proof of the lemma is given in the appendix.Now we introduce the SN-derivation structure of a TAG derivation tree D in anRSN-MCTAG.
It consists of D enriched with additional links for the secondary adjunc-tions.
These links are equipped with the positions of the first substitutions/adjunctionson the chain that corresponds to the secondary adjunctions.Definition 6Let G = ?I, A, N, T,A?
be an RSN-MCTAG.
Let D = ?N , E?
be a TAG derivationtree in G. The SN-derivation structure of D, DSN, is then DSN := ?N , E ?
?,with E ?
E ?. For all secondary adjunction links ??1,?2?
in D with ??
and p such that??1,?
?, p?
?
E and ???,?2?
?
DD: ?
?1,?2, p?
?
E ?. These are all elements of E ?.All e ?
E are called primary edges in DSN, and all e ?
E ?
\ E are called secondaryedges in DSN.With the notion of the SN-derivation structure, we can formulate the limitation onthe maximal number of secondary adjunctions to an elementary tree that we mentionedat the beginning of this section:Lemma 3Let G = ?I, A, N, T,A?
be an RSN-MCTAG.
Then there is a constant c such that for allTAG derivation trees D in G with SN-derivation structure DSN := ?N , E?, the followingholds:202Kallmeyer Multicomponent TAGs with Shared NodesThere is no n ?
N such that there exist m ?
c + 1 pairwise different n1, .
.
.
, nm suchthat for all i, 1 ?
i ?
m, there is a p such that either ?n, ni, p?
is a secondary edge in DSN; or ?n, ni, p?
is a primary edge in DSN, and there are no n?
and p?
such that?n?, ni, p??
is a secondary edge in DSN.That this lemma holds is nearly immediate: Each secondary adjunction must be as-sociated with a primary adjunction or substitution into the same tree instance.
Thereare at most k primary adjunctions or substitutions into any tree instance if k is themaximal number of nodes per elementary tree.
Consequently there are at most k ?
nsecondary adjunctions per node if n + 1 is the maximal number of trees per elementarytree set.In linguistic applications, the SN-derivation structure is intended to reflect thepredicate-argument dependencies of a sentence in the following way: For each tree inthe SN-derivation structure, if this tree is secondarily adjoined to some other tree ?,then it depends on ?.
Otherwise it depends on its mother node in the TAG derivationtree.
In this way, the grammar for SCR in Figure 7 yields the desired dependencystructure.3.
Linguistic Applications3.1 Scrambling with RSN-MCTAGIn this section, we present a small German grammar that allows us to analyze somecases of scrambling.
The aim is not an exhaustive treatment of the phenomenon, butjust to show that in principle, an analysis of scrambling in German is possible usingRSN-MCTAG.
The data to which we restrict ourselves are word order variations ofexample (3) without extraposition, that is, under the assumption that the order of theverbs is zu reparieren zu versuchen verspricht:(3) .
.
.
dass er dem Kunden das Fahrrad zu reparieren.
.
.
that henom the customerdat the bikeacc to repairzu versuchen versprichtto try promises?.
.
.
that he promises the customer to try to repair the bike?The elementary trees and tree sets for example (3) are shown in Figure 8.
In contrastto standard TAG practices, which are often guided by technical considerations, werepresent all arguments of a verb (including an embedded VP) by substitution nodes.For those parts that might be scrambled, there is a single elementary tree (for the casewithout scrambling) and a tree set used for scrambling.
The tree set contains an auxiliarytree that can be primarily or secondarily adjoined to some root node and a tree with theempty word that is intended to fill the argument position.
In order to avoid spuriousambiguities, we assume that whenever a derivation using the single elementary tree ispossible, this is chosen.A scrambled element always adjoins to a VP node, and the scrambled element isto the left of the foot node.
Therefore it precedes everything that is below or on the203Computational Linguistics Volume 31, Number 2Figure 8Elementary trees for scrambling.right of the VP node to which it adjoins.
Consequently, given the form of the verbalelementary trees in Figure 8, in which the verb is always below or to the right of all VPnodes allowing adjunction, the order x v for an x being a nominal or a verbal argumentof v is always respected.For an element (a lexical item), the tree set for scrambling is used whenever one ofthe following three cases holds: The element is scrambled. Scrambling of depth more than one out of the element takes place. The element intervenes between some element A (on its right) and someelement B (on its left) scrambled out of A, and the element itself does notbelong to A.In other words, the fact that the set for scrambling is used for some element doesnot necessarily mean that this element is scrambled.
It just means that one of thethree cases above holds, that is, that some scrambling around this element takesplace.One could actually do without the single trees and always use the tree sets.
In thiscase, even if no scrambling took place, all argument slots would be filled by emptywords, and all lexical material would be adjoined to the root node of the derived tree.At first glance, this seems rather odd.
But if one does not consider the substitutionnodes argument slots but rather some kind of subcategorization features marking whicharguments need to be added, an analysis using only the tree sets makes sense.
However,for this article, we keep the single trees.For example (3), a derivation without secondary adjunctions and using only thesingle trees is possible.
Let us consider the following word orders as examples of howsecondary adjunction is used for scrambling:204Kallmeyer Multicomponent TAGs with Shared Nodes(4) .
.
.
dass er1 [[das Fahrrad zu reparieren] zu versuchen]2 t1 dem Kunden t2.
.
.
that he the bike to repair to try the customerversprichtpromises(5) .
.
.
dass er [das Fahrrad zu reparieren]1 dem Kunden [t1 zu versuchen].
.
.
that he the bike to repair the customer to tryversprichtpromises(6) .
.
.
dass [das Fahrrad]1 er2 [[t1 zu reparieren] zu versuchen]3 t2 dem Kunden t3.
.
.
that the bike he to repair to try the customerversprichtpromisesIn example (4), the versuchen-VP and er are scrambled.13 Consequently, for versuchen ander, the sets with two trees are used, whereas for all the other elements, the single treescan be used.
In example (5), the reparieren-VP is scrambled out of the versuchen-VP, withdem Kunden intervening between the two.
Therefore, the tree sets are used for reparierenand dem Kunden.
For versuchen, the single tree can be used, since the scrambling out ofversuchen is of depth one.
In example (6), we have the same scrambling as in example (4),and additionally, das Fahrrad is scrambled out of the reparieren-VP and the versuchen-VP(depth two).
Consequently, in this case one needs tree sets for Fahrrad, er, versuchen, andreparieren.Let us consider the analysis of example (4): Starting with verspricht, the single treefor dem Kunden and the tree set for versuchen (with adjunction of the auxiliary tree atthe root) are added.
This leads to the first tree in Figure 9.
The VP nodes in boldfacetype in the figure are shared by versuchen and verspricht; that is, they can be used forfurther adjunction at the verspricht tree.
(Of course, only the root node can be used foradjunction, since the other nodes have NA constraints.)
It does not matter in which orderer and zu reparieren are added.
For er, the tree set is used.
The auxiliary tree is secondarilyadjoined to the root node, and the initial tree is substituted for the NPnom node in theverspricht tree.
This leads to the second tree in Figure 9.
For reparieren and das Fahrrad,the single trees are added below the VP substitution node in the versuchen tree.
Thecorresponding SN-derivation structure (see Figure 9) contains the desired predicate-argument dependencies.
The TAG derivation tree is RSN-tree-local.Next, let us consider example (5).
Here, the single trees for er and versuchen areadded to verspricht.
This leads to the first tree in Figure 10.
The VP node in boldface typein the figure belongs to verspricht and versuchen.
It is next used for secondary adjunctionof dem Kunden to the verspricht tree.
The initial tree is substituted at the NPdat slot.
Thisleads to the second tree.
Here, the bold VP node belongs to verspricht, versuchen, andKunde.
It is next used for secondary adjunction of the auxiliary tree of reparieren toversuchen, while the initial tree is substituted for the VP leaf in the versuchen tree.
This13 Actually, er here is not really scrambled, but since in our formalism, scrambled elements attach at the leftof a VP, any other element even more to the left is treated as if it is scrambled (even if it depends on thematrix verb).205Computational Linguistics Volume 31, Number 2Figure 9Analysis of example (4).Figure 10Analysis of example (5).leads to the third tree.
After that, one needs only to add the single tree for das Fahrradto reparieren.
Note that this is a derivation in which the foot node of the elementary treecontaining the lexical material does not dominate the tree with the empty word.Now let us consider the derivation of example (6).
Here, only for dem Kunden, thesingle tree is added by substitution.
In all other cases, the tree set is used with (primary206Kallmeyer Multicomponent TAGs with Shared Nodesor secondary) adjunction at the root node of the already derived tree.
This root nodeconsequently belongs to all verbs that have already occurred in the derivation and cantherefore be used to add arguments to any of them.We leave it to the reader to verify that all word orders can be generated.
This kindof analysis also works for more than two embeddings.Since all scrambled elements attach to a VP node in the elementary tree of the verbthey depend on, they cannot attach to the VP of a higher finite verb that embeds thesentence in which the scrambling occurs.
In this way, a barrier effect is obtained withoutestablishing any explicit barrier, as is done in V-TAG.
Instead, this locality of scramblingis a consequence of the form of the elementary trees and of the locality of the derivations.Concerning adjunct scrambling, each adjunct has a single auxiliary tree as in stan-dard TAG and additionally a set of two auxiliary trees, a lower auxiliary tree with anempty word and a higher auxiliary tree with the adjunct.
This is shown in Figure 11.The internal VP node of the higher tree in the tree set serves as an adjunction site for thelower parts of other adjuncts.
Similarly, the elementary trees of verbs need an extra VPnode in order to adjoin adverbs.For more analyses of scrambling, including scrambling in combination with extra-position and topicalization, and also for an extension of the analysis presented here toKorean data, see Kallmeyer and Yoon (2004).3.2 Raising Verbs and Subject-Auxiliary InversionOther phenomena often mentioned in the TAG literature (see, e.g., Rambow, Vijay-Shanker, and Weir 1995; Kulick 2000; Dras, Chiang, and Schuler 2004) as beingproblematic for TAG and tree-local MCTAG are sentences with raising verbs andsubject-auxiliary inversion, as in examples (7) and (8):(7) Does Gabriel seem to be likely to eat gnocchi?
(8) What does John seem to be certain to like?The standard TAG analyses of examples (7) and (8) (see Figure 12 for the analysis ofexample (8)) start with the eat and like tree, respectively, adjoin an auxiliary tree forlikely and certain, respectively, and then add the trees for does and seem, respectively.
Ifwe assume that these trees are in the same elementary tree set, then this last derivationstep is nonlocal, since the does tree adjoins to eat and like, respectively, while the seemtree adjoins to likely and certain, respectively.
Though different from scrambling, thisproblem seems to be of a similar nature, and formalisms that have been proposed forscrambling have also been used to treat these examples (see Kulick 2000).RSN-MCTAG allows us to analyze examples (7) and (8) in a way that puts does andseem into a single elementary tree set: After having adjoined to be likely and to be certain,Figure 11Trees for adjuncts.207Computational Linguistics Volume 31, Number 2Figure 12Derivation for (8).respectively, the root nodes of the adjoined trees are considered still to be part of theelementary trees of eat and like, respectively.
These elementary trees can then be used toadd the elementary tree set for does and seem: Both auxiliary trees are adjoined to thesetrees.
Figure 12 shows the corresponding SN-derivation structure.4.
RSN-MCTAG and Range Concatenation GrammarIn the following, we show that for each RSN-MCTAG of a certain type (i.e., withan additional restriction), a weakly equivalent simple range concatenation grammar(Boullier 1999, 2000) can be constructed.
It has been shown that RCGs generate ex-actly the class of all polynomially parsable languages (Bertsch and Nederhof 2001;appendix A).
Furthermore, as shown in Boullier (1998b), simple RCGs in particularare even weakly equivalent to linear context-free rewriting systems (Weir 1988).
As aconsequence, one obtains that the languages generated by simple RSN-MCTAGs aremildly context-sensitive.
This last property was introduced in Joshi (1985).
It includesformalisms that are polynomially parsable, are semilinear, and allow only a limitednumber of crossing dependencies.
(We do not give formal definitions of mild context-sensitivity and of LCFRS, since we do not need these definitions in this article.
)Concerning RSN-MCTAGs in general, that is, without any further restriction, we arealmost sure that they are not mildly context-sensitive.
Perhaps they can even generatelanguages that are not in the class of languages generated by RCGs.4.1 Range Concatenation GrammarsThis section defines range concatenation grammars.14Definition 7A range concatenation grammar is a tuple G = ?N, T, V, S, P?
such that N is a finite set of predicates, each with a fixed arity; T and V are disjoint finite sets of terminals and of variables; S ?
N is the start predicate, a predicate of arity 1; P is a finite set clauses of the form A0(x01, .
.
.
, x0a0 ) ?
,or A0(x01, .
.
.
, x0a0 ) ?
A1(x11, .
.
.
, x1a1 ) .
.
.An(xn1, .
.
.
, xnan ),with n ?
1 and Ai ?
N, xij ?
(T ?
V)?
and ai being the arity of Ai.14 Since throughout the article, we use only positive RCGs; whenever we say ?RCG,?
we actually mean?positive RCG.
?208Kallmeyer Multicomponent TAGs with Shared NodesWhen applying a clause with respect to a string w = t1 ?
?
?
tn, the arguments of thepredicates in the clause are instantiated with substrings of w, more precisely, with thecorresponding ranges.
A range ?i, j?
with 0 ?
i < j ?
n corresponds to the substringbetween positions i and j, that is, to the substring ti+1 ?
?
?
tj.
If i = j, then ?i, j?
correspondsto the empty string .
If i > j, then ?i, j?
is undefined.Definition 8For a given clause, an instantiation with respect to a string w = t1 .
.
.
tn consists ofa function f : {t?
| t?
is an occurrence of some t ?
T in the clause} ?
V ?
{?i, j?
| i ?
j, i,j ?
IN} such that for all occurrences t?
of a t ?
T in the clause: f (t?)
:= ?i, i + 1?
for somei, 0 ?
i < n, such that ti = t; for all v ?
V: f (v) = ?j, k?
for some 0 ?
j ?
k ?
n; if consecutive variables and occurrences of terminals in an argument in theclause are mapped to ?i1, j1?, .
.
.
, ?ik, jk?
for some k, then jm = im+1 for1 ?
m < k. By definition, we then state that f maps the whole argument to?i1, jk?.The derivation relation is defined as follows.
For a predicate A of arity k, a clauseA(.
.
.)
?
.
.
.
, and ranges ?i1, j1?, .
.
.
, ?ik, jk?
with respect to a given w: If there is an instan-tiation of this clause with left-hand side A(?i1, j1?, .
.
.
, ?ik, jk?
), then A(?i1, j1?, .
.
.
, ?ii, jk?
)can be replaced with the right-hand side of this instantiation.The language of an RCG G is the set of strings that can be reduced to the emptyword, that is, {w |S(?0, |w|?)
??
 with respect to w}.15 An RCG with maximal predicatearity n is called an RCG of arity n.For illustration, let us consider a sample RCG: The RCG with N = {S, A, B},T = {a, b}, V = {X, Y, Z}, start predicate S, and clauses S(X Y Z) ?
A(X, Z) B(Y),A(a X, a Y) ?
A(X, Y), B(b X) ?
B(X), A(,) ?
, B() ?
 has the string language{anbkan | k, n ?
IN}.
Consider the reduction of w = aabaa:We start from S(?0, 5?).
First we can apply the following clause instantiation:S(X Y Z ) ?
A(X , Z ) B(Y )?0, 2?
?2, 3?
?3, 5?
?0, 2?
?3, 5?
?2, 3?aa b aa aa aa bWith this instantiation, S(?0, 5?)
?
A(?0, 2?, ?3, 5?
)B(?2, 3?).
ThenB(b X ) ?
B(X )?2, 3?
?3, 3?
?3, 3?b  15 |w| is the length of the word w; that is, the range ?0, |w|?
with respect to w corresponds to the wholeword w.209Computational Linguistics Volume 31, Number 2and B() ?
 lead to A(?0, 2?, ?3, 5?
)B(?2, 3?)
?
A(?0, 2?, ?3, 5?
)B(?3, 3?)
?
A(?0, 2?,?3, 5?).
Next,A(a X a Y ) ?
A(X , Y )?0, 1?
?1, 2?
?3, 4?
?4, 5?
?1, 2?
?4, 5?a a a a a aleads to A(?0, 2?, ?3, 5?)
?
A(?1, 2?, ?4, 5?).
ThenA(a X a Y ) ?
A(X , Y )?1, 2?
?2, 2?
?4, 5?
?5, 5?
?2, 2?
?5, 5?a  a   and A(,) ?
 lead to A(?1, 2?, ?4, 5?)
?
A(?2, 2?, ?5, 5?)
?
.An RCG is said to be noncombinatorial if each of the arguments in the right-handsides of the clauses are single variables.
It is said to be linear if no variable appears morethan once in the left-hand sides of the clauses and no variable appears more than oncein the right-hand side of the clauses.
It is said to be nonerasing if for each clause, eachvariable occurring in the left-hand side occurs also in the right-hand side and vice versa.It is said to be simple if it is noncombinatorial, linear, and nonerasing.Simple RCGs and LCFRSs are equivalent (Boullier 1998b).4.2 Relation between RSN-MCTAG and Simple RCGThe goal of this section is to construct an equivalent simple RCG for a given RSN-MCTAG.
In order to be able to perform this construction, in the following we furtherconstrain the formalism of RSN-MCTAG by defining RSN-MCTAG of a specific arityn.
For this version of RSN-MCTAG, the construction of an equivalent simple RCG ispossible.First, let us sketch the general idea of the transformation from TAG to RCG (seeBoullier 1998a).
The RCG contains predicates ???
(X) and ???
(L, R) for initial and aux-iliary trees, respectively.
X covers the yield of ?
and all trees added to ?, and L and Rcover those parts of the yield of ?
(including all trees added to ?)
that are to the leftand the right of the foot node of ?.
The clauses in the RCG reduce the argument(s)of these predicates by identifying those parts that come from the elementary tree ?/?itself and those parts that come from one of the elementary trees added by substitutionor adjunction.
A sample TAG with an equivalent RCG is shown in Figure 13.For the construction of an equivalent RCG from a given RSN-MCTAG, we followthe same ideas while considering a secondary adjunction of ?
at some ?
as adjunctionat ?
and not as adjunction at the elementary tree that is the mother node of ?
in theTAG derivation tree.
There are two main differences between RSN-MCTAG and TAGthat influence the construction of an equivalent RCG.First, more than one tree can be added to a node.
Therefore we allow predicatesof the form ??
?1 .
.
.
?k?
and ?
?0?1 .
.
.
?k?.
The first means that at the node in question,first ?
was added by substitution, and then ?1 .
.
.
?k (in this order) were secondarilyadjoined.
The second means that at the node in question (an internal node), first ?0 wasprimarily adjoined, and then ?1 .
.
.
?k were secondarily adjoined.
Since the number ofsecondary adjunctions at a node is limited by some constant depending on the grammar210Kallmeyer Multicomponent TAGs with Shared NodesFigure 13A sample TAG and an equivalent RCG.
(see Lemma 3), k is limited as well, and therefore this extension with respect to TAG addsonly a finite number of predicates.Second, the contribution of an elementary tree ?/?
including the trees addedto it can be separated into arbitrarily many parts.
Since each of the argumentsof the predicates in the RCG has to cover a true substring of the input string,one needs predicates of arbitrary arities, namely, ??
.
.
.?
(Ln, .
.
.
, L1, X, R1, .
.
.
, Rn) and??
.
.
.?
(Ln, .
.
.
, L1, L0, R0, R1, .
.
.
, Rn), for the case where n auxiliary trees were added atthe root of ?/?
that were actually secondarily adjoined at some higher tree such thatthese n trees separate the contribution of ?/?
into 2n + 1 / 2n + 2 parts, respectively.This extension is problematic, since it leads to an RCG with predicates of arbitrary arity:a dynamic RCG (Boullier 2001), a variant of RCG that is not polynomially parsable andthat we therefore want to avoid.
For this reason, we need an additional constraint onthe RSN-MCTAGs we employ.An example in which the contribution of an elementary tree is separated intothree different parts is example (9), analyzed with the RSN-MCTAG in section 3.1(see Figure 14).
In the derived tree, the VP das Fahrrad zu reparieren zu versuchen (thebroken triangles), which is the contribution of versuchen, is separated into three parts,Figure 14Analysis of example (9).211Computational Linguistics Volume 31, Number 2since reparieren secondarily adjoins at versuchen and das Fahrrad secondarily adjoins atreparieren.
(9) .
.
.
dass [das Fahrrad]1 er [t1 zu reparieren]2 dem Kunden [t2 zu versuchen].
.
.
that the bike he to repair the customer to tryversprichtpromisesThe crucial point in example (9) is that in the SN-derivation structure (see Figure 14),there are two crossings of secondary edges inside one group of secondary links.
Thismeans that the contribution of versuchen is interrupted twice by arguments of verspricht(by Kunde and er).
In order to avoid predicates of arbitrary arity, we therefore limitthe number of crossings of secondary links.
We define the arity of an RSN-MCTAGdepending on the maximal number of crossings that are allowed.First, we define special subgraphs of the SN-derivation structure, secondarygroups.
These are subgraphs consisting of a chain of one primary substitu-tion/adjunction and subsequent adjunctions at root or foot nodes such that there aresecondary adjunctions along the whole chain.
For example, the nodes verspricht, zuversuchen, Kunde, zu reparieren, er, and Fahrrad in the SN-derivation structure in Figure 14form such a group.
For an SN-derivation structure of a certain arity, the number ofcrossings of secondary edges inside a single secondary group is then limited: For anSN-derivation structure of arity n, the number of crossings of secondary edges persecondary group is limited to n2 ?
1.
In other words, if i is the maximal number ofcrossings, then 2(i + 1) is the arity of the grammar.
Of course, the arity is chosen suchthat an equivalent RCG of the same arity can be constructed.
TAG, for example, is agrammar with 0 crossings, that is, an arity 2(0 + 1) = 2 if the grammar is viewed as anSN-MCTAG, and the corresponding RCG is actually of arity 2.Definition 9Let DSN = ?N , E?
be a SN-derivation structure.1.
?N ?, E ??
is a secondary group in DSN iff N ?
= {n0, n1, .
.
.
, nk} ?
N for some k > 1 such that there areprimary edges ?ni, ni+1, pi?
for 0 ?
i < k with pi ?
IN; E ?
?
E such that for all n, n?
?
N , p ?
IN with ?n, n?, p?
?
E : ifn, n?
?
N ?, then ?n, n?, p?
?
E ?
; for all i, 0 < i < k, there are i1, i2 with i1 ?
i ?
i2, i1 = i2, such that?ni1 , ni2 , p?
?
E ?
is a secondary edge in D for some p ?
IN.2.
DSN is of arity n iff for each secondary group ?N ?, E ??
in DSN with primaryedges ?n0, n1, p0?, ?n1, n2, p1?, .
.
.
, ?nk?1, nk, pk?1?
as above, there are at mosti ?
n2 ?
1 pairwise different sets of the form {j0, j1, j2, j3} such thatj0 < j1 < j2 < j3 and there are secondary edges ?nj0 , nj2 , p1?
and ?nj1 , nj3 , p2?for some p1, p2 ?
IN.Definition 10Let G be an MCTAG, n ?
1.
G is a restricted tree-local MCTAG with shared nodes ofarity n iff the set of trees generated by G, LT(G), is defined as the set of those trees thatcan be derived in G with an RSN-tree-local multicomponent TAG derivation tree suchthat the corresponding SN-derivation structure is of arity n.212Kallmeyer Multicomponent TAGs with Shared NodesFigure 15Sample RSN-MCTAG of arity four.Consider a simple example of a construction of an equivalent RCG for a givenRSN-MCTAG.
We choose an RSN-MCTAG of arity four, and we see that the arityof the corresponding RCG is four as well.
The RSN-MCTAG is shown in Figure 15.Whether this grammar is considered to be a general RSN-MCTAG or an RSN-MCTAGof arity four does not matter in this case, since even in the general case, all possibleSN-derivation structures are of arity four.
However, in the case of other RSN-MCTAGs,the restriction to a certain arity might exclude certain TAG derivation trees and therebydecrease the language generated by the grammar.The language generated by the RSN-MCTAG in Figure 15 is {er zu kommen (zuversuchen)?
verspricht, zu kommen (zu versuchen)+ er (zu versuchen)?
verspricht}.
The SN-derivation structures corresponding to the different strings are shown in Figure 15.
Thelast one contains one crossing of secondary links; that is, the RSN-MCTAG is of arityfour.Now let us look at the corresponding RCG.
Since the arity of the RSN-MCTAG isfour, the predicates of the corresponding RCG are of arity three (for initial trees) andfour (for auxiliary trees).The contribution of ?1 is never separated into parts, therefore the first and the thirdarguments of the predicate ??1?
are always .
Looking at the SN-derivation structuresin Figure 15, we have three different possibilities for ??1?
:213Computational Linguistics Volume 31, Number 2??1?
(,LN V verspricht R,) ?
??2?(,L,R,)???2?(,N,)??2?
(,V,) |??1?2?(,L,R,)???2?(,N,)???1?
(,V,) |??2?1?(,L,R,)???2?(,N,)???1?
(,V,)The interesting part of the grammar is the clauses for ?
?1?2?, where two trees wereadded to the same node and further adjunctions at the root of ?1 are possible.
The pointis that the part covered by ?1 and the trees added to it can be separated into differentsubstrings.
This leads to??1?2?
(,L1 L2 L3,R3 R2 R1,) ?
??1?(L1,L3,R3,R1)??2?(,L2,R2,)??1?2?
(L1,L2 L3,R3 R2,R1) ?
??1?(L1,L3,R3,R1)??2?(,L2,R2,)??1?2?
(L1 L2,L3,R3,R2 R1) ?
??1?(L1,L3,R3,R1)??2?
(,L2,R2,)Concerning ?
?2?1?, the contribution of ?2 cannot be separated into different parts,since nothing can be adjoined to ?2.
Consequently??2?1?
(,L1 L2,R2 R1,) ?
??2?(,L2,R2,)??1?(,L1,R1,)??2?1?
(L1,L2,R2,R1) ?
??2?(,L2,R2,)??1?
(,L1,R1,)Concerning ??1?
(L1, L3, R3, R1), either (L1, R1) cover something adjoined to ?1 (thiscan only be ?1), or (L1, R1) cover something adjoined to something .
.
.
adjoined to ?1.In this case, (L3, R3) cover ?1 and ?1 adjoined to its root, respectively.
This leads to??1?
(L1,L2 V zu versuchen,R2,R1) ?
??1?(L1,L2,R2,R1)???1?
(,V,)If the inner parts are empty, the outer parts are moved:??1?
(L,,,R) ?
??1?
(,L,R,)Furthermore, there is a clause for ??1?
without adjunction at the root:??1?
(,V zu versuchen,,) ?
??2?
(,V,)For elementary trees where nothing needs to be added, simple -clauses are introduced:??2?
(, zu kommen,) ?
 ???1?
(,,) ?
??2?
(,er,,) ?
 ???2?
(,,) ?
In order to see how the RCG simulates the RSN-MCTAG, let us consider the deriva-tion for zu kommen zu versuchen er zu versuchen verspricht:??1?
(, zu kommen zu versuchen er zu versuchen verspricht,)?
??1?2?
(, zu kommen zu versuchen er zu versuchen,,)???2?(,,)???1?(,,)??
??1?
(zu kommen zu versuchen, zu versuchen,,)??2?(,er,,)??
??1?
(zu kommen zu versuchen,,,)???1?(,,)??
??1?
(, zu kommen zu versuchen,,)?
??2?
(, zu kommen,) ?
214Kallmeyer Multicomponent TAGs with Shared NodesThis example should give an idea of how an equivalent RCG for a given RSN-MCTAGof arity n can be constructed.As already mentioned, in an RSN-MCTAG, the number of substitutions and(primary or secondary) adjunctions that can occur at each node is limited (see Lemma 3).Therefore, the number of predicates needed in the corresponding RCG is limited as well.Furthermore, in an RSN-MCTAG of arity n, the contribution of an elementary tree isseparated into at most n parts.
This still needs to be shown:Lemma 4Let G be an RSN-MCTAG of arity n. Then for all w in the string language of G and forall elementary trees ?
used to derive w in G, the contribution of ?, that is, the yield of ?and everything added to ?, is separated into at most n parts.The proof is given in the appendix.Theorem 1For each RSN-MCTAG G of arity n, a simple RCG G?
of arity n can be constructed suchthat L(G) = L(G?
).The construction algorithm and a sketch of the proof are presented in the appendix.
Asa consequence of this theorem, the following corollary holds:CorollaryFor a given n, the string languages generated by RSN-MCTAGs of arity n are mildlycontext-sensitive, and they are in particular polynomially parsable.Since we have shown that for RSN-MCTAG with a fixed arity, one obtains gram-mars that are LCFRSs, we know that we can even construct a weakly equivalent set-local MCTAG.
This set-local MCTAG, however, does not present an alternative to theRSN-MCTAG with fixed arity: It is very large, containing a large number of elementarytrees per tree set (the number depends on the arity of the grammar) and, furthermore, alarge number of trees without lexical material and a large number of internal nodes thatare needed only to provide adjunction sites.An example is the set-local MCTAG in Figure 16.
It is weakly equivalent to theRSN-MCTAG of arity four in Figure 15, and it even gives the correct dependencystructure.
The verspricht tree contains several VP nodes that are needed in order toprovide adjunction sites for the different parts of er and versuchen.
The versuchen treeset needs an extra auxiliary tree that provides an additional VP node for adjunctionand has to be separated from the tree containing versuchen, since the contributionof versuchen might be separated into different parts.
Of course this little grammaris still simple, since there are almost no possibilities of adjoining different trees atthe same node or of separating the contribution of one lexical item into differentparts.As we have seen in Lemma 4, the linguistic signification of restricting the arityof the grammar to some n is that the lexical material containing a verb, all its argu-ments (including arguments and adjuncts of these arguments, etc.
), and all its adjunctscannot be separated into more than n discontinuous substrings in the whole sentence.For example, an RSN-MCTAG of arity two with elementary tree sets similar to thoseproposed above for scrambling would not be able to analyze example (9).
However,RSN-MCTAGs of arity n for some sufficiently large fixed n can perhaps even describe215Computational Linguistics Volume 31, Number 2Figure 16Equivalent set-local MCTAG for the RSN-MCTAG from Figure 15.all cases of scrambling: See again the analysis of example (9) in Figure 14.
Here, thecontribution of versuchen and its arguments is split only by other elements secondarilyadjoined to verspricht.
If only a limited number of such secondary adjunctions werepossible (this is the case), and if none of these other secondarily adjoined elementsallowed for further secondary adjunctions at its root or foot node (this still needs tobe investigated), then the number of crossings might be limited.
We leave this issue forfurther research.Even if RSN-MCTAG with a fixed arity could not analyze all scrambling data, basedon empirical studies, n could be chosen sufficiently great such that the grammar wouldcover all scrambling cases that one assumes to occur.16 The important point is that thecomplexity limit given by the fixed n is variable; that is, an arbitrary n can be chosen.This is different from TAG, for example, in which the limit is fixed (assuming, of course,that we desire only analyses respecting the CETM).
In this sense one can say that RSN-MCTAG can analyze scrambling in general.5.
Conclusion and Future WorkThis article addresses the problem of scrambling in tree-adjoining grammar, a formalismknown not to be powerful enough to treat scrambling phenomena.
In order to keepthe advantages of TAG while being able to analyze scrambling, a local TAG variant isproposed that is based on the notion of node sharing, so-called (restricted) tree-localmulticomponent TAG with node sharing.
RSN-MCTAG is a true extension of TAG inthe sense that the formalism can generate all tree-adjoining languages.
The analysis ofsome German scrambling data is sketched in order to show that this TAG extension cantreat scrambling.Then, RSN-MCTAGs of specific arities are defined, and it is shown that for eachRSN-MCTAG of a fixed arity n, an equivalent simple RCG of arity n can be constructed.Simple RCGs are mildly context-sensitive and in particular polynomially parsable andtherefore, this also holds for RSN-MCTAGs of a fixed arity.
RSN-MCTAGs of arity nperhaps cannot analyze all scrambling phenomena but, if the n is appropriately chosen,it can analyze an arbitrarily large set.16 Joshi, Becker, and Rambow (2000) even argue that there might be a competence limit regarding thecomplexity of scrambling data.
However, we do not discuss this issue here.216Kallmeyer Multicomponent TAGs with Shared NodesThe scrambling data analyzed in section 3 present just a small part of the possiblescrambling configurations.
As already noted, this article does not present an exhaustivetreatment of the phenomenon.
Even though the examples we looked at indicate thatRSN-MCTAGs are able to deal with scrambling, an exhaustive analysis of a largeramount of data still needs to be done, in particular, of scrambling in combinationwith other ?movements?
that cause word order variations, such as topicalization orextraposition.
A first proposal in this direction can be found in Kallmeyer and Yoon(2004), but this proposal does not cover all phenomena one needs to take into account.So this is still an important issue for further research.A formal issue one would like to see investigated more in detail is the relationsbetween the different types of MCTAG.
We have shown that the languages of RSN-MCTAG with fixed arity are in the class of set-local MCTALs.
Furthermore, generalSN-MCTAG can generate languages that cannot be generated by set-local MCTAG.However, this leaves open many interesting questions concerning the relations be-tween set-local MCTAG and non-local MCTAG and the different formalisms definedin this article, namely, RSN-MCTAG of fixed arity and RSN-MCTAG and MCTAG withSN-tree-local and SN-set-local derivations.
We plan to address these questions in thefuture.Appendix: ProofsProof of Lemma 1Let G = ?I, A, N, T,A?
be an MCTAG, GTAG := ?I, A, N, T?.
Let D = ?N , E?
be a derivationtree in GTAG with corresponding derived tree t ?
L(GTAG).1.
First show ?
of the iff: Let D be a TAG derivation tree with t ?
L(G).
It isimmediate that the root of D is an instance of an initial tree and that all other nodesare elements of instances of elementary tree sets.Assume that either there is an instance ?
of elementary tree sets from A such that thereare ?1,?2 ?
?, with ?1 ?
N and ?2 ?
N , and ?1 is not the root of D. ?
it isnot possible that ?
has been used in one of the multicomponent derivationsteps in the course of the derivation of t. Contradiction. or there is an instance ?
of an elementary tree set such that there are?1,?2 ?
?, ?1 = ?2, with ??1,?2?
?
DD ?
?2 has been added to a treederived from ?1.
Contradiction to condition that all elements of ?
musthave been added simultaneously. or there are pairwise different instances ?1,?2, .
.
.
,?n of elementary treesets from A such that there are ?
(i)1 ,?
(i)2 ?
?i, 1 ?
i ?
n, with??
(1)1 ,?
(n)2 ?
?
DD and ??
(i)1 ,?
(i?1)2 ?
?
DD for 2 ?
i ?
n. ?
?
(i)1 was addedbefore ?
(i?1)2 for 2 ?
i ?
n, and since all elements from ?i must be addedsimutaneously for 1 ?
i ?
n, ?n was added before ?1.
?
??
(1)1 ,?
(n)2 ?
?
DD.Contradiction.Consequently, D satisfies (MC1)?(MC3).2.
Then show ?
of the iff: Let D be a derivation tree in GTAG satisfying (MC1)?
(MC3).217Computational Linguistics Volume 31, Number 2There are different orderings of the derivation steps in D possible: Let the nodepositions on the derived tree be pairs ?
?, p?, with ?
being an instance of an elementarytree and p being a position in ?.
Every top-down order read off D (no matter whether[partly] depth first or not and whether left to right or right to left) is a possible deriva-tion order in GTAG for the derivation tree D, since in order to perform the derivationstep .
.
.
[?
?1, p?,?2] corresponding to an edge ?
?1,?2, p?
in D, one needs only to ensurethat ?1 (i.e., the mother node of ?2) has already been added.Because of (MC1), the root of D is an initial tree, and the set of all other nodes in Dcan be partitioned into pairwise different instances of elementary tree sets.To show: There is a top-down traversal of D such that the traversal starts with aninitial tree and then there is always one instance ?
of an elementary set whose membersare visited next in any order (i.e., simultaneously).The top-down traversal has to start with the root node (i.e., an initial tree ?).
Assumethat at some point of the traversal, the choice of a new instance of an elementary set tobe visited next is not possible.
?
for each set ?
that has not been visited yet, there isat least one ?
?
?
whose mother node has not been visited yet (otherwise ?
could bevisited next).Pick an unvisited ?1 with at least one ?
(1)1 ?
?1 whose mother node has been visited.Assume ?
(1)2 ?
?1 with mother not yet visited.
Suppose ?
(2)1 to be the highest unvisitednode dominating ?
(1)2 .
Since ?
(2)1 = ?
(1)2 and ??
(2)1 ,?
(1)2 ?
?
DD, (with (MC2)) ?
(2)1 ?
?2 =?1.Then there is a ?
(2)2 ?
?2 with unvisited mother such that(a) either ??
(1)1 ,?
(2)2 ?
?
DD.
Contradiction to (MC3) with n = 2.?
(1)1 ?(2)1?
(2)2 ?
(1)2(b) or ??
(1)1 ,?
(2)2 ?
/?
DD.
Because of (MC2), ??
(2)1 ,?
(2)2 ?
/?
DD.
Let ?
(3)1 ?
?3 be thehighest unvisited node dominating ?
(2)2 .
Because of (MC2), ?3 = ?2, andbecause of (MC3), ?3 = ?1.?
(1)1 ?
(2)1 ?(3)1?
(1)2 ?
(2)2In the (b) case, there is a ?
(3)2 ?
?3 with unvisited mother node.
Because of (MC2)and (MC3), ??
(1)1 ,?
(3)2 ?
/?
DD, ??
(2)1 ,?
(3)2 ?
/?
DD, and ??
(3)1 ,?
(3)2 ?
/?
DD.
Then there is a high-est unvisited node ?
(4)1 ?
?4 dominating ?
(3)2 with ?4 = ?3,?4 = ?2, and ?4 = ?1.
Andthere is a ?
(4)2 ?
?4 with unvisited mother node.In general, for each of the ?n, 1 ?
n, with ?
(n)1 ,?
(n)2 as above, the situation isas follows: ?n = ?i for 1 ?
i < n (otherwise contradiction to (MC2) or (MC3)) and??
(i)1 ,?
(n)2 ?
/?
DD for i ?
n (otherwise contradiction to (MC2) for i = n or to (MC3)218Kallmeyer Multicomponent TAGs with Shared Nodesfor i = n).
Consequently, there is always a new ?n+1, with a new ?
(n+1)1 being thehighest unvisited node dominating ?
(n)2 and ?
(n+1)2 being a node with unvisitedmother.?
(1)1 ?
(2)1 ?
(n)1 ?(n+1)1?
(1)2 .
.
.
?
(n?1)2 ?
(n)2Contradiction to the finiteness of the number of nodes in D. ?
there is a top-downtraversal of D that corresponds to a multicomponent derivation in G in the sense that itallows us to visit the instances of elementary tree sets one after the other.
Proof of Lemma 2Only the uniqueness needs to be shown.Let G = ?I, A, N, T,A?
be an RSN-MCTAG.
Let D = ?N , E?
be a TAG derivation treein G.Assume that there is an instance {?1, .
.
.
,?n} of an elementary tree set such thatthere are ?,??
with ?
= ??
and ?
?,?1?, .
.
.
, ?
?,?n?, ??
?,?1?, .
.
.
, ???,?n?
?
SND and thereare i, j, 1 ?
i, j ?
n with ?
?,?i?, ???,?j?
?
PD.?
since ???,?j?
?
PD and ??,?j?
?
DD with ?
= ?j, there is a ???
with ??,????
?
PDand ????,???
?
DD.
Furthermore, ??i,????
/?
DD (otherwise ??i,?j?
?
DD which wouldcontradict (MC2)) and ????,?i?
/?
DD (otherwise, since ?i = ??
?, ??,?i?
/?
PD).
Conse-quently ???,?i?
/?
DD.
Contradiction to assumption.
Proof of Lemma 4Let G be an RSN-MCTAG of arity n, w ?
L(G), such that the elementary tree ?
was usedto derive w. Assume that the contribution of ?
is separated into m > n parts.Then the SN-derivation structure for this derivation is as shown in Figure 17.Consequently, there are at least m2 ?
1 crossings, and the arity of G is (m2 ?
1+1) ?
2. ?
if m is even, G is of arity m, and if m is odd, G is of arity m + 1.
This is acontradiction to the assumption that the arity of G is n < m. Proof of Theorem 1For reasons of space, we do not give the whole proof of the theorem but re-strict ourselves to the construction algorithm and a rough outline of the rest of theproof.Construction algorithm.
Let G be an RSN-MCTAG of arity n.Construction of a weakly equivalent RCG G?
:The terminals and nonterminals will be implicitly defined by the clauses of thegrammar.Predicates: Let k1 be the maximal number of nodes in an elementary tree in G andk2 be the maximal number of trees in an elementary tree set.
k := k1(k2 ?
1).219Computational Linguistics Volume 31, Number 2Figure 17SN-derivation structure for proof of Lemma 4. There is a unary predicate S. Each ???
and each ??
?1 ?
?
?
?l?, with l < k, ?
an initial tree, and ?1, .
.
.
,?lauxiliary trees is an n ?
1-ary predicate. Each ???
and each ??
?1 ?
?
??l?
with l < k and ?,?1, .
.
.
,?l auxiliary trees isan n-ary predicate.Define the decoration string ??
of an elementary tree ?
as in Boullier (1999), exceptthat a root node ?
has n variables, L?1 .
.
.
L?
n2 on the left and R?
n2 .
.
.R?1 on the right.Every other internal node ?
has two variables L?
and R?, and each substitution nodehas one variable X.
In a top-down, left-to-right traversal, the left variables are collectedduring the top-down traversal, the terminals and variables of substitution nodes arecollected while visiting the leaves, and the right variables are collected during bottom-up traversal.Construction of the clauses:In the following, P(, .
.
.
,, x,, .
.
.
,) signifies that x is the n2 th argument,and P(, .
.
.
,, x1, x2,, .
.
.
,) signifies that x1 is the n2 th and x2 the (n2 + 1)thargument.220Kallmeyer Multicomponent TAGs with Shared Nodes(1) Predicate SFor each initial ?, there is a clauseS(X ) ?
???
(, .
.
.
,,X,, .
.
.
,)(2) Predicates ??
?For each elementary ?
: lhs := ?
?, rhs := .For each combination of substitutions and adjunctions at ?, with substitutions at allsubstitution nodes and adjunctions at all internal nodes, with obligatory adjunction thatrespects the conditions for restricted tree-local multicomponent derivation:For all nodes ?
in ?
: If ?
is an internal node that is not the root, and no adjunction takes place at?, then delete L?
and R?
in lhs. If ?
is the root node and no adjunction takes place at ?, then deleteL?1 ?
?
?
L?
n2 and R?
n2 ?
?
?R?1 in lhs. If only the initial tree ?
is substituted at ?,rhs := ???
(, .
.
.
,, S?,, .
.
.
,)rhs. If ?
is substituted at ?
and then ?1, .
.
.
,?m (in that order) are secondarilyadjoined at ?, then rhs := ??
?1 ?
?
??m?
(, .
.
.
,, S?,, .
.
.
,)rhs. If ?
is an internal node that is not the root and ?1, .
.
.
,?m are adjoined (inthat order) at ?, then rhs := ?
?1 ?
?
??m?
(, .
.
.
,, L?, R?,, .
.
.
,)rhs.If there is no adjunction at the root of ?, there is a clause???
(, .
.
.
,, lhs,, .
.
.
,) ?
rhsIf ?1, .
.
.
,?m are adjoined in this order at the root of ?, and if L1, .
.
.
, L n2 , R n2 , .
.
.
, R1are the parts of the root in lhs such that lhs = L1 ?
?
?
L n2 lhs?R n2?
?
?R1, then there is aclause???
(L1, .
.
.
,Ln2?1,Ln2 lhs?Rn2,Rn2?1, .
.
.
,R1) ??
?1 ?
?
??m?
(L1, .
.
.
,Ln2 ,Rn2 , .
.
.
,R1)rhsFurther, for each initial ?
and for all i, 1 ?
i ?
n2 ?
2 , there are clauses???
(L1, .
.
.
,Li ,,Li+1, .
.
.
,Ln2?2,X,Rn2?2, .
.
.
,Ri+1,,Ri , .
.
.
,R1) ????
(,L1, .
.
.
,Ln2?2,X,Rn2?2, .
.
.
,R1,)And for each auxiliary ?
and for all i, 1 ?
i ?
n2 ?
1 , there are clauses???
(L1, .
.
.
,Li ,,Li+1, .
.
.
,Ln2?1,Rn2?1, .
.
.
,Ri+1,,Ri , .
.
.
,R1) ????
(,L1, .
.
.
,Ln2?1,Rn2?1, .
.
.
,R1,)221Computational Linguistics Volume 31, Number 2(3) Predicates ?
?1?2 ?
?
?
?m?For each ?
?1?2 ?
?
??m?
with m ?
2 occurring in the clauses constructed so far:Define sets of variablesL := {L1(?1), .
.
.
,Ln2 (?1),L1(?2), .
.
.
,Ln2 (?m )}, andR := {R1(?1), .
.
.
,Rn2 (?1),R1(?2), .
.
.
,Rn2 (?m )}, andthree other pairwise different variables X1,X2,X /?
L?R.Define for all x ?
L?
: R(x) := y ?
R?
such that if Lj(?i) is the kth letter of x, then Rj(?i)is the (|x| ?
k + 1)th letter of y.For all w ?
L?
such that(a) each L ?
L occurs exactly once in w,(b) for all 1 ?
i1 < i2 ?
m, L n2 (?i1 ) is to the right of L n2 (?i2 ) in w, and(c) for all 1 ?
i ?
m and 1 ?
j1 < j2 ?
n2 , Lj1 (?i) is to the left of Lj2 (?i) in w,and for all x1, .
.
.
, x n2 ?
L?
with x1 ?
?
?
x n2 = w,there is the following clause:If ?1 is an initial tree, a clause with L n2 (?1) eliminated from the x1, .
.
.
, x n2 :?
?1 ?
?
??m?
(x1, .
.
.
, x n2 X R(x n2 ), .
.
.
,R(x1)) ???1?
(L1(?1), .
.
.
,Ln2?1(?1),X,Rn2?1(?1), .
.
.
,R1(?1))??2?
(L1(?2), .
.
.
,Ln2 (?2),Rn2 (?2), .
.
.
,R1(?2))...??m?
(L1(?m ), .
.
.
,Ln2 (?m ),Rn2 (?m ), .
.
.
,R1(?m ))If ?1 is an auxiliary tree, a clause?
?1 ?
?
??m?
(x1, .
.
.
, x n2 ,R(x n2 ), .
.
.
,R(x1)) ???1?
(L1(?1), .
.
.
,Ln2 (?1),Rn2 (?1), .
.
.
,R1(?1))...??m?
(L1(?m ), .
.
.
,Ln2 (?m ),Rn2 (?m ), .
.
.
,R1(?m ))(4) These are all clauses.Sketch of Proof.
We do not give the whole proof of the correctness of the construction,but we sketch the principal steps:Mainly, two lemmas, concerning, respectively, the clauses constructed under para-graph 2 above and under paragraph 3 above, are shown:Lemma 5For each elementary tree ?
in G with decoration string ??
as defined above:There is a ??
derived from ?
with yield w (if ?
is an initial tree) or ?wl, wr?
(if ?
is anauxiliary tree with wl on the left and wr on the right of the foot node) such that all leaves in ??
have terminal labels; there are no OA constraints in ??
;222Kallmeyer Multicomponent TAGs with Shared Nodes for all node positions p in ?
at which substitutions or adjunctions tookplace, the elementary trees ?
(p)1 ,?
(p)1 , .
.
.
,?
(p)m (in that order) weresubstituted/adjoined at the node at position p in ?
(these are all treesattached to this node).iffThere is a ??
?-clause in G?
corresponding to the attachments to ?
in this derivation inthe way described in the construction, with ??
being the decoration string of ?
withoutthe symbols for the nodes to which nothing was attached such thatThere is an instantiation f : {t?
| t?
is an occurrence of some t ?
T in ??}
?
V ?
{?i, j?
| 0 ?
i ?
j ?
|w|} as defined in Definition 8, and the following hold for f : For each substitution node ?
in ?
with position p, the yield of the trees?
(p)1 ,?
(p)1 , .
.
.
,?
(p)m and everything added to them is the connected substringf (S?
), even if the derivation of ??
from ?
is part of a larger derivation. For each internal node ?
in ?
with position p at which adjunctions tookplace, the yield of the trees ?
(p)1 ,?
(p)1 , .
.
.
,?
(p)m consists of the two connectedsubstrings ?
f (L?
), f (R?
)?, even if the derivation of ??
from ?
is part of alarger derivation. If adjunctions at the root took place, then the yield of the trees?
(p)1 ,?
(p)1 , .
.
.
,?
(p)m consists of the substrings ?
f (L1) f (L2) ?
?
?
f (L n2 ),f (R n2) ?
?
?
f (R1)?, and this yield can be disconnected if the derivation of ?
?from ?
is part of a larger derivation; it can be separated into disconnectedsubstrings f (L1), f (L2), .
.
.
, f (L n2 ), f (R n2 ), .
.
.
, f (R1).Proof by induction on structure of ?.Lemma 6For all ?1,?2, .
.
.
,?m:There is a derivation in G of a tree with yield w in which ?1,?2, .
.
.
,?m (in thatorder) attach to some node ?
in an elementary tree ?
such that the yield of the trees?1,?2, .
.
.
,?m is separated into at most n disconnected substrings (ranges) of w. If ?1is an auxiliary tree, it is separated into the substrings l1, .
.
.
, l n2 , r n2 , .
.
.
, r1; otherwise(?1 initial), the substrings are l1, .
.
.
, l n2 ?1, x, r n2 ?1, .
.
.
, r1.iffThere is a ?
?1?2 ?
?
?
?m?-clause as described in paragraph 3 of the construction abovesuch that there is an instantiation f of the clause such that If ?1 is initial, then f (x1) = l1, .
.
.
, f (x n2 ?1) = l n2 ?1, f (x n2 XR(x n2 )) =x, f (R(x n2 ?1)) = r n2 ?1, .
.
.
, f (R(x1)) = r1, and if ?1 is auxiliary, thenf (x1) = l1, .
.
.
, f (x n2 ) = l n2 1, f (R(x n2 )) = r n2 , .
.
.
, f (R(x1)) = r1. If ?1 is initial, then its yield in w consists of the n ?
1 substrings (ranges)f (L1(?1)), .
.
.
, f (L n2 ?1(?1)), f (X), f (R n2 ?1(?1)), .
.
.
, f (R1(?1)). For all auxiliary ?i, 1 ?
i ?
m, the yield of ?i in w consists of the nsubstrings (ranges) f (L1(?i)), .
.
.
, f (L n2 (?i)), f (R n2 (?i)), .
.
.
, f (R1(?i)).Proof by induction on m.The whole theorem can then be proven using these two lemmas.223Computational Linguistics Volume 31, Number 2AcknowledgmentsFor valuable suggestions, helpful commentsand fruitful discussions of the subject of thisarticle, we would like to thank Anne Abeille?,Pierre Boullier, David Chiang, Eric de laClergerie, Chung-Hye Han, Aravind Joshi,Tony Kroch, Seth Kulick, Maribel Romeroand SinWon Yoon.
Furthermore, we are reallygrateful to three anonymous reviewers whogave many very helpful comments and whosesuggestions for improvements influencedconsiderably the final form of the article.ReferencesBecker, Tilman, Aravind K. Joshi, and OwenRambow.
1991.
Long-distance scramblingand tree adjoining grammars.
InProceedings of ACL-Europe, Berlin.Becker, Tilman, Owen Rambow, and MichaelNiv.
1992.
The derivational generativepower of formal systems, or Scrambling isbeyond LCFRS.
Technical ReportIRCS-92-38, Institute for Research inCognitive Science, University ofPennsylvania.Bertsch, Eberhard and Mark-Jan Nederhof.2001.
On the complexity of someextensions of RCG parsing.
In Proceedingsof the Seventh International Workshop onParsing Technologies, pages 66?77, Beijing,October.Boullier, Pierre.
1998a.
A generalization ofmildly context-sensitive formalisms.
InProceedings of the Fourth InternationalWorkshop on Tree Adjoining Grammars andRelated Formalisms (TAG+4), pages 17?20,University of Pennsylvania, Philadelphia.Boullier, Pierre.
1998b.
A proposal for anatural language processing syntacticbackbone.
Technical Report 3342, InstitutNational de Recherche en Informatique eten Automatique (INRIA) Rocquencourt.Boullier, Pierre.
1999.
On TAG parsing.
InProceedings of TALN 99: Sixie`me Confe?renceAnnuelle sur le Traitement Automatique desLangues Naturelles, pages 75?84, Carge`se,Corse, July.Boullier, Pierre.
2000.
Range concatenationgrammars.
In Proceedings of the SixthInternational Workshop on ParsingTechnologies (IWPT2000), pages 53?64,Trento, Italy, February.Boullier, Pierre.
2001.
From contextualgrammars to range concatenationgrammars.
In Proceedings of the SixthConference on Formal Grammar and SeventhConference on Mathematics of Language(FG/MOL?01), Helsinki, August.Candito, Marie-He?le`ne and Sylvain Kahane.1998.
Can the TAG derivation treerepresent a semantic graph?
An answer inthe light of meaning-text theory.
InProceedings of the Fourth InternationalWorkshop on Tree Adjoining Grammars andRelated Formalisms, IRCS Report 98?12,pages 25?28, University of Pennsylvania,Philadelphia.Dras, Mark, David Chiang, and WilliamSchuler.
2004.
On relations of constituencyand dependency grammars.
Research onLanguage and Computation, 2(2):281?305.Frank, Robert.
1992.
Syntactic Locality and TreeAdjoining Grammar: Grammatical,Acquisition and Processing Perspectives.Ph.D.
thesis, University of Pennsylvania.Frank, Robert.
2002.
Phrase StructureComposition and Syntactic Dependencies.MIT Press, Cambridge, MA.Gerdes, Kim.
2002.
Topologie et grammairesformelles de l?allemand.
Ph.D. thesis,Universite?
Paris 7.Joshi, Aravind K. 1985.
Tree adjoininggrammars: How much context sensitivityis required ro provide reasonablestructural descriptions?
In D. Dowty,L.
Karttunen, and A. Zwicky, editors,Narural Language Parsing.
CambridgeUniversity Press, Cambridge, pages206?250.Joshi, Aravind K. 1987.
An introduction totree adjoining grammars.
InA.
Manaster-Ramer, editor, Mathematics ofLanguage.
John Benjamins, Amsterdam,pages 87?114.Joshi, Aravind K., Tilman Becker, and OwenRambow.
2000.
Complexity of scrambling:A new twist to the competence/performance distinction.
In Anne Abeille?and Owen Rambow, editors, Tree AdjoiningGrammars: Formalisms, Linguistic Analysesand Processing.
Center for the Study ofLanguage and Information (CSLI)Publications, Stanford, CA, pages 167?181.Joshi, Aravind K., Leon S. Levy, and MasakoTakahashi.
1975.
Tree adjunct grammars.Journal of Computer and System Science,10:136?163.Joshi, Aravind K. and Yves Schabes.
1997.Tree-adjoining grammars.
In G. Rozenbergand A. Salomaa, editors, Handbook ofFormal Languages.
Springer, Berlin, pages69?123.Joshi, Aravind K. and K. Vijay-Shanker.
1999.Compositional semantics with lexicalizedtree-adjoining grammar (LTAG): Howmuch underspecification is necessary?
InH.
C. Blunt and E. G. C. Thijsse, editors,224Kallmeyer Multicomponent TAGs with Shared NodesProceedings of the Third InternationalWorkshop on Computational Semantics(IWCS-3), pages 131?145, Tilburg, TheNetherlands.Kallmeyer, Laura.
2001.
Local treedescription grammars: A local extension ofTAG allowing underspecified dominancerelations.
Grammars, 4:85?137.Kallmeyer, Laura.
2002.
Using an enrichedTAG derivation structure as basis forsemantics.
In Proceedings of TAG+6Workshop, pages 127?136, Venice,May.Kallmeyer, Laura and Aravind K. Joshi.
2003.Factoring predicate argument and scopesemantics: Underspecified semantics withLTAG.
Research on Language andComputation, 1(1?2):3?58.Kallmeyer, Laura and Sinwon Yoon.
2004.Tree-local MCTAG with shared nodes:Word order variation in German andKorean.
In Proceedings of TAG+7,Vancouver.Kulick, Seth Norman.
2000.
ConstrainingNon-local Dependencies in Tree AdjoiningGrammar: Computational and LinguisticPerspectives.
Ph.D. thesis, University ofPennsylvania.Rambow, Owen.
1994a.
Formal andComputational Aspects of Natural LanguageSyntax.
Ph.D. thesis, University ofPennsylvania.Rambow, Owen.
1994b.
Multiset-valuedlinear index grammars: Imposingdominance constraints on derivations.In Proceedings of ACL, Las Cruces,NM.Rambow, Owen and Young-Suk Lee.
1994.Word order variation and tree-adjoininggrammars.
Computational Intelligence,10(4):386?400.Rambow, Owen, K. Vijay-Shanker, andDavid Weir.
1995.
D-tree grammars.
InProceedings of ACL, Cambridge, MA.Rambow, Owen, K. Vijay-Shanker, andDavid Weir.
2001.
D-tree substitutiongrammars.
Computational Linguistics,27(1):87?121.Rogers, James.
1994.
Studies in the Logic ofTrees with Applications to GrammarFormalisms.
Ph.D. thesis, University ofDelaware.Schabes, Yves.
1990.
Mathematical andComputational Aspects of LexicalizedGrammars.
Ph.D. thesis, University ofPennsylvania.Schabes, Yves and Stuart M. Shieber.
1994.An alternative conception of tree-adjoiningderivation.
Computational Linguistics,20(1):91?124.Vijay-Shanker, K. 1987.
A Study of TreeAdjoining Grammars.
Ph.D. thesis,University of Pennsylvania.Vijay-Shanker, K. 1992.
Using descriptions oftrees in a tree adjoining grammar.Computational Linguistics, 18(4):481?517.Vijay-Shanker, K. and Aravind K. Joshi.
1988.Feature structures based tree adjoininggrammar.
In Proceedings of COLING, pages714?719, Budapest.Weir, David J.
1988.
Characterizing mildlycontext-sensitive grammar formalisms.
Ph.D.thesis, University of Pennsylvania.XTAG Research Group.
1998.
A lexicalizedtree adjoining grammar for English.Technical Report IRCS 98-18, Institute forResearch in Cognitive Science, Universityof Pennsylvania.225
