Memoizat ion  o f  Corout ined  Const ra in tsMark JohnsonCognitive and Linguistic Sciences, Box 1978Brown UniversityProvidence, l~I 02912, USAMark_Johnson~Brown.eduJ ochen  DSr re*Institut fiir maschinelle SprachverarbeitungUniversit~it StuttgartD-70174 Stuttgart, GermanyJochen.Doerre~ims.uni-stuttgart.deAbstractSome linguistic constraints cannot be effec-tively resolved during parsing at the loca-tion in which they are most naturally intro-duced.
This paper shows how constraintscan be propagated in a memoizing parser(such as a chart parser) in much the sameway that variable bindings are, providing ageneral treatment of constraint coroutiningin memoization.
Prolog code for a sim-ple application of our technique to Boumaand van Noord's (1994) categorial gram-mar analysis of Dutch is provided.1 IntroductionAs the examples discussed below show, some lin-guistic constraints cannot be effectively resolved u-ring parsing at the location in which they are mostnaturally introduced.
In a backtracking parser, anatural way of dealing with such constraints is tocoroutine them with the other parsing processes, re-ducing them only when the parse tree is sufficientlyinstantiated so that they can be deterministicallyresolved.
Such parsers are particularly easy to im-plement in extended versions of Prolog (such as Pro-loglI, SICStus Prolog and Eclipse) which have suchcoroutining facilities built-in.
Like all backtrackingparsers, they can exhibit non-termination and expo-nential parse times in situations where memoizingparsers (such as chart parsers) can terminate in po-lynomial time.
Unfortunately, the coroutining ap-proach, which requires that constraints hare varia-bles in order to communicate, seems to be incompa-tible with standard memoization techniques, which*This research was largely conducted at the Institutffir maschinelle Sprachverarbeitung in Stuttgart.
Wewould like to thank Andreas Eisele, Pascal van Hen-tenryck, Martin Kay, Fernando Pereira, Edward Stablerand our colleagues at the Institut ffir maschinelle Sprach-verarbeitung for helpful comments and suggestions.
Allremain ing errors are our own.
The  Prolog code presen-ted in this  paper  is available via anonymous ftp fromIx.cog.brown.edu as/pub/lernrna.tar.Zrequire systematic variable-renaming (i.e., copying)in order to avoid spurious variable binding.For generality, conciseness and precision, we for-malize our approach to memoization and constraintswithin H6hfeld and Smolka's (1988) general theoryof Constraint Logic Programming (CLP), but wediscuss how our method can be applied to mote stan-dard chart parsing as well.
This paper extends ourprevious work reported in DSrre (1993) and John-son (1993) by generalizing those methods to arbi-trary constraint systems (including feature-structureconstraints), even though for reasons of space suchsystems are not discussed here.2 Lex ica l  ru les  in Categor ia lGrammarThis section reviews Bouma and van Noord's (1994)(BN henceforth) constraint-based categorial gram-mar analysis of modification in Dutch, which we useas our primary example in this paper.
However,the memoizing CLP interpreter presented below hasalso been applied to GB and HPSG parsing, both ofwhich benefit from constraint coroutining in parsing.BN can explain a number of puzzling scope phe-nomena by proposing that heads (specifically, verbs)subcategorize for adjuncts as well as arguments (rat-her than allowing adjuncts to subcategorize for thearguments they modify, as is standard in CategorialGrammar).
For example, the first reading of theDutch sentence(1) Frits opzettelijk Marie lijkt te ontwijkendeliberately seems avoid'Fritz deliberately seems to avoid Marie''Fritz seems to deliberately avoid Marie'is obtained by the analysis depicted in Figure 1.
Theother reading of this sentence is produced by a de-rivation in which the adjunct addition rule 'A' addsan adjunct to lijkt re, and applies vacuously to ont-wijken.It is easy to formalize this kind of grammar in pureProlog.
In order to simplify the presentation of theproof procedure interpreter below, we write clauses100Marieopzettelijk NP2 VPI\ADV\NP2lijkt teVPt/VP.___.__.___~I A ontwijken(VPI\ADV\ VPI"/yP1pI\ADV\NP2)NP2)/D(V D v(V~NP2)VP'\NP2 AFrits ADV VPt\ADVNP1 VP1Figure 1: The BN analysis of (1).
In this derivation 'VPI' abbreviates 'S\NPI', 'A' is a lexieal rule whichadds adjuncts to verbs, 'D' is a lexical 'division' rule which enables a control or raising verb to combine witharguments of higher arity, and 'D' is a unary modal operator which diacritically marks infinitival verbs.as 'H : : -  B' where H is an atom (the head) and Bis a list of atoms (the negative literals).The atom x(Cat, Left, Right) is true iff the sub-string between the two string positions Left andRight can be analyzed as belonging to category Cat.
(As is standard, we use suffixes of the input stringfor string positions).The modal operator '~' is used to diacriticallymark untensed verbs (e.g., ontwijken), and preventthem from combining with their arguments.
Thusuntensed verbs must combine with other verbs whichsubcategorize for them (e.g., lijkt re), forcing allverbs to appear in a 'verb cluster' at the end of aclause.For simplicity we have not provided a semanticshere, but it is easy to add a 'semantic interpretation'as a fourth argument in the usual manner.
The for-ward and backward application rules are specified asclauses of x/3.
Note that the application rules areleft-recursive, so a top-down parser will in generalfail to terminate with such a grammar.
: -  op(990, x fx ,  : : -  ) .
: -  op(400, y fx ,  \ ) .
: -  op(300, fy ,  # ).X Clause operatorX Backward combinatorX Modal operator b'x(X, Left ,  Right) : : -  \[ ~ Forward applicationx(X/Y, Left ,  Mid),x(Y, Mid, Right) \ ] .x(X, Left ,  Right) : : -  \[ ~ Backward applicationx(Y, Left ,  Mid),x(X\Y, Mid, Right) \ ] .x(I, \[Word\[Words\], Words) ::- \[lex(Word, X) \ ] .Lexical entries are formalized using a two place re-lation lex(W0rd, Cat), which is true if Cat is a ca-tegory that the lexicon assigns to Word.lex('Frits', np) ::- ~.lex('Marie', np) ::- \[\].l ex (opzet te l i j k ,  adv) : : -  D.lex(ont2i jken,  #I ) : : -  \[add_adjunots(s~np~np, I ) \].lex(lijkt_te, I / #Y ) ::- \[add_adjuncts( (s \np) / (s \np) ,  IO),division(IO, I/Y ) \].The add_adjuncts/2 and d iv i s ion /2  predicatesformalize the lexical rules 'A' (which adds adjunctsto verbs) and 'D' (the division rule).add_adjuncts(s, ) : : -  ~ .add_adjuncts(I ,  Y\adv) : : -  \[add_adjuncts(I, Y) \].add_adjuncts(I\?, Y\A) ::- \[add_adjuncts(X, Y) \].add_adjuncts(I/A, T/A) ::- \[add_adjunc~s(l, T) 3.d iv i s ion( I ,  I )  : : -  \[\].division(XO/YO, (I\Z)/(Y\Z)) ::- \[division(IO/YO, I/Y) \].Note that the definitions of add_adjuncSs/2 anddivision/2 are recursive, and have an infinite num-ber of solutions when only their first arguments areinstantiated.
This is necessary because the num-ber of adjuncts that can be associated with anygiven verb is unbounded.
Thus it is infeasibleto enumerate all of the categories that could beassociated with a verb when it is retrieved fromthe lexicon, so following BN, we treat the predica-tes add_ad j lmcts /2  and d iv i s ion /2  as coroutinedconstraints which are only resolved when their se-cond arguments become sufficiently instantiated.As noted above, this kind of constraint corouti-ning is built-in to a number of Prolog implemen-tations.
Unfortunately, the left recursion inherentin the combinatory rules mentioned earlier doomsany standard backtracking top-down parser to non-termination, o matter how coroutining is applied to101the lexical constraints.
As is well-known, memoizingparsers do not suffer from this deficiency, and wepresent a memoizing interpreter below which doesterminate.3 The  Lemma Tab le  proo f  p rocedureThis section presents a coroutining, memoizing CLPproof procedure.
The basic intuition behind our ap-proach is quite natural in a CLP setting like the oneof HShfeld and Smolka, which we sketch now.A program is a set of definite clauses of the formp(x) ql(Xl) ^ .
.
.
^  q.(X.)
^  ?where the Xi are vectors of variables, p(X)  andqi(Xi) are relational atoms and ?
is a basic cons-traint coming from a basic constraint language C. ?~will typically refer to some (or all) of the variablesmentioned.
The language of basic constraints i clo-sed under conjunction and comes with (computable)notions of consistency (of a constraint) and entail-ment (?1 ~c ?2) which have to be invariant undervariable renaming} Given a program P and a goalG, which is a conjunction of relational atoms andconstraints, a P-answer of G is defined as a consi-stent basic constraint ?
such that ?
--+ G is valid inevery model of P. SLD-resolution is generalized inthis setting by performing resolution only on rela-tional atoms and simplifying (conjunctions of) basicconstraints thus collected in the goal list.
When fi-nally only a consistent basic constraint remains, thisis an answer constraint ?.
Observe that this use ofbasic constraints generalizes the use of substitutionsin ordinary logic programming and the (simplifica-tion of a) conjunction of constraints generalizes uni-fication.
Actually, pure Prolog can be viewed as asyntactically sugared variant of such a CLP languagewith equality constraints as basic constraints, wherea standard Prolog clausep(T) ~- ql (T,) , .
.
.
,  qn (T,)is seen as an abbreviation for a clause in whichthe equality constraints have been made explicit bymeans of new variables and new equalitiesp(X) ,--- X=T,  X I - -T , , .
.
.
,Xn=T, ,q,(x,,).Here the Xl are vectors of variables and the T/ arevectors of terms.Now consider a standard memoizing proof proce-dure such as Earley Deduction (Pereira and War-ren 1983) or the memoizing procedures describedby Tamaki and Sato (1986), Vieille (1989) or War-ren (1992) from this perspective.
Each memoizedgoal is associated with a set of bindings for its ar-guments; so in CLP terms each memoized goal is a1This essentially means that basic constraints can berecast as first-order predicates.conjunction of a single relational atom and zero ormore equality constraints.
A completed (i.e., ato-mic) clause p(T) with an instantiated argument Tabbreviates the non-atomic clause p(X) ~ X - T,where the equality constraint makes the instantia-tion specific.
Such equality constraints are 'inheri-ted' via resolution by any clause that resolves withthe completed clause.In the CLP perspective, variable-binding or equa-lity constraints have no special status; informally,all constraints can be treated in the same way thatpure Prolog treats equality constraints.
This is thecentral insight behind the Lemma Table proof proce-dure: general constraints are permitted to propagateinto and out of subcomputations i  the same waythat Earley Deduction propagates variable bindings.Thus the Lemma Table proof procedure generalizesEarley Deduction in the following ways:1.
Memoized goals are in general conjunctions ofrelational atoms and constraints.
This allowsconstraints to be passed into a memoized sub-computation.We do not use this capability in the categorialgrammar example (except to pass in variablebindings), but it is important in GB and HPSGparsing applications.
For example, memoizedgoals in our GB parser consist of conjunctionsof X' and ECP constraints.
Because the X'phrase-structure rules freely permit empty ca-tegories every string has infinitely many well-formed analyses that satisfy the X' constraints,but the conjoined ECP constraint rules out allbut a very few of these empty nodes.2.
Completed clauses can contain arbitrary ne-gative literals (rather than just equality cons-traints, as in Earley Deduction).
This allowsconstraints o be passed out ofa memoized sub-computation.In the categorial grammar example, theadd_adjuncts/2 and d iv i s ion /2  associatedwith a lexical entry cannot be finitely resolved,as noted above, so e.g., a clausex(#X, \[onl:wijken\], r-I) : : -\[ add_adjuncl ;s(s\np\np,  Z ) \] ..is classified as a completed clause; theadd_adjuncts/2 constraint in its body is inhe-rited by any clause which uses this lemma.Subgoals can be selected in any order (EarleyDeduction always selects goals in left-to-rightorder).
This allows constraint eoroutining wi-thin a memoized subcomputation.In the categorial grammar example, a cate-gory becomes more instantiated when it com-bines with arguments, allowing eventually theadd_adjuncts/2 and d iv is ion /2  to be deter-ministically resolved.
Thus we use the flexibility102in the selection of goals to run constraints whe-never their arguments are sufficiently instantia-ted, and delay them otherwise.4.
Memoization can be selectively applied (EarleyDeduction memoizes every computational step).This can significantly improve overall efficiency.In the categorial grammar example only x/3goals are memoized (and thus only these goalsincur the cost of table management).The 'abstraction' step, which is used in most me-moizing systems (including complex feature gram-mar chart parsers where it is somewhat confusinglycalled 'restriction', as in Shieber 1985), receives anelegant reatment in a CLP approach; an 'abstrac-ted' goal is merely one in which not all of the equalityconstraints associated with the variables appearingin the goal are selected with that goal.
2For example, because of the backward applicationrule and the left-to-right evaluation our parser uses,eventually it will search at every left string positionfor an uninstantiated category (the variable Y in theclause), we might as well abstract all memoized goalsof the form x(C, L, R) to x(_, L, _), i.e., goals in whichthe category and right string position are uninstan-tinted.
Making the equality constraints explicit, wesee that the abstracted goal is obtained by merelyselecting the underlined subset of these below:x(Xl,X2, X3),Xl = C, X2 = L, Xa = R.While our formal presentation does not discuss ab-straction (since it can be implemented in terms ofconstraint selection as just described), because ourimplementation uses the underlying Prolog's unifi-cation mechanism to solve equality constraints overterms, it provides an explicit abstraction operation.Now we turn to the specification of the algorithmitself, beginning with the basic computational enti-ties it uses.Def in i t ion  1 A (generalized) goal is a multiset ofrelational atoms and constraints.
A (generalized)clause Ho 4-- Bo is an ordered pair of generalizedgoals, where /fro contains at least one relationalatom.
A relational interpretation .4 (see HShfeldand Smolka 1988 for definition) satisfies a goal G iff.A satisfies each element of G, and it satisfies a clauseH0 *--- B0 iff either .A fails to satisfy some element ofB0 or .A satisfies each element of H0.2After this paper was accepted, we discovered that amore general formulation of abstraction is required forsystems using a hierarchy of types, such as typed featurestructure constraints (Carpenter 1992).
In applicationsof the Lemma Table Proof Procedure to such systems itmay be desirable to abstract from a 'strong' type cons-tralnt in the body of a clause to a logically 'weaker' typeconstraint in the memoized goal.
Such a form of ab-straction cannot be implemented using the selection rulealone.This generalizes the standard notion of clause byallowing the head H0 to consist of more than oneatom.
The head H0 is interpreted conjunctively; i.e.,if each element of B0 is true, then so is each elementof H0.
The standard efinition of resolution extendsunproblematically to such clauses.Def in i t ion  2 We say that a clause co - H0 ~ B0resolves with a clause cl = Ht ~-- BI on a non-emptyset ofliterals C C_ Bo iff there is a variant Cl ~ of el ofthe form C *--- BI '  such that V(co)NV(Bx' )  C V(C)(i.e., the variables common to e0 and BI ~ also appearin C, so there is no accidental variable sharing).If Co resolves with Cl on C, then the clauseH0 ~ (B0 - C) U Bx' is called a resolvent of co withC 1 On C .Now we define items, which are the basic computa-tional units that appear on the agenda and in thelemma tables, which record memoized subcomputa-tions.Def in i t ion  3 An item is a pair (t, c) where c is aclause and t is a tag, i.e., one of program, solution ortable(B) for some goal B.
A lemma table for a goalG is a pair (G, La) where La is a finite list of items.The algorithm manipulates a set T of lemma tableswhich has the property that the first components ofany two distinct members of T are distinct.
Thisjustifies speaking of the (unique) lemma table in Tfor a goal G.Tags are associated with clauses by a user-specified control rule, as described below.
The tagassociated with a clause in an item identifies the ope-ration that should be performed on that clause.
Thesolution tag labels 'completed' clauses, the programtag directs the proof procedure to perform a non-memoizing resolution of one of the clanse's negativeliterals with program clauses (the particular nega-tive literal is chosen by a user-specified selection rule,as in standard SLD resolution), and the table(B) tagindicates that a subcomputation with root goal B(which is always a subset of the clause's negativeliterals) should be started.Def in i t ion  4 A control rule is a function from clau-ses G *-- B to one of program, solution or table(C) forsome goal C C B.
A selection rule is a function fromclauses G *-- B where B contains at least one rela-tional atom to relational atoms a, where a appearsin B.Because program steps do not require memoizationand given the constraints on the control rule justmentioned, the list LG associated with a lemmatable (G, LG) will only contain items of the form(t, G ,-- B) where t is either solution or table(C) forsome goal C C_ B.Def in i t ion  5 To add an item an item e =(t, H ~ B) to its table means to replace the table(H, L) in T with (H, JelL\]).103I nput  A non-empty goal G, a program P, a selection rule S, and a control rule R.Output  A set of goals G' for which RiG' ) = solution and P ~ G *-- G'.G loba l  Data  S t ructures  A set T of lemma tables and a set A of items called the agenda.A lgor i thm Set T := {(G, 0)} and A := ((program, G *-- G)}.Until A is empty, do:Remove an item e = it, c) from A.Case t ofprogram For each clause p E P such that c resolves with p on S(c), choose a corresponding resolvente' and add iRic'), c') to A.table(B) Add e to its table, sIf T contains a table (B', L) where B' is a variant of B then for each item (solution, d) E L suchthat c resolves with d on B choose a corresponding resolvent d'  and add iR(c"), d') to A.Otherwise, add a new table i B, ?)
to T, and add (program, B ~-- B) to the agenda.solution Add e to its table.Let e = H ~ B.
Then for each item of the form (tabh(H') ,  d) in any table in T where H '  is avariant of H and c' resolves with c on H',  choose a corresponding resolvent d'  and add (R(d'),  d')to A.Set r := {B:  (solution, G *-- B) E L , /G ,  L) E T}.Figure 2: The Lemma Table algorithmThe formal description of the Lemma Table proofprocedure is given in Figure 2.
We prove the so-undness and completeness of the proof procedure inDSrre and Johnson (in preparation).
In fact, so-undness is easy to show, since all of the operationsare resolution steps.
Completeness follows from thefact that Lemma Table proofs can be 'unfolded' intostandard SLD search trees (this unfolding is well-founded because the first step of every table-initiatedsubcomputation is required to be a program reso-lution), so completeness follows from HShfeld andSmolka's completeness theorem for SLD resolutionin CLP.4 A worked  exampleReturning to the categorial grammar example above,the control rule and selection rule are specified bythe Prolog code below, which can be informallydescribed as follows.
All x/3 literals are classi-fied as 'memo' literals, and add_ad juncts /2  andd iv i s ion /2  whose second arguments are not suf-ficiently instantiated are classified as 'delay' literals.If the clause contains a memo literal G, then the con-trol rule returns tablei\[G\]).
Otherwise, if the clausecontains any non-delay literals, then the control rule3In order to handle the more general form of abstrac-tion discussed in footnote 2which may be useful with ty-ped feature structure constraints, replace B with a(B)in this step, where a(B) is the result of applying theabstraction operation to B.The abstraction operation should have the propertythat a(B) is exactly the same as B, except hat zero ormore constraints in B are replaced with logically weakerconstraints.returns program and the selection rule chooses theleft-most such literal.
If none of the above apply,the control rule returns solution.
To simplify the in-terpreter code, the Prolog code for the selection ruleand tableiG ) output of the control rule also returnthe remaining literals along with chosen goal.
: -  ensure_ loaded( l ibrary( l i s ts ) ) .
:-  op(990, fx ,  \ [delay, memo\]).delay d iv i s ion(_ ,  X/Y) : -  var ( l ) ,  var(Y).delay add_adjuncts(_, X/Y) : -  vat(X),  vat(Y).memo x( .
.
.
.
.
).control(GsO, Control) :-memo(G), select(G, CeO, Gs)-> Control  = table(\[G\],  Gs) ;member(G, GsO), \+ delay(G)-> Control  = program ;Control  = solution.selection(GsO, G, Gs) :-select(G1, GsO, Gel), \+ delay(Gl)-> G = Gl, Ca = Gel.Because we do not represent variable binding as ex-plicit constraints, we cannot implement 'abstraction'by means of the control rule and require an explicitabstraction operation.
The abstraction operationhere unbinds the first and third arguments of x/3goals, as discussed above.abetraction(\[x(_,Left,_)\], \[x(_,Left,_)\]).1040.1\[o\] e0.211\] T0.311\] T0.411\] P0.514\] s0.6\[2,5\] W1.716\] P1.817\] T1.917\] T1.1017\] P1.111101 S0.1216,11\] S0.1312,12\] W2.14113\] P2.15114\] W2.161141 T0.1713,12\] T1.1819,11\] T0.1913,5\] Tx(A, \[l_t, o\], B) ~-- x(A, \[l_t, o\], B).x(A, \[l_t, o\], B) ~-- x(A/C, \[l_t, o\], D), x(C, D, B).x(A, \[l_t, o\], B) ~ x(C, \[l_t, o\], D), x(A\C, D, B).x(A, \[l_t, o\], \[o\]) *-- lex(l_t, A).x(A/#B, \[l_t, o\], \[o\]) ~-- add(s\np/(s\np), C), div(C, A/B).x(A, \[l_t, o\], B) ~ add(s\np/(s\np), C), div(C, A/D), x(#D, \[o\], B).x(A, \[o\], B) ~ x(A, \[o\], S).x(A, \[o\], B) *-- x(A/C, \[o\], D), x(C, D, B).x(A, \[o\], B) ~-- x(C, \[o\], D), x(A\C, D, S).x(A, \[o\], 4) ~- lex(o, A).x(#A, \[o\], ~) ~- add(s\np\np, A).x(A, \[l_t, o\], 0) ~'- add(s\np\np, S), add(s\np/(s\np), C), div(C, A/B).x(A, \[Lt, o\], B) *-- add(s\np\np, C), add(s\np/(s\np), D), div(D, A/E/C), x(E, Q, B).x(A, 0, B) ~- x(A, 0, B).x(A, 0, B) ~- x(A/C, Q, D), x(C, D, B).x(h, 4, B) +-- x(C, 4, D), x(A\C, D, B).x(A, \[l_t, o\], B) ~-- add(s\np\np, C), add(s\np/(s\np), D), div(D, E/C), x(A\E, ~, B).x(A, \[o\], B) ~-- add(s\np\np, C), x(A\#C, ~, B).x(A, \[l_t, o\], B) ~ add(s\np/(s\np), C), div(C, D/E), x(A\(D/#E), \[o\], B).Figure 3: The items produced uring the proof of x(?, \[lijkLte,on~wijkenJ ,=) using the control andselection rules specified in the text.
The prefix t.n\[a\] T identifies the table t to which this item belongs,assigns this item a unique identifying number n, provides the number(s) of the item(s) a which caused thisitem to be created, and displays its tag T (P for 'program', T for 'table' and S for 'solution').
The selectedliteral(s) are shown underlined.
To save space, 'add_adjuncts' i  abbreviated by 'add', 'division' by 'div','lijkt_te' by 'It', and 'ontwijken' by 'o'.Figure 3 depicts the proof of a parse of the verb clu-ster in (1).
Item 1 is generated by the initial goal;its sole negative literal is selected for program reso-lution, producing items 2-4 corresponding to threeprogram clauses for x/3.
Because items 2 and 3 con-tain 'memo' literals, the control rule tags them table;there already is a table for a variant of these goals(after abstraction).
Item 4 is tagged program bec-ause it contains a negative literal that is not 'memo'or 'delay'; the resolution of this literal with the pro-gram clauses for lex/3 produces item 5 containingthe constraint literals associated with lijkt re.
Bothof these are classified as 'delay' literals, so item 5 istagged solution, and both are 'inherited' when item 5resolves with the table-tagged items 2 and 3, produ-cing items 6 (corresponding to a right applicationanalysis with lijkt te as functor) and item 19 (cor-responding to a left application analysis with ont.wijken as functor) respectively.
Item 6 is taggedtable, since it contains a x/3 literal; because thisgoal's second argument (i.e., the left string position)differs from that of the goal associated with table 0,a new table (table 1) is constructed, with item 7 asits first item.The three program clauses for x/3 are used to re-solve the selected literal in item 7, just as in item 1,yielding items 8-10.
The lex/3 literal in item 10 isresolved with the appropriate program clause, pro-ducing item 11.
Just as in item 5, the second argu-ment of the single literal in item 11 is not sufficientlyinstantiated, so item 11 is tagged solution, and theunresolved literal is 'inherited' by item 12.
Item 12contains the partially resolved analysis of the verbcomplex.
Items 13-16 analyze the empty string;notice that there are no solution items for table 2.Items 17-19 represent partial alternative analyses ofthe verb cluster where the two verbs combine usingother rules than forward application; again, theseyield no solution items, so item 12 is the sole analy-sis of the verb cluster.5 A s imple  in terpreterThis section describes an implementation of theLemma Table proof procedure in Prolog, designedfor simplicity rather than efficiency.
Tables arestored in the Prolog database, and no explicit agendais used.
The dynamic predicate goal_Cable(G, I)records the initial goals G for each table subcompu-tation and that table's identifying index I (a numberassigned to each table when it is created).
The dy-namic predicate table_solut ion(I ,  S) records all ofthe solution items generated for table I so far, andtable_paxent(I, T) records the table items T, called'parent items' below, which are 'waiting' for additio-nal solution items from table I.The 'top level' goal is prove(G, Cs), where G is105a single atom (the goal to be proven), and Cs isa list of (unresolved) solution constraints (differentsolutions are enumerated through backtracking).prove/2 starts by retracting the tables associa-ted with previous computations, asserting the tableentry associated with the initial goal, and then callstake_action/2 to perform a program resolution onthe initial goal.
After all succeeding steps are com-plete, prove/2 returns the solutions associated withtable 0.prove(Goal, _Constraints) :-retractall (goal_gable(_, _) ),retractall (table_solut ion (_, _) ),retractall (gable_parent (_, _) ),regractall (counter (_)),assert(goal_gable( \[Goal\], O)),?ake_acgion(proEram , \[Goal\] : :-\[Goal\], O),fail.prove(Goal, Constraints) :-table_solution(O, \[Goal\] : :-Constraints).The predicate take_action(L, C, I) processes items.L is the item's label, C its clause and I is the in-dex of the table it belongs to.
The first clausecalls complete/2 to resolve the solution clause withany parent items the table may have, and the thirdclause constructs a parent item term (which enco-des both the clause, the tabled goal, and the in-dex of the table the item belongs to) and callsinsert_into_table/2 to insert it into the appro-priate table.take_action(solution, Clause, Index) :-assert (Cable_solution(Index, Clause)),findall(P, gable_parent (Index, P),Paren?Items),member (ParentIgem, ParenCItems),complete (ParentItem, Clause).take_acCion(proEram , Head: :-Goal, Index) :-selection(Goal, Selected, Bodyl),Selected : :- HodyO,append(BodyO, Bodyl, Body),control(Body, Action),take_action(Action, Head: :-Body, Index).take_action(table(Goal, Other), Head : : -_Body,Index) :-ins err_into_table (Goal,?ableItem(Head, Goal, Other, Index)).complete/2 takes an item labeled table and a clause,resolves the head of the clause with the item, andcalls contro l /2  and take_act ion/3 to process theresulting item.complete(tableItem(Head, Goal, Body1, Index),Goal: :-BodyO) : -append(BodyO, Bodyl, Body),control (Body, Action),take_action(Action, Head: :-Body, Index).The first clause inser t_ in to_ tab le /2  checks to seeif a table for the goal to be tabled has already beenconstructed (numbervars/3 is used to ground a copyof the term).
If an appropriate table does not exist,the second clause calls c reate_ tab le /3  toconstructone.insert_into_table(Goal, ParentItem) :-copy_term(Goal, GoalCopy),numbervars (GoalCopy, O, _),goal_table (GoalCopy, Index),!,assert (table_parent (Index, ParentIgem) ),findall(Sol, table_solution(Index, Sol),Solutions), !,member(Solutlon, Solutions),complege(ParengItem, SQlugion).insert_into_table (GoalO, ParentICem) :-absgraction(GoalO, Goal), !,create_gable(Goal, ParengItem, Index),?ake_action(proEram, Goal: :-Goal, Index).create_ tab le /3  performs the necessary databasemanipulations to construct a new table for the goal,assigning a new index for the table, and adding ap-propriate ntries to the indices.create_table(Goal, Parent I?~,  Index) : -(retract(councer(IndexO)) -> true; IndexO=O),Index is IndexO+l,assert (counter (Index)),assert(goal_table(Goal , Index)),as sert (table_parent (Index, ParentItem) ).6 Conc lus ionThis paper has presented a general framework whichallows both constraint coroutining and memoizs-tion.
To achieve maximum generality we statedthe Lemma Table proof procedure in HShfeld andSmolka's (1988) CLP framework, but the basicidea--that arbitrary constraints can be allowed topropagate in essentially the same way that variablebindings do--can be applied in most approaches tocomplex feature based parsing.
For example, thetechnique can be used in chart parsing: in such asystem an edge consists not only of a dotted ruleand associated variable bindings (i.e., instantiatedfeature terms), but also contains zero or more asyet unresolved constraints that are propagated (andsimplified if sufficiently instantiated) uring applica-tion of the fundamental rule.At a more abstract level, the identical propagationof both variable bindings and more general cons-traints leads us to question whether there is anyprincipled ifference between them.
While still preli-minary, our research suggests that it is often possible106to reexpress complex feature based grammars moresuccinctly by using more general constraints.Re ferencesG.
Bouma and G. van Noord.
Constraint-Based Ca-tegorial Grammar.
In Proceedings of the 3Pnd An-nual Meeting of the ACL, New Mexico State Uni-versity, Las Cruces, New Mexico, 1994.B.
Carpenter.
The Logic of Typed Feature Structu-res.
Cambridge Tracts in Theoretical ComputerScience 32.
Cambridge University Press.
1992.J.
DSrre.
Generalizing Earley deduction forconstraint-based grammars.
In J.
D6rre(ed.
), Computational Aspects of Constraint-BasedLinguistic Description I, DYANA-2 deliverableRI.~.A.
ESPRIT, Basic Research Project 6852,July 1993.J.
DSrre and M. Johnson.
Memoization and co-routined constraints, ms. Institut fiir maschinelleSprachverarbeitung, Universit~it Stuttgart.M.
HShfeld and G. Smolka.
Definite Relations overConstraint Languages.
LILOG Report 53, IWBS,IBM Deutschland, Postfach 80 08 80, 7000 Stutt-gart 80, W. Germany, October 1988.
(availableon-line by anonymous ftp from /duck.dfki.uni-sb.de:/pub/papers)M. Johnson.
Memoization in Constraint LogicProgramming.
Presented at First Workshop onPrinciples and Practice of Constraint Program-ming, April P8-30 1993, Newport, Rhode Island.F.
C. Pereira and D. H. Warren.
Parsing as Deduc-tion.
In Proceedings of the Plst Annual Meeting ofthe ACL, Massachusetts Institute of Technology,pp.
137-144, Cambridge, Mass., 1983.S.
M. Shieber.
Using Restriction to Extend Par-sing Algorithms for Complex-Feature-Based For-malisms.
In Proceedings of the 23rd Annual Mee-ting of the Association for Computational Lingui-stics, pp.
145-152, 1985.Tamaki, H. and T. Sato.
"OLDT resolution withtabulation", in Proceedings of Third Internatio-nal Conference on Logic Programming, Springer-Verlag, Berlin, pages 84-98.
1986.Vieille, L. "Recursive query processing: the power oflogic", Theoretical Computer Science 69, pages 1-53.
1989.Warren, D. S. "Memoing for logic programs", inCommunications of the ACM 35:3, pages 94-111.1992.107
