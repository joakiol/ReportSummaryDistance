A Language for the S tatement  of  Binary  Re la t ionsover  Feature  S t ructuresGraham Russell Afzal Ballim Dominique Estival Susan Warwick-ArmstrongISSCO, 54 rte.
des Acacias1227 Geneva, Switzerlandelu@divsun.unige.chAbstractUnification is often the appropriate method forexpressing relations between representations ithe form of feature structures; however, thereare circumstances in which a differentapproach is desirable.
A declarative formalismis presented which permits direct mappings ofone feature structure into another, and illustra-tive examples are given of its application toareas of current interest.1.
IntroductionBenefits arising from the adoption ofunification as a tool in computational linguis-tics are well known: a declarative, monotonicmethod of combining partial informationexpressed in data structures convenient forlinguistic applications permits the writing ofsensible grammars that can be made indepen-dent from processing mechanisms, and a grow-ing familiarity, in both theoretical nd compu-tational circles, with the techniques ofunification fosters fruitful interchange of ideasand experiences.
There are, however, occa-sions when unification alone is not anappropriate tool.
In essence, unification is aternary relation in which two structures, whenmerged, form a third; it is less attractive in cir-cumstances where the relation to be expressedis binary - when one would like to manipulatea single feature structure (FS), perhaps imu-lating the direct transformation f one FS intoanother.
1 The present paper introduces adeclarative formalism intended for the expres-sion of such relations, and shows how it maybe applied to some areas of current interest.The formalism in question is based upon anotion of 'transfer ule'; informally, a set ofsuch rules may be considered as characterizingWe are indebted to Jacques Jayez for comments on anearlier draft of this paper.1 Clearly there is a sense in which such relations canbe viewed as ternary: T(FI, R, F2), where 171 and 172 are?
17Ss, and R is the rule set which relates them.a binary relation over a set of feature struc-tures, the properties of that relation dependingon the content of the particular rule set in use.Transfer ules associate the analysis of one FSwith the synthesis of another; they may bethought of as a specialized variety of pattern-matching rule.
They are local in nature, andpermit the recursive analysis and synthesis ofcomplex structures according to patternsspecified in a format closely related to thatwidely employed in unification-based compu-tational inguistics.
Indeed, the interpretationof transfer rules involves unification, albeit in acontext which restricts it to the role of astructure-building operation.
2In the remainder of this paper we provide abrief specification of the transfer ule formal-ism, discuss its interpretation, outline twoalternative rule application regimes, and illus-trate the use of the formalism in the areas ofmachine translation and reduction of FSs tocanonical form.
We conclude with an over-view of continuing strands of research.2.
Rule Format and Interpretation2.1.
General RemarksA transfer rule consists of four parts:(i) a role name; 3(ii) a set of constraint equations describing aFS;(iii) a set of constraint equations describing aFS;  42 The rule formalism is thus monotonic, being unableto effect changes in the input representation, and con-stmcting the output by means of unification.3 The rule name plays no part in the interpretation ofroles, but provides a convenient reference for tracingtheir ordering and application.4 The equations in each of (ii) and (iii) must heuniquely rooted.
The current implementation disallowsdisjunction in the equation sets for this reason.- 287 -(iv) a (possibly empty) set of 'transfercorrespondence statements' - equationsdescribing transfer correspondences thatmust hold between variable bindings esta-blished in (ii) and (iii).A transfer rule relates the two FSs it describeseither directly or indirectly, via the rule'stransfer correspondence statements; in orderfor the relation to hold between the source anddestination FS, it must hold between the FSs towhich any transfer-variables are bound.
Anexample of a transfer rule is given below::T: exampled:LI: <* a b> = XI<* c d> = YI:L2: <* p q> = X2<*p  r>ff iY2:X: Xl <=> X2YI <=> Y2This rule establishes a correspondence b tweenthe two feature structures hown below, (1)being the FS described by the equations under'L l '  and (2) by those under 'L2':The correspondence is licensed provisionallyfor this FS pair by "example-l"; it is licensedabsolutely for a pair of FSs (1') and (2') havingthe same root as (1) and (2) respectively onlyif:(i) (1') contains sub-FSs (z unified with X1and \[3 unified with Y1 in (1),(ii) (2') contains sub-FSs y unified with X2and 8 unified with 3(2 in (2), and(iii) the same type of correspondence islicensed, possibly by some other rule,between (x and y and between \[~ and 8.Complex FSs are analysed and constructedrecursively as a result of the passage of controlthrough transfer variables.
/In the abstract, transfer rules have noinherent directionality; the two FSs above maybe visualized interchangeably as input and out-put, or 'source' and 'destination'.
When com-piled for a particular application, however,they are interpreted irectionally, the domainof the transfer relation being collectivelycharacterized by the equation sets labelled 'L I 'and the range by those labelled 'L2', or viceversa.
One may then think of compiledtransfer rules as having a 'left-hand' or 'input'and a 'right-hand' or 'output' side, the formerdescribing a source FS and the latter a destina-tion FS.
We shall use these terms freely incontexts where directionality is at issue, andassume that the rules have been compiledaccordingly.2.2.
InterpretationThe relation of transfer between a source FS Xand a destination FS A is defined recursively interms of the quintuple (R, ?bx(R), ~p(R),T(R), O(Z)), where R is a rule, ~(R)  and?
p(R) are, respectively, the FSs induced by theleft-hand and right-hand equation sets in R,T(R) is the set of transfer correspondencestatements in R, and O(Y~) is the result of con-vertin\[\[ any path-final variables in Z to con-stants:-'Z stands in the transfer relation to A withrespect to Riff:(i) (b~.
(R) subsumes (~(Y-), and(ii) ~p(R) unifies with A, and(iii) for each % e T(R), the sub-FSs of 5"- and Aunifying with the transfer variables men-tioned in 'c stand in the transfer elationwith respect o some rule in the currentlyaccessible rule set.The first clause of this definition states the con-dition under which a rule is a candidate forapplication to a given input FS.
The secondstates the condition under which a rule is acandidate for application to a given output FS.Note that the operations differ; whereas thematching in (i) is based on subsumption, theaction in (ii) employs unification.
As a conse-quence, the FS q)p(R) is added to the output FSA.
The third clause imposes the further condi-tion that, in order for \]: and A to be related byR, any FSs they contain which are explicitlyconnected via variable binding and a transfercorrespondenc e statement in T(R) are alsorelated.As will be~ seen from clause (iii) of thedefinition, a complex FS is traversed from rootto terminals, control being passed via variablesin tran~er equations, and the extent of eachsub-transfer (i.e.
how much of the input FS isconsumed at each stage) being determined by5 It may well be the case that, in certain applicationsor envixonments, source FSs will not contain such vari-ables; the possibility must be acknowledged nevertheless,since non-declarative rule interactions may otherwise oc-CUlt'.- 288 -the path specifications in the left-hand sideequation set of the currently active rule.
Possi-ble paths through the FS from a given point aredetermined collectively by the left-hand sideequations of all rules, together with theirtransfer correspondence statements.Because FSs are finite and acyclic, termina-tion is guaranteed as long as there is no rule ofthe form shown below.
This is able to apply(in the 'L1-->L2' direction - we ignore theconverse) without consuming part of thesource FS::T: infinite-recursion:LI: <*>-- X:L2" ...:X: X <--> YCoherence of a destination FS with respect to asource FS and a set of transfer ules is ensuredby the formalism; material can only be intro-duced into a destination FS by the right-handside of transfer ules which have successfullyapplied.
Completeness, on the other hand,must be verified explicitly; every part of thesource FS must be subsumed by a subpart ofthe FS obtained by unifying the FSs inducedby the left-hand side patterns of every rulesthat has successfully applied.
In the currentimplementation, it is possible to declare thatcertain subparts of a source FS are not to betransferred; in this case, it is the remainder ofthat FS which must be covered by the rules.3.
Applications of the FormalismWe now illustrate how the transfer rule formal-ism may be exploited, and indicate briefly howthe rule invocation regime may vary.
Themachine translation example in the followingsection assumes parallel invocation of the ruleset, while that involving reductions to canoni-cal form seems most amenable to the serialinvocation of individual rules or subsets ofrules.3.1.
Machine TranslationPerhaps the most obvious application for theformalism presented here lies in the domain ofmachine translation.
The transfer model ofMT may be thought of as involving three dis-tinct mappings; from the source languageexpression to a source linguistic representa-tion, from the source representation to a targetrepresentation, and from this to an expressionin the target language.
The first and last ofthese are to be performed by parsing and gen-eration with natural anguage grammars, but,while proposals have been made to combinesome of the three stages (e.g.
Kaplan et at.,1989), there are advantages in treating theintermediate, transfer, stage independently.As an example, consider the FSs shownbelow: 6(3) \[sem Ipred schwimmen \ ] \ ]args (<1> sem pred Maria)Lmod sem pred gem(4) Isem \[pred aimer \[ )1args (<I> sem pred Maria,<2> sem pred nager\]args (#I)\](3) and (4) are possible representations for theGerman sentence Maria schwimmt gem, andthe French sentence Maria aime nager, both ofwhich might translate into English as 'Marialikes swimming'.
Note that, whereas (3) hasthe predicate which translates 'swim' at the toplevel, and contains a modifier gem whichmight be glossed as 'gladly', (4) embeds the'swim' predicate within an argument to themain predicate aimer 'like', and links the firstargument of aimer to the first argument ofnager by means of a re-entrancy.
7The set of rules given below together estab-lish a transfer relation between (3) and (4): sNote the use of a list, indicated by ' ( .
.
.
)', to encodearguments in these FSs, the identification of elements onsuch a llst by e. 8.
'<1>', and re-entrancy flagged by '#'.7 Clearly, one could employ a similar analysis for theGerman sentence by making gem an 'equl' predicate likea imer  - th is  would amount o simplifying transfer byshifting complexity from the transfer rules into the Gear-man grammar.8 This is not quite true; the variables 'T f  and 'Tg' inthe rule "gem-aimer" will bind to lists (the empty list inthis case), and we therefore require additional genericlist-transfer rules that will have the effect of passingthrough a list, recursively transferring heads and tails.Implementations for systems that lack the list data typewill naturally be able to dispense with this.
In addition,the lexical transfer ules assume the presence in thecurrent set of a rule consuming the '<* sere pred>'paths terminating inPaul and Maria.- 289 -:TA: Paul Paul:TA: Maria Maria:T: schwimmen-nager:LI: < * sere pred > = schwimmen<* sere args> = \[Xg\]:L2: < * sem pred > = nager<* sem args> = \[Xf\]:X: Xg <=> Xf:T: gem-aimer:LI:<* sem pred> = Rg<* sem args> = \[AglTg\]<* sem mod sere pred> ffi gem:L2: < * sere pred> ffi aimer<* sere args> = \[Af, Vf\]<* sem args> = \[Af, Vf\]<Vf sere args> = \[AfiTf\]:X: Rg <-> RfAg <=> AfTg <--> Tf< Vf sem pred > ffi RfThe pair of rules ' :TA:PaulPaul '  and':TA: Maria Maria' are 'lexical transfer ules';they state a transfer elation between atomicFSs (i.e.
words, in the context of MT), ratherthan complex ones, and, further, do so withoutreference to the context of these FSs.
They areequivalent to e.g.
:T: Maria Maria:LI: <*> = Maria:L2: < * > = Maria:X: -The re-entrancy in FS (4), in which the firstargument associated with the predicate aimeris also the argument associated with theembedded predicate nager, is of some interestin connection with transfer.
Taking (4) as thesource, application of "gern-aimer" results inthe binding of both instances of the variable'Af' to the sub-FS indexed as '<1>' which issubject o the relevant ransfer correspondencestatement and whose corresponding destinationsub-FS (in this case identical) will be presentin the overall destination FS as the first ele-ment on the argument list of schwimmen.
Rev-ersing the direction, with (3) as the source, thevariable 'Ag' is bound to the sub-FS indexedas '<1>', whose corresponding destinationsub-FS is similarly present in the overall desti-nation FS, this time as the first element in bothargument lists, and, moreover, owing to theidentity of variables in "gern-aimer", unifiedrather than duplicated.
Re-entrancy may thusbe detected in the source FS and created in thedestination; naturally, responsibility forcorrectly analysing structures confining re-entrancies, and enforcing them where desiredin output structures, lies with the writer oftransfer rules.3.2.
Reduct ion  to Canon ica l  FormIt is often the case that a grammar assigns justone of a range of logically equivalent represen-tations to a sentence; designers of grammarsfor use in analysis generally take care to ensurethat the result of parsing a non-ambiguous sen-tence is a unique semantic representation, andmultiple representations are seen as the hall-mark of (pre-theoretical) ambiguity.
In gen-eration, as Shieber (1988) and Appelt (1989)observe, a situation may arise in which therepresentation supplied as input to the process(perhaps by another program) is not itselfdirectly suitable, but is logically equivalent toone that is.
The use of distinct grammars forparsing and generation could provide a solu-tion to this problem, but it raises others con-nected with management of the resulting sys-tem.
An alternative is to define equivalenceclasses of representations, and reduce allmembers of a class to the single canonicalform which the grammar can map into a sen-fence.
Exactly how the classes and reductionsare defined will doubtless depend on many fac-tors; we consider here some of the standardlogical equivalences exploited in reducingarbitrary expressions of the propositional cal-cuius to disjunctive normal form.
:T: not-not:LI: <*  op> ffi not<* val 1 op> ffi not<* val 1 val 1> = Y:L2: <*> ffi X:X: X <ffi> Y:T: not-or:LI: <*  op> ffi not<* val 1 op> = or<* val 1 val 1> = XI<* val 1 val 2> = X2:L2: <* op> = and<* val 1 op> ffi not<* val 1 val 1> ffi Y1<* val 2 op> = not<* val 2 val 1> = Y2:X: XI <ffi> Y1X2 <ffi> Y2The two rules shown above expressequivalences which are more familiar as:--,(-,p) ~ pand- ,(p v q) ~-~ (-,p ^ -,q).the- 290 -The mode of application required here is ratherdifferent from that described in the precedingsection, for a context in which "not-not"applies may not exist prior to the application of"not-or".
Consider the three FSs below:(5) op notval op notval 1Q(6) "opvaland1 \]?Pal n?t \ [~12 \[OPval not Q \ ] I.ot\]\]Given (5), the desired result is (7), by way of (6).A suitable context for the role "not-not" is createdby "not-or"; note, however, that this context existsonly in the destination FS, and not in the source.What is required is a serial mode of invocation, asopposed to the parallel mode assumed for the MTapplication, with the 'output' of one rule serving asthe 'input' to another.
An alternative would be toformulate transfer ules that encompass a widercontext; drawbacks of such an approach would bethat it is not possible to cater for all contexts, andthat, in attempting todo so, one would dimini.~h t elocality and thus the transparency ofthe rules.There are several possibilities for imple-menting serial rule invocation; the moststraightforward involves taking an output FSas the input to another pass through the ruleset.
In this case, vacuous application of therule set must be detected in order to ensure ter-mination.It will not normally be desirable to applycanonicalization rules 'in reverse': the effectwill be to derive all forms that are logicallyequivalent o the input, and, if the relevantequivalence classes are not finite, the processwill not terminate.
Consider the rule "not-not"; its presence in a rule set compiled with'L2' as the left-hand side will result in thederivation of forms involving, at each point, anembedding of the source FS under a progres-sively higher even number of nots .
This is asit should be, however, given the semantics oftransfer ules outlined in section 2, since, inthis direction, the rule characterizes a relationwhose range is not finite.
Individual applica-tions of the rule terminate, nevertheless.4.
Conc lus ionWe have presented what is to our knowledgethe first formalization and implementation f atype of rule and control regime intended foruse in situations where it is desired to producethe effect of transforming one feature structureinto another.
9The formalism described above has beenimplemented as part of ISSCO's ELU l?, anenhanced PATR-II style (Shieber, 1986)unification grammar environment, based on theUD system presented by Johnson and Rosner(1989).
ELU incorporates a parser and genera-tot, and is primarily intended for use as a toolfor research in machine translation.
Use oftransfer rules in translation has not so farbrought o light instances where the serial ruleinvocation regime described in section 3.2proves necessary.
ELU grammars permit theuse of typed feature structures (cf.
Johnson andRosner, op.
cit., Moens et al, 1989) in gram-mars; although the present transfer ule formatdoes not, they are clearly a desirable addition,since they would provide a means of exertingcontrol over rule interactions.A third area in which the transfer ule for-realism might be applied concerns the manipu-lation of re-entrant structures.
While re-entrancy is in general a useful property of FSs,the complexity entailed by its presence is insome cases unwelcome; the method of genera-: 9 Van Noord (1990) describes the use of a standardunification grammar to successively instantiate a singlefeature structure mbodying meaning representations forboth source and target language xpressions in a machinetranslation application.
Similarly, the transfer ules ofZajac (1990) express a relation between subparts of a sin-gle complex structure.
Such an approach does not appearsuitable for the appl/cation discussed in section 3.2above.10 "Environnement Linguistique d'Unification"- 291 -tion proposed by Wedekind (1988), for exam-ple, requires that the LFG-style f-structureswhich form the input to the generation processbe 'unfolded' into unordered trees.
This maybe done with a suitably formulated rule set ofthe kind introduced here.
The present rule for-mat is unable to preserve the information thatdistinct sub-FSs in a destination FS arise fromthe duplication of a single, re-entrant, sub-FSin the source.
Ways of incorporating this abil-ity into the rule formalism are under considera-tion, one possibility being the addition of anindexing mechanism that would flag sub-FSsas originating in a re-entrancy.A companion paper describes an interpreta-tion of transfer ule sets in terms of a partialordering with respect to the specificity of rules,and discusses linguistic and computationalmotivations for this view; it also comments ingreater detail on the rule interaction problemsreferred to in fn.
3, and on issues of termina-tion, completeness and coherence in transfer.Here, we simply note that, in the currentimplementation, it is possible to declare to thesystem the path set of a source FS that is to besubject to transfer, so as to provide rim-timenotification ff inadequacies in the rule setresult in a specified sub-FS being neglected.With respect to a given rule set and source FS,however, correctness of the transfer process isAssured.ReferencesAppelt, Douglas E. (1989) "BidirectionalGrammars and the Design of: NaturalLanguage Generation Systems", in Y.Wilks (ed.)
Theoretical Issues in NaturalLanguage Processing; 19.9-205.
Hillsdale,NJ: Laurence Erlbaum.Johnson, Rod and Mike Rosner (1989) "ARich Environment for Experimentationwith Unification Grammars".
Proceedingsof the Fourth Conference of the EuropeanChapter of the Association for Computa-tional Linguistics, Manchester, UK, April10th-12th 1989; 182-189.Kaplan, Ronald M., Klans Netter, JiirgenWedekind, and Annie Zaenen (1989)"Translation by Structural Correspon-dence".
Proceedings of the Fourth Confer-ence of the European Chapter of the Asso-ciation for Computational Linguistics,Manchester, UK, April 10th-12th 1989;272-281.Moens, Marc, Jo Calder, Ewan Klein, MikeReape, and Henk Zeevat (1989) "Express-ing Generalizations in Unification-basedGrammar Formalisms".
Proceedings of theFourth Conference of the EuropeanChapter of the Association for Computa-tional Linguistics, Manchester, UK, April10th-12th 1989; 174-181.Shieber, Stuart M. (1986) An Introduction toUnification-Based Theories of Grammar.CSLI Lecture Notes no.
4, CSLI, Stanford.Shieber, Smart M. (1988) "A Uniform Archi-tecture for Parsing and Generation".Proceedings of the 12th InternationalConference on Computational Linguistics,Budapest, August 22nd--27th, 1988;614-619.van Noord, Gertjan (1990) "ReversibleUnification Based Machine Translation".Proceedings of the 13th InternationalConference on Computational Linguistics,vol.2, Helsinki, Finland, August 20th-24th,1990; 299-304.Wedekind, Jiirgen (1988) "Generation asSWacture-Driven Derivation".
Proceedingsof the 12th International Conference onComputational Linguistics, Budapest,August 22nd-27th, 1988; 732-737.Zajac, R~ai (1990) "A Relational Approach toTranslation".
Proceedings of the ThirdInternational Conference on Theoreticaland Methodological Issues in MachineTranslation of Natural Language, Austin,Texas, June llth-13th, 1990.- 292 -
