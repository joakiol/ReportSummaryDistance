A Lexical Functional Grammar System in PrologAndreas Eisele and Jochen DOrreDepartment of LinguisticsUniversity of StuttgartWest GermanyAbst rac tThis paper describes a system in PROLOG for the automatictransforination of a grammar, written in LFG formalism, intoa DCG-based parser.
It demonstrates the main principles ofthe transformation, the representation of f-structures andconstraints, the treatment of long-distance dependencies,and left rccursion.Finally some problem areas of the system and possibilitiesfor overcoming them are discussed.IntroductionIn order to intprove our knowledge about natural language, itis desirable to have a high-level description language whichcan be used to test grammars on a computer system, but whichis independent of the details of the implementation.
Forlinguists without knowledge of programming languages, asystem for writing and testing grammars on a computer shouldbe offered.At the University of Stuttgart such a system has been imple-mented in PROLOG, which uses tile formalism of Lexical-Functional Grammar \[Kaplan/Bresuan 82\] as its descriptionlanguage.The system makes it possible for the user to enter grammarrules and lexical entries directly in the form described in\[Kaplan/Bresnan 82\].
The input is translated into PROLOGrules, which form a top down parser in defiuite clausegrammar style.Equations and constraints associated with a grammar ule areevalnated as soon as the rule is used, thus allowing therejection of incorrect parses as soon as constraints areviolated.One of the main problems using DCG grammars - theprohibition of using left-recursive grammar rules issolved by a conversion to right-recursive rules that doesnot violate the semantics of the functional description.grammar implementors in two respects:i) Using DCGs for parsing (and overcoming the prohibition ofleft recursion)ii)Profiting from PROLOG's unification mechanism toimplement LFG-Unification.Uui f i ca t ionLFG is a unification-based grammar formalism.
To be moreprecise, any defining equation in LFG can be interpreted asthe unification of certaiu f-structures.
Unifying two f-structures is an operation very similar to set union.However, unification may fail, if the stuctures containcontradicting values for the same attribute.
Otherwise thetwo structures become the same object, which contains theinformation of hoth structures.
Consider for example the LFGruleS -.~ NP VP/t sueJ)=$ T==~and take FS, FNP and FVP as the f-strnctures associated totile S, NP and VP node, respectively.
Then the two equationscau be interpreted as the unificationsFS U - FVP and FS U \[SUBJ = FNP\].The unification of f-structures is also closely related tothe unification of PROLOG-Terms, yet there are two importantdifferences: lu f-structures values are identified by labels(the attributes) and their number is potentially unlimited,whereas in PROLOG-terms the arguments are identified bytheir position and their number is fixed.
In the followingwe show how we can model f-structure unification in PROLOG.We represent partial f-structures as an 'open ended' list ofpairs:\[ A I  = V I  , A2  = V2 .
.
.
.
.
An = Vn I _ \]Main Goals of tile ImplementationWhen we started the implementation f our LFG-Sytem we hadmainly the following tasks in mind:- Independence o f  ImplementationThe LFG system is meant to be a grammar-writer's tool whichallows him to ignore completely the details of theimplementation.
Specifically we wanted tile system to beuseful for linguists without any prior knowledge of PROLOG.- Complete Coverage of  the LFG-Formal i smThe system should cover all features of LFG as they arestated by \[Kaplan/Bresnan 82\].
This means we had toincorporate the principles of consisteucy, completeness andcoherence, inequality, positive and negative existentialconstraints and long distance dependencies.- F lexible Environment for Grammar DevelopmentTo be a really useful tool, the system must allow fortesting the grammar fragment and changing it incrementally.In this point we had to find a good compromise between speedof parsing and speed of grammar modification.- Using as much of  PROLOG as possibleWe wanted to profit from the facilities PROLOG offers forwhere the Ai stand for (atomic) attributes and the Vi forthe values associated to these attributes.
These values areeither atomic, terms denoting semantic forms, f-structuresthemselves or tile term 'set(S)' where S stands for an open-ended llst of f-structures denoting a set.The unification of two f-structures is evaluated in thisrepresentation by inserting into both structures thefeatures missing with respect to the other, and then PROLOG-unifying the variables that stand for the rest of the lists.The values of features which the structures have in commonhave to be unified recursively.A procedure which performs this action can easily be writtenin PROLOG* :merge(X,X) :- !.merge(\[A=VllRl\],F2) :- deI(A=V2,F2,R2),merge(V1,V2),merge(R 1,R2).deI(F,\[FIX\],X) :- !.deI(F,\[EIX\],\[EIY\]) :- del(F,X,Y).When called with the f-structures FSI and FS2, the predicate'merge' recursively reduces the attributes in FSI.
If an*The ~re,~ment of sets is omitted here for the sake of simplicity.551attribute appears also in FS2, 'del' f inds its value in FS2and the two values are unif ied by the first recursive callof 'merge'.
If  an attr ibute is unspecif ied in FS2, 'del'will insert it at the end of the structure as a newattribute.
Eventual ly,  'merge' will reach the tail variableof FS1 and instantiate it with exactly the attributes whichappear in FS2 but not in FSI, After successful execution of'merge' FSI and FS2 contain the same attributes with thesame values (maybe in di f ferent order) and tail variables atany level are shared.
So any further unif ication affectingone of them wil l  affect the other structure in exactly thesame way.Example: The goalmerge( \[subj = \[spec = def ,nu~ = sg,pred = glrl\] RSubj I\]\[ RI\] ,\[pred = hand(subj,obj2,obj),tense = present,subj = \[num = sg I RSubj2\]I R2\] ).yields the instantiationsR1 = \[pred = hand(sub j ,ob j2 ,ob j ) ,  tense = present \[ R2\]RSubj2 = \[spec = def ,  pred = g i r t  I gSubj l \ ]The  fac t  that  the  un i f i ca t ion  is  per fo rmed by  extend ing  bothof the structures and that there is no explicit result isessential when dealing with reentrant structures, i.e.embedded structures that can be reached by more than onepath.
In the case when such a structure is extended while itis reached by one of the possible paths, an access via adi f ferent path wil l  also reach this extension.Treatment of Completeness, Coherence and ConstraintsIn addit ion to def ining equations, which can be mapped ontothe monotonic operation of unif ication, LFG includes formaldevices, some of which cannot be treated monotonically, butneed the notion of a ' f inal '  f -structure \[Shieber 85\].
Moreconcretely, the violation of positive existentialconstraints, constraining equations and completeness cannotbe checked before the parsing process has finished.Existential constraints are treated by inserting theattribute into the f-structure, but leaving the associatedvalue uninstantiated (if it isn't already known).
Thecondition that tiffs variable must be instantiated isstored in a list (Ex Tests) especially for this purpose andtested after the parse.Negative existential constraints are treated by assigningthe value 'ni l '  to the attribute.
The value 'ni l '  isinterpreted as non-existence of the feature and must notappear in the grammar itself.- Constraining equations can be handled as follows*:We introduce a special term 'C'(Value,Mark), where Value isthe value demanded by the constraining equation and Mark isuninstantiated.
The def init ion of the unif ication ischanged, such that a simple value X is treated as a shortform of the term 'C'(X,t).
Therefore, any unsatisfiedconstraining equation results in an uninstantiated mark inthe f-structure and can easily be detected after parsing.
*this treatraent of constraining equations is due to an idea of Jo Calder(personal communication).In our current implementation a more general method is used which also allowsboth sides of the equation to denote substructures, but which is omitted heresince these cases never occur in realistic grammars.552Completeness of f -structures is tested by existentialconstraints on the sub-structures required by the semanticform.We think that the mere existence of a required sub-structureis not enough.
For example, verb entries often introduce apartial f -structure for the subject by specifying itsnumber.
This should not lead to the acceptance of a sentencewithout a subject.
For that reason we use existentialconstraints on the 'pred' of a structure to test if  it isthere.Coherence of an f -structure is equivalent to negativeexistential constraints concerning all governable functions(i.e.
functions that can appear in semantic forms) that arenot required by its semantic form.
Introduction of negativeexistential constraints for all those attributes, asdescribed above, would be a correct but ineff ic ientsolution.
Instead we use a special mark 'ngf' ,  which closesan f -structure for governable functions, i.e.
the definit ionof 'merge' is extended by an addit ional test that prohibitsthe insertion of a governable function after the 'ngf ' -mark.Example: the lexical entrypromised: V, (1' TENSE) = PAST("i" PRED) = 'PROMISE(( 1' SUBJ) (C OBJ) ('~ VCOMP))'(T VCOMP To) :c  +(t VCOMP suaJ) = ('t SU~J)is transformed tov(V,  Ex_Tests,  \[PSUBJ, POBJ, PVCOMP\[Ex_Tests\]) -->(promised\],{merge(V, \ [ tense  = past ,pred = promise(sub j ,ob j ,vcomp) ,subj = \[pred = PSUBJ \[ RSUBJ\]ebj = \[pred = POBJ \[ \ ] ,vcemp = \[to = 'C*(+,),pred = PVCOMP,subj = \[pred = PSUBJ RSUBJ\]I _  \],ngfI _ l ) ) .Treatment of Long-Distance DependenciesIn order to handle long-distance dependencies correctly, LFGprovides bounded domination metavariables.
The conditionsfor proper instantiation given by \[Kaplan/Bresnan 82\] haveto be satisfied.
They concern:- The relation between domain roots and controllers- The one-to-one assignment between domain root andeontrollee- The observance of the crossing limit.Also, bounding nodes, i.e.
nodes that are excluded from thecontrol domains of higher nodes, have to be handledcorrectly.S ~ I "  s(FS,\[np/FNPIC IN\],ZnplC OUT\],II I "  - - / /~t  ~ ExTestlN,Ex_Test_CUT ) \/NP / / /  / \ \ \/ \/ x/ 2 \/ x !
\/ I \  \ItNPTreatment of bounded domination metavariables in two stepsThe binding of the bounded domination metavariables consistsof two steps.
The first step, the identification of thedomain roots, only depends on the grammar and can be doneduring the transforgaation f the grammar ules into PROLOGclauses.The main job, the assignment between domain root andcontrollee, is performed as follows:Each goal has two extra parameters for input and output of acontroller list.
These lists, which are threaded through allnodes, except the bounding nodes, act as a global stack onwhich the controllers are pushed.
Each element of the stackrefers to a node which dominates the current goal, and whichis a domain root.A domain root adds an element o the stack before the parserenters its control domain and removes a receipt after thedomain is left.
The element that is pushed consists of theclass name (eg.
\[+wh\]) of the controller and its actualvariable.If a eontrollee appears, the stack is searched for the firstelement with the same class name (for crossing limit n thefirst n+l matching elements can be chosen) and replaces itby a receipt.
Now the controUee can use the actual variableof the controller.This treatment resembles the hold list device in the ATNformalism \[Winograd 83\] a lot, but differs in two importantaspects.By using unification to establish the correspondencebetween controller and controllee, information may flow inboth directions.A controllee does not cause a pop-operation on the stack,but a substitution of an element by a receipt.
The checkingof the receipt by the domain root ensures that a controlleecan only occur within the domain of its domain root.As an example, the transformations of LFG rules withcontroller and controllee are given:N P --, enp(Fnp, CLOr CL1, Ex Tests, Ex tests) -->13,(subst(np/Fnp, rip, CLO, CLI)).S' ~ NP \ [ \ ](t ,:ocus):-$s bar(Fs_bar, CLO, CL1, Ex_TestsO, ExTests2) -->np(Fnps \[~h/QICLO\], \[~hICL1\], Ex_festsO, Ex_Testsl)~{merge(\[q=O, focus=Fnp \[3, Fsbar)},s(Fsbar, \[np/Fnp\], \[np\], Ex_Testsl, ExTests2).Treatment of Left RecursionDefinite Clause Grammars do not allow left-recursive grammarrules when interpreted by a top-down parser.
This is aserious shortcoming for a natural language system, sincemany linguistic phenomena can be most naturally describedwith left-recursive rules (coordination, possessive NPsetc.
).In the theory of formal languages, there exist severalalgorithms to convert a grammar containing left recursioninto a weakly equivalent grammar that does not \[Aho/Ullman77\].
But in LFG, the c-structures are essential for thecorrect evaluation of f-structures, so a transformation mustprovide a way to get the right interpretation of thefunctional description.For a detailed discussion of how this can be achieved forlocally left-recursive rules, please refer to \[Eisele 85\].Experience with the SystemWe have implemented two versions of the LFG system, bothrunning on a VAX 11/780.
The first version was written bythe autlmrs in PROLOG II, using ideas of W.Frey and U.Reyle.It made use of the built-in predicates 'freeze' and 'dif',which give the possibility of delaying subgoals to optimizethe evahmtion of constraints \[Eisele 85\].To improve the flexibility of the user interface, the systemwas reimplemented in C-PROLOG by Stefan Schimpf and AndreasEisele.
It has been used for the development and testing ofdifferent grammars for fragments of English, German \[Netter86\] and French, the latter consisting of about 50 grammarrules and more than 200 lexical entries, and turned out tobe a useful tool for this purpose.The performance of the system is quite good for simplegrammars with a small amount of nondetermiuism.
Using thegrammar given in \[Kaplan/Bresnan 82\], parsing the sentence"I wondered which violin the sonata is tough for her to play on"needs about 2.3 seconds cpu time (C-PROLOG interpreter).Yet, we don't expect that our system constructs an efficientparser from an arbitrary grammar mainly for two reasons:The complexity of the LFG recognition problem is known tobe NP-complete \[Berwick 82\].- Our approach to handle nondeterminism by mere backtrackingleads to unneccessary duplications of parsing actions.Whereas the first point is highly questionable as to whetherit concerns practical grammars, there are severalpossibilities to improve the behaviour of the parser.Storing intermediate results in a chart could help toavoid multiple parsing of' the same constituents and wouldfacilitate error analysis.Explicit representation of ambiguities in f-structures(instead of a chronological enumeration) would be a steptowards a packaging of local ambiguity.But in either case, the built-in structure-sharing mechanismof PROLOG could not be used as straightforward a way as inour current system and tim definition of unification wouldhave to be considerably more complex.ReferencesAho, A.V.
and Ullman, J.D,, "Principles of Compiler Design",Addison-Wesley, Reading, Mass., 1977.Berwick, R.C., "Computational Complexity and Lexical-Functional Grammar", ACL Journal, Vol.8, 1982.Eisele, A., "A Lexical Functional Grammar System ill Prolog",LDV-Forum 2/85.Kaplan, R.M.
and Bresnan, J., "Lexical-Functioual Grammar: AFormal System for Grammatical Representation" in "MentalRepresentation of Grammatical Relations", Bresnan eds., MITPress, 1982Netter, K., "Getting Things Out Of Order", this volume.Sbieber, S.M., "An Introduction to Unification-BasedApproaches to Grammar", Tutorial Session at the 23rd AnnualMeeting of the ACL, Chicago, 1985.Winograd, T., "Language as a Cognitive Process", Vol.
lSyntax, Addison.-Wesley, Reading, Mass., 1983.553
