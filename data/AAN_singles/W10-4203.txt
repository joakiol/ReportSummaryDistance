Generating Referring Expressions with Reference Domain TheoryAlexandre DenisTALARIS team / UMR 7503 LORIA/INRIALorraine.
Campus scientifique, BP 239F-54506 Vandoeuvre-le`s-Nancy cedexalexandre.denis@loria.frAbstractIn this paper we present a reference gen-eration model based on Reference DomainTheory which gives a dynamic account ofreference.
This reference model assumesthat each referring act both relies and up-dates the reference context.
We present aformal definition of a reference domain, ageneration algorithm and its instantiationin the GIVE challenge.1 IntroductionReference is a process in which participants interpretand produce their referring expressions according tothe previous context.
But as Stalnaker puts it: thediscourse context ?is both the object on which speechacts act and the source of the information relative towhich speech acts are interpreted?
(Stalnaker, 1998).To put it briefly, referring acts not only rely on thecontext to produce a reference but also modify it.This aspect is not taken into account in the classi-cal generation algorithm by (Dale and Reiter, 1995).Each referent is generated by discriminating it insidea context.
However, the construction and update ofthis context is not adressed.Further literature on reference generation partiallygives an account for the dynamic nature of the re-ferring process.
For example in (Krahmer and The-une, 2002), each referring act increases the salienceof the referent such that further references can bemade according to a smaller context, namely the setof objects whose salience is greater than the referent?ssalience.
Reference Domain Theory (RDT) (Reboul,1998; Salmon-Alt and Romary, 2001) goes a step fur-ther by assuming that referring acts make salient thecontext sets themselves.
This theory addresses theconstruction and update of the context sets, calledin this theory reference domains.
The goal of a re-ferring act is then to discriminate a referent insidea reference domain but also a reference domain ina set of reference domains that we call here referen-tial space.
Moreover each referring act presupposesa given state of the referential space, and the ex-plicit representation of these presuppositions as con-straints on the suitable domain for interpretation orgeneration allows the implementation of a reversiblereference module.
We will focus here on generation.Details about the interpretation side of RDT can befound in (Salmon-Alt and Romary, 2001; Denis etal., 2006).However most of the previous work on RDTdoes not address computational details.
Although(Salmon-Alt and Romary, 2000) provides a genera-tion algorithm, the formal definition of a referencedomain and the explicit representation of the con-straints are not provided.
In this paper we show howRDT can be used to generate referring expressions.The context of our work is the GIVE challenge (By-ron et al, 2007; Byron et al, 2009).
This challengeaims to evaluate instruction generation systems in asituated setting.
The goal is to provide instructionsto a player in a 3D maze in order to guide him to finda hidden trophy.
We are here interested with the re-ferring aspect involved in GIVE: the player has topush buttons to open doors or disable alarms, thusthe system has to generate referring expressions tothese buttons.We first present in section 2 some definitions, thenin section 3 we detail a generic generation algorithm.Section 4 shows a use case of RDT in the context ofthe GIVE challenge and provides a detailed exam-ple of the reference process.
The presented model isgeneric, but all the examples given throughout thepaper refer to the GIVE setting.
Eventually, in sec-tion 6 we conclude the paper by demonstrating thesuccess of RDT in an evaluation based on the GIVEsetting.2 DefinitionsThe referring process is a discrimination processwhose goal is to discriminate one or more individ-uals in a context set.
The discrimination can makeuse of different sources of information.
It can be asemantic discrimination, for instance by uttering se-mantic properties possessed by the referent to ruleout distractors, e.g.
?the blue button?.
It can bea discrimination of the focus, that is to make use ofthe current center of attention, e.g.
?this button?or ?the other button?.
The discrimination can alsorely on the previous referring acts, for instance whenuttering ?Push a blue button.
Yes this one?, where?this one?
would be unambiguously uttered in a con-text of a red and a blue button thanks to the mentionof ?a blue button?.
A reference model has to takeinto account these different ways to discriminate.On the other hand, a reference model has also toconsider how objects are grouped together to formthe context sets.
They can be constructed thanks tosimilarity or proximity of objects (Thorisson, 1994),by the gestures that are made (Landragin, 2006) orby the discourse itself (Denis et al, 2006).
We willbe limited to the dimension of semantic similarity inthis paper.RDT claims that the context sets (reference do-mains or RD) are structures that both gather indi-viduals and discriminate them.
A reference domainis basically a set of objects that share some seman-tic description N .
A partition that discriminates theelements is also attached to the domain.
The parti-tion is based on a differentiation criterion such thattwo elements being discriminated with this criterionare put in two different equivalency classes.
For in-stance, in a domain of two buttons, one blue andone red, the two individuals share the same type andare differentiated with the color.
While each one is?a button?, they can unambiguously be referred towith ?the blue button?
and ?the red button?
(or evenshorter ?blue?, ?red?
).Different elements of a domain may be more or lessfocused/salient depending on the visual scene, or onthe previous discriminations.
We are assuming thatthe focus is defined as the most salient parts of thepartition of a domain and can thus be represented asa subset of the partition.
This is a binary state, thatis, a part is focused or not.
While it removes thepossibility to have different degrees of focus inside adomain, it would help modeling a preference to focussimilar objects together.
We did not explore thoughthe empirical relevance of this hypothesis.We assume that each domain could be said moreor less salient in a set of reference domains, calleda referential space or RS.
The referential space is astorage for the domains that have been created sofar.
We consider here it is unique and shared.
In theGIVE setting, the RS is actually not shared becausethe player does not know the maze a priori while thesystem knows it completely.
But we assume that theRS is limited to the current room where the player isstanding.
Each time the player enters a new room,the RS is refreshed and a new one is built.
We thensuppose that the player is able to access the objectsby walking around, and hence that the RS is shared,removing problems related to asymmetry.The referential space provides a traversal order forthe reference domains it contains.
The most salientRD are tested first.
While it would be interestingto model visual salience in the GIVE setting (Lan-dragin, 2006), we are limited to equate salience andrecency.
Thus, each domain will be associated to anumber indicating how recently it has been selected.The way the salience or the whole RS is affected bythe discrimination process is described in section 3.2.We now provide a formal definition of a reference do-main and a referential space building algorithm.2.1 Reference domainsWe assume that ?E, V ?
is an environment composedof E, the universe of all objects and V , the setof ground predicates that hold in the environment.Props is a set of unary predicates names such as blue,red, left, or right.
Types is a set of types of unarypredicates such as color, or position.
We distinguishtwo disjoint subsets of Types, Typespers the persis-tent types, that are all the properties that describepermanently the objects, and Typestrans the tran-sient types, that are all the properties that changeacross time.
val is the function val : Types?
2Propswhich maps a type on the predicates names, e.g.val(color) = {blue, red, green, yellow}A reference domain D is a tuple?GD, SD, ?D, (c, P, F )?where:?
GD ?
E is the set of objects of the domain,called the ground of the domain.?
SD ?
Props is the semantic description of thedomain, such that ?p ?
SD,?x ?
GD, p(x) ?
V ,that is, SD is a description satisfied for all theelements of the ground.?
?D ?
N is the salience of the domainAnd (c, P, F ) is a partition structure where:?
c ?
Types is a differentiation criterion?
P is the partition generated by c, that is, if wedefine the equivalence relationRc(x, y) ?
?p ?
val(c), p(x) ?
V ?
p(y) ?
Vthen P = GD/Rc, i.e.
P is the quotient set ofGD by Rc.?
F ?
P is the focus of P .For instance, a domain composed of two buttons,b1 a blue button and b2 a red button, with a salienceequal to 3, where b1 and b2 are differentiated usingthe color, and where b1 is in focus, would be notedas:D =?
{b1, b2}, {button}, 3,(color, {{b1}, {b2}}, {{b1}})?2.2 Referential spaceThe referential space RS is the set of existing do-mains.
In the GIVE context, we assumed that it isboth shared and refreshed each time the player entersa room.
The initial construction of the RS consistsin grouping all the objects of the room that are sim-ilar inside new reference domains.
The RS can beviewed as a tree-like structure whose nodes are RD.The root node is a RD whose ground is all objects ofthe room.
For a node domain D, and for each partof its partition which is not a singleton, there existsa child domain which discriminates the elements ofthe part.
In other words, if a domain does not dis-criminate some individuals of its ground there existsanother domain which does.
Formally, the RS has torespect the following proposition where PD denotesthe partition of D.?D ?
RS,?P ?
PD,|P | > 1?
?D?
?
RS;GD?
= P ?
|PD?
| > 1In order to make sure that all the individuals couldbe discriminated, and thus focused, we introduce thedefault partition structure of a set X, which is a par-tition structure where the criterion is the identifierof objects and that contains then only singletons, wenote def(X) the default partition of a set X, that isdef(X) = (id, X/Rid, ?
).To build initially the RS, the grouping algorithm(figure 1) is the following: it takes a list of types T(T0 means the head, and T1..n the tail) which corre-sponds to different properties to group the objects.We are here only using the permanent properties ofobjects, that is in GIVE their type and their color,ordered arbitrarly.
It takes also an input domainwhich has a default partition.
It then tries to parti-tion the ground of this domain with the first prop-erty.
If this property does not partition the ground,the next property is tested.
If this property parti-tions the ground, a new domain is created for eachnon-singleton part of the partition, and the algo-rithm tries to partition it with the next property,so on recursively.
We note sh(X, c) the set of prop-erties of the type c that are shared by all elements ofX: sh(X, c) = {p|p ?
val(c),?x ?
X; p(x) ?
V }.This partitioning algorithm is slightly differentfrom the partitioning algorithm called IApart foundin (Gatt and van Deemter, 2007).
First, it only par-titions a set of objects using one unique property,whereas in IApart the same set of objects can bepartitioned several times.
And second, while IApart?destroys?
the ground that is partitioned, our par-titioning algorithm maintains both the ground andthe partition attached to the domain.1: RS ?
RS ?
{D}2: if T 6= ?
then3: P ?
GD/RT04: if |P | = 1 then5: SD ?
SD ?
sh(GD, T0)6: createPartitions(D, T1..n, RS)7: else8: set (T0, P, ?)
as D?s partition structure9: for all X ?
P such that |X| > 1 do10: D?
?
?X,SD ?
sh(X,T0), ?D,def(X)?11: createPartitions(D?, T1..n, RS)12: end for13: end if14: end ifFigure 1: createPartitions(D, T , RS)3 ReferringIn this section we detail the generation algorithmin RDT.
It implements a dynamic view of referringwhereby each referring act updates the current ref-erential space.
This incremental update of the refer-ential space proceeds in three steps.
First, a domaincontaining the referent is found.
Then this domainis used to match a so called underspecified domain(Salmon-Alt and Romary, 2001).
Third, the inputRS is restructured relative to the selected referencedomain.The approach enables the implementation of atype B reversible reference module (Klarner, 2005),that is a module in which both directions share theExpression U(N, t) matches D iff ?
(c, P, F ) ?
D;this one F = {{t}} ?
msd(D)this N F = {{t}} ?
t ?
NIthe N t ?
NI ?
{t} ?
P ?
?X?P,X 6={t}?X?NI =?the other one F 6= ?
?
P \ F = {{t}} ?
msd(D)the other N F 6= ?
?
P \ F = {{t}} ?GD ?
NIanother one F 6= ?
?
{t} ?
P \ F ?
msd(D)another N F 6= ?
?
{t} ?
P \ F ?GD ?
NIa N t ?
NI ?
t ?
GDTable 1: Underspecified domains for each type ofreferring expressionsame resources, namely a set of underspecified do-mains.
In interpretation, the goal is to check foreach existing domain if it matches the underspeci-fied domain obtained from the referring expression.In generation, the idea is the opposite, that is, tocheck from an existing domain and a referent, whichunderspecified domain matches them.We first introduce the different types of underspec-ified domains.
We then present the overall referringalgorithm and the process steering the continuousupdate of the referential space.3.1 Underspecified domainsAn underspecified domain (UD) represents a par-tially specified reference domain corresponding to theconstraints carried by a referring act.
We will saythat an underspecified domain matches a referencedomain if all the constraints of the UD are satis-fied for the reference domain.
There may be con-straints on the ground of the domain, its salienceor the existence of a particular partition structure.Table 1 summarizes most of the types of under-specified domains described in (Salmon-Alt and Ro-mary, 2000; Salmon-Alt and Romary, 2001).
Eachunderspecified domain is noted U(N, t), where t isthe intended referent and N ?
Props is a seman-tic description.
We will note NI the set of ob-jects that have the semantic description N that isNI = {x|x ?
E,?p ?
N, p(x) ?
V }.
We assumethere is for each description N a given wording, andwe will write for instance ?the N?
to denote a defi-nite RE where N has to be replaced by the wordingof N .
The notation msd(D) stands for most salientdescription, that is, there is no more salient domainthan D with a different description.
This is equiva-lent to @D?
?
RS;?D?
?
?D ?
SD?
6= SD.The indefinite ?a N?
can always be generated butmay be ambiguous.
The only constraint placed on adomain by the corresponding UD is that it containsan element of type N. For example, the domain D1 =?
{b1, b2, b3}, {button}, 0, (color, {{b1, b2}, {b3}}, ?
)?does not differentiate b1 from b2, the only way wecould access to b1 would be by uttering ?a bluebutton?.The definite expression ?the N?
requires that thetarget forms a semantically disjoint part in the ref-erence domain partition.
For example, in the abovedomain D1, ?the red button?
can be used to refer tob3.Like the definite and indefinite, the demonstrative?this N?
requires that the referent is of type N (be-longs to NI), but also requires the existence of a fo-cused partition containing exactly the referent.
Forexample, if a domain of blue buttons contains a par-tition structure such that P = {{b1}, {b2}}, it is pos-sible to refer to b1 given that F = {{b1}} by uttering?this blue button?, but it would not be the case ifF = {{b1}, {b2}}.Alternative phrases such as ?another/the other N?both require that there is already something in focuswhich is not the referent.
Definite alternative phrasesrequire that the unfocused part of the partition con-tains exactly the target referent while indefinites onlyrequire that the unfocused part contains the referent.For example, if there is a domain of three blue but-tons b1, b2, b3 with a partition structure such thatF = {{b2}}, it is possible to use the indefinite ?an-other blue button?
to refer to b1 while it would not bepossible to use the definite ?the other blue button?.One-anaphora of the form ?this/another/the otherone?
can be generated only if the description of thedomain in which the referent has to be discriminatedis already salient, in other words that msd(D) is true.For example, if the most salient domain in RS is adomain of blue buttons, it would not be possible toutter ?this one?
to refer to a red button inside a lesssalient domain.3.2 Generation algorithmThe referring algorithm (figure 2) proceeds in threesteps as follows.The first step (line 1?2) determines in which refer-ence domain, referring will be processed and thereby,which description will be used for instantiating theunderspecified domains.
The selected RD is the mostsalient RD with the smallest ground containing thetarget referent.
If there are several such RD, anarbitrary one is picked.
If the selected domain isD = ?GD, SD, ?D, (c, P, F )?, then the description Sused to instantiate the underspecified domain is theconjunction of the properties in the description SDwith the value of the differentiation criterion usedto create the partition namely, properties of val(c)true of the referent (line 2).
If the criterion is theidentifier, it is ignored in S. For instance, if there isa domain of buttons with a partition on color, thedescription might be {button, blue}.In the second step, the algorithm iterates throughthe underspecified domains instantiated with S andselects the first that matches.
The order in whichunderspecified domains are tested is particularly im-portant.
We use (Gundel et al, 1993) Givenness hi-erarchy and ordered the UDs based on the cognitivestatus of the corresponding referent.
We extendedthe hierarchy to include alternative NPs: ?this one?> ?this N?
> ?the N?
> ?the other one?
> ?theother N?
> ?another one?
> ?another N?
> ?a N?.In the third step, the referential space is restruc-tured by either creating a new domain or increasingthe salience of an existing domain (Figure 3).
Thegoal of this restructuring step is to be able to re-strict the further focus to a smaller domain.
Forinstance, when dealing with red buttons we wantto avoid focusing the blue buttons.
The functionfirst gathers all objects of D that have the persis-tent part of description S (Gp and Sp), and if thereis already a domain composed by these objects, itssalience is increased such that it is the most salient(line 4).
If there is no such domain, a new mostsalient domain is created with these objects and adefault partition.
Transient properties are not takeninto account to regroup the objects because it wouldrestrict too much further focus.
For instance, limit-ing the restructuring to persistent properties avoidssequences like ?Push the button on the right.
Yeahthis one?.For example in a domain D containing a buttonb1 and a chair c1,D =?
{b1, c1}, ?, 0,(objType, {{b1}, {c1}}, ?
)?a reference to b1 could lead to the generation ofthe expression ?the button?, the restructuring makessure to create a new domain whose ground is only{b1}.
Therefore, we avoid producing unecessary ref-erence to the chair such as ?Not this chair!
Look forthe button?
(see section 4).3.3 Dealing with pluralsThe plurals treatment is quite similar to the singu-lar cases, but we need to do two modifications tobe able to generate plurals.
The first modificationis about the underspecified domains.
Whereas wehad individuals, here we want to generate an RE toa set of targets T = {t1..tn}.
The UDs can eas-ily be modified by just replacing every occurrenceof {t} by T (and t ?
NI by T ?
NI).
With thismodification, we can only generate plurals for sets of1: D ?
most salient/specific domain containing t2: S ?
SD ?
{p|p ?
val(c), p(t) ?
V }3: for all U(S, t) sorted by Givenness do4: if U(S, t) matches D then5: restructure(D, S, RS)6: return U(S, t)7: end if8: end for9: return failureFigure 2: generate(t, RS)1: Sp ?
{p|p ?
S, val?1(p) ?
Typespers}2: Gp ?
{x|x ?
GD,?p ?
Sp, p(x) ?
V }3: if ?D?
?
RS;GD?
= Gp then4: ?D?
?
max?
(RS) + 15: else6: D?
?
?Gp, Sp,max?
(RS) + 1,def(Gp)?7: RS ?
RS ?
{D?
}8: end ifFigure 3: restructure(D, S, RS)objects that are parts of an existing partition.
Imag-ine we have GD = {b1, b2, b3, b4}, and a partitionP = {{b1, b2}, {b3, b4}} then it is not possible to referto {b2, b3} using a demonstrative because they can-not be focused together.
It may be possible to adaptthe UD to consider?F instead of F , that is for in-stance instead of F = {T} we would require that?F = T .
But this possibility and its side-effectshave not been yet explored.The second modification is related to the gener-ation algorithm and the description used to buildthe underspecified domains.
Instead of retrieving theproperties of the differentiation criterion for a singletarget we need to make sure that the properties aretrue for all the targets, that is (line 2), we need tohave S ?
SD ?
{p|p ?
val(c),?t ?
T, p(t) ?
V }.4 Generation in the GIVE challengeWe present here how the generation module has beeninstantiated in the second edition of the GIVE chal-lenge (Byron et al, 2007).First, each time the player enters a new room,the partition algorithm is called on an initial domainDr = ?Gr, ?, 0,def(Gr)?, with Gr ?
E the set of allobjects in the room, and the list of GIVE persistenttypes, that is objType, the type of objects, and color.We then use the above referring algorithm in twoways.
First, it is used to produce a first mention us-ing only persistent properties and without updatingthe focus.
Second, it is used to produce a series ofadditional subsequent mentions whose function is toguide the player search.
In this second step, tran-sient spatial properties are used and the visual focusis continuously updated.4.1 First mentionThe referring algorithm just described (cf.
Figure 2)takes as input the current referential space RS, gen-erates a referring expression for the target referentt and outputs a push instruction of the form ?Push?+v(generate(t, RS)) where v is the verbalizationfunction.
Note that the referential space may con-tain domains with focused partitions coming fromprevious references to other objects, and therefore isnot limited to producing definite or indefinite NPs.4.2 Subsequent mentionsAll the subsequent mentions assume that the firstmention has been performed but has not succeededyet in identifying the referent.
They are all based onfocus and potentially on transient properties.
Thefocus is defined as the set of visible objects.
The al-gorithm (figure 4) first updates the focus of the parti-tion of the most salient/specific domain D containingthe target t. Then the rest of the algorithm gener-ates different instructions depending on whether thetarget is or is not focused.The lines 7?8 refine the focus using relative spa-tial properties of objects in their domain.
It firstcomputes these new properties hpos and vpos for allobjects in?F , and adds them in V .
The refinementis made by calling the partition function (algorithm1) on a new domain DF = ?GF , SD, ?D+1,def(GF )?,using [hpos,vpos].
The salience of DF is just higherthan the salience of D such that DF is preferredover D when generating.
This refinement allowsproducing expressions like ?the blue button on theright?.
Because these properties are transient, theyare erased from V after the generation and all thedomains and partitions that may have been createdusing them including DF are also erased.Other lines produce expressions if the referent isnot in focus.
If there is nothing in focus, it produces?Look for X?
where X is an RE for the referent.
Ifthere is something in focus which is not the referent,it first produces ?Not X?
where X is an RE designat-ing what is in focus, then ?Look for X?
where X is anRE for the referent.
Note that this is the only placewhere plurals can be generated (see section 3.3).5 Detailed exampleWe present here a detailed example of the behaviorof the reference module in the GIVE setting (Table2).
We assume that the player U enters a room with1: D ?
most salient/specific domain containing t2: F ?
focus of the visible objects in D3: GF ?
?F4: if t ?
GF then5: if |GF | > 1 then6: computePositions(GF )7: DF ?
?GF , SD, ?D + 1,def(GF )?8: createPartitions(DF , [hpos,vpos], RS)9: end if10: return ?Yeah!
?+v(generate(t, RS))+?
!
?11: else12: if |GF | = 0 then13: return ?Look for ?+v(generate(t, RS))14: else15: return ?Not ?+v(generate(GF , RS))+?
!Look for ?+v(generate(t, RS))+?
!
?16: end if17: end ifFigure 4: Algorithm to instruct the search for a ref-erentstate of U utterance of SPush a blue button (b1)see(b2) Not this one!
Look for the other one!see(b1,b2) Yeah!
The blue button on the right!see(b1) Yeah!
This one!push(b1)Push the red button (b3)see(b3) Yeah!
This one!push(b3)Push the other blue button (b2)Table 2: Utterances produced by the system Sthree buttons, two blue buttons, b1 and b2 and a redbutton b3.5.1 Initializing the referential spaceAs soon as the player enters the room, the partitionalgorithm is called on the initial domain:D0 = ?Gr, ?, 0, def(Gr)?with Gr = {b1, b2, b3}.
The result is the RS :D0 =?
{b1, b2, b3}, {button}, 0,(color, {{b1, b2}, {b3}}, ?
)?D1 =?
{b1, b2}, {button, blue}, 0,(id, {{b1}, {b2}}, ?
)?We will note the RS by grouping the domains thathave the same salience and indicating the salienceof a set of domains in subscript.
That is, after theconstruction, the RS is: {{D0, D1}0}.5.2 ?Push a blue button?The system is first required to refer to b1.
As all thedomains all are equally salient, the algorithm tries topick the most specific domain containing b1, and itfinds D1.
The description used to refer to b1 is thedescription of the domain SD1 = {button, blue} andthe value for the criterion which is the identifier andis then ignored.
Inside D1 it then tries to refer tob1 by iterating through the underspecified domainsto find the first one that matches D1.
Because thereis no focus at this moment, the first found UD thatmatches is ?a N?.
It then performs restructurationof the RS, by trying to build a new subdomain ofD1.
However, because there are only blue buttonsin D1, no subdomain is created and the salience ofD1 is increased.
Eventually, the expression is verbal-ized and ?Push a blue button?
is uttered.
After thisreference, the RS is then {{D1}1, {D0}0}.5.3 ?Not this one!
Look for the other one!
?Before the subsequent mentions to b1 are made, thefocus of the most salient/specific domain containingb1 is updated.
We assume first that only b2 is visible,thus D1 becomes:D1 =?
{b1, b2}, {button, blue}, 1,(id, {{b1}, {b2}}, {{b2}})?According to the algorithm in figure 4, a referenceto b2 has to be made first ?Not b2!?.
Underspeci-fied domains are iterated and the first that matchesis ?this one?
considering that {blue, button} is themost salient description and b2 is in focus.
No sub-domain is created when restructuring the RS, onlythe salience of D1 is increased.
The uttered expres-sion is then ?Not this one!?.
As for the referenceto b1, the reference is still made in D1 and the firstUD that matches is ?the other one?.
No restructur-ing apart from increasing salience is performed andthe returned expression is eventually ?Look for theother one!?.
So, after referring to b2 and b1, the RSis {{D1}3, {D0}0}.5.4 ?The blue button on the right?We enjoined the player to turn around to search forb1.
We assume here that he did so and now can seeboth b1 and b2.
Before any reference can take place,the focus of D1 is updated:D1 =?
{b1, b2}, {button, blue}, 3,(id, {{b1}, {b2}}, {{b1}, {b2}})?However, the focus can no more discriminate bothbuttons, and a refinement with the position has to beperformed according to the algorithm 4.
We assumethat b1 is on the right while b2 is on the left.
Positionsare computed and new ground predicates are addedto V : {right(b1), left(b2)}.
A new domain D2 with aground equal to the focus of D1, that is {b1, b2}, isbuilt and used as input for the partition algorithm.It is partitioned along the horizontal position (hpos),and then added to the RS, that is:D2 =?
{b1, b2}, {button, blue}, 4,(hpos, {{b1}, {b2}}, ?
)?Before the reference to b1, the RS is then{{D2}4, {D1}3, {D0}0}.
A new reference to b1 isthen made, but as D2 is more salient than D1 itis preferred for the reference.
The first UD thatmatches is the definite ?the N?
built with the de-scription {button, blue, right}, and ?the blue buttonon the right?
is uttered.
However, because D2 wasbuilt with transient properties, it is erased from theRS and is recreated before each reference unless theplayer changes its visual focus.5.5 ?Yeah!
This one!
?Now we assume that the player turned around againand only sees now b1.
The most salient/specific do-main containing b1 is D1 and its focus is updated:D1 =?
{b1, b2}, {button, blue}, 3,(id, {{b1}, {b2}}, {{b1}})?The first matching UD is the demonstrative one-anaphora ?this one?, no restructuring takes place ex-cept the increased salience of D1 and ?Yeah!
Thisone!?
is produced.
The RS is thus {{D1}4, {D0}0}.5.6 ?Push the red button?We assume that given all these referring expressions,the player is at last able to push b1.
A new referencehas to be made, this time to b3, the red button.
Themost salient/specific domain containing b3 is actuallyD0.
In D0, the first matching underspecified domainis the definite ?the N?.
The restructuring leads thistime to create a new most salient domain D3 com-posed only of b3 (because it is the only red button):D3 =?
{b3}, {button, red}, 5,(id, {{b3}}, ?
)The further reference to objects will thus avoid re-ferring to something else than red buttons (see sec-tion 3.2).
The RS is then {{D3}5, {D1}4, {D0}0}.5.7 ?Yeah!
This one!
?Provided that D3 is now the most salient/specificcontainer of b3, b3 can be focalized in the defaultpartition of D3, resulting in:D3 =?
{b3}, {button, red}, 5,(id, {{b3}}, {{b3}})?The first matching UD is then ?this one?, the re-structuring just increases the salience of D3 and thesystem utters eventually ?Yeah!
This one!?.
TheRS is then {{D3}6, {D1}4, {D0}0}.
Note that, evenif the player would turn around and see b1 or b2 inthe same time than b3, D3 being the current mostsalient/specific domain, b1 or b2 would not be fo-cused.5.8 ?Push the other blue button?We now have to refer to the last button b2.
Themost salient/specific domain containing b2 is D1,however D1 contains already a focus to b1.
Thus,the first matching UD is ?the other N?.
Note thatwe only considered visual focus, therefore the alter-native anaphora ?the other?
does not refer to b2 be-cause we already mentioned b1 but only because itis the last object the player saw in D1.
By chance,in the GIVE setting, the visual focus correspondsto the linguistic focus and thus uttering ?Push theother blue button?
sounds natural.
It would be morecomplex to handle a setting with both the linguisticand the visual focus, but we think that the RDT iswell-equipped to resolve this issue.6 EvaluationWe evaluated the RDT generation model by compar-ing its performances with another system also com-peting in the GIVE challenge but based on a clas-sical approach on (Dale and Haddock, 1991) that isrestricted to generating definite and indefinite NPs.We designed a special evaluation world to test severalreference cases, and for both approaches, we mea-sured the average time from the moment of utteringa first mention designating a button to the momentof completion, that is when the button is success-fully pushed.
We also measured the average numberof instructions that were provided in the meantime.The evaluation has been conducted with 30 subjectsresulting in 20 valid games.
The results show thatthe RDT performs better than the classical strategy,both for the average completion time (8.8 secondsversus 12.5 seconds) and for the number of instruc-tions (6.4 versus 9.3).
We conjecture that the goodresults of RDT can be explained by the lower cog-nitive load resulting from the use of demonstrativeNPs and one-anaphoras.7 Other works and extensionsWhile some RE generation models focus on the sideof generating the description itself (Dale and Re-iter, 1995; Krahmer et al, 2003), we tried to focusmore on the side of generating the determiner.
Whileworks such as (Poesio et al, 1999) also generates thedeterminer, they rely on statistical learning of thisdeterminer.
On the contrary we did so by represent-ing logically the constraints carried by a referring ex-pressions on the context of its interpretation.
How-ever, the presented model has several limits.
First,as (Landragin and Romary, 2003) describe, there isno one-to-one relation between the referring expres-sions and the referring modes.
In order to tackle thisproblem we can associate a set of UD to a referringexpression.
We only need then to add an additionalloop on the different UDs for a given type of referringexpression.
The second extension is the possibilityto have several partitions.
It is also possible to it-erate over the set of partitions of a domain, but wethen need to consider the salience of each partition.In addition, the restructuring has to be amended toincrease the salience of the partition in which a gen-eration is made.8 ConclusionsWe presented a reference generation algorithm basedon Reference Domain Theory.
The main improve-ment of this algorithm over existing approaches isthe construction and update of a set of local con-texts called a referential space.
Each local context(reference domain) can be used as a context for re-ferring.
The dynamic aspect of the reference processconsists both in the continuous update of the ref-erence domains and in the update of the referentialspace.
Thus, the presented algorithm can generate avariety of referring expressions ranging from definite,indefinite to demonstrative, alternative phrases, one-anaphora and plurals.
The instantiation in the GIVEchallenge was a baptism for the generation algorithmand the GIVE setting offered us a good opportunityto test the serial nature of the reference process.
Itenabled us to evaluate the RDT approach and provedthat it is successful.We would like to thank Luciana Benotti, ClaireGardent, and the people participating to the GIVEchallenge at the LORIA for their help during themodel development.
We also would like to thank theanonymous reviewers for their precious insights.ReferencesDonna K. Byron, Alexander Koller, Jon Oberlander,Laura Stoia, and Kristina Striegnitz.
2007.
Gener-ating instructions in virtual environments (GIVE):A challenge and an evaluation testbed for NLG.In Proceedings of the Workshop on Shared Tasksand Comparative Evaluation in Natural LanguageGeneration, Washington, DC.Donna Byron, Alexander Koller, Kristina Striegnitz,Justine Cassell, Robert Dale, Johanna Moore, andJon Oberlander.
2009.
Report on the First NLGChallenge on Generating Instructions in VirtualEnvironments (GIVE).
In Proceedings of the 12thEuropean Workshop on Natural Language Gen-eration (ENLG 2009), pages 165?173, Athens,Greece, March.
Association for ComputationalLinguistics.Robert Dale and Nicholas J. Haddock.
1991.
Gener-ating referring expressions involving relations.
InProceedings of the 5th Conference of the EuropeanChapter of the ACL, EACL-91.Robert Dale and Ehud Reiter.
1995.
Computationalinterpretations of the gricean maxims in the gen-eration of referring expressions.
Cognitive Science,19(2):233?263.Alexandre Denis, Guillaume Pitel, and MatthieuQuignard.
2006.
Resolution of Referents Group-ings in Practical Dialogues.
In Proceedings of the7th SIGDial Workshop on Discourse and Dialogue- SIGdial?06, Sydney Australia.Albert Gatt and Kees van Deemter.
2007.
Incre-mental generation of plural descriptions: Similar-ity and partitioning.
In Proceedings of the Confer-ence on Empirical Methods in Natural LanguageProcessing, EMNLP-07.Jeanette K. Gundel, Nancy Hedberg, and RonZacharski.
1993.
Cognitive status and the formof referring expressions in discourse.
Language,69(2):274?307.Martin Klarner.
2005.
Reversibility and re-usabilityof resources in NLG and natural language dia-log systems.
In Proceedings of the 10th Euro-pean Workshop on Natural Language Generation(ENLG-05), Aberdeen, Scotland.Emiel Krahmer and Marit Theune.
2002.
Effi-cient context-sensitive generation of referring ex-pressions.
In K. van Deemter and R. Kibble, edi-tors, Information sharing: Givenness and newnessin language processing, pages 223?264.
CSLI Pub-lications, Stanford.Emiel Krahmer, Sebastiaan van Erk, and Andr Ver-leg.
2003.
Graph-based generation of referringexpressions.
Computational Linguistics, 23:53?72.Fre?de?ric Landragin and Laurent Romary.
2003.
Re-ferring to Objects Through Sub-Contexts in Multi-modal Human-Computer Interaction.
In Proceed-ings of the Seventh Workshop on the Semanticsand Pragmatics of Dialogue (DiaBruck?03), pages67?74.
Saarland University.Fre?de?ric Landragin.
2006.
Visual perception, lan-guage and gesture: A model for their understand-ing in multimodal dialogue systems.
Signal Pro-cessing, 86(12):3578?3595.Massimo Poesio, Renate Henschel, Janet Hitzeman,and Rodger Kibble.
1999.
Statistical NP genera-tion: A first report.
In Proceedings of the ESSLLIWorkshop on NP Generation, Utrecht.Anne Reboul.
1998.
A relevance theoretic approachto reference.
In Acts of the Relevance TheoryWorkshop, University of Luton, England.Susanne Salmon-Alt and Laurent Romary.
2000.Generating referring expressions in multimodalcontexts.
In Workshop on Coherence in GeneratedMultimedia - INLG 2000, Mitzpe Ramon, Israel.Susanne Salmon-Alt and Laurent Romary.
2001.Reference resolution within the framework of cog-nitive grammar.
In Proceeding of the InternationalColloquium on Cognitive Science, San Sebastian,Spain.Robert Stalnaker.
1998.
On the representation ofcontext.
Journal of Logic, Language and Informa-tion, 7(1):3?19.Kristinn R. Thorisson.
1994.
Simulated perceptualgrouping: An application to human-computer in-teraction.
In Proceedings of the Sixteenth AnnualConference of the Cognitive Science Society, At-lanta, Georgia.
