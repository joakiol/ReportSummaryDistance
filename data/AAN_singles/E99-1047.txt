Proceedings of EACL '99#-TBL Lite: A Small, ExtendibleTransformation-Based LearnerTorbj6rn LagerDepartment ofLinguisticsUppsala UniversitySWEDENTorbjorn.Lager@ling.uu.seAbst ractThis short paper describes - and in factgives the complete source for - a tinyProlog program implementing a flexi-ble and fairly efficient Transformation-Based Learning (TBL) system:1 IntroductionTransformation-Based Learning (Brill, 1995) is awell-established learning method in NLP circles.This short paper presents a 'light' version of the#-TBL  sys tem - a genera/, logically transparent,flexible and efficient ransformation-based l arnerpresented in (Lager, 1999).
It turns out thata transformation-based l arner, complete with acompiler for templates, can be implemented in lessthan one page of Prolog code.2 #-TBL Rules &= RepresentationsThe point of departure for TBL is a tagged initial-state corpus and a correctly tagged training cor-pus.
Assuming the part-of-speech tagging task,corpus data can be represented by means of threekinds of clauses:wd(P,W) is true iff the word W is at position P in thecorpustag(P,A) is true iff the word at position P in thecorpus is tagged Atag(A,B,P) is true iff the word at P is tagged A andthe correct ag for the word at P is BAlthough this representation may seem a bit re-dundant, it provides exactly the kind of indexinginto the data that is needed3 A decent Prologsystem can deal with millions of such clauses.1 Assuming a Prolog with first argument indexing.The #-TBL systems are implemented in SICStus Pro-log.The object of TBL is to learn an ordered se-quence of transformation rules.
Such rules dictatewhen - based on the context - a word should haveits tag changed.
An example would be "replacetag vb with nn if the word immediately to the lefthas a tag dr." Here is how this rule is representedin the #-TBL rule/template formalism:tag:vb>nn <-tag:dr@\[-1\].Conditions may refer to different features, andcomplex conditions may be composed from sim-pler ones.
For example, here is a rule saying "re-place tag rb with j j ,  if the current word is "only",and if one of the previous two tags is dr.":tag:rb>jj <- wd:only@\[O\] ~ tag:dt~\[-l,-2\].Rules that can be learned in TBL are instancesof templates, such as "replace tag A with B if theword immediately to the left has tag C", where A,B and C are variables.
In the/~-TBL formalism:t3(A,B,C) # tag:A>B <- tag:C~\[-l\].Positive and negative instances of rules that areinstances of this template can be generated bymeans of the following clauses:pos (t3(A,B,C)) :-dif(A,B),tag(A,B,P),Pl is P-l,tag(Pl,C).neg(t3(A,B,C)) :-tag(A,A,P),P1 is P-l,tag(Pi,C).Tied to each template is also a procedure that willapply rules that are instances of the template:app(t3(A,B,C)) :-(tag(A,X,P), Pl is P-l, tag(Pl,C),retract (tag(A,X,P)), retract (tag(P,A)),assert(tag(B,X,P)), assert(tag(P,B)),fail ; true).3 The #-TBL Template CompilerTo write clauses such as the above by hand forlarge sets of templates would be tedious and proneto errors.
Instead, Prolog's term expansion facil-ity, and a couple of DCG rules, can be used tocompile templates into Prolog code, as follows:279Proceedings of EACL '99term_expansion((ID # A<-Cs),\[(pos(ID) :- Gt),(neg(ID) :- G2),(app(ID) :- (G3,fail;true))\]) :-pos((A<-Cs),Ll,\[\]), list2goal(Li,Gl),neg((A<-Cs),L2,\[\]), list2goal(L2,G2),app((A<-Cs),L3,\[\]), list2goal(L3,G3).pos((F:A>B<-Cs)) -->{G =.. \[F,A,B,P\]},\[dif(A,B),G\], cond(Cs,P).neg((F:A>_<-Cs)) -->{G =.. \[F,A,A,P\]}, \[G\], cond(Cs,P).app ( (F: A>B<-Cs) ) -->{G1 =.. \[F,A,X,P\], G2 =.. \[F,P,A\],G3 =.. \[F,B,X,P\], G4 =.. \[F,P,B\]},\[GI\], cond(Cs,P), \[retract(Gl),retract(G2), assert(G3), assert(G4)\].cond((C~Cs),P) --> cond(C,P), cond(Cs,P).cond(FA?Pos,PO) --> pos(Pos,PO,P), feat(FA,P).pos(Pos,P0,P) -->\[member(0ffset,Pos), P is P0+0ffset\].feat(F:A,P)--> {G =.. \[F,P,A\]}, \[G\].4 The #-TBL Lite LearnerGiven corpus data, compiled templates, and avalue for Threshold, the predicate tb l /1  imple-ments the /~-TBL main loop, and writes a se-quence of rules to the screen:tbl (Threshold) :-( setof (N-Rule,L" (bagof (.
,pos (Rule) ,L),length(L,N), N >= Threshold) ,FL),reverse (FL, RevFL),bestof (RevFL, dummy, Threshold, Winner),dif (Winner, dummy)-> write(Winner) ,nl,app (Winner),tbl (Threshold); crue).The call to the setof-bagof combination generatesa frequency listing of all positive instances of alltemplates, based on which the call to besto f /4then selects the rule with the highest score, tb l /1terminates if the score for that rule is less than thethreshold, else it applies the rule and goes on tolearn more rules from there.bestof (FL0, Leader, HiScore, Winner) ?
-( FL0 = \[Pos-Kule\]FL\] ,Pos > HiScore-> Max is Pos-HiScore,( count0 (neg (Rule) ,Max,Neg)-> bestof (FL,Rule,Pos-Neg,Winner); bestof (FL, Leader, HiScore, Winner))Winner = Leader).To compute the rule with the highest score,besto f /4  traverses the frequency listing, keepingtrack of a leading rule and its score.
The score ofa rule is calculated as the difference between thenumber of its positive instances and its negativeinstances.
When the list of rules is empty or thenumber of positive instances of the most frequentrule in what remains of the list is less than theleading rules score, the leader is declared winner.The following procedure implements the count-ing of negative instances in an efficient way:count0 (G,M,N) :-( bb_put(c,O), G, bb_get(c,NO),N is NO+l, bb_puZ(c,N), N > M-> fail; bb_get (c, N)).5 p -TBL  L i te  Per fo rmanceThe  learner was benchmarked on a 250Mhz  SunUltra Enterprise 3000, training on Swedish cor-pora of three different sizes, with 23 differenttags, and the 26 templates that Brill uses inhis context-rule learner 2.
In each case, the ac-curacy of the resulting sequence of rules wasmeasured on a test corpus consisting of 40kwords, with an initial-state accuracy of 93.3~.The  following table summarizes the results:Size Thrshld Runtime ~ of rules Acc.30k 2 15 min 99 95.5%60k 4 24 rain 85 95.7%120k 6 60 rain 92 95.8%By comparison, it took Brill's C-implementedcontext-rule learner 90 minutes, 185 minutes,and 560 minutes, respectively, to train on thesecorpora, producing similar sequences of rules.Thus #-TBL Lite is an order of magnitude fasterthan Brill's learner.
The full #-TBL systempresented in (Lager, 1999) is even faster, usesless memory, and is in certain respects moregeneral.
Small is beautiful, however, and thelight version may also have a greater pedagogi-cal value.
Both versions can be downloaded fromhttp ://www.
ling.
gu.
se/~lager /mutbl ,  html.ReferencesLager, TorbjSrn.
1999.
The  #-TBL  System:Logic P rogramming Tools for Transformation-Based Learning, In: Proceedings of CoNLL-99,Bergen.Brill, Eric.
1995.
Transformation-Based Error-Driven Learning and Natural Language Process-ing: A Case Study in Part of Speech Tagging.Computational Linguistics, December 1995.2Available from http://www, cs.
jhu.
edu/~br i l l .280
