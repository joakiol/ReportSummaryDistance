Proceedings of EACL '99The Treegram Index An Efficient Technique for Retrieval inLinguistic TreebanksHans Argenton  and Anke  Fe ldhausInfineon Technologies, DAT CIF, Postbox 801709, D-81617 Miinchenhans.argenton@infineon.comUniversity of Tiibingen, SfS, Kleine Wilhelmstr.113, D-72074 Tiibingenfeldhaus@sfs.nphil.uni-tuebingen.deMultiway trees (MT, henceforth) are acommon and well-understood data struc-ture for describing hierarchical linguisticinformation.
With the availability of largetreebanks, retrieval techniques for highlystructured ata now become essential.
Inthis contribution, we investigate the effi-cient retrieval of MT structures at the costof a complex index--the Treegram Index.We illustrate our approach with theVENONA retrieval system, which han-dles the BH t (Biblia Hebraica transeripta)treebank comprising 508,650 phrase struc-ture trees with maximum degree ight andmaximum height 17, containing altogether3.3 million Old-Hebrew words.1 Mul t iway- t ree  retr ieval  based ont reegramsThe base entities of the tree-retrievalproblem for positional MTs are (labeled)rooted MTs where children are distin-guished by their position.Let s and t be two MTs; t contains s(written as s ~ t) if there exists an in-jective embedding such that (1) nodes aremapped to nodes with identical labels and(2) a root of a child with position i ismapped to a root of a child with the sameposition.Retr ieva l  problem: Let DB be a setof' labeled positional MTs and let q be aquery tree having the same label alphabet.The problem is to find efficiently all treest C DB that contain q.To cope with this tree-retrieval problem,we generalize the well-known n-gram in-dexing technique for text databases: Inplace of substrings with fixed length, weuse subtrees with fixed maximal height--treegrams.Let TG(t,h) denote the set of all tree-grams of height h contained in the MTt, and let T(DB, g) denote the set of alldatabase trees that contain the treegramg.
Assume that g has the height h andthat T(DB, g) can be efficiently computedusing the index relation I~B := {(g, t)lt EDB A g C TG(t, h)}, which lists for eachtreegram g of height h every database treethat contains g. We compute the desiredresult set R = {t C DBIq ___ t} for a givenquery tree q such that q's height is greaterthan or equal h as follows:Retr ieva l  method:(1) Compute the set TG(q,h): All tree-grams of height h contained in thequery.
(2) Compute the candidate set of" (tCandh(q) := Ng~Ta(q,h ) T(DB, g).The set of all database trees that con-tain every query treegram.
(3) Compute the result set R = {t ECand~(q)l q !
t}.The costly operation in this approach isthe last containment test q _ t. The build-ing of index Ihs  is justified if in general tile267Proceedings of EACL '99number of candidateswill be much smallerthan the number of trees in DB.2 Efficient query evaluat ionThe treegram-index retrieval method givenabove encounters the following interestingproblems:(A) A single treegram may be very com-plex because of its unlimited degreeand label strings; this leads to costlylook-up operations.
(B) There are many treegrams rooting ata given node in a database tree: Toaccomodate queries with subtree vari-ables, the index has to contain allmatching treegrams for that subtree.
(c) It is quite expensive to intersect hetree sets T(DB, g) for all treegrams gcontained in the query q.VENONA addresses these problems by thefollowing approach:P rob lem A: Processing of a single tree-gram: (1) Node labels hash to an integerof a few bytes: We do not consider labelsstructured; to model the structure of wordforms, feature terms should be used 1.
(2)VENONA deals only with treegrams of amaximal degree d; if a tree is of greaterdegree, it will be transformed automati-cally to a d-ary tree.
2 (3) For describinga single treegram g, VENONA takes eachof g's hashed labels and combines it withthe position of its corresponding node ina complete d-ary tree; an integer encod-ing g's structure completes this represen-tation: Structure is at least as essential fortree retrieval as label information.1Due to lack of space, we cannot present our ex-tension of treegram indexing to feature terms in thisabstract.2The employed algorithm is a generalization of thewell-known transformation of trees to binary trees.d's value is a configurable parameter of the index-generation.Prob lem B VENONA uses only one tree-gram per node v: the treegram includ-ing every node found on the first h lev-els of the subtree rooted in v. This ap-proach keeps the index small but intro-duces another problem: A query treegrammay not appear in the treegram index as itis.
Therefore, VENONA expands all querytreegram structures at runtime; for a givenquery treegram g, this expansion yields alldatabase treegrams with a structure com-patible to g. That approach keeps the tree-gram index small and preserves efficiency.P rob lem C The evaluation of a givenquery q is processed along the followingsteps: (1) According to q's degree andheight, VENONA chooses a treegram in-dex among those available for the treedatabase.
(2) VENONA collects q's tree-grams and represents them by sets of tree-gram parts.
For a given query treegram,VENONA expands the structure number toa set of index treegram structures and re-moves those labels that consist of a vari-able: Variables and the constraints thatthey impose belong to the matching phase.
(3) VENONA sorts q's treegrams accordingto their .selectivity by estimating a tree-gram's selectivity based on the selectivityof its treegram parts.
(4) VENONA esti-mates how many query treegrams it hasto evaluate to yield a candidate set smallenough for the tree matcher; only for thoseit determines the corresponding index tree-grams.
(5) VENONA processes these se-lected treegrams until the candidate sethas the desired size--if necessary, fallingback on some of the treegrams put aside.
(6) Finally, the tree matcher selects the an-swer trees from these candidates.268
