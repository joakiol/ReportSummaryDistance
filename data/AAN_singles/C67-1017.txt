The Application of FORTRAN to Automatic TranslationPaul O. SamuelsdorffI.
IntroductionA multitude of problem-oriented programming languages are beingcreated in order to facilitate programming in various fields.Th~selanguages have two advantages for non-programmers who need a com-puter for solving their problems: I. they are not forced to spendmuch time on learning a complicated machine language; 2. they donot necessarily have to alter their programs when they are obligedto use a different machine.
These advantages seem to justify thelabour of writing a multitude of compilers that translate eachproblem-oriented language into the machine language of each machine.The existence of various problem-oriented languages, however, makesit difficult for the users of computers in various fields to ex-change their experience.
In addition there is the danger that acertain machine possesses only a limited number of compilers, andthat therefore a program may have to be rewritten when for somereason or other a different machine has to be used.
The questiontherefore arises whether it is not possible to have the advantagesof problem-orlented languages without multiplying their number.This paper wants to show that one of the most widespread problem-oriented languages, originally created for mathematicians, mayefficiently be used for non-numerical data-processing, if thenecessary subroutines are available.Another object of this paper is to give a concrete picture of howlinguistic problems may be handled by the computer to those readerswho have only a theoretical knowledge of data-processing.
For thebenefit of these readers a few definitions will be given, so thatthe examples will be understood by everybody.bit = the smalles unit of information that may be stored in thecomputer, having one of two values symbolized by "I" or "O".character = a letter of the alphabet, a decimal digit, or one of 11special signs including the blank.
A character is re-presented in the computer used for our examples (IBM709@) by a combination of 6 bits.machlne-word = a string of six characters (represented in the com-puter by a combination of 36 bits).location = the place in the computer where a machine-word is stored.array = a combination of locations treated as a unit.subroutine = a program that may be called up by another program forperforming a specific job.function = a subroutine that in addition to handling a certain jobleaves a definite result in a certain location.IF-statement ~ an instruction of the program that enables a branch -ing to one of three different statements in the pro-gram, depending on whether the value in the paren-theses of this statement is negative, zero or posit-ive.
Its format is "IF (x) 1,m,n", where 1,m and nare the numbers of the statements to which the pro-gram may branch.The appl ication of a mathematical ly oriented programming languageto l inguistic problems will be exemplif ied by a Hebrew-Engl ishtranslat ion project written in FORTRAN with the aid of subroutinesprogrammed at the Deutsches Rechenzentrum in Darmstadt.
These sub-routines handle data smaller than the machine-word (single bits,.single characters and their concatenation), the non-numericalmachine-word and data larger than the machine-word.We shall now explain the subroutines used in our project and giveexamples of their application.
In order to avoid a repeated ex-planat ion of the variables used in the formats of the subroutines,we introduce the fol lowing conventions.M = a posit ive integer not greater than 36, referr ing to oneof the 36 bits of a machine-word.WORD = the location of a machine-word to be handled by the sub-routine.
If two machine-words are to be handled, we dis-t lnguish between WORD1 and WORD2.BLOCK ~ the location of the first machine-word of an array contain-ing the characters or the string to be handled by the sub-routine.
If two arrays are involved, we dist inguish betweenBLOCKI and BLOCK2.NA = a posit ive integer indicating the posit ion of the firstcharacter of a string in the array BLOCK to be handled byt~ subroutine.
If two strings are to be handled, we dis-t inguish between NA1 and NA2.N = an integer, usual ly positive, indicating the number ofcharacters to be treated by the subroutine.
~wi l l  be neg-ative if we count the characters from NA to the left.TABLE = an array containing characters to be used by a subroutine.This table is prepared before the subroutine is called.The subroutines will be described in the order of the units theyhandle, starting from the smallest units.2.
Bits2.1.
PAKRThis routine faci l i tates the codinE of ~rammatical information.Each bit of a 36-bit machine-word represents a certain kind o~grammatical information.
Its value is "I" when this informationapplies to the Hebrew word it is coordinated to and "0" when thisinformation does not apply.
The 36 bits of one machine-word, storedin the array CODE, represent the fol lowing information.2I = definite noun2 = indefinite noun3 = construct state= pronoun5 = preposit ional phrase6 = preposit ion7 = adverb8 = numeral9 -- indefinite adjective10 = definite adjective11 = indefinite part ic iple12 = definite part ic iple13=ZHI~  = AT15 = AUTU, AUTH, AUTM, AUTN16 = KI, AM, KAWR17 = GM, RQ18= LA19= IW20 = verb21 = infinit ive22 = comma23 = KL2@ = present25 = past26 = future27 = copula28 = WL29 = W30=U31 = mascul ine singular32 = feminine singular33 = masculine plural= feminine plural35 = no indefinite article36 = no definite article(The words in capital letters are Hebrew words that need specialtreatment.
)It would be very complicated to work out the figure to be storedin a certain location for each possible combination of grammaticalinformation.
Let us take as an example a mascul ine singular verbin the past tense.
The machine-word coordinated to this verb willhave a "I" in bit-posit ions 20, 25, and 31, and a "O" in all otherblt-positions: 000000000000000000010000100000100000.
This is thebinary equivalent of the decimal number 69 664.
Instead of workingout this figure, we code a "I" into the 2Oth, 25th and 31st columnof a punched card and leave the other columns blank.
The first 36columns of the card are then read into an array of 36 locations.The 36 machlne-words of this array are subsequently packed withthe aid of the subroutine PAKR into one location (containing 36bits), the ones and blanks of the 36 columns on the card result ingin ones and zeros in the respective bits of one machine-word.2.2.
KBITThis subroutine is a function and identif ies single bits.
If wewant to f ind out whether a word possesses a certain grammaticalfeature, we have to ask whether the value of the respective bitof the machine-word that contains the desired grammatical inform-ation is "I" or "0".Format: J = KBIT(WORD,M)The result stored in the location J will be "I" or "0", dependingon the value of the respective bit.The subroutine EBIT enables the control to cause a branching tothe specif ic part of the program needed for the treatment of amember of a certain word-class.
A computed GOTO after the dic-t ionary Iooku~ handles this process very efficiently, as seen inthe fol lowing example.379 DO 90 L ~ 1 25999,90 , IF 8O80 GO TO (100,200,300,400,500,600,1000,75,920,910,1200.2000,13000,$000,5000,1000,75,1000,1000,2200,1000,1000,700~,L90 CONTINUEThe valne of the variable L must be computed before the GOTO state-ment is reached.
It must be a positive integer not greater than thenumber of statement-numbers in the parentheses of the GOTO state-ment, since it determines which statement of the program is to beexecuted next.
L is computed in statement 79.
It assumes the valuesfrom 1 to 23 as long as the program reaches statement 90.
The IF-statement between statement 79 and statement 80 causes the programto branch to statement 90 as long as the Lth bit of the machine-word containing the grammatical information of the Nth word of thesentence equals zero.
As soon as the Lth bit equals one, the pro-gram will branch to statement 80.
(999 is a dum~ statement number,since the result of KBIT will never be negative.)
Since we areexamining the machine-word found in the dictionary together withthe Hebrew word we were ~ooking up, statement 80 will cause a branch-ing to that part of the program that handles members of the word-class this Hebrew word belongs to.An IF-statement using the subroutine KBIT may also enable the pro-gram to branch conditionally during the syntactic analysis or thetranslation process and thus make the solution of ambiguities poss-ible.
Specific parts of the program for the solution of ambiguitiesare reached by statements examining the bits of machine-words loc-ated in the array SCODE.
For instance for ambiguous verbs the state-ment will be:"2200 IF (KBIT(SCODE(N)~I)) 999,2210,25OO".
The partof the program solving the ambiguity of the verb s tar tsat  state-ment 2500.
The other "1"-bits of SCODE, coded with a verb or anoun, indicate how a preposition is to be translated.2.3.
LBITThis subroutine permits the conversion of "O"-bits into "1"-bitsand vice versa.
Its format is similar to that o - -~ IT ,  namelyJ = LBIT(WORD,N)~he result stored at J will be "1" when "0" has been replaced by "1"and "0" when "1" has been replaced by "0".LBIT is used for storing or deleting grammatical information duringthe analysis process.An example is the indication of definite nouns or prepositionalphrases during the dictionary lookup.
Since in Hebrew the definitearticle and some of the prepositions consist of one letter thatis attached to the following noun, this letter has to be strippedbefore the word can be found in the dictionary.
We use the subroutineLBIT during the dictionary lookup for storing "1" In the first bit-position of CODE(N)and deleting the "1" in the second bit-posltionif the Nth word of the sentence is a noun preceded by the definitearticle, or "1" is stored in the fifth bit-position, if the Nth~ord of the sentence is a noun preceded by a preposition.4~.
Single characters3.1.
IFPP (find first position)This subroutine makes the identification of s,in~le characters, poss-ible.Format: J = IFFP(BLOCK,NA,N,TABLE,IND)This function finds the first position of a character in the arrayBLOCK which is equal to a character of TABLE if IND = I or unequalto amy of the characters of TABLE if IND = O.
The search startsfrom the NAth character of the array.
It goes to the right if N ispositive and to the left if N is negative.One of the characters we frequently want to identify is the blank,in order to find word boundaries.
This subroutine is used, for in-stance, when we want to insert an adjective between a prepositionand the following noun.
We have to look for the blank after thepreposition in order to insert the adjective in the right place.An example for a negative N will be given in section 6.3.3.2.
SEPO (seek positions)This subroutine traces the positions of occurrence of a character(or a member of a set of characters) stored in a table.Format: CALL SEPO (BLOCK,NA,N,TABLE,NSP,NFIND)The subroutine SEPO examines N characters in the array BLOCK,starting from the NAth character.
The number of characters foundto be equal to the characters stored in TABLE is stored in the loc-ation NFIND.
The actual positions of these NFIND characters arestored in the array NSP.If the only character stored in the table is the blank, dictionarylookup will be very convenient, since the occurrence of word bound-aries may be stored for a whole text.
NSP(I) will contain the posi-tion of the blank after the Ith word of the text.
The next word tobe processed will therefore easily be found.
Its first characterwilly,be in the first position after the one indicated by the con-tents of NSP(I) and its length will be NSP(I+I) - NSP(1) - I.3.3.
ICPC (compare character)This subroutine compares a character with a set of characters stor-ed in a table.Format: J = ICPC(BLOCK,NA,TABLE,NTAB)NTAB is a positive integer stating with how many characters ofTABLE we want to compare the NAth character of the array.The result of this function, stored in J, is zero if the NAth cha-racter is unequal to any of the characters of the table, otherwiseit is a positive integer not greater than NTAB, indicating thatthe NAth character of the array BLOCK is equal to the Jth characterof TABLE.5In the following example we see how this subroutine is used forchoosing between the English indefinite articles "a" (WORD(I)) and"an" (WORD(5)).1476 K = ICPC (EWD(1,N),I,VOC,5)1477 IF (K-l) 1905.1910,19151905 ENG(1 ,I) = WORD(1)I = I+1GO TO 14801910 K = ICPC (EWD(1,N),5.VOC,5)IF (K) 1905,1915,1905ENG(1 ,I) ~ WORD(5)I = I+IGO TO 1480EWD is the array where the English words were brought after thedIB~ionary lookup and ENG where they are brought d~ring the ana-lysis.
The first five locations of the table VOC contain the vowelsU, O, I, E A.
If the first letter of the noun in question, storedin EWD(1 ,N~, starts with a consonant, K in statement 1476 will bezero, and K-1 in statement 1477 will be negative.
If the firstletter is U, K-1 =0, and if the first letter is any other vowel tK-1 will be positive.
That means, that for any first letter of thenoun, except U, statement 1477 decides whether "a" or "an" will bechosen.
In the case of U the choice depends on the third letter ofthe noun, found in statement 1910.
"A" will be chosen if the thirdletter is a vowel, and "an" will be chosen if it is a consonant.This routine will, of course, still have to be refined for the casewhen the prefix "un" is followed by a vowel.4.
Machine-word parts4.1.
CSW0 (compose word)This subroutine, composing a machine-word from two parts of twoother machine-word's, facilitates the insertion of short words likeprepositions or the definite article.Format : S = CSWO (WORI~ ,WORD2,K)As a result of this function the first K characters of the machine-word in location WORDI is composed with the last 6 - E charactersof the machine-word in location WORD2.
The resulting machine-wordis stored in location S. S may be identical with WORI~ or WORD2.We see an example of the application of this subroutine in t~he partof the program that translates a date into English.575 EWD(1 ,IL) = CSW0 (WORD(50),EWD(I ,IL),2)K = IL-ICALL SHA2(EWD(1 ,K) ,1,52,4,1 )EWD(1 ,K) -- CSWO (WORD(40) ,EWD(1 ,K), 5)CALL SHA2 (EWD(1 ,K) ,1,55,5,1 )GO TO 550In statement 575 the preposition "of" (WORD(50)), chosen in thiscase as the translation of the Hebrew p~epcsitional prefix B, iscomposed with the first part of the name of the month which followsit.
The statements following statement 575 translate the Hebrew Bbefore the day of the month by "on the" (WORD(52) and ~ORD(~O)).The shifting subroutine SHA2 will be explained in section 6.2.5- Machine-words5.1.
CPWO (compare words)A special subroutine for comparing non-numerical machine-words isnecessary for ignoring the sign-bit.
When we make a mathematicalcomparison between two machine-words (subtracting one word from theother) the first bit is interpreted as a sign (0 = + and I = -).This will give a wrong result when we compare a word starting witha letter between A and I with a word starting with a letter betweenJ and Z, since the former have "0" in their first bit-position,while the latter have "I"In non-numerical data-processing we therefore have to regard themachine-word as an entity of six characters, where the first bitof the first character is part of the binary number representingthe whole machine-word.Format: S = CPWO(WORDI,WORD2)The machine-words at the two locations WORDI and WORD2 are compared.S = I if the contents of WORD1 is greater than the contents ofWORD2, S = 0 if the two machine-words are equal, and S = -I if thecontents of WORDI is smaller than the contents of WORD2.6.
Units lar~er than the machine-word6.1.
CPST (compare strings)This routine differs from CE~O in enabling us to define the numberof characters (N) that we regard as the entity to be compared.Format: CPST(BLOCKI,NAI,BLOCK2,NA2,N)The result is similar to that of the comparison of two machine-words: S = I if the binary number representing the string in BLOCKI(starting from NA1) is greater than the binary number representingthe string in BLOCK2 (starting from NA2), S = 0 if the two stringsare equal, and S = -I if the binary number representing the stringin BLOCKI is smaller than the binary number representing the stringin BLOCK2.We shall see an example of this subroutine in the dict ionary lookup,section 6.5., where the words from the text will be compared to thewords in the dictionary.6.2.
SHA2 (shift in array)This subroutine enables us to shift strinEs of variable length.Format: CALL SHA2 (BLOCK,NA,N,NSHIFT,IND)NSHIFT is the number of posit ions we want to shift a string of Ncharacters, start ing from the NAth character in the array BLOCK.NSHIFT may be a posit ive or a negative integer, depending on whetherwe want to shift to the right or to the left.
IND = I if we wantto fill the vacant posit ions by blanks and IND = 0 if we want tofill them by zeros.
We saw two examples of this subroutine in sec-t ion 4.1.
Since we reserved six machine-words for one English word,N+NSHIFT = 36 (6x6 characters).6.5.
1OSS (compose strings)With the aid of this subroutine we may brin K a string of variabl e(N) from one arra~ (BLOCK1) ~o another (BLOCK2), startingposition in the two arrays (NA1 and NA2).Format: J = ICSS(BLOCK1,NA1,N,BLOCK2,NA2):The result of this function will be J = NA2+N.This routine, combined with IFFP (section 5.1.
), is very useful inbringing the processed English sentence,word for word, into the out-put area.5060 NA2 = 1DO 5075 L = 1,IN = IFFP (ENG(1 ,L), 56,-36,TAB,O)+1IF (N-l) 5075,5075,50705070 NA2 =ICSS (ENG(1,L),I,N,OUT,NA2)5075 CONTINUEI is the number of arrays, each consisting of six locations, thatcontain the English words after the analysis process.
IFFP has tolook for the first non-blank, since the English equivalent of aHebrew word may be a word group.
For the same reason we have tostart the search from the 56th character, going left.
We add 1 tothe result of the function, so that the English word (or word group)is stored ~ith an additional blank and the result (NA2) of the func-tion ICSS may serve as a parameter of the same function in the nextround.
The IF-statement before 5070 is a safeguard against the Eng-lish word being blank.6.4.
A subroutine changing the word order was added to the existingsubroutines.
Since in Hebrew the adjective always follows the nounit qualifies, we have to change the word order in English.Format: OALLADT(N)N is a positive integer indicating that the adjective is the Nthword in the sentence.
It changes position (together with its grammarcodes) with the (N-1)th word.
This subroutine was entirely writtenin FORTRAN, without a~ing subroutines.6.5.
The following subroutine was written for the dictionarF lookupof the translation project.
The words in the dictionary are alpha-betically ordered, with the exception of the blank, that standsbetween R and S, because of the value of its binary equivalent.For this reason, the blank following the word in the text is addedbefore the word is compared with the dictionary entries (HW).The following parameters are used by the subroutine:NA = The position of the first letter of the word in the text thatis looked up in the dictionary.NZ = The number of characters of the word.IL = The ordinal number of the word in the sentence.M = The number of entries in the dictionary.85" Machine-words5.1.
CPW0 (compare words)A special subroutine for comparing non-numerical machine-words isnecessary for ignoring the sign-b~t.
When we make a mathematicalcomparison between two machine-words (subtracting one word from theother) the first bit is interpreted as a sign (0 = + and 1 = -).This will give a wrong result when we compare a word starting witha letter between A and I with a word starting with a letter betweenJ and Z, since the former have "0" in their first bit-position,while the latter have "1"In non-numerical data-processing we therefore have to regard themachine-word as an entity of six characters, where the first bitof the first character is part of the binary number representingthe whole machine-word.Format: S = CPW0(WORD1,WORD2)f e machine-words at the two locations WORD1 and WORD2 are compared.- 1 if the contents of WORD1 is greater than the contents ofWORD2, S = 0 if the two machine-words are equal, and S = -1 if thecontents of WORD1 is smaller than the contents of WORD2.6.
Units larger than the machine-word6.1.
CPST (compare strings)This routine differs from CPW0 in enabling us to define the numberof characters (N) that we regard as the entity to be compared.Format: CPST(BLOCK1,NA1,BLOCK2,NA2,N)The result is similar to that of the comparison of two machine-words: S = 1 if the binary number representing the string in BLOCK1(starting from NA1) is greater than the binary number representingthe string in BLOCK2 (starting from NA2), S = 0 if the two stringsare equal, and S = -1 if the binary number representing the stringin BLOCK1 is smaller than the binary number representing the stringin BLOCK2.We shall see an example of this subroutine in the dictionary lookup,section 6.5., where the words from the text will be compared to thewords in the dictionary.6.2.
SHA2 (shift in array)This subroutine enables us to shift strings of variable length.Format: CALL SHA2 (BLOCK,NA,N,NSHIFT,IND)NSHIFT is the number of posit ions we want to shift a string of Ncharacters, starting from the NAth character in the array BLOCK.NSHIFT may be a posit ive or a negative integer, depending on whetherwe want to shift to the right or to the left.
IND = 1 if we wantto fill the vacant posit ions by blanks and IND = 0 if we want tofill them by zeros.
We saw two examples of this subroutine in sec-t ion 4.1.
Since we reserved six machine-words for one Engl ish word,N+NSHIFT = 36 (6x6 characters).76.3.
ICSS (compose strings)With the aid of this subroutine we may bring a string of variable(N) from one arra~ (BLOCKI) ~o another (BLOCK2), startingfrom any position in the two arrays (NAt and NA2).Format: J = ICSS(BLOCK1,NA1,N,BLOCK2,NA2):The result of this function will be J = NA2+N.This routine, combined with IFFP (section 5.1.
), is very useful inbringing the processed English sentence,word for word, into the out-put area.5O6O NA2 = 1,,\]~x)= 5075 L = ~ iIFFP (ENG(1 ,L~, 56,-56,~-?B,0)+1I~ (N-I) 5075,507~,50705070 NA2 = ICSS (ENG(I,L),I,N,OUT,NA2)5075 CONTINUEI is the number of arrays, each consisting of six locations, thatcontain the English words after the analysis process.
IFFP has tolook for the first non-blank, since the English equivalent of aHebrew word may be a word group.
For the same reason we have tostart the search from the 56th character, going left.
We add 1 tothe result of the function, so that the English word (or word group)is stored @Ith an additional blank and the result (NA2) of the func-tion ICSS may serve as a parameter of the same function in the nextround.
The IF-statement before 5070 is a safeguard against the Eng-lish word being blank.6.4.
A subroutine chan~in~ the word order was added to the existingsubroutines.
Since in Hebrew the adjective always follows the nounit qualifies, we have to change the word order in English.Format: CALL ADT(N)N is a positive integer indicating that the adjective is the Nthword in the sentence.
It changes position (together with its grammarcodes) with the (N-1)th word.
This subroutine was entirely writtenin FORTRAN, without a~?ng subroutines.6.5.
The following subroutine was written for the dictionar~ lookupof the translation project.
The words in the dlctio~ary are alpha-betically ordered, with the exception of the blank, that standsbetween R and S, because of the value of its binary equivalent.For this reasen, the blank following the word in the text is addedbefore the word is compared with the dictionary entries (HW).The following parameters are used by the subroutine:NA = The position of the first letter of the word in the text thatis looked up in the dictionary.NZ = The number of characters of the word.IL = The ordinal number of the word in the sentence.M = The number of entries in the dictionary.8The following two constants are set up in the subroutine:N = the first power of 2 greater than M (in our case 1024)J = 2Log N (in our case 10)SUBROUTINE LOOKUP(NA,NZ,IL,N)DIMENSION ~(#,1024),HC( lO2#),HSC(102#),EW~6,102#),EC(1024),I~EX~ (200),  CODE (50) ,SCODE(50), EWD (6,5O) ,ECOD~(50), ~ D  (2)COMMON TEXT,HW,CODE,SCODE,EWD,ECODE,HC,HSC,EW,EC,TESTWDTESTWD(1 ) = 6HO00000J= lON = 1024NI = N/2555 N = N-NI54O J = J -1.i~ (J) 59o,54a,5~544 NI = NI/2545 IF (CPST (TEXT,NA,HW(1,N),NZ+I)) 535,575,555555 N =N+NI560 IF (M-N) 565,540,540565 N = N-NINZ = ~Z/2N = N+NI3=3-1IF I~ ~ 590,570,570570 IF N) 565,544,544575 CODE(IL) = HC(N)SCODE(tL) = HSC(N)DO 580 K = 1,6580 EWD(K,IL) = EW(K,N)ECODE(IL) = EC(N)j = LB I~(~ES~WD(1 ) ,1 )590 RETURNENDThe lookup is done by the logarithmic method.
We jump into themiddle of the array reserved for the dictionary and exclude thelower half of the dictionary from further search if t~e textwordis greater than the word of the dictionary that it was comparedwith, and exclude the upper half if the word was smaller than theword in the dictionary.
This process of halving the searched areais repeated till either the word is found or J, which is decreasedby one before each search, is equal to zero.
That means, we meyerhave to compare more than ten times to find a word in the diction-ary or to know that it cannot be found.
Statements 560 and 570 pre-vent us from searching in the area between M and N. When the wordis found, the grammatical information from the dictionary and theEnglish translation of the Hebrew word is delivered to.
the mainprogram and the first bit-position of TESTWD(1) is set "1".If the word is not found in the dictionary, the program proceedsas follows.
If the first letter is one of the possible Hebrew pre-fixes (found by ICPC), the word is looked ~p again, with Ehe firstletter stripped and NZ diminished by one.
The result of the func-tion ICPC is used by a computed GOTO for a branching to that partof the program that will prepare the insertion of the definitearticle or the solution of the ambiguity of the preposition.If the first letter is none of the possible prefixes and the wordis not found in the dictionary, the program will use the Hebreworiginal in the t rans lat ionand print out a message that the wordwas not found.7.
ConclusionApart from the subroutines described above, there are additionalsubroutines that facilitate information retrieval and other lingu-istic data-processing.
Statistical linguistics may obviously beefficiently treated by a mathematically oriented programming langu-age.This paper is not supposed to be a plea for FORTRAN, but for a uni-versally applicable problem-oriented language, which will make theprogress achieved in programming in one field accessible to theusers of computers in all fields.
A combination of subroutineswritten in this language may do the job that is done today by sepa-rate problem-oriented languages.
A programming language like PL/I,or a language still to be created, may do the job more efficientlythan FORTRAN.
The idea is that the programs written will have amaximal possibility of application and that programmming examplesgiven in the literature describing computer problems will be under-stood by all the readers interested.8.
ReferenceDipl.-Nath.
Gisela Schlotter, Verarbeitung nichtnumerischer DatenTell I. Unterprogramme (PI-17)Deutsches Rechenzentrum, Darmstadt10
