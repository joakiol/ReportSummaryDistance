SOME COMPUTATIONAL PROPERT IESOF TREE ADJO IN ING GRAMMARS*K.  V i jay -Shank l t r  and  Ar~v lnd  K .
Josh lDepar tment  o f  Computer  and  In fo rmat ion  Sc ienceRoom 268 Moore  Schoo l /D2Un ivers i ty  o f  Pennsy lvan iaPh i lade lph ia ,  PA  191C4.ABSTRACTTree Adjoining Grammar (TAG) is a formalism for naturallanguage grammars.
Some of the basic notions of TAG's wereintroduced in \[Joshi,Levy, and Takahashi 19751 and by \[Joshi, 1083\].A detailed investigation of the linguistic relevance of TAG's has beencarried out in \[Kroch and Joshi,1985\].
In this paper, we will describesome new results for TAG's, especially in the following areas: (I)parsing complexity of TAG's, (2) some closure results for TAG's, and(3) the relationship to Head grammars.1.
INTRODUCTIONInvestigation of constrained grammatical systems from thepoint of view of their linguistic adequacy and thei?
computationaltractability has been a major concern of computational linguists forthe last several years.
Generalized Phrase Structure grammars(GPSG), Lexical Functional grammars" (LFG), Phrase Linkinggrammars (PLG), and Tree Adjoining grammars (TAG) are somekey examples of grammatical systems that have been and stillcontinue to be investigated along these lines.Some of the basic notions of TAG% were introduced in \[Joshi,Levy, and Takahashi,1975\] and \[Jo6hi,lQ83\].
Some preliminaryinvestigations of the linguistic relevance and some computationalproperties were also carried out in \[Jo6hi,1983\].
More recently, adetailed investigation of the linguistic relevance of TAG's werecarried out by \[Kroch and Joshi,1985\].In this paper, we will describe some new results for TAG's,especially in the following areas: (1) parsing complexity of TAG's, (2)some closure results for TAG's, and (3) the relationship to Headgrammars.
These topics will be covered in Sections 3, 4, and Srespectively.
In section 2, we will give an introduction to TAG's.
Insection 6, we will state some properties not discussed here.
A detailedexposition of these results is given in \[Vijay-Shankar nd Joshi,1985\].
"This work wu partially supported by NSF Grants MCS-821011e-CER.MCS-82~7204.
We want to thuk Carl P'oUard, Kelly Roach, David SeaM, tadDavid Weir.
We have benefited enormously by valuable dbcussion8 with them.2.
TREE ADJO IN ING GRAMMARS- -TAG'sWe now introduce tree adjoining grammars (TAG's).
TAG'sare more powerful than CFG's, both weakly and strongly.
!
TAG'swere first introduced in \[Joshi, Levy, and Takahashi,1O7$\] and\[Joshi,1983\].
We include their description in this section to make thepaper self-contained.We can define a tree ~ grammar as follows.
A treeadjoining grammar G is'-~pair (I,A) where \] ~ a set of initial trees,and A is a set of auxiliary trees.A tree o is an initial tree if it is of the formCZ~s/ \/ \ ,6~"/ \/ \That L% the root node of a is labelled S and the frontier nodesare all terminal symbols.
The internal nodes are aU non-terminaL.A tree ~ is an a~xiliary tree if it is of the form/ \/ \/ \ -xvz EI \v I v2That is, the root node of ~0 m labelled with a non-termb~al Xand the frontier nodes are all labelled with terminals ymbols exceptone which is labelled X.
The node labelled by X on the frontier willbe called the foot node of ~.
The frontiers of initial trees belong toL ~, whereas the frontiers of the auxiliary trees belong to ~ N L~ + O~+ N L'.We will now define a composition operation called adjoininL(or adjunetion) which composes an auxiliary tree fl with a tree "I.Let '7 be a tree with a node n labelled X and let B be an auxiliarytree with the root labelled with the same symbol X.
(Note thatmust have, by definition, a node (and only one) labelled X on thefrontier.
)IGr~ramm GI tad G2 are weakly equivalent if the string language of GI.L(GI) ~ the strbqE italr,~e4e of G2, L(G2).
GI  tad G2 m strongly equlvsleutthey are weakly eqolwJent ad for each w In L(GI) ~ t~G2), both GI  sad G2mlga  the 8Lme structural description to w. A Ip'ffimmu G iz weakbr adequatefor a (string) hmgeqe L, if L(G) --  L. G iJ strongly adequate for L if L(G) -- Ltad for each w in L, G as~slgne ta  eappropriatea structural description to w. Thenotion of strung adequacy is undoubtedly not precls?
beesas?
it depends on thenotion of appropriate structural descriptions212Adjoining can now be defined as follows, if p is adjoined to "Ist the node n then the resulting tree "ft' is as shown in Fig.
2.1below.1 = ~=$ XI \  / \/ \ / \node / X ~ /s / / _ \  \ - - -x - - -  {_/.T_x.__ xt3' =SI \  7I We"'withoutI x \ t-- i  \ - -I \ --x-- pIXi \+- - tFisure ~The tree t dominated by X in "~ is excised, ~ is inserted at" thenode n in "1 and the tree t is attached to the foot node (labelled X) of,?.
i.e., ~ is inserted or adjoined to the node n in 7 pushing tdo*swards.
Note that adjoining is not a substitution operation.We will now defineT(G): The set of all truce derived in G starting from initialtrees in I.
This set will be called the tree net of G.L(G): The set of all terminal strings which appear in thefrontier of the trees in T(G).
This set will be called the stringI.xngeage (or language) of G. If L is the string language of a TAG Gthee we say that L is a Tree-Adjoining Language ITAL\].
Therelationship between TAG's , context-free grammars, and thecorresponding string languages can be summarized as follows (\[Joehi,Levy, and Takahashi, 1975\], \[aoehi, *~SSl).Theorem 2.1: For every context-free grammar, G', there is anequivalent TAG, G, both weakly and strongly.Theorem 2.2: For ever,/ TAG, G, we have the followingsituations:*.
I,(G) is context-free and there is a context4ree grammarG' that is strongly (end therefore weakly) equivalent toG.b.
L(G) is context-free and there is no context4ree grammarG' that is equivalent to G. Of course, there must be acontext-free grammar that is weakly equivalent to G.?.
L(G) is strictly context-sensitive.
Obviously in this case,there is no context-free grammar that is weaklyequivalent to G.Parts (a) and (e) of Theorem 2.2 appear in (\[Joehi, Levy, andTskahashi, 1075\]).
Part (b) is implicit in that paper, but it isimro~taut to state it explicitly u we have done here because of itslinguistic significance.
Example 2.1 illustrates part (a).
We will nowillustrate parts (b) and (c).Example 2.2: Let G - -  (I,A) whereI :A :Pt =a I =$In$ TI \  I \?
T n SI \  I \I b  Ib$ T ?LaL us look at  anne der lvat lon8 in G.70=a =$eIa72 =$I \z~a /T \/ u $\P=i I \  %t I b %I T _._~.
.
.
.
f~IbSIe7tS/ \a TI \$bIePt3t = "70 with ,0 s 7s = "It with paadjoined at S as indicated in 70- adjoined at T as indicated in 7=.Clearly, L(G), tlie string language of G isL= (**eh=/n  > o )which is a context-free language.
Thus, there must exist a context,..free grammar, G', which is at least weakly equivalent to G. It can beshown however that there is no context4ree grammar G' which isstrongly equivalent to G, i.e., T(G) - -  T(G').
This follows from thefact that the set T(G) (the tree set of G) is non-recognizable, Le.,there is no finite state bottom-up tree automaton that can recognizeprecisely T(G).
Thus a TAG may generate a context-free language,yet assign structural descriptions to the strings that cannot beassigned by any context-free grammar.Example 2.3: Let G , (LA) whereI : a l l$IU* : Pt = P= ="S TI \  /~a T ?
S/ IX / IXI1 \  /1 \b S c b T ?213The precise definition of L(G) is as follows:L(G) - LI ffi {w ?
e u / u > o, w is a string of a's and b', such that(1) the n?mber of ?% ~ the number of b's - -  ?
i  and(2) for any initial substring of w, the n?mberof a's .~  the number of b's.
}L!
is a strictly context-sensitive language (i.e., ?
context-sensitive language that is not context-free).
This can be shown asfollows.
Intersecting L with the regular language a* b* e c* results inthe languageL, = { na bS e ca / n ~.. o } ~ffi LI I'l a" b" e c *L 2 is well-known strictly co?text-sensitive language.
The resultof intersecting a context-free language with a regular language isalways a context-free language; hence, L i is ?ot ?
context-freelanguage.
It is thus a strictly context-sensitive language.
Example2.3 thus illustrates part (c) of Theorem 2.2.TAG's have more power than CFG's.
However, the extrapower is quite limited.
The language L!
has equal number of a's, b'sand c's; however, the a's and b's are mixed in ?
certain way.
Thelanguage L~ is similar to Li, except that a's come before all b's.TAG's as defined so far are not powerful enough to generate L=.This can be seen as follows.
Clearly, for any TAG for L2, eachinitial tree must contain equal ?amber of ?
'% b's and e's (includingzero), and each auxiliary tree must also contain equal number of a'n,b's and c's.
Further in each case the a's meet precede the b's.
Thenit is easy to see from the grammar of Example 2.3, that it will not bepo~ible to avoid getting the a's and b's mixed.
However, L~ can begenerated by a TAG with local constraints (see Sectio?
2.1) The so-tailed copy language.Lff i  {wew/w~ {a,b}" )also cannot be generated by ?
TAG, however, again, with localconstraints.
It is thus clear that TAG's can generate more thancontext-free languages.
It can be shown that TAG's cannot generateall context-sensitive languages \[Joehi ,1984\].Although TAG's are more powerful than CFG's, this extrapower is highly constrained and appace?tly it is just the right kindfor characterizing certain structural description.
TAG's share almostall the formal properties of CFG's (more precisely, the correspo?dingclasses of la?guages), as we shall see in sectio?
4 of this paper and\[Vijay-Shankar nd Joshi01985\].
I?
addition,the string languages ofTAG's can also be parsed in polynomial time, in particular in O(ne).The parsing algorithm is described in detail in section 3.2.1.
TAG's  w i th  Local  Const ra in ts  on Ad jo in ingThe adjoining operation as defined in Sectio?
2.1 is "context-free'.
An a?xiliary tree, say,X/ \/ \/ \- - -X - - -is adjoinable to ?
tree t at ?
?ode, say, ?
,  if the label of thatnode is X. Adjoining does ?or depend on the context (tree context)around the node n. I?
this sense, adjoining is co?text-free.In \[Joshi ,1983\].
local constraints o ?
adjoining similar to thoseinvestigated by \[Joshi and Levy ,1977\] were considered.These are ageneralization of the context-sensitive constraints studied by \[Petersand Ritchie .1069\].
it was soon recognized, however, that the fullpower of these co?straints was never fully utilized, both in thelinguistic context as well as in the "formal languages" of TAG's.The so-called proper analysis contexts and domination contexts (asdefined i?
\[Joshi and Levy ,1977l) as used in \[Joshi .10831 alwaysturned out to be such that the context elements were always in aspecific elementary tree i.e.. they were further localized by being inthe same elementary tree.
Based on this observation and asuggestio?
in \[Joshi, Levy and Takahashi ,1975\], we will describe anew way of introducing local ?o?strainta.
This approach ?ot onlycaptures the insight stated above, but it is truly in the spirit ofTAG's.
The earlier approach was not so, although it was certainlyadequate for the investigatio?
in \[Joshi ,1983\].
A precisecharacterization f that approach still remains an ope?
problem.G ~ (I,A) be a TAG with local constraints if for eachelementary tree t 6 I U A, and for each node, n, in t, we specify theset fl of auxiliary trees that can be adjoined ?
t  the node n. Notethat if there is no constraint then ?H auxiliary trees are adjoinabl?
atn (of course, only those whose root has the same label as the label ofthe node n).
Thee, in general, ~ is a subnct of the set of all theauxiliary trees adjoinable at n.We will adopt the following conventions.1.
Since, by definition, no auxiliary trees are adjoinable to anode labelled by a terminal symbol, ?o co?straint ha8 tobe stated for node labelled by a terminal.2.
If there is no constraint, i.e., all auxiliary trees (with theappropriate root label) are adjoinable ?
t  a node, say, n,then we will not state this explicitly.3.
If no auxiliary trees are adjoinabie at a ?ode n, then wewill write the constraint as (~b), where ?b de?ores the nullset.4.
We will als,~ allow for the po~ihility that for a node atleast one adjoining is obligatory, of course, from the setof all possible auxiliary trees adjoinable at that node.Hence, a'TAG with local constraints i defined as follows.
G =(1, A) is a TAG with local constraints if for each node, n. in each treet, be specify one (and only one) of the f'ollowing constraints.1.
Selective Adjoining ~SA:) Only a specified subset of theset of all auxiliary trees are adjoinable at n. SA iswritten as (C), where C is a subset of the set of allauxiliary trees adjoinable at n.If C equals the set of all auxiliary trees adjoinable at n,then we do not explicitly state this at the node u.2.
Null Adjoinin~ INA:) No attxiliary tree is adjoinable atthe node N. NA will be writte?
a8 (~).3.
Obligating Adjoining IOA: ) At least one (oat of all theauxiliary trees adjoinable at n) must be adjoined at ?.OA is writte?
as (OA), or as O(C) where C i~ ?
subset ofthe set of all auxiliary trees adjoinable at n.Example 2.4: Let G =ffi (I,A) be a TAG with local co?attaints where1: O~ ffi=S (~)/ \~ S S (POI I?
b214A: #, = p , -s (Pt) s (#=)/ \  / \/ \ / \= s (4,) (?)
s bIn 01 no auxiliary trees can be adjoined to the root node.
Only~1 is ~ljoinable to the left S node at depth 1 and only /9 s isadjoinable to the right S node at depth 1.
In ~1 only Pi is ad\]oinableat the root node and no auxiliary trees are adjoinable at the \[(~,~.node.
Similarly for PS"We must now modify our definition of adjoining to take care ofthe local constraints, given a tree "1 with a node, say, n, labelled Aand given an auxiliary tree, say, ~, with the root node labelled A, wedefine adjoining as follows.
# is adjoinable to "1 at the node n if ~ E#, where B is the constraint associated with the node n in "1.
Theresult of adjoining p to 7 will be as defined in earlier, except hat theconstraint C associated with n will be replaced by C', the constraintassociated with the root node ore and by C ?, the constraintassociated with the foot node of ~.
Thus.
given7= p=s A (c ' )/ \ node n I \/ ^ (c) / \I 1 \  I \l l  \ \  1 \I I  \ \  I \.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
I t  .
.
.
.
.
(c l)The resultant tree "/' is ".-/' =S/ \/ \/ \/ A (c')/ / \  \- - - /  \ - - -/ \/ x (c')/ / \  \- - - /  \ - - -/ \We also adopt the convention that any derived tree with a nodewhich has an OA constraint associated with it will not be included inthe tree set associated with a TAG, G. The string language L of G isthen defined as the set of all terminal strings of all trees derived in G(starting with initial trees) which have no OA constraints left-inthem.Example 2.5:whereZ : 0 =Let G = (I,A) be a TAG with local constraintsA:  ~=s (~)/II Ia S/1\I1 \b I cs (~)There are no constraints in a t. In ~ no auxiliary trees are adjoJnablest the root node sad the foot node and for the center S node thereare no constraints.Starting with a I and adjoining ,8 to a !
at the root node weobtain3' =s (4O/I/ It S/1 \/1 \b I ?S (?
)I@Adjoining ~ to the center S node (the only node at whichadjunction can be made} we haves (~)III In/s" (~)/ II ~/ / I' aS  ~ ,-- P/ I1\/ I I \I b I c tL.
.
.
.
.
.I I \b l cs (~)IUIt is easy to see that G generates the string languageL= {a"b~ec"/n >o}Other languages such ~ L'f{a u' In >I}, L" ---- {a u: I n _> I}also cannot be generated by TAG's.
This is because the strings of aTAt  grow linearly (for a detailed definite of the property called?
contact growth" property, see \[Joshi ,198.3J.For those familiar with IJoshi, 1983\], it is worth pointing outthat the SA constraint is only abbreviating, i.e., it does not affect thepower of TAG's.
The NA and OA constraints however do affect thepower of TAG's.
This way of looking at local constraints has onlygreatly simplified their statement, but it has also allowed us tocapture the insight that the 'locality' of the constraint is statable interms of the elementary trees themselves!l .
I .
Simple Linguistic ExamplesWe now give a couple of lingnistle xamples.
Readers may referto \[Kroch and Joshi, 1985J for details.1.
Starting with "II m a I which is an initial tree and then adjoiningPl (with appropriate l xical insertions) at the indicated node in a I.we obtain '/s-21571 = ~tl =$/ \Nps/ \  I \DET Ii V MPI I I I\I I I I \the glrl I DET Nis I It seniorthe girl t8 a seniorPI zlip/ \liP $/ \/ \Ifl ~ YpI / \?
?
liPI Inet IIIBi l l"~2 =SI \I \, -d  \tNP ~ VP%/\ ~ / \\ \  v NPDgT/\N~ S~ I / \  / \~ i8  DET NI l aw s\  I Ithe girl~ ~T/ \ X\ ?
seniorVP \I I / \  \l e  V m' \net  I ~ ~pt\ N t\ I IBlllThe g i r l  vho net Blll 18 ?
senior2.
Starting with the initial tree 3`1 ~ a2 and adjoining ~2 atthe'indicated node in a 2 we obtain 3`2-3`1 = e l2  =3`2 =* S 0(82) S/ \  / \NP VP NP VPl IX I II\PRO To vP H I I \I\ I v ~ S (~)V lip John J \I I I \inv i te  Ii persuaded NI IMary BillPRO to inv i te  Mary John persuaded Bi l l  S4 S N / / \  ,,/ t IP  VP ~ // I II\ "~ ~ .8 21 N I I \  \I John II II persuaded I~ I / \t I; I rovP\ I tPa0 I \  %.
.
B i l l~  V NP.
.
.
.
I Jinv i te  NIif t ryJohn persuaded Bi l l  to inv i te  MaryNote that the initial tree a 2 is not ?
matrix sentence.
In orderfor it to become ?
matrix sentence, it must undergo an adjunction atits root node, for example, by the auxiliary tree ~it as show?
above.Thus, for o 2 we will specify a local constraint O(~t) for the root?
node, indicating that o= requires for it to undergo tn adjunct\on atthe root node by an auxiliary tree ~2- In ?
fuller grammar there willbe, of course, some alternatives in the scope of O().3.
PARSING TREE-ADJO IN INGLANGUAGES3,1, Definit ionsWe will give ?
few additional definitions.
These are notnecessary for defining derivations in ?
TAG as defined in section 2.However, they are introduced to help explain the parsing algorithmand the proofs for some of the closure properties of TAL's.DEF IN IT ION 3.1 Let %3`' be two trees.We say 3  `I--- 3`' i f  i?
3  `weadjoin an auxiliary tree to obtain 3`'.I--* is the reflexive,transitive closure of \[--.DEF IN IT ION 3.2 7' is called ?
derived tree if 3  `\],--" 3`' for someelementary tree %We then say "7' 6 D(3`).The frontier of any derived tree "I belongs to either L ~ N E + ULE t- N E ?
if 3'6 D($) for some auxiliary tree ~0, or to E* if 3  `6 D(o)for some initial tree ?x.
Note if 3  `6 D(c~) for some initial tree ?x, then3  `is also ?
sentential tree.If ~ is an auxiliary tree, 3  `6 D(~) and the frontier of 3  `is w s Xw 2 (X is ?
nonterminal,Wl,W 2 6 L ~') the?
the leaf node having thisnon-terminal symbol X at the frontier is called the foot of 3 .`Sometimes we will be loosely using the phrase "adjoining witha derived tree" ,7 6 D(~) for some auxiliary tree ~8.
What we mean isthat suppose we adjoin ,8 at some node and then adjoin within ~8 andso on, we can derive the desired derived tree 6 D(~) which uses thesame adjoining sequence and use~this resulting tree to "adjoin" atthe original node.3.~.
The Pars ing A lgor i thmThe algorithm, we present here to parse Tree-AdjoiningLanguages (TALe), is a modification of the CYK algorithm (which isdescribed in detail in \[Aho and Ullman,1073\]), which ?sea a dynamicprogramming technique to parse CFL's.
For the sake of making ourdescription of the parsing algorithm simpler, we shall present healgorithm for parsing without considering local constraints.
We willlater show how to handle local constraints.We shall a~ume that any node in the elementary trees in thegrammar hal ?tmost two children.
This assumption ca?
be madewithout ?
?y loss of generality, bee?use it can be easily shown thatfor any TAG G there is ?n equivalent TAG G !
such that ?
?y node inany elementary tree in G l has utmost two children.
A similarassumption is made in CYK algorithm.
We use the terms ancestorand descendant, hroughout the paper as ?
transitive and reflexiverelation, for example, the foot ?ode may be called the ancestor of thefoot node.The algorithm works as follows.
Let al..a, n be the input to be"parsed.
We use ?
four.dimensional rray A; each element of thearray contains ?
subset of the nodes of derived trees.
We nay ?
nodeX of ?
derived tree 3  `belongs to A\[i~,k01J if X dominates ?
nab-tree of3  `whose frontier is given by either ai+i...a j Y nk+l...a u (where thefoot node of "7 is labelled by V) or ai+v..a u (i.e., j ~ k. This216corresponds to the case When -f is ?
sentential tree).
The indices(iJ,k,I) refer to the positions between the input symbols and rangeover 0 through n. If i - -  5 say, then it refers to the gap between atand a s.Initially, we fill A\[ i , i+l, i+l, i+l\] with those nodes in thefrontier of the elementary trees whose label is the same as the inputti+ 1 for 0 < i < n*l. The foot nodes of auxiliary trees will belong toall Aii,i,jj I. such that i -- j.We are now in n position to fill in ?11 the elements of the arrayA.
There are five cases to be considered.Case 1.
We know that if a node X in a derived tree is theancestor of the foot node, and node Y is its right sibling, such that XE Ali,j,k,l\] and Y E All,m,m,n\], then their parent, sayt Z shouldbelong to Alij.k,n l, see Fig 3.1a.Case 2.
U the right sibling Y is the ancestor of the foot nodesuch that it belongs to A\[I,m,n,p\] and its left sibling X belongs toA\[i,jj,I\], then we know that the parent Z of X and Y belongs toA\[i,m,n,p\], see Fig 3.1bCase 3.
If neither X nor its right sibling Y are the ancestors ofthe foot node ( or there is no foot node) then if X E Ali,j,j,l\] and Y 6All,re,?,el then their parent Z belongs to A\[i,j,j,n\].Case 4.
If a node Z has only one child X, and if X E Alij,k,I\],then obviously Z E A\[i,j,k,l\].
~"Case 5.
U a node X E Ali,j,k,I\], and the root Y of ?
derivedtree "/having the same label as that of X, belong,s to Alm,i,l,n\], thenadjoining ?
at X makes the resulting node to be in Almj,k,n\], see Fig3.1c.
(t) X' (c) T/ \  / \/ \ / \/ \ / \/ \ / \/ z' \ / \/ / \  \ / \/ I \ \ / \ / / \ \ / \/ V' y.
\ .
.
.
.
.
.
.
.
.
.
X .
.
.
.
.
.
.
.I / \  I \  \ I \/ / \ / \ \ I / \ Ii / \ /  \ \ n / \ n. .
.
.
.
.
.
.
.
x .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
/ \ .
.
.
.
.
.
/ \t i I  i i i .
.
.
.
.
.
.
.
.
$--:i J k  l n nt I I I(b) X" / \  i j k 1I \/ \/ \I Z' \/ / \  \/ / \ \/ / \ \/ v '  T' \/ / \  / \  \/ / \ I \ \/ / \1  \ \.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
X t .
.
.
.
.
.
.
.I I I I I  Ii J 1 nn  pFil~ure 3.__.~Although we have stated that the elements of the arraycontain ?
subset of the nodes of derived trees, what really goes inthere ate the addressee of nodes in the elementary trees.
Thus thethe size of any set is bounded by ?
constant, determined by thegrammar.
It is hoped that the presentation of the algorithm belowwill make it clear why we do m.a .a .
The  al lgor l thmThe compkteMgor i thmk given belowStep 1 For i=0 to n- I  s tep 1 doStep 2 put a l l  nodes in  the f ront ie r  of  elementaryt rue  v hose lnbe l  i8 ?t*t in a \ [ i .
i * l , i * l .
l * l \ ] .Step 3 For i=O to n- I  s tep I doStep 4 for  J=l to n- I  s tep 1 doStep 6 put foot  nodes of a l l  nux i l in ry  t rees  InA \ [ l .
t .
J .
J \ ]Step 6 For 1=0 to n step 1 doStep 7 For i=l  to 0 step - I  do~Step 8 For J=i to I s tep | doStep 9 For k=l to J s tep -1 doStep 10 do Cue  1Step 11 do Cane 2Step  12 do Case 8Step 13 do Case 6Step 14 do Case 4Step 18 Accept i f  root  of sons in i t ia l  t ree E A \ [O. J .
J ,n \ ] ,0<j<nwhere,(a) Came 1 corresponds to situation where the left sibling is theancestor of the foot node.
The parent is put in A\[Q,k,I\] if the leftsibling is in A\[i,j,k,m\] and the right sibling is in A\[m,p,p,l\], where k_ m < I, m ~ p, p < I.
Therefore Case I is written asFor n=k to 1-I s tep I dofor  p= n to 1 ,s tep  I doi f  there i s  a le f t  s ib l ing  in A \ [ i , J .
k .n \ ]  and ther ight  s ib l ing  in A\[a.p.p.1\]  sa t i s fy ing  appropriateres t r i c t ions  then put the i r  parentin A \ [ i , J .
k .1 \ ] .
(b) Case 2 corresponds to the ease where the right sibling is theancestor of the foot node.
If the left sibling is in A\[i,m,m,p\] and theright sibling is in A\[p,j,k,I\], i < m < p and p < j, then we put theirparent in A\[i,j,k,I\].
This may be written asFor n=i to J - !
step I doFor p=a*l to \] s tep i dofor  a l l  l e f t  s ib l in~ in A\[ i .n,m,p\]  ud  r ights ib l ingsin A\ [p .
J .k .1 \ ]  sa t i s fy ing  appropr iate rent r i c t ionn  putthe i= parentsin A \ [ i .
J .
k .1 \ ] .217(?)
Case 3 corresponds to the case where ?either ehildre?
?reancestors of the foot ?ode.
If the left sibling E A\[i,j,j,m\] and the right?
sibling E A\[m,p,p,l I then we ca?
pet the parent in A\[i,j,j,l\] if it is the?g~ul that ( i< j  <_ mor i _< j  <m)  and(m < p< Io rm < p <| ) ,  This may be written asfor  ?
= J to 1-1 step I dofor  p = J to 1 step i dofor  a l l  l e f t  81blLngs In ACL, | , J .a\ ]  andr ight  s lb l ings  in A\[nop.p.
l \ ]  8at i s fy lng  the appropr iateres t r i c t ions  pet  the i r  parent  in A \ [ io J , J ?
l \ ] .
(e) Case 5 corresponds to adjoining.
If X is ?
node in A\[m~,k,p\] andY is the root of a auxiliary tree with same symbol as that of X, suchthatY is iuA\ [ i ,m,p , I \ ] ( ( i  < m < p < Io r i  < m < p < l) and(m< j < k_  porm_~ j < k < p)).
Thls may be written asfor  ?
= ~.
to | s tep t dofor  p = ?
to I s tep I doi f  t node X 6 A\[n, J .k ,p \ ]  tad the root ofaux i l i a ry  t ree Is  in A \ [ i ,a .po l \ ]  then put X in A \ [ l .
J .
k .1 \ ]Case 4 corresponds to the case where a node Y has only one child XIf X E A\[i,j,k,I\] then put Y in A\[i,j,k,I I. Repeat Case 4 again if Y hasno siblings.3.4.
Complex i ty  of  the  A lgor i thmIt is obvious that steps 10 through 15 (cases ~-e) are completedin O(e:~), because the different cases have at most two nested forloop statements, the iterating variables taking values in the range 0through n. They are repeated atmost O(n 4) times, because of thefour loop statements in steps 6 through 9.
The initialization phase(steps 1 through 5) has a time complexity of O(n + n 2) = O(n2).Step 15 is completed in O(n).
Therefore, the time complexity of theparsing algorithm is O(nS).3.5.
Cor rec tness  of  the  A lgor i thmThe main issue in proving the algorithm correct, is to showthat while computing the contents of an element of the array A, wemust have already determined the contents of other elements of thearray needed to correctly complete this entry.
We can show thisinductively by considering each case individually.
We give aninformal argument below.Case l: We need to know the contents of A{i,j,k,m\], A\[m,p,p,l lwhere m < I, i < m, when we ate trying to compute the contents ofA\[i,j,k,l\].
Since I is the variable itererated in the outermost loop (step6), we nan assume {by induction hypothesis) that for all m < I andfor all p,q,r, the co?teats of AIp,q,r,m \]are already computed.
Hence,the contents of A\[i,j,k,m\] are known.
Similarly, for all m > i. andfor all p,q, and r _ I, A\[m,p,q,r i would have been computed.
Thus,A\[m,p,p,!
!
would also have bee?
computed.Case 2: By ?
similar reasoning, the contents of A\[i,m,m,p\] andAlp,i,k,l\] are known since p < i and p > i.Case 3: When we are trying to compute the contents of someA\[ij,i,I\], we ?end to know the ?odes in A\[i,i,i,p\] and A\[p,q,q,I\].
Note i> i or j < I.
Hence, we know that the co?teats of A\[i,j,j,p\] andA\[p,q,q,I\] would have been compared already.Case 5: The co?tents of A\[i,m,p,I\] and A\[m,j,k,p\] mesa beknow?
in order to compute A\[i,j,k,ll, where ( i < m < p < I or im_p_<l )and(m <_j <k<porm<j_<k_<p) .
Sinceeither m > i or p < I, contents of A\[m,j0k,p\] will be known.Similarly, since either m < j or k < p, the contents of A\[i,m,p,l\]would have been computed.3.6.
P in ing  w i th  Local Coust rs ln t6So far,we have ~ ?med that the give?
grammar has ?o localconstraints, if the grammar has local constraints, it is easy to modifythe above algorithm to take care of them.
Note that in Case 5, if anadjuectio?
occurs at a node X, we add X again to the element of thearray we are computing.
This seems to be in contrast with ourdefinition of how to associate local constraints with the nodes in asentential tree.
We should have added the root of the auxiliary treeinstead to the element of the array being competed, since so far asthe local constraints are concerned,this ?ode decides the localconstraints at this node in the derived tree.
However, this schemecannot be adopted in our algorithm for obvious reasons.
We let pairsof the form {X,C) belong to elements of the array, where X is asbefore and C represents the local constraints to be associated withthis node.We then alter the algorithm as follows.
If (X,Ct) refers to ?node at which we attempt to adjoin with ?n auxiliary tree {whoseroot is denoted by (Y,Ca)).
then adjunctioa would determined by C t.If adjunction is allowed, then we can add (X,C2) in the correspondingelement of the array.
In cases 1 through 4, we do not attempt o adda new element if any one of the children has a?
obligatoryconstraint.Once it has been determined that the given string belongs tothe language, we can find the parse in a way similar to the schemeadopted in CYK algorithm.To make this process simpler and moreefficient, we can use pointers from the new element added to theelements which caused it to be put there.
For example, considerCase 1 of the algorithm (step 10 ).
if we add a node Z to A\[i,j,k,I\],because of the presence of its children X and Y in A\[i,j,k,m\] andA\[m,p,p,I\] respectively, then we add pointers from this node Z inA\[i,j,k,I\] to the nodes X, Y in Ali,j,k,m\] and A\[m,p,p,I\].
Once this hasbeen done, the parse can be found by traversing the tree formed bythese pointers.A parser based on the techniques described above is currentlybeing implemented and will be reported at time of presentation.4.
CLOSURE PROPERTIES  OF  TAG'sIn this section, we present some closure results for TALe.
Wenow informally sketch the proofs for the closure properties.Interested readers may refer to \[Vijay-Shankar nd Joshi,19851 fortthe complete proofs.4.1.
C losure  under  Un ionLet G 1 and G 2 be two TAGs generating L!
and ~ respectively.We can construct a TAG G such that L(G)~L!
tJ L2.Let G 1 = ( !
!, A v N v S ), and G 2 ---- ( 12 , A 2, N 2, S ).Without loss of generality, we may Lssume that the N!
f'l N 2 ~ #.LetG ~ ( I  IU  12, A tUA 2 ,N,  t.JN 2, S ).
We claim that L(G) - L IUL2Let x 6 L l U I ,  2 .
Then x 6 L!
or x 6 L2.
If x 6 Ll, thee itmust be possible to generate the string x in G , since I 1 , A!
ate inG.
Hence x E L(G).
Si~nilarly if x E ~ , we can show that x E L(G).Hence L 1 LIL 2 ~ L(G).
If x E L(G), then x is derived using eitheronly I l ,A  Io ron ly  12, A 2s inceN!
f ' IN2~ ~.
Hence, x6L!
o rx6l..~z.
Thus, L(G) C_ L I V L2.
Therefore, L(G} = L, O L=z.2184.S.
C losure  under  Coneatennt tonLet G, - - ( l t .A t ,Nt .S t ) ,  G s - -  (la,As.Ns.Sa) be two TAGsgenerating LI, 1,2 respectively, such that N 1 I"1 N2 ,m at.
We canconstruct ?
TAG G == (I, A, N, S) such that L(G)== L t .
L a. WechooeeSsucbthatS isnot inN n UNa.
We let N == N t U N2U{S), A ffi= A i U A 2.
For all t I E !
l, tz E 1 2, we add tlz to !, as shownin Fig 4.2.1.
Therefore, I ffi= ( t12 \[ t I E It, ta E lz), where the nodesin the subtrees t I and t z of the tree t12 have the same ?oustrxintsassocinted with them as in the original grammars Gs ned G s. It iseMy to show that L(G) ~ L 1 .
L2.
once we note that there are noauxiliary trees in G rooted with the symbol S, and that N 1 13 N z ==as.t ,=  / \ ~= / \/ \ I \I \ / \t12 =SI \/ \I \/ \stI \ / \ / 4~ 1\ / ta \Figure 4 .2 .1  ~.4.8, Clo,ure under Kleene St.m.Let G 1 ~ (Ii.Ai.NI.Si) be a TAG generating L 1.
We can showthat we can construct a TAG G such that L(G) = Ls' .
Let S be asymbol ant in Ni, and let N == N t U (S).
We let the set I of initialtrees of G be (te}, where t e is the tree shown in Fig 4.3a.
The set ofauxiliary trees A is dermed MA= (tsx/t IE I t}UA t.The tree teA is as shown in Fig 4.3b, with the constraints onthe root of each ttA being the null adjoining constraint, noconstraints on the foot, and the constraints on the nodes of thesubtreee tI of the trees tlA being the same as those for thecorresponding nodes in the initial tree t I of G t.To see why L(G) .
-  Lt" , consider x (~ L(G).
Obviously, the treederived (whose frontier is given by x ) must be of the form shown inFig 4.3?, where each t i' is a eeutential tree in Gl,such t i' E D(ti), foran initial tree t i in G I.
Thus, L(G) _ Lt ' .On the other hand, if x E L t ' ,  then x ~ wt...wn, w i 6 L l for 1i _~ n. Let each w i thee be the frontier of the eenteutial tree t i' ofG t such that t i' E D(tl)  , t i E !
t. Obviously, we can derive the tree T,using the initial tree re.
and have a sequence of adjoining'operationsusing the auxiliary trees tiA for I < i _< n. From T we can obviouslyobtain the tree T'  the same as give?
by Fig 4.3?, using only the?
~xiliary trees in A t .
The frontier of T '  is obviously ws...w n. Hence, xG L(G).
Therefore, L t. G L(G).
Thus L(G) -- L,'.
(a )  t o ffi g/(h)  ttA :Ss (c) / \I \ / st/ \ / 1%S S t / ,%.
.
t '  t/ \/ \ ra t/ .% s/ \/ sts / \/ I \~- t 'a@T 'Figure 4 ..__.334.4.
C lo lu re  under  Intersect ion w i th  Regu lu  LanguagesLet L T be a TAL and L R be a regular language.
Let G be aTAG generating L T and M = (Q , E , 6 ,  q0 , QF) be a fruits stateautomaton recognizing L R. We can construct a grammar G and will8how that L(GI) - -  L T N L R.Let a be an elementary tree in G. We shall negotiate with eachnode a quadruple (ql,q2,q~,q4) where ql,q2,qa,q4 E Q.
Let (ql,qa,qs,q4)be associated with a node X in a.
Let us assume that a is anauxiliary tree, and that X is an ancestor of tbe foot node of n, udhence, the ancestor of the foot node of any derived tree - / iu D(a).Let Y be the label of the root and foot nodes of a.
If the frontier of'7 ('r in D(a)) is w I w 2 Y w s w4, and the frontier of the subtree of 7rooted at Z, which corresponds to the node X in a is w z Y wt.
Theidea of associating (ql,q2.qs,q4) with X is that it must be the easethat 6"(ql, w2) = q2, and 6"(q~, ws) ffi q4- When "t becomes a part ofthe sentential tree 7' whose frontier is given by u w I w z v w s w 4 w,then it must be the case that 6"(q2, v) == qs.
Following thisreasoning, we must make q2 ~ qa, if Z is not the ancestor of the footnode of % or if "7 is in D(a) for some initial tree a in G.We have assumed here.
as in the case of the parsing algorithmprcsented earlier, that any node in any elementary tree has atmoettwo children.From G we can obtain G s as follows.
For each initial tree a,ar~ociate with the root the quadruple (q0, q, q, qt) where qo is theinitial state of the finite state automaton M, nnd qf E QF- For eachauxiliary tree 0 of G, a~5ociate with the root the quadruple(qt,q2,q.q,q4), where q,ql,q2,q~,q4 are some variables which will laterbe given values from Q.
Let X be some ?ode in some elementary treea.
Let (qt,q2,q3,q4) be associated with X.
Then, we have to considerthe follo'~ing caacs.Case 1: X has two children Y and Z.
The left child Y is theancestor of the foot node of a.
Then associate with Y the quadruple (P, q2, q3, q ), and ( q, r, r, s ) with Z, and associate with X theconstraint that only those trees whose root has the quadruple ( ql, P,e, q4 ), among those which were allowed in the original grammar, "may be adjoined at this node.
If ql ~ p, or q4 ~ u , then theconstraint as6ociated with X must be made obligatory.
If in theoriginal grammar X had an obligatory constraint aasocinted with itthen we retain the obligatory constraint regarding of the relationshipbetween ql and p, and q4 and s. If the constraint a~mciated with Xis a null adjoining constraint, we sumociate ( qt, el,q, qa, q ), and ( ?b r,r.
q4 ) with Y and Z respectively, and associate the null adjoiningconstraint with X.
If the label of Z is ~, where ?
E E, then we chooses and q such that 6 ( q, a ) ~ s. In the null adjoining constraint ease,q is chosen such that 6 ( q, a ) ~ q4.219Case 2: This corresponds to the ease where a node X has twochildren Y and Z, with (ql,qs,qs,q4) ~mocinted at X.
Let Z ( the rightchild } be the ancestor of the the foot node the tree a.
Then we shallassociate (p,q,q,r), (r,qs,q3,s) with Y and Z.
The associated constraintwith X shall be that only those trees among those which wereallowed in the orignal grammar may be adjoined provided their roothas the quadruple (ql,p,s,qt) associated with it.
If q, ~ p or q4 ~ rthen we make the constraint obligatory.
If the original grammar hadobligatory constraint we will retain the obligatory constraint.
Nullconstraint in the original grammar will force us to use null constraintand not consider the cases where it is not the case that ql == P andq4 - -  s. If the label of Y is a terminal 'a' then we choose r such thatoe'(p,n) ~ r. If the constraint at X is n null adjoining constraint, hen?
o~(ql,a) = r.Case 3: This corresponds to the case where neither the leftchild Y nor the right child Z of the node X is the ancestor of the footnode of o or if ~ is a initial tree.
Then q2 ~ q~ ffi q- We willassociate with Y and Z the quadruples (p,r,r,q) and (q,s,s,t) reap.
Theconstraints are assigned as before , in this case it is dictated by thequadruple (ql,p,t,q4).
If it is not the case that qt ~ P and ql ~ t,then it becomes an OA constraint.
The OA and NA constraints at Xare treated similar to the previous cases, and so is the case if eitherY or Z is labelled by a terminal symbol.Case 4: If (qt,q2,~,q4) is associated with a node X, which hasonly one child Y, then we can deal with the various cases as follows.We will associate with Y the quadruple (p,q20q~,s) and the constraintthat root of the tree which can be adjoined at X should have thequadruple (ql,P,e,q4) associated with it among the trees which wereallowed in the original grammar, if it is to be adjoined at X. Thecases where the original grammar had null or obligatory "constraintassociated with this ?ode or Y is labelled with a terminal symbol, aretreated similar to how we dealt with them ia the previous cases.Once this has bee?
done, let ql,"',qm be the independentvariables for this elementary tree a, then we produce as many copiesof a so that ql,"',qm take all possible values from Q.
The onlydifference among the various copies of a so produced will beconstraints associated with the ?odes in the trees.
Repeat he processfor all the elementary trees in G !.
Once this has bee?
done and eachtree given ?
unique name we can write the constraints in terms ofthese ?ames.
We will now show why L(GI) =ffi L T f3 L R.Let w E L(GI).
Theu there is s seque?ce of adjoiningoperatio?s tarting with an initial tree a to derive w. Obviously, w 6LT, also since corresponding to eseh tree used in deriving w, there is.
correspo?ding tree ia G, which differs only in the ?onstrai?tsassociated with its ?odes.
Note, however, that the ?o?strai?tsassociated with the ?odes in trees in G t are just * restriction of thecorrespo?ding o?es in G, or an obHgatoiT ?o?straint where there was?
o?e in G. Now, if we can assume ( by inductin?
hypothesis ) that if~fter n adjoining operatio?s we can derive "f 6 D(~x'), then there is acorrespo?ding tree "T 6 D(a) iu G, which has the same tree structureas ~/' but differing o?ly in the constraints associated with thecorresponding ?odes, then if we adjoin at some node in "~' to obtain"h', we can adjoin in "~ to obtain "h (corresponding to gl')-Therefore, if w can be derived in Gi, then it can dcfmitely be derivedinG.If we can also show th~ L(Gi) C L a. then we can co?clodsthat L(GI) C L T N Lit.
We can use induetio?
to prove this.
Theinduction hypothesis that if all derived trees obtained after k < nadjoining operations have the property P then so will th?
derivedtrees after ?
.4- I adjoiniugs where P is defi?ed as,Property P: If any node X in a derived tree '3' has the foot-node ofthe tree p to which X belo?gs labelled Y as a desce?dant such thatw s Y w s is the frontier of the subtree of # rooted at X, then if(qs,q2,~,q4) had been associated with X, 6'(qvwl) ,~ qz and~(q3,w2) ~ q4, a?d if w is the frontier of the subtree under the foot?
ode of # in '7 is then ~(qs,w) ~= q~.
If X is not the ancestor of thefoot ?ode of # then the subtree of # below is of the form wlw s.Suppose X has associated with it (qt,q,q,q2) then ~(ql,wa) -~ q,~*(q,w2) ffi q2"Actually what we mean by an adjoining operation is ?ofnecessarily just o?e adjoining operatio?
but the minimum number sothat no obligatory co?straints are associated with any ?odes in thederived trees.
Similarly, the base case ?teed ant cousider o?lyelementary trees, but the smallest (in terms of the ?umber ofadjoining operatin?s) tree starting with eleme?tary trees which has?
o obligatory coustrai?t associated with any of its ?odes.
The basecase ca?
be see?
easily co?sidering the way the grammar was built(it can be shown formally by induction ou the height of the tree) Theinductive step is obvious.
Note that the derived tree we are going touse for adjoining will have the property P, and so will the tree atwhich we adjoin; the former because of the way we designed thegrammar and a~ig?ed constraints, and the latter because ofinduction hypothesis.
Thus so will the new derived tree.
Once wehave proved this, all we have to do to show that L(Gx) C L R is toconsider tho6e derived trees which are se?tential trees and observethat the roots of these trees obey property P.Now.
if n string x E L T 13 L R, we ca?
show that x E L(G).
Todo that, we make use of the foUowing claim.Let ~ be an auxiliary tree in G with root labelled ?
and let "y 6D(~).
We claim that there is a 8' in G I with the same structure as 8,such that there is a ";' in D(bet~0)' ) where "I' has the same structureas 7, such that there is ?o OA coustraint in '7'.
Let X be a ?ode infit which was used in deriving -;.
Then there is a ?ode X' in 7' suchthat X' belongs to the auxillixry tree #l' (with the same structure as~|.
There are several cams to co?sider -Case I: X. is the ancestor of the foot node of 81, such that thefro?tier of the subtree of ,81 rooted at X is wsYw 4 and the frontier ofthe subtree of 7 rooted at X is w,wlZwsw4.
Let ~(ql,ws) ~ q,~(q,wl) -~- q2, ~(qS,w2) = r, and ~(r,w4) ~ q4.
Then X' will have(ql,q,r,q4) associated with it, and there will be ?o OA co?straint in'7'*Case 2: X is the ancestor of the foot ?ode of ~l, and the frontier ofthe subtree of fll rooted at X is wsYw 4.
Let the frontier of theaubtree of 'T rooted at X is wawlwsw 4.
Then we claim that X' in -;'will have associated with it the quadruple (ql,q,r,q4), if G*(qt,wa)q, f (q,wl)  = p0 6"(p,wz} = r, and ~(r,w4} = q4-Case 3: Let the froutier of the subtree of ~i (and also "7) rooted at Xis wlw 2.
Let f (q,wl)  = p, 6*(p,ws) = r. The?
X' will haveassociated with it the quadruple (q,p,p,r).We shall prove our claim by inductio?
o?
the ?umber ofadjoining operations used to derive "I.
The base case (where "1 == 0) isobvious from the way the grammar G 1 was built.
We shall ?owassume that for all derived trees % which have bee?
derived from pusing k or less adjoining operatio?s, have the property as required inour claim.
Let ~ be a derived tree in p after k adju?ctio?s.
By ourinductive hypothesis we may ~asume the existence of thecorresponding derived tree "y' E D(~') derived in G I.
Let X be a uodein 7 as shown ia Fig.
4.4.1.
Then the ?ode X* in "y' eorrespo?di?g toX will have associated with it the quadruple (ql',q2S,q~l',q4")- Note weare aseumin~ here that the left child Y' of X' is the ancestor of the220foot node of D'- The quedruples (qt',q~',qa',P) and (P,Pt*Pt,q4") willbe associated with Y' and Z' (by the induction hypothesis).
Let ~t bederived from ~ by edjoining Pt at X as in Fig.
4.4.2.
We have toslaw the existence of I t '  in GI such that the root of this auxi l i~ft t~ has asmeinted with K the quedruple (q,qt',q4O,r).
The existence0( the tree follows from induction hypothesis (k m 0).
We have alsogot to show that there exkts '71' with the mane structure as q' butone that allows I t '  to be adjoined at the required no?le.
But thisshould be so, since from the way we obtained the trees in GI, therewill exist "/1" such that X t '  has the quadruple (q,q:t',qs',r) and theconstraints t X 1' are dictated by the quadruple (q,qt',q4eJ'), butsuch that the two children of X t' will have the same quedruple as in1'.
We san now adjoin I t '  in 7t ?
to obtain "Yl'- It can be shown thatlt '  has the required property to establish our claim./ \/ \/ \/ \/ \/ \/ \/ \I I \  \ / / \ \I I \ \I \  I I \ \/ \ .
.
.
.
.
.
.
.
i \ .
.
.
.
.
.
.
.I \ ~ / \I \ / \I x \ / \I / \ \ .
.
.
.
.
.
.
.
1\__2._ .
.
.
./ / \ \ x / \ y/ / \ \ / \/ / \ \ / \/ / \  / \  \ / \/ / \ / \ \ / \  / \/ / \ /  \ \ / \ / \...........................
I \ / \v' t T v'2 v't v's I \ I \/ V. \V' 1 Y V' 2 V?!
Se2~ (q" t ,v '  t)=q'26"(p.v't)=pt6"(q'i.v'2)=p ~(pt .v '2 ) fq ' t  6*(q,x)=q, t ~ ' (q ' i , y )=rFiKure 4.4.1.
F i~re  4.4.2Firstly, any node below the foot of PI' in 7t '  will satisfy ourrequirement~ as they are the same as the corresponding nodes in "/l '-Since ~t' satisfy?
the requirement, it is simple to observe that thesods?
in 01' will, even after the edjuuction of I1' in "el'" Howcver,because the quadruple associated with X l '  are different, thequadruples of the nodes above X i' must reflect this change.
It is easyto chock the existence of an auxiliary tree such that the nodes aboveX l' satisfy the requirements a stated above.
It can also be argued anthe by?is of the design of grammar GI, that there exists trees whichallow this new auxiliary tree to be adjoined at the appropriate pi~ce.This then allows us to conclude that there exist ?
derived tree fore~h derived tree bebngin to D(0) as in our el~timo The next step isto extend our claim to take into amount all derived trees (Le.,including the centennial truest This can be done in ?
manner similarto our treatment of derived trees belonging to D(~) for someauxiliary tree I as above.
Of course, we have to consider only the?~-~e where the finite state automaton starts from tlie initial state q0,and teaches ome fmal state ?4 on the ihput which is the frontier oftome sentential tree in (3.
This, then allows us to conclude that L T f3Ln c_ L(C,)..nose, C(G,} -- C r n t~.?5.
HEAD GRA.MMARS AND TAG'sIn this section, we attempt o show that Heed Grtmmar* (JIG)are remarktbly similar to Tree Adjoining Grammars.
it  appears thatthe bask: intuition behind the two systems is more ~ lea the same.Head Grammars were introduced in \[Pollard,10841, .but we follow thenotations used in \[Roach,1084\].
It has been observed that TAG's  udHG's share s lot of common formal properties such as ahnoetidentical cloture results, similar pummping leman.Consider the bask operation in llead Grammars - the HeedWrapping operation.
A derivation from ?
non-terminal produces ?pair (i,?t...ai...sa) ( ?
more convenient representation for this pair is?
l .
.
.ai lai?l.. .~ ).
* The arrow denotes the head of the string, which inturn determines where the string is split up when wrapping operationtakes pl~e.
For example, consider X->LI~(A,B), and let A=t*WhlXand B=t'Uglv.Thcn we say, X=t'whUglVX-'We shall define some functions used in the HG formalism,which we need here.
If A derives in 0 or more steps the heeded stringwhx~ and B derives u~v, thenl )  i f  X -> LLt(A.B) i s  ?
ru le in the granaar thenX der ives  vhugvx't2) i f  X -> LI.q(A.B) 18 a rule In the Kraaaar thenX der ives  shugvx@3) i f  I -> LCt(A,B) i s  a rule in the grLanar thenX der ives  vhxugv4"4) i f  X -> LC2(A.B) i8 a rule in the ~rsJLaar thenX der ives  vhx~v4,Nov consider  hov ?
derLvtt ion Lu TAGs proceeds -Let ~ be In auxilliary tree and let a be ?
eentential tree as inFig 5.1.
Adjoining ~ st the root of the sub-tree "r gives us theseutential tree in File 5.1.
We can, now see how the string whx has"wrapped around" the sub-tree i.e,tbe string ugv.
This seems tosuggest that there is something similiar in the role played by the footin ?n auxilliary tree and the head in a Head Grammar how theadjoining operations and head-wrapping operations operate onstrings.
We could say that if X is the root of an auxillizry tree ~ ted?
l...al X ~i+l...an is the frontier of a derived tree "1 6 D(~), then thederivation of "/would correspond to ?
derivation from a non-terminalX to the string at...a i lai+t...tu in HG and the nee of "f in somesentential tree would correspond to how the strings st... a i andai+t...?
a are used in deriving a string in IlL.S/ \I \I z \/ I - \  \/ ,/---\,<_.l~__~/_3 .~_l_~ugvtqS/ \/ \I x \-7~ / \/ x \,h-7"-~-xI \~-~ugv~= X/ \I \I \/ x \vh  x221Based on this observation, we attempt to show the closerelationship of TAL% and llL's.
It k more convinient for us to thinkof the headed string (i,a,.
:.aa) as the string al...a with the headpointing in between the symbok a I and el+ , rather than at thesymbol t1.
The defmition of the derivation oporatom can be extendedin ,  straightforward manner to take this into aeeount.
However, wecan acheive the same eHeet by considering the definitions of theoperators LL,LC,etc.
Pollard suggest~ that cases uch u LL2~,~ ) beleft undefined.
We shall assume that if ~" mwty  then L L~,k )  - -andLC,(X~) ~ kx.We, then ;ay tha~t if G is x Head Grammar, then w I - -  whx belongsto L(G) if and only if S derives the headed string w~or  whkx.With this new definition, we shall show, without giving the pro~* f,that the ci-,ss of TAL'e is contained in the clan of HL's.
bysystematically converting any TAG G to n HG G'.
We shall assume,without loss of generality, that the constraints expressed at the nodesof elementary trees of G are -1) Nothing can be adjoined at a node {NA).2) Any appropriate tree (symbols at the node and root of theauxilliary tree must match) can be adjoined {AA), or3) Adjoining at the node is obligatory {OA).It is easy to show that these constraints are enough, and thatselective adjoining can be expressed in terms of these and additionalnon-terminals.
We know give a procedural description of obtainingan equivalent Head Grammar from a Tree-Adjoining Grammar.
Theprocedure works as follows.
It is n recursive p~rocedure{Convert to HG) which takes in two parameters, the firstrepresenting the node on which it is being applied and the second thelabel appearing on the left-hand side of the HG productions for thisnode.
If X is a nonterminal, for each auxiliary tree #.whose root hasthe label X, we obtain a sequence of productions such that the firstone has X on the left-hand side.
Using these productions, we canderive the string w|Xw z where a derived tree in D(~) has a frontierwlYw =.
If Y is a#node with with label X in rome tree whereadjoining is allowed, we introduce the productionsY' -> LL2(X,N') (so that  s derived tree with rootIabel X nay wrap around the s t r ing  derived free the 8ubtreebelow th is  node}N' -> LCi(A , .
.
.
.
.
Aj) {asstming that  thereare J chi ldren of th is  node and the t tit child in theancestor of the foot node.
By ca l l ing  the procedurerecurs ively for a l l  the J chi ldren of Y with Ak.kranging from I through J, ve can derive frou N' thef ront ie r  of the subtree below Y}Y' - )  N' ( th i s  i8 to handle the case where noadJunctton takes place at  Y}If G k a TAGthen we do the following -Repeat for  every In i t ia l  treeConvert to HG(root,S') {S' v i i i  be the s tar t  symbol ofthe new Head Grammar).Repeat for  etch Auxi l l inry treeConvert td~_HG(root,rootsyabol)where Convert to HG(node,ntue) I s  defined u fol lowsi f  node i s  an in terna l  node thencue  1 I f  the const ra in t  ?
t  the node t8 AAadd productioan Sym->LL=(node nyabo l , | ' ) .r ->LCt (A I * .
.
.
.
.
A i 'o  .
.
.
.
Aj*)SYm->LCt(AI'.
.
.
.
.
At' .
.
.
.
.
t j ' )where N ' .A I ' .~ 'o .
.
.A  J '  are new non-tera int luymbolu.A t .
.
.
.
.
Aj correspond to the | chi ldrenof the node and i=i i f  foot node i s  not ?
descendantof node else =1 such that  the 1 ~ chi ld of node toancestor of foot node0J=nuaber of chi ldren of nodefor  k=l to J step I doConvert to Hf(k t& chi ld of node,Ak').Cue 2 The constra int  at the node in NA.Same as Case 1 except don't  add the productionsSya->LLl(node nyabol .g ' ) .N' ->LCi (At ' .
.
.
.
.
Aj ' ) .Case 3 The constra int  at the node i80A.State as Case I except that we don ' t  addSyn->LCi(AI ' , .
.
.Aj ' )else i f  the node has t tera inai  syabol a.then add the production Sya ->~e'lse { i t  i8 a foot node }i f  the constra int  at the foot node is  AA thenadd the productions - --Sya ->LL2(node eysbolok)/ki f  the constra int  i s  0A then add only theproductionSya ->LL2(node syabo l~)if the constra int  is  NA add the productionSym.->XWe shall now give an example of converting a TAG G to aHG.
G contains a single initial tree a, and a single auxiliary treeas in Fig.
5.2.Sa= I .8=eFigure 6.__2S (4')/ \/ \a $/1 \/ I \/ I \b s(?)
cObviously, L(G) ~ {aabac a / n :> O}222Applying the procedure Convert_to_HG to this grammar weobtain the HG whose productions are gives by-s ' -~ LL=(S,S)s - ?
t.c2(e.c)8 - ?
"\[c - ?
U.,2(S,D)mO - ?
~Ct(E.F,G)E - ?
bF -> "~which eta be revr i t tan us' - ?
s/~S- ?
LC=(a,A')A' - ?
L tq(S,b~c)  or t '  ->l, lq(S,l~c)be veri f ied that  th is  g rma~ gennratsn exactly It  canL(6).It is worth emphaaising that the main point of this exercise wasto show the similarities between Head Grammars and Tree AdjoiningGrammars.
We have shown how a HG G' (using our extendeddefinitions) can be obtained in a systematic fashion from a TAGG.
It is our belief that the extension of the definition may notnecessary.
Yet, this conversion process hould help us understand thesimilarities between the two formalisms.6.
OTHER MATHEMATIC~kL  PROPERTIESOF TAG's  ~.Additional formal properties of TAG's have been discussed in|Vijay-Shtakar nd Joshi,1985\].
Some of them are listed belowil  Pumping lemma for TAG'sTAL's are closed under substitution and homomorphlsmsTAL's ate not closed under the following operationsa) intersect ion with TAL*sb) intersect ion with CFL*8?)
conplsntatationSome other properties that have been considered in \[Vijay*Shankar tad Joehi,1985\] are as follows1) closure under the following propertieua) inverse hmsoaorphimtb) gem napplng82) seni l lnsurtty and Parikh-boundednus8.References1.
Aho,A.V., and Ullman,J.D., 1073 "Theer 7 -f ~ Translation.and Compiling, Volume h Parsing, Prentice-Hall, Eaglewood Cliffs,N.J., 1073.2.
Joshi,A.K., 1083 "How much context-sensitivity k necessary forcharecterizing structural descriptions * tree adjoining grammars" inNatural Language ~ -  Theoretical, Computational I and~og ica l  Perspectives (ed.
"D~.Dowty, L.Karttunea, A.Zwicky~,Cambridge University Press, New York, (originally presented in1983) to appear in 1985.3.
Joshi,A.K., and Levy,L.S., 1977 "Constraints on StructuralDescriptions: Local Transformations', SIAM Journal of Computing?
June 1977.4.
Joshi,A.K., Levy,L.S., and Takaha~hi, M., 1975 "Tree adjoininggrammars', Journal of Computer Swat.eros and Sciences, March 19755.
Kroch, T., and Joshi, A.K., 1935 "Linguistic relevance of treeadjoining grammars', Technical Report, MS-CIS-gS-18 a Dept.
ofComputer and Information Science t University of Pennsylvania, April19856.
Pollard, C., 1984 "Generalized Phrase Structure Grammars, HeadGrammars, and Natural languao~e *, Ph.D diseertation~ StanfordUniversity, August 19S47.
Roach, K., 1984 "Formal Properties of Head Grammars',unpublished manuscript, Stanford University, also presented at theM,~thematics of LanK,ages workshop at the University of Michigan,Ann Arbor, Oct. 1984.8.
Vijay-Shaukar,K., Joshi,A.K., 1985 "Formal Properties of TreeAdjoining Grammars', Technical Report: Dept.
of Computer sn._d_Information Science, University o_.f Pennsylvani__a., July 1985.223
