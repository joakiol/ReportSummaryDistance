Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 525?533,Uppsala, Sweden, 11-16 July 2010. c?2010 Association for Computational LinguisticsOptimal rank reductionfor Linear Context-Free Rewriting Systems with Fan-Out TwoBenot SagotINRIA & Universite?
Paris 7Le Chesnay, Francebenoit.sagot@inria.frGiorgio SattaDepartment of Information EngineeringUniversity of Padua, Italysatta@dei.unipd.itAbstractLinear Context-Free Rewriting Systems(LCFRSs) are a grammar formalism ca-pable of modeling discontinuous phrases.Many parsing applications use LCFRSswhere the fan-out (a measure of the dis-continuity of phrases) does not exceed 2.We present an efficient algorithm for opti-mal reduction of the length of productionright-hand side in LCFRSs with fan-out atmost 2.
This results in asymptotical run-ning time improvement for known parsingalgorithms for this class.1 IntroductionLinear Context-Free Rewriting Systems(LCFRSs) have been introduced by Vijay-Shanker et al (1987) for modeling the syntaxof natural language.
The formalism extends thegenerative capacity of context-free grammars, stillremaining far below the class of context-sensitivegrammars.
An important feature of LCFRSs istheir ability to generate discontinuous phrases.This has been recently exploited for modelingphrase structure treebanks with discontinuousconstituents (Maier and S?gaard, 2008), as well asnon-projective dependency treebanks (Kuhlmannand Satta, 2009).The maximum number f of tuple componentsthat can be generated by an LCFRS G is calledthe fan-out of G, and the maximum number r ofnonterminals in the right-hand side of a productionis called the rank of G. As an example, context-free grammars are LCFRSs with f = 1 and rgiven by the maximum length of a productionright-hand side.
Tree adjoining grammars (Joshiand Levy, 1977) can also be viewed as a specialkind of LCFRS with f = 2, since each auxil-iary tree generates two strings, and with r givenby the maximum number of adjunction and sub-stitution sites in an elementary tree.
Beyond treeadjoining languages, LCFRSs with f = 2 canalso generate languages in which pair of stringsderived from different nonterminals appear in so-called crossing configurations.
It has recently beenobserved that, in this way, LCFRSs with f = 2can model the vast majority of data in discontinu-ous phrase structure treebanks and non-projectivedependency treebanks (Maier and Lichte, 2009;Kuhlmann and Satta, 2009).Under a theoretical perspective, the parsingproblem for LCFRSs with f = 2 is NP-complete(Satta, 1992), and in known parsing algorithmsthe running time is exponentially affected by therank r of the grammar.
Nonetheless, in natu-ral language parsing applications, it is possible toachieve efficient, polynomial parsing if we suc-ceed in reducing the rank r (number of nontermi-nals in the right-hand side) of individual LCFRSs?productions (Kuhlmann and Satta, 2009).
Thisprocess is called production factorization.
Pro-duction factorization is very similar to the reduc-tion of a context-free grammar production intoChomsky normal form.
However, in the LCFRScase some productions might not be reducible tor = 2, and the process stops at some larger valuefor r, which in the worst case might as well be therank of the source production (Rambow and Satta,1999).Motivated by parsing efficiency, the factoriza-tion problem for LCFRSs with f = 2 has at-tracted the attention of many researchers in recentyears.
Most of the literature has been focusing onbinarization algorithms, which attempt to find a re-duction to r = 2 and return a failure if this is notpossible.
Go?mez-Rodr?
?guez et al (2009) report ageneral binarization algorithm for LCFRS which,in the case of f = 2, works in time O(|p|7), where|p| is the size of the input production.
A more ef-ficient binarization algorithm for the case f = 2 ispresented in (Go?mez-Rodr?
?guez and Satta, 2009),working in time O(|p|).525In this paper we are interested in general factor-ization algorithms, i.e., algorithms that find factor-izations with the smallest possible rank (not nec-essarily r = 2).
We present a novel technique thatsolves the general factorization problem in timeO(|p|2) for LCFRSs with f = 2.Strong generative equivalence results betweenLCFRS and other finite copying parallel rewrit-ing systems have been discussed in (Weir, 1992)and in (Rambow and Satta, 1999).
Through theseequivalence results, we can transfer the factoriza-tion techniques presented in this article to otherfinite copying parallel rewriting systems.2 LCFRSsIn this section we introduce the basic notation forLCFRS and the notion of production factoriza-tion.2.1 DefinitionsLet ?T be a finite alphabet of terminal symbols.As usual, ?
?T denotes the set of all finite stringsover ?T , including the empty string ?.
For in-teger k ?
1, (?
?T )k denotes the set of all tuples(w1, .
.
.
, wk) of strings wi ?
?
?T .
In what followswe are interested in functions mapping several tu-ples of strings in ?
?T into tuples of strings in ?
?T .Let r and f be two integers, r ?
0 and f ?
1.We say that a function g has rank r if there existintegers fi ?
1, 1 ?
i ?
r, such that g is definedon (?
?T )f1 ?
(?
?T )f2 ?
?
?
?
?
(?
?T )fr .
We also saythat g has fan-out f if the range of g is a subset of(?
?T )f .
Let yh, xij , 1 ?
h ?
f , 1 ?
i ?
r and1 ?
j ?
fi, be string-valued variables.
A func-tion g as above is said to be linear regular if it isdefined by an equation of the formg(?x11, .
.
.
, x1f1?, .
.
.
, ?xr1, .
.
.
, xrfr?)
== ?y1, .
.
.
, yf ?, (1)where ?y1, .
.
.
, yf ?
represents some grouping intof sequences of all and only the variables appear-ing in the left-hand side of (1) (without repeti-tions) along with some additional terminal sym-bols (with possible repetitions).For a mathematical definition of LCFRS we re-fer the reader to (Weir, 1992, p. 137).
Informally,in a LCFRS every nonterminal symbol A is asso-ciated with an integer ?
(A) ?
1, called its fan-out,and it generates tuples in (?
?T )?(A).
Productionsin a LCFRS have the formp : A ?
g(B1, B2, .
.
.
, B?
(p)),where ?
(p) ?
0, A and Bi, 1 ?
i ?
?
(p), are non-terminal symbols, and g is a linear regular func-tion having rank ?
(p) and fan-out ?
(A), definedon (?
?T )?
(B1) ??
?
??
(?
?T )?(B?
(p)) and taking val-ues in (?
?T )?(A).
The basic idea underlying therewriting relation associated with LCFRS is thatproduction p applies to any sequence of string tu-ples generated by the Bi?s, and provides a newstring tuple in (?
?T )?
(A) obtained through functiong.
We say that ?
(p) = ?
(A) is the fan-out of p,and ?
(p) is the rank of p.Example 1 Let L be the language L ={anbnambmanbnambm |n,m ?
1}.
A LCFRSgenerating L is defined by means of the nonter-minals S, ?
(S) = 1, and A, ?
(A) = 2, and theproductions in figure 1.
Observe that nonterminalA generates all tuples of the form ?anbn, anbn?.
2Recognition and parsing for a given LCFRScan be carried out in polynomial time on the lengthof the input string.
This is usually done by exploit-ing standard dynamic programming techniques;see for instance (Seki et al, 1991).1 However, thepolynomial degree in the running time is a mono-tonically strictly increasing function that dependson both the rank and the fan-out of the productionsin the grammar.
To optimize running time, one canthen recast the source grammar in such a way thatthe value of the above function is kept to a min-imum.
One way to achieve this is by factorizingthe productions of a LCFRS, as we now explain.2.2 FactorizationConsider a LCFRS production of the formp : A ?
g(B1, B2, .
.
.
, B?
(p)), where g isspecified as in (1).
Let alo C be a subset of{B1, B2, .
.
.
, B?
(p)} such that |C| 6= 0 and |C| 6=?(p).
We let ?C be the alphabet of all variablesxij defined as in (1), for all values of i and j suchthat Bi ?
C and 1 ?
j ?
fi.
For each i with1 ?
i ?
f , we rewrite each string yi in (1) in aform yi = y?i0zi1y?i1 ?
?
?
y?idi?1zidiy?idi , with di ?
0,such that the following conditions are all met:?
each zij , 1 ?
j ?
di, is a string with one ormore occurrences of variables, all in ?C ;?
each y?ij , 1 ?
j ?
di ?
1, is a non-emptystring with no occurrences of symbols in ?C ;?
y?0j and y?0di are (possibly empty) strings withno occurrences of symbols in ?C .1In (Seki et al, 1991) a syntactic variant of LCFRS isused, called multiple context-free grammars.526S ?
gS(A,A), gS(?x11, x12?, ?x21, x22?)
= ?x11x21x12x22?
;A ?
gA(A), gA(?x11, x12?)
= ?ax11b, ax12b?
;A ?
g?A(), g?A() = ?ab, ab?.Figure 1: A LCFRS for language L = {anbnambmanbnambm |n,m ?
1}.Let c = |C| and c = ?
(p) ?
|C|.
Assume thatC = {Bh1 , .
.
.
, Bhc}, and {B1, .
.
.
, B?
(p)} ?
C ={Bh?1 , .
.
.
, Bh?c}.
We introduce a fresh nontermi-nal C with ?
(C) = ?fi=1 di and replace pro-duction p in our grammar by means of the twonew productions p1 : C ?
g1(Bh1 , .
.
.
, Bhc) andp2 : A ?
g2(C,Bh?1 , .
.
.
, Bh?c).
Functions g1 andg2 are defined as:g1(?xh11, .
.
.
, xh1fh1 ?, .
.
.
, ?xhc1, .
.
.
, xhcfhc ?
)= ?z11, ?
?
?
, z1d1 , z21, ?
?
?
, zfdf ?
;g2(?xh?11, .
.
.
, xh?1fh?1 ?, .
.
.
, ?xh?c1, .
.
.
, xh?cfh?c ?
)= ?y?10, .
.
.
, y?1d1 , y?20, .
.
.
, y?fdf ?.Note that productions p1 and p2 have rank strictlysmaller than the source production p. Further-more, if it is possible to choose set C in such away that?fi=0 di ?
f , then the fan-out of p1 andp2 will be no greater than the fan-out of p.We can iterate the procedure above as manytimes as possible, under the condition that the fan-out of the productions does not increase.Example 2 Let us consider the following produc-tion with rank 4:A ?
gS(B,C,D,E),gA(?x11, x12?, ?x21, x22?, ?x31, x32?, ?x41, x42?
)= ?x11x21x31x41x12x42, x22x32?.Applyng the above procedure twice, we obtain afactorization consisting of three productions withrank 2 (variables have been renamed to reflect ourconventions):A ?
gA(A1, A2),gA(?x11, x12?, ?x21, x22?
)= ?x11x21x12, x22?
;A1 ?
gA1(B,E),gA1(?x11, x12?, ?x21, x22?)
= ?x11, x21x12x22?
;A2 ?
gA2(C,D),gA2(?x11, x12?, ?x21, x22?)
= ?x11x21, x12x22?.2The factorization procedure above should be ap-plied to all productions of a LCFRS with ranklarger than two.
This might result in an asymptoticimprovement of the running time of existing dy-namic programming algorithms for parsing basedon LCFRS.The factorization technique we have discussedcan also be viewed as a generalization of well-known techniques for casting context-free gram-mars into binary forms.
These are forms where nomore than two nonterminal symbols are found inthe right-hand side of productions of the grammar;see for instance (Harrison, 1978).
One importantdifference is that, while production factorizationinto binary form is always possible in the context-free case, for LCFRS there are worst case gram-mars in which rank reduction is not possible at all,as shown in (Rambow and Satta, 1999).3 A graph-based representation forLCFRS productionsRather than factorizing LCFRS productions di-rectly, in this article we work with a more abstractrepresentation of productions based on graphs.From now on we focus on LCFRS whose non-terminals and productions all have fan-out smallerthan or equal to 2.
Consider then a production p :A ?
g(B1, B2, .
.
.
, B?
(p)), with ?
(A), ?
(Bi) ?2, 1 ?
i ?
?
(p), and with g defined asg(?x11, .
.
.
, x1?
(B1)?, .
.
.. .
.
, ?x?
(p)1, .
.
.
, x?(p)?(B?(p))?
)= ?y1, .
.
.
, y?
(A)?.In what follows, if ?
(A) = 1 then ?y1, .
.
.
, y?
(A)?should be read as ?y1?
and y1 ?
?
?
y?
(A) should beread as y1.
The same convention applies to allother nonterminals and tuples.We now introduce a special kind of undirectedgraph that is associated with a linear order definedover the set of its vertices.
The p-graph associatedwith production p is a triple (Vp, Ep,?p) such that?
Vp = {xij | 1 ?
i ?
?
(p), ?
(Bi) = 2, 1 ?j ?
?
(Bi)} is a set of vertices;22Here we are overloading symbols xij .
It will always beclear from the context whether xij is a string-valued variableor a vertex in a p-graph.527?
Ep = {(xi1, xi2) |xi1, xi2 ?
Vp} is a set ofundirected edges;?
for x, x?
?
Vp, x ?p x?
if x 6= x?
and the(unique) occurrence of x in y1 ?
?
?
y?
(A) pre-cedes the (unique) occurrence of x?.Note that in the above definition we are ignor-ing all string-valued variables xij associated withnonterminals Bi with ?
(Bi) = 1.
This is be-cause nonterminals with fan-out one can alwaysbe treated as in the context-free grammar case, asit will be explained later.Example 3 The p-graph associated with theLCFRS production in Example 2 is shown in Fig-ure 2.
Circled sets of edges indicate the factoriza-tion in that example.
2x21 x31 x41x11BCDEA1A2x42x12 x22 x32Figure 2: The p-graph associated with the LCFRSproduction in Example 2.We close this section by introducing some ad-ditional notation related to p-graphs that will beused throughout this paper.
Let E ?
Ep be someset of edges.
The cover set for E is defined asV (E) = {x | (x, x?)
?
E} (recall that our edgesare unordered pairs, so (x, x?)
and (x?, x) denotethe same edge).
Conversely, let V ?
Vp be someset of vertices.
The incident set for V is definedas E(V ) = {(x, x?)
| (x, x?)
?
Ep, x ?
V }.Assume ?
(p) = 2, and let x1, x2 ?
Vp.
If x1and x2 do not occur both in the same string y1 ory2, then we say that there is a gap between x1 andx2.
If x1 ?p x2 and there is no gap between x1and x2, then we write [x1, x2] to denote the set{x1, x2} ?
{x |x ?
Vp, x1 ?p x ?p x2}.
For x ?Vp we also let [x, x] = {x}.
A set [x, x?]
is called arange.
Let r and r?
be two ranges.
The pair (r, r?
)is called a tandem if the following conditions areboth satisfied: (i) r?r?
is not a range, and (ii) thereexists some edge (x, x?)
?
Ep with x ?
r andx?
?
r?.
Note that the first condition means that rand r?
are disjoint sets and, for any pair of verticesx ?
r and x?
?
r?, either there is a gap between xand x?
or else there exists some xg ?
Vp such thatx ?p xg ?p x?
and xg 6?
r ?
r?.A set of edges E ?
Ep is called a bundle withfan-out one if V (E) = [x1, x2] for some x1, x2 ?Vp, i.e., V (E) is a range.
Set E is called a bundlewith fan-out two if V (E) = [x1, x2] ?
[x3, x4] forsome x1, x2, x3, x4 ?
Vp, and ([x1, x2], [x3, x4])is a tandem.
Note that if E is a bundle with fan-outtwo with V (E) = [x1, x2] ?
[x3, x4], then neitherE([x1, x2]) nor E([x3, x4]) are bundles with fan-out one, since there is at least one edge incidentupon a vertex in [x1, x2] and a vertex in [x3, x4].We also use the term bundle to denote a bundlewith fan-out either one or two.Intuitively, in a p-graph associated with aLCFRS production p, a bundle E with fan-out fand with |E| > 1 identifies a set of nonterminalsC in the right-hand side of p that can be factorizedinto a new production.
The nonterminals in C arethen replaced in p by a fresh nonterminal C withfan-out f , as already explained.
Our factorizationalgorithm is based on efficient methods for the de-tection of bundles with fan-out one and two.4 The algorithmIn this section we provide an efficient, recursivealgorithm for the decomposition of a p-graph intobundles, which corresponds to factorizing the rep-resented LCFRS production.4.1 Overview of the algorithmThe basic idea underlying our graph-based algo-rithm can be described as follows.
We want tocompute an optimal hierarchical decomposition ofan input bundle with fan-out 1 or 2.
This decom-position can be represented by a tree, in whicheach node N corresponds to a bundle (the rootnode corresponds to the input bundle) and thedaughters of N represent the bundles in which Nis immediately decomposed.
The decompositionis optimal in so far as the maximum arity of thedecomposition tree is as small as possible.
Asalready explained above, this decomposition rep-resents a factorization of some production p of aLCFRS, resulting in optimal rank reduction.
Allthe internal nodes in the decomposition representfresh nonterminals that will be created during thefactorization process.The construction of the decomposition tree iscarried out recursively.
For a given bundle withfan-out 1 or 2, we apply a procedure for decom-posing this bundle in its immediate sub-bundleswith fan-out 1 or 2, in an optimal way.
Then,528we recursively apply our procedure to the obtainedsub-bundles.
Recursion stops when we reach bun-dles containing only one edge (which correspondto the nonterminals in the right-hand side of theinput production).
We shall prove that the result isan optimal decomposition.The procedure for computing an optimal de-composition of a bundle F into its immediate sub-bundles, which we describe in the first part of thissection, can be sketched as follows.
First, we iden-tify and temporarily remove all maximal bundleswith fan-out 1 (Section 4.3).
The result is a newbundle F ?
which is a subset of the original bundle,and has the same fan-out.
Next, we identify allsub-bundles with fan-out 2 in F ?
(Section 4.4).
Wecompute the optimal decomposition of F ?, rest-ing on the hypothesis that there are no sub-bundleswith fan-out 1.
Each resulting sub-bundle is laterexpanded with the maximal sub-bundles with fan-out 1 that have been previously removed.
This re-sults in a ?first level?
decomposition of the originalbundle F .
We then recursively decompose all in-dividual sub-bundles of F , including the bundleswith fan-out 1 that have been later attached.4.2 Backward and forward quantitiesFor a set V ?
Vp of vertices, we write max(V )(resp.
min(V )) the maximum (resp.
minimum)vertex in V w.r.t.
the ?p total order.Let r = [x1, x2] be a range.
We write r.left =x1 and r.right = x2.
The set of backward edgesfor r is defined as Br = {(x, x?)
| (x, x?)
?Er, x ?p r.left , x?
?
r}.
The set of for-ward edges for r is defined symmetrically as Fr ={(x, x?)
| (x, x?)
?
Er, x ?
r, r.right ?px?}.
For E ?
{Br, Fr} we also define L(E) ={x | (x, x?)
?
E, x ?p x?}
and R(E) ={x?
| (x, x?)
?
E, x ?p x?
}.Let us assume Br 6= ?.
We write r.b.left =min(L(Br)).
Intuitively, r.b.left is the leftmostvertex of the p-graph that is located at the leftof range r and that is connected to some ver-tex in r through some edge.
Similarly, we writer.b.right = max(L(Br)).
If Br = ?, then we setr.b.left = r.b.right = ?.
Quantities r.b.left andr.b.right are called backward quantities.We also introduce local backward quanti-ties, defined as follows.
We write r.lb.left =min(R(Br)).
Intuitively, r.lb.left is the leftmostvertex among all those vertices in r that are con-nected to some vertex to the left of r. Similarly,we write r.lb.right = max(R(Br)).
If Br = ?,then we set r.lb.left = r.lb.right = ?.We define forward and local forward quanti-ties in a symmetrical way.The backward quantities r.b.left and r.b.rightand the local backward quantities r.lb.left andr.lb.right for all ranges r in the p-graph canbe computed efficiently as follows.
We processranges in increasing order of size, expanding eachrange r by one unit at a time by adding a newvertex at its right.
Backward and local backwardquantities for the expanded range can be expressedas a function of the same quantities for r. There-fore if we store our quantities for previously pro-cessed ranges, each new range can be annotatedwith the desired quantities in constant time.
Thisalgorithm runs in time O(n2), where n is the num-ber of vertices in Vp.
This is an optimal result,since O(n2) is also the size of the output.We compute in a similar way the forward quan-tities r.f .left and r.f .right and the local forwardquantities r.lf .left and r.lf .right , this time ex-panding each range by one unit at its left.4.3 Bundles with fan-out oneThe detection of bundles with fan-out 1 within thep-graph can be easily performed in O(n2), wheren is the number of its vertices.
Indeed, the incidentset E(r) of a range r is a bundle with fan-out oneif and only if r.b.left = r.f .left = ?.
This imme-diately follows from the definitions given in Sec-tion 4.2.
It is therefore possible to check all rangesthe one after the other, once the backward andforward properties have been computed.
Thesechecks take constant time for each of the ?
(n2)ranges, hence the quadratic complexity.We now remove from F all bundles with fan-out1 from the original bundle F .
The result is the newbundle F ?, that has no sub-bundles with fan-out 1.4.4 Bundles with fan-out twoEfficient detection of bundles with fan-out two inF ?
is considerably more challenging.
A direct gen-eralization of the technique proposed for detectingbundles with fan-out 1 would use the followingproperty, that is also a direct corollary of the def-initions in Section 4.2: the incident set E(r ?
r?
)of a tandem (r, r?)
is a bundle with fan-out two ifand only if all of the following conditions hold:(i) r.b.left = r?.f .left = ?, (ii) r.f .left ?
r?,r.f .right ?
r?, (iii) r?.b.left ?
r, r?.b.right ?
r.529However, checking all O(n4) tandems the one af-ter the other would require time O(n4).
Therefore,preserving the quadratic complexity of the overallalgorithm requires a more complex representation.From now on, we assume that Vp ={x1, .
.
.
, xn}, and we write [i, j] as a shorthandfor the range [xi, xj].First, we need to compute an additional datastructure that will store local backward figures ina convenient way.
Let us define the expansion ta-ble T as follows: for a given range r?
= [i?, j?
],T (r?)
is the set of all ranges r = [i, j] such thatr.lb.left = i?
and r.lb.right = j?, ordered by in-creasing left boundary i.
It turns out that the con-struction of such a table can be achieved in timeO(n2).
Moreover, it is possible to compute inO(n2) an auxiliary table T ?
that associates with rthe first range r??
in T ([r.f.left, r.f.right]) suchthat r?
?.b.right ?
r. Therefore, either (r, T ?
(r))anchors a valid bundle, or there is no bundle Esuch that the first component of V (E) is r.We now have all the pieces to extract bundleswith fan-out 2 in time O(n2).
We proceed as fol-lows.
For each range r = [i, j]:?
We first retrieve r?
= [r.f.left, r.f.right] inconstant time.?
Then, we check in constant time whetherr?.b.left lies within r. If it doesn?t, r is notthe first part of a valid bundle with fan-out 2,and we move on to the next range r.?
Finally, for each r??
in the ordered setT (r?
), starting with T ?
(r), we check whetherr?
?.b.right is inside r. If it is not, we stop andmove on to the next range r. If it is, we out-put the valid bundle (r, r??)
and move on tothe next element in T (r?).
Indeed, in case ofa failure, the backward edge that relates a ver-tex in r??
with a vertex outside r will still beincluded in all further elements in T (r?)
sinceT (r?)
is ordered by increasing left boundary.This step costs a constant time for each suc-cess, and a constant time for the unique fail-ure, if any.This algorithm spends a constant time on eachrange plus a constant time on each bundle withfan-out 2.
We shall prove in Section 5 that thereare O(n2) bundles with fan-out 2.
Therefore, thisalgorithm runs in time O(n2).Now that we have extracted all bundles, weneed to extract an optimal decomposition of the in-put bundle F ?, i.e., a minimal size partition of alln elements (edges) in the input bundle such thateach of these partition is a bundle (with fan-out 2,since bundles with fan-out 1 are excluded, exceptfor the input bundle).
By definition, a partition hasminimal size if there is no other partition it is arefinment of.34.5 Extracting an optimal decompositionWe have constructed the set of all (fan-out 2) sub-bundles of F ?.
We now need to build one optimaldecomposition of F ?
into sub-bundles.
We needsome more theoretical results on the properties ofbundles.Lemma 1 Let E1 and E2 be two sub-bundles ofF ?
(with fan-out 2) that have non-empty intersec-tion, but that are not included the one in the other.Then E1 ?
E2 is a bundle (with fan-out 2).PROOF This lemma can be proved by consideringall possible respective positions of the covers ofE1 and E2, and discarding all situations that wouldlead to the existence of a fan-out 1 sub-bundle.
Theorem 1 For any bundle E, either it has atleast one binary decomposition, or all its decom-positions are refinements of a unique optimal one.PROOF Let us suppose that E has no bi-nary decomposition.
Its cover corresponds tothe tandem (r, r?)
= ([i, j], [i?, j?]).
Letus consider two different decompositions ofE, that correspond respectively to decomposi-tions of the range r in two sets of sub-rangesof the form [i, k1], [k1 + 1, k2], .
.
.
, [km, j] and[i, k?1], [k?1 + 1, k?2], .
.
.
, [k?m?
, j].
For simplifyingthe notations, we write k0 = k?0 = i and km+1 =km?+1 = j.
Since k0 = k?0, there exist an in-dex p > 0 such that for any l < p, kl = k?l, butkp 6= k?p: p is the index that identifies the firstdiscrepancy between both decomposition.
Sincekm+1 = km?+1, there must exist q ?
m andq?
?
m?
such that q and q?
are strictly greaterthan p and that are the minimal indexes such thatkq = k?q?
.
By definition, all bundles of the formE[kl?1,kl] (p ?
l ?
q) have a non-empty intersec-tion with at least one bundle of the form E[k?l?1,k?l]3The term ?refinement?
is used in the usual way concern-ing partitions, i.e., a partition P1 is a refinement of anotherone P2 if all constituents in P1 are constituents of P2, or be-longs to a subset of the partition P1 that is a partition of oneelement of P2.530(p ?
l ?
q?).
The reverse is true as well.
Ap-plying Lemma 1, this shows that E([kp+1, kq]) isa bundle with fan-out 2.
Therefore, by replacingall ranges involved in this union in one decom-position or the other, we get a third decomposi-tion for which the two initial ones are strict refine-ments.
This is a contradiction, which concludesthe proof.
Lemma 2 Let E = V (r ?
r?)
be a bundle, withr = [i, j].
We suppose it has a unique (non-binary)optimal decomposition, which decomposes [i, j]into [i, k1], [k1 + 1, k2], .
.
.
, [km, j].
There existno range r??
?
r such that (i) Er??
is a bundle and(ii) ?l, 1 ?
l ?
m such that [kl, kl+1] ?
r?
?.PROOF Let us consider a range r??
that would con-tradict the lemma.
The union of r??
and of theranges in the optimal decomposition that have anon-empty intersection with r??
is a fan-out 2 bun-dle that includes at least two elements of the opti-mal decomposition, but that is strictly included inE because the decomposition is not binary.
Thisis a contradiction.
Lemma 3 Let E = V (r, r?)
be a bundle, with r =[i, j].
We suppose it has a binary (optimal) decom-position (not necessarily unique).
Let r??
= [i, k]be the largest range starting in i such that k < jand such that it anchors a bundle, namely E(r??
).Then E(r??)
and E([k + 1, j]) form a binary de-composition of E.PROOF We need to prove that E([k + 1, j]) is abundle.
Each (optimal) binary decomposition ofE decomposes r in 1, 2 or 3 sub-ranges.
If no opti-mal decomposition decomposes r in at least 2 sub-ranges, then the proof given here can be adaptedby reasoning on r?
instead of r. We now sup-pose that at least one of them decomposes r in atleast 2 sub-ranges.
Therefore, it decomposes r in[i, k1] and [k1 + 1, j] or in [i, k1], [k1 + 1, k2] and[k2 + 1, j].
We select one of these optimal decom-position by taking one such that k1 is maximal.We shall now distinguish between two cases.First, let us suppose that r is decomposedinto two sub-ranges [i, k1] and [k1 + 1, j] bythe selected optimal decomposition.
Obviously,E([i, k1]) is a ?crossing?
bundle, i.e., the rightcomponent of its cover is is a sub-range of r?.Since r is decomposed in two sub-ranges, it isnecessarily the same for r?.
Therefore, E([i, k1])has a cover of the form [i, k1] ?
[i?, k?1] or [i, k1] ?
[k?1 + 1, j].
Since r??
includes [i, k1], E(r??)
has acover of the form [i, k]?
[i?, k?]
or [i, k]?[k?
+ 1, j].This means that r?
is decomposed by E(r??)
inonly 2 ranges, namely the right component ofE(r??
)?s cover and another range, that we can callr???.
Since r \ r??
= [k + 1, j] may not anchora bundle with fan-out 1, it must contain at leastone crossing edge.
All such edges necessarily fallwithin r???.
Conversely, any crossing edge thatfalls inside r???
necessarily has its other end inside[k + 1, j].
Which means that E(r??)
and E(r???
)form a binary decomposition of E. Therefore, bydefinition of k1, k = k1.Second, let us suppose that r is decomposedinto 3 sub-ranges by the selected original decom-position (therefore, r?
is not decomposed by thisdecomposition).
This means that this decompo-sition involves a bundle with a cover of the form[i, k1]?
[k2 + 1, j] and another bundle with a coverof the form [k1 + 1, k2] ?
r?
(this bundle is in factE(r?)).
If k ?
k2, then the left range of both mem-bers of the original decomposition are included inr?
?, which means that E(r??)
= E, and thereforer??
= r which is excluded.
Note that k is at leastas large as k1 (since [i, k1] is a valid ?range start-ing in i such that k < j and such that it anchorsa bundle?).
Therefore, we have k1 ?
k < k2.Therefore, E([i, k1]) ?
E(r??
), which means thatall edges anchored inside [k2 + 1, j]) are includedin E(r??).
Hence, E(r??)
can not be a crossing bun-dle without having a left component that is [i, j],which is excluded (it would mean E(r??)
= E).This means that E(r??)
is a bundle with a coverof the form [i, k] ?
[k?
+ 1, j].
Which meansthat E(r?)
is in fact the bundle whose cover is[k + 1, k?
+ 1]?
r?.
Hence, E(r??)
and E(r?)
forma binary decomposition of E. Hence, by definitionof k1, k = k1.
As an immediate consequence of Lemmas 2and 3, our algorithm for extracting the optimal de-composition for F ?
consists in applying the fol-lowing procedure recursively, starting with F ?,and repeating it on each constructed sub-bundle E,until sub-bundles with only one edge are reached.Let E = E(r, r?)
be a bundle, with r = [i, j].One optimal decomposition of E can be obtainedas follows.
One selects the bundle with a left com-ponent starting in i and with the maximum length,and iterating this selection process until r is cov-ered.
The same is done with r?.
We retain the opti-mal among both resulting decompositions (or oneof them if they are both optimal).
Note that this531decomposition is unique if and only if it has fourcomponents or more; it can not be ternary; it maybe binary, and in this case it may be non-unique.This algorithm gives us a way to extract an op-timal decomposition of F ?
in linear time w.r.t.
thenumber of sub-bundles in this optimal decomposi-tion.
The only required data structure is, for eachi (resp.
k), the list of bundles with a cover of theform [i, j]?
[k, l] ordered by decreasing j (resp.
l).This can trivially be constructed in time O(n2)from the list of all bundles we built in time O(n2)in the previous section.
Since the number of bun-dles is bounded by O(n2) (as mentioned aboveand proved in Section 5), this means we can ex-tract an optimal decomposition for F ?
in O(n2).Similar ideas apply to the simpler case of thedecomposition of bundles with fan-out 1.4.6 The main decomposition algorithmWe now have to generalize our algorithm in or-der to handle the possible existence of fan-out 1bundles.
We achieve this by using the fan-out 2algorithm recursively.
First, we extract and re-move (maximal) bundles with fan-out 1 from F ,and recursively apply to each of them the com-plete algorithm.
What remains is F ?, which is aset of bundles with no sub-bundles with fan-out 1.This means we can apply the algorithm presentedabove.
Then, for each bundle with fan-out 1, wegroup it with a randomly chosen adjacent bundlewith fan-out 2, which builds an expanded bundlewith fan-out 2, which has a binary decompositioninto the original bundle with fan-out 2 and the bun-dle with fan-out 1.5 Time complexity analysisIn Section 4, we claimed that there are no morethan O(n2) bundles.
In this section we sketch theproof of this result, which will prove the quadratictime complexity of our algorithm.Let us compute an upper bound on the num-ber of bundles with fan-out two that can be foundwithin the p-graph processed in Section 4.5, i.e., ap-graph with no fan-out 1 sub-bundle.Let E,E?
?
Ep be bundles with fan-out two.
IfE ?
E?, then we say that E?
expands E. E?
issaid to immediately expand E, written E ?
E?,if E?
expands E and there is no bundle E??
suchthat E??
expands E and E?
expands E?
?.Let us represent bundles and the associated im-mediate expansion relation by means of a graph.Let E denote the set of all bundles (with fan-outtwo) in our p-graph.
The e-graph associated withour LCFRS production p is the directed graphwith vertices E and edges defined by the relation?.
For E ?
E , we let out(E) = {E?
|E ?
E?
}and in(E) = {E?
|E?
?
E}.Lack of space prevents us from providing theproof of the following property.
For any E ?
Ethat contains more than one edge, |out(E)| ?
2and |in(E)| ?
2.
This allows us to prove our up-per bound on the size of E .Theorem 2 The e-graph associated with anLCFRS production p has at most n2 vertices,where n is the rank of p.PROOF Consider the e-graph associated with pro-duction p, with set of vertices E .
For a vertexE ?
E , we define the level of E as the number|E| of edges in the corresponding bundle from thep-graph associated with p. Let d be the maximumlevel of a vertex in E .
We thus have 1 ?
d ?
n.We now prove the following claim.
For any inte-ger k with 1 ?
k ?
d, the set of vertices in E withlevel k has no more than n elements.For k = 1, since there are no more than n edgesin such a p-graph, the statement holds.We can now consider all vertices in E with levelk > 1 (k ?
d).
Let E(k?1) be the set of all ver-tices in E with level smaller than or equal to k?1,and let us call T (k?1) the set of all edges in the e-graph that are leaving from some vertex in E(k?1).Since for each bundle E in E(k?1) we know that|out(E)| ?
2, we have |T (k?1)| ?
2|E(k?1)|.The number of vertices in E(k) with level largerthan one is at least |E(k?1)| ?
n. Since for eachE ?
E(k?1) we know that |in(E)| ?
2, we con-clude that at least 2(|E(k?1)| ?
n) edges in T (k?1)must end up at some vertex in E(k).
Let T be theset of edges in T (k?1) that impinge on some ver-tex in E \ E(k).
Thus we have |T | ?
2|E(k?1)| ?2(|E(k?1)|?n) = 2n.
Since the vertices of level kin E must have incoming edges from set T , and be-cause each of them have at least 2 incoming edges,there cannot be more than n such vertices.
Thisconcludes the proof of our claim.Since the the level of a vertex in E is necessarilylower than n, this completes the proof.
The overall complexity of the complete algo-rithm can be computed by induction.
Our in-duction hypothesis is that for m < n, the timecomplexity is in O(m2).
This is obviously truefor n = 1 and n = 2.
Extracting the bundles532with fan-out 1 costs O(n2).
These bundles are oflength n1 .
.
.
nm.
Extracting bundles with fan-out2 costs O((n?
n1 ?
.
.
.?
nm)2).
Applying re-cursively the algorithm to bundles with fan-out 1costs O(n21) + .
.
.
+O(n2m).
Therefore, the com-plexity is in O(n2)+O((n ?
n1 ?
.
.
.?
nm)2)+?ni=1 O(ni) = O(n2) +O(?ni=1 ni) = O(n2).6 ConclusionWe have introduced an efficient algorithm for opti-mal reduction of the rank of LCFRSs with fan-outat most 2, that runs in quadratic time w.r.t.
the rankof the input grammar.
Given the fact that fan-out 1bundles can be attached to any adjacent bundle inour factorization, we can show that our algorithmalso optimizes time complexity for known tabularparsing algorithms for LCFRSs with fan-out 2.As for general LCFRS, it has been shown byGildea (2010) that rank optimization and timecomplexity optimization are not equivalent.
Fur-thermore, all known algorithms for rank or timecomplexity optimization have an exponential timecomplexity (Go?mez-Rodr?
?guez et al, 2009).AcknowledgmentsPart of this work was done while the second authorwas a visiting scientist at Alpage (INRIA Paris-Rocquencourt and Universite?
Paris 7), and was fi-nancially supported by the hosting institutions.ReferencesDaniel Gildea.
2010.
Optimal parsing strategies forlinear context-free rewriting systems.
In HumanLanguage Technologies: The 11th Annual Confer-ence of the North American Chapter of the Associa-tion for Computational Linguistics; Proceedings ofthe Main Conference, Los Angeles, California.
Toappear.Carlos Go?mez-Rodr?
?guez and Giorgio Satta.
2009.An optimal-time binarization algorithm for linearcontext-free rewriting systems with fan-out two.
InProceedings of the Joint Conference of the 47th An-nual Meeting of the ACL and the 4th InternationalJoint Conference on Natural Language Processingof the AFNLP, pages 985?993, Suntec, Singapore,August.
Association for Computational Linguistics.Carlos Go?mez-Rodr?
?guez, Marco Kuhlmann, GiorgioSatta, and David J. Weir.
2009.
Optimal reduc-tion of rule length in linear context-free rewritingsystems.
In Proceedings of the North AmericanChapter of the Association for Computational Lin-guistics - Human Language Technologies Confer-ence (NAACL?09:HLT), Boulder, Colorado.
To ap-pear.Michael A. Harrison.
1978.
Introduction to FormalLanguage Theory.
Addison-Wesley, Reading, MA.Aravind K. Joshi and Leon S. Levy.
1977.
Constraintson local descriptions: Local transformations.
SIAMJournal of ComputingMarco Kuhlmann and Giorgio Satta.
2009.
Treebankgrammar techniques for non-projective dependencyparsing.
In Proceedings of the 12th Meeting of theEuropean Chapter of the Association for Computa-tional Linguistics (EACL 2009), Athens, Greece.
Toappear.Wolfgang Maier and Timm Lichte.
2009.
Character-izing discontinuity in constituent treebanks.
In Pro-ceedings of the 14th Conference on Formal Gram-mar (FG 2009), Bordeaux, France.Wolfgang Maier and Anders S?gaard.
2008.
Tree-banks and mild context-sensitivity.
In Philippede Groote, editor, Proceedings of the 13th Confer-ence on Formal Grammar (FG 2008), pages 61?76,Hamburg, Germany.
CSLI Publications.Owen Rambow and Giorgio Satta.
1999.
Independentparallelism in finite copying parallel rewriting sys-tems.
Theoretical Computer Science, 223:87?120.Giorgio Satta.
1992.
Recognition of linear context-freerewriting systems.
In Proceedings of the 30th Meet-ing of the Association for Computational Linguistics(ACL?92), Newark, Delaware.Hiroyuki Seki, Takashi Matsumura, Mamoru Fujii, andTadao Kasami.
1991.
On multiple context-freegrammars.
Theoretical Computer Science, 88:191?229.K.
Vijay-Shanker, David J. Weir, and Aravind K. Joshi.1987.
Characterizing structural descriptions pro-duced by various grammatical formalisms.
In Pro-ceedings of the 25th Meeting of the Association forComputational Linguistics (ACL?87).David J. Weir.
1992.
Linear context-free rewritingsystems and deterministic tree-walk transducers.
InProceedings of the 30th Meeting of the Associationfor Computational Linguistics (ACL?92), Newark,Delaware.533
