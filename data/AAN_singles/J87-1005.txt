AN ALGORITHM FOR GENERATING QUANTIF IER  SCOPINGSJerry R. Hobbs  and Stuart  M.  Sh ieberArtificial Intelligence CenterSRI InternationalMenlo Park, CA 94025andCenter for the Study of Language and InformationStanford UniversityStanford, CA 94305The syntactic structure of a sentence often manifests quite clearly the predicate-argument s ructure andrelations of grammatical subordination.
But scope dependencies are not so transparent.
As a result, manysystems for representing the semantics of sentences have ignored scoping or generated scopings withmechanisms that have often been inexplicit as to the range of scopings they choose among or profligate inthe scopings they allow.This paper presents, along with proofs of some of its important properties, an algorithm that generatesscoped semantic forms from unscoped expressions encoding predicate-argument s ructure.
The algorithmis not profligate as are those based on permutation of quantifiers, and it can provide a solid foundation forcomputational solutions where completeness i sacrificed for efficiency and heuristic efficacy.1 INTRODUCTIONA principal focus of computational linguistics, as abranch of computer science, ought to be the design ofalgorithms.
A large number of algorithms have undoubt-edly been devised for dealing with problems everyresearcher has to face in constructing a natural anguagesystem, but they simply have not received wide circu-lation.
These algorithms are part of the "folk culture",buried in the most technical, unreadable portions of thes-es, passed among colleagues informally at best, and oftenreinvented.
It should be a practice to publish these algo-rithms in isolation, independent of a particular implemen-tation or system.This paper constitutes an effort to initiate such a prac-tice.
A problem that many natural-language efforts havefaced is the recovery of implicit semantic scope depend-ency possibilities - such as those manifest in quantifiersand modals - from predicate-argument relations andrelations of grammatical subordination, which are moreor less transparently conveyed by the syntactic structureof sentences.
Previous computational efforts typicallyhave not been based on an explicit notion of the range ofpossible scopings.
In response to this problem, wepresent an algorithm that generates quantifier scopingsfor English sentences.I.I THE PROBLEM OF GENERATING QUANTIFIER SCOPINGSThe naive algorithm for generating quantifier scopings isto generate all permutations of the quantifiers.
For asentence with n quantified noun phrases this will gener-ate n!
different readings.
But for the sentence(1) Every representative of a company saw mostsamples.there are not six different readings, but only five.
Thereading that is missing is the one in which most samples isoutscoped by every representative but outscopes a compa-ny.
A model for the disallowed reading could include adifferent company not only for each representative butalso for each sample.The reduction in number of readings for a givensentence is not significant for sentence (1), but in thesentence(2) Some representative of every department in mostcompanies saw a few samples of each product.there are only 42 valid readings, as opposed to the 120readings the naive algorithm would generate, and thisCopyright1987 by the Association for Computational Linguistics.
Permission tocopy without fee all or part of this material isgranted provided thatthe copies are not made for direct commercial dvantage and the CL reference and this copyright notice are included on the first page.
To.copyotherwisc, or to republish, requires a fee and/or specific permission.0362-613X/87/010047-63503.00Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 47Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsconstitutes a significant difference indeed.
The recenttrend in computational linguistics has been to view moreand more noun phrases, as well as other constituents, asintroducing quantifiers, so that sentences with this muchquantificational complexity are not at all unusual.
(Theimmediately preceding sentence, for example, has six orseven quantifiers.
)This observation of "illegitimate readings" is notintended as a new or controversial claim about an idio-syncrasy of English.
It accords well with semantic judg-ments about the possibility of such readings.
Forinstance, we find it impossible to view sentence (1) asexpressing that for each representative there was a groupof most samples which he saw, and furthermore, for eachsample he saw, there was a company he was a represen-tative of.We can find the same problem of illegitimate readingsin the standard account of the "Cooper storage" mech-anism for generating quantifier scopings (Cooper 1983).Cooper's method generates an expression in intensionallogic for the illegitimate readings, but the expressioncontains an unbound variable and a vacuous quantifier.
1Finally, the observation follows merely syntacticallyfrom the ill-formedness of certain logical formexpressions.
Let us examine why this is so.
The proposi-tional content of a sentence can be seen as combiningspecifications that restrict he range of quantified entities,together with assertions about the entities so specified.This intuition is often made formal in the use of logicallanguages that syntactically separate the notion of therange of a quantified expression from its scope by placingthe information about the range in a part of theexpression we call the restriction and the assertions in apart called the body.
(Henceforth, we will uniformly usethe terms restriction and body.)
The separation of thesetwo semantic roles of range and scope into restrictionand body as an important fact of the logical structure ofEnglish can be seen, for example, in Woods's four-partquantifier structures (Woods 1977), in the recommen-dations of Moore (1981), and in the generalized quantifi-er research of Barwise and Cooper and others.
Thelatter have demonstrated the necessity of such a sepa-ration for quantifiers other than the standard first-orderones (Barwise and Cooper, 1981 ; Cushing, 1976).But under this understanding of English logical struc-ture, it follows that no sixth reading exists for sentence(1) above.
Consider the reading in which the universaloutscopes the most which outscopes the existential in thelogical form for this sentence.
Then, using the notationof Moore (1981) for four-part quantifier structures, thelogical form must have the following structure:all(r, representative(r) ....... )since the universal is outermost.
Now the existential iswithin the scope of the universal by hypothesis, and sinceit provides a restriction on the range of the variable r, itmust occur in the restriction of the quantifier.
Thus, wehave:all(r, representative(r) & some(c, company(c),of(c,r)) .... saw(r,s)...)But where can the quantifier most be put to bind the vari-able s corresponding to the samples seen?
It mustoutscope its occurrence in the body of the universal, butit must also by hypothesis outscope the existential in therestriction of the universal.
To outscope both, it mustoutscope the universal itself, but this violates theassumed scope relations.
Thus, no such reading is possi-ble.
By a similar argument, it follows from the logicalstructure of English that in general a quantifier from else-where in a sentence cannot come after the quantifierassociated with a head noun and before the quantifierassociated with a noun phrase in the head noun's comple-ment.Most research in linguistic semantics, e.g., Montague(1973) and Cooper (1983), has concentrated on explicit-ly defining the range of possible scope relationships thatcan be manifested in sentences.
But, to our knowledge,all fall prey to the profligacy of generation just outlined.1.2 OTHER ISSUES IN QUANTIFIER SCOPING1.2.1 OTHER SPURIOUS SCOPINGSWe are concerned here only with suppressing readingsthat are spurious for purely structural reasons, that is, forreasons that follow from the general relationship betweenthe structure of sentences and the structure of theirlogical forms and independent of the meanings of theparticular sentences.
For instance, we are not concernedwith logical redundancies, such as those due to thecommutativity of successive universal quantifiers.
Whenwe move beyond the two first-order logical quantifiers todeal with the so-called generalized quantifiers such asmost, these logical redundancies become quite rare.
Simi-larly, we are not concerned with the infelicity of certainreadings due to lexical semantic or world knowledge,such as the fact that a child cannot outscope very man inthe sentenceI've met a child of every man in this room.1.2.2 HEURISTICALLY PRIMARY SCOPINGSComputational research on quantifier scoping hasemphasized generating a single scoping, which can bethought of as heuristically primary, as discussed by, forexample, Woods (1977), Pereira (1983), and Grosz et al(1985).
We are concerned not with generating the bestreading but with generating all readings.
The reader mayobject that it is inappropriate in a practical naturallanguage system to generate scopings one by one fortesting against semantic and pragmatic riteria.
Instead,one should appeal to various heuristics to generate onlythe most likely reading, or at least to generate readings inorder of their plausibility.
These include the following:?
lexical heuristics, e.g., each usually outscopes some;?
syntactic heuristics, e.g., a noun phrase in a relativeclause is usually outscoped by the head noun, and anoun phrase in a prepositional phrase complement of a48 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsrelational head noun usually outscopes the head noun;and?
ordering heuristics, such as the principle that left-to-right order at the same syntactic level is generallypreserved in the quantifier order.
2We are sympathetic with this view.
Nevertheless, thereare several reasons that codifying a complete algorithmremains useful.
First, a complete and sound algorithmprovides a benchmark against which other approachescan be tested.
Second, one may actually wish to use agenerate-and-test mechanism in simpler implementations,and it should be correct and as efficient as possible.
Itshould not generate scopings that can be ruled out onpurely structural grounds.
Finally, the algorithm wepresent might be modified to incorporate heuristics togenerate scopings in a certain order or only certain of thescopings.
The soundness and correctness of the underly-ing algorithm, provide a guarantee of soundness for aheuristically guided version.
We include a few commentsbelow about incorporating ordering heuristics into ourscoping generation algorithm, although we should pointout that the possibilities are somewhat limited due to thelocal nature of where the heuristics can be applied.
Afull discussion of heuristically-guided scoping generationis, of course, beyond the scope of this paper.1.2.3 SCOPE OF OPAQUE PREDICATESIn addition to handling the scoping of quantifiers relativeto each other, the algorithm we present also allows quan-tifiers to be scoped within or outside of opaque argu-ments of higher-order predicates.
For instance, thealgorithm generates two readings for the sentenceEveryone isn't here.corresponding to the two relative scopings of theuniversal quantifier and the negation.2 THE ALGORITHMIn the discussion below, we assume that parsing hasmade explicit the predicate-argument relations and therelations of grammatical subordination i  the form of alogical encoding in an input language.
A well-formedformula (wff) in the input language is a predicate or otheroperator applied to one or more arguments.
An argu-ment can be a constant or variable, another wff, or whatwe will call a complex term.
A complex term is anordered triple consisting of a quantifier, a variable, and awff (called the restriction), which represents the predi-cation that is grammatically subordinated to the variable.The input representation for sentence (2) is, then, thefollowing (ignoring tense):see(<some rand(rep(r),of(r,<every dand(dept(d),in(d,<most c co(e)>) )>) )>,<a-few s and(samp(s),of(s,<each p prod(p)>))>)A complex term can be read "quantifier variable suchthat restriction", e.g., "most c such that c is a company".The output language is identical to the input language,except hat it does not contain complex terms.
Quantifi-ers are expressed in the output language as operators thattake three arguments: the variable bound by the quantifi-er, a wff restricting the range of the quantified variable,and the body scoped by the quantification, schematicallyquantifier(variable, r striction, body)This encoding of quantification is the same as that foundin Woods (1977) and Moore (1981).
We will refer tosuch expressions as quantified wffs.
Thus, one readingfor sentence (2) is represented by the following quanti-fied wff:some(r, and(rep(r),every(d, and(dept(d),most(c, co(c),in(d, c))),of(r, d))),a-few(s, and(samp(s),each(p, prod(p),of(s, p))),see(r, s)))Intermediate structures built during the course of scopinginclude both complex terms and quantified wffs.
We usethe term full seoping for an expression in the outputlanguage, i.e., one that has no complex terms.We also will use the terms bound and free as follows:An expression binds a variable v if the expression is of theform < q v r > or q(v, r ,s)  where q is a quantifier.
Thevariable v is said to be bound in the expressions r, or rand s, respectively.
A variable v is unbound or free in anexpression a if there is an occurrence of v in a that is notalso an occurrence in a subexpression of a binding v.Note that here quantified wffs and complex terms areboth thought of as expressions binding a variable.2.1 SUMMARY OF THE ALGORITHMWe present both nondeterministic and deterministicversions of the algorithm 3 in an ALGOL-like language.Both algorithms, however, have the same underlyingstructure, based on the primitive operation of "applying"a complex term to a wff in which it occurs: a complexterm in a wff is replaced by the variable it restricts, andthat variable is then bound by wrapping the entire formin the appropriate quantifier.
Thus, applying the term< q x r(x) > to a wff containing that complex term, say,p( < q x r(x) > ), yields the quantified wffComputational Linguistics, Volume 13, Numbers 1-2, January-June 1987 49Jerry R. Hobbs and Sluart M. Shieber An Algorithm for Generating Quantifier Scopingsq(x, r(x),p(x)).
This is the primitive operation by whichcomplex terms are removed from a wff and quantifiedwffs are introduced.
It is implemented by the functionapply.The generation of a scoping from a wff proceeds intwo stages.
First, the opaque argument positions withinthe wff are scoped.
The function pull-opaque-argsperforms this task by replacing wffs in opaque argumentpositions by a (full or partial) scoping of the original wff.For instance, if p were a predicate opaque in its onlyargument, then, for the wff p(s (<qxr (x )  > )), pull-opaque-args would generate the wff p(q(x, r(x), s(x))) orthe unchanged wff p(s( < qx r(x) > )).
In the former,the opaque predicate p outscopes the quantifier q.
In thelatter, the quantifier q has not been applied yet and thewff will subsequently yield readings in which q has widerscope than p.Second, some or all of the remaining terms are appliedto the entire wff.
The function apply-terms iteratively(through a tail recursion) chooses a complex term in thewff and applies it.
Thus apply-terms acting upon the wffP( < ql x q(x) > , < qzY r2(Y) > ) will yield one of thefive wffsP( < qlxr l(x) >,  < q2Yr2(Y) >)qlCX, rl(x), p(x, < q2Yr2(Y) > ))q2(Y, r2(Y), P( < ql x rl(x) > , y))q2(y, r2(Y), ql(x, rl(x), p(x, y)))ql(x, rl(x), q2(v, r2(Y), p(x, y)))depending on how many quantifiers are applied and inwhat order.
The choice of a complex term is restricted toa subset of the terms in the wff, the so-called applicableterms.
The principal restriction on applicable terms isthat they not be embedded in any other complex term inthe wff.
Section 4.1 discusses a further restriction.
Thefunction applicable-term returns an applicable term in agiven wff.These two stages are manifested in the function pullwhich generates all partial or full scopings of a wff byinvoking pull-opaque-args and apply-terms.
Since ulti-mately only full scopings are desired, an additional argu-ment to pull and apply-terms controls whether partialscopings are to be returned.
When this flag, completeL istrue, apply-terms, and hence pull will return onlyexpressions in which no more complex terms remain tobe applied, for example, only the last two of the fivereadings above.Finally, the restrictions of the complex terms maythemselves contain complex terms and must be scopedthemselves.
The apply function therefore recursivelygenerates the scopings for the restriction by calling pullon that restriction, and a quantified wff is generated foreach possible partial or complete scoping of therestriction.
Schematically, in the simplest case, for theexpression p( < ql x rl(x, < q2y r2fy) > ) and its complexterm < ql -.. > ,4 apply generates the complete scopingql(x, q2(Y, r2(Y), rl(x,y)), p(x))(having called apply recursively on < q2 ... > ), and thepartial scopingql(x, rl(x , < q2Yr20,) > ), p(x))A subsequent application of the remaining complex termwill yield .the "wide scope" readingq2(.v, r2(Y), ql (x, rl (xy), P(X) )The disallowed readings produced by the "all per-mutations" algorithm are never produced by this algo-rithm, because it is everywhere sensitive to the four-partquantifier structure of the target logical form.The difference between the nondeterministic anddeterministic versions lies only in their implementation ofthe choice of terms and returning of values.
This is doneeither nondeterministically, or by iterating through andreturning explicit sets of possibilities.
A nondeterministicProlog version and a deterministic COMMON LISPversion of the algorithm are given in Appendices A andB.
The full text of these versions (including auxiliaryfunctions not listed here) is available from the authors.A variant of the COMMON LISP version is currentlybeing used at SRI International to generate scopings inthe KLAUS system.2.2 LANGUAGE CONSTRUCTSIn the specifications below, the let construct implementslocal variable assignment.
All assignments are donesequentially, not in parallel.
The syntax islet (assignments)in (body)The entire expression returns what the body returns.Destructuring by pattern matching is allowed in theassignments; for example,let <quant var restrict> := termin (body)simultaneously binds quant, var, and restrict to the threecorresponding components in term.
The symbol " :="  isused for assignment, lambda is an anonymous-function-forming operator.
Its syntax islambda((variable)).
(body)where (variable) is free in (body).
We assume lexicalscoping in lambda expressions.
The statement "returnvalue" returns a value from a function.
The binary func-tion map (similar to LISP's mapcar) applies its secondargument (a lambda expression) to each of the elementsof its first argument (a list).
It returns a correspondinglist of the values of the individual applications.
The func-tion integers(lower, upper) returns a list of the integers in50 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsthe range lower to upper, inclusive and in order(corresponding to APL's iota).
The function length(list)is obvious.
The expression list!n!
returns the nth elementof the list list.
The function subst(x,y, expr) substitutes xfor all occurrences of y in expr.The unary function predicate(wff) returns the mainpredicate in a wff.
The unary function arguments(wff)returns a list of the arguments in a wff.
Applied to twoarguments, wff is a binary function that takes a predicatename and a list of arguments, and returns the wff consist-ing of the application of the predicate to the arguments.Applied to four arguments, wff is a quaternary functionthat takes a quantifier name, a variable name, arestriction, and a body, and returns the quantified wffconsisting of the binding of the variable by the quantifierin the restriction and body.
The binary predicateopaque(predicate, n) returns true if and only if the predi-cate is opaque in its nth argument.
It is naturallyassumed that opaque argument positions are filled by wffexpressions, not terms.
Each of the unary predicateswff?, term?, and quantifier?
returns true if and only if itsargument is a wff, a complex term, or a quantifier opera-tor, respectively.2.3 THE NONDETERMINISTIC ALGORITHMIn the nondeterministic version of the algorithm, thereare three special language constructs.
The unary predi-cate exists(expression) evaluates its argument nondeter-ministically to a value and returns true if and only if thereexist one or more values for the expression.
The binaryoperator "a 1\[ b" nondeterministically returns one of itsarguments (a or b).
The function term(form) nondeter-ministically returns a complex term in form.
Finally, thefunction applicable-term(form) nondeterministicallyreturns a complex term in form that can be applied toform.The nondeterministic version of the algorithm is asfollows.
The function gen(form) nondeterministicallyreturns a valid full scoping of the formula form.function gen (form);return pull(form, true).The function pull(form, complete?)
nondeterministicallyreturns a valid'scoping of the formula form.
If complete?is true, then only full scopings are returned; otherwise,partial scopings arc allowed as well.function pull(form, complete?
);return apply-terms(pull-opaque-args(f orm ),complete?
).The function pull-opaque-args(form), when applied to awff, returns a wff generated from form but with argu-ments in opaque argument positions replaced by a validscoping of the original value.
Since the recursive call topull has complete?
set to false, the unchanged argument isa nondeterministic possibility, even for opaque argumentpositions.
When applied to any other type of expression(i.e., a term of some sort), form is unchanged.function pull-opaque-args(f orm );if not (wff?
(form) )then return formelselet predicate := predicate(form);args := arguments(form)in returnwff(predicate,map(integers(1,length(args)),lambda(arg-index).if opaque(predicate, arg-index)then pull(args\[arg-index\],false)else pull-opaque-args(args\[arg-index\]) ) ).The function apply-terms(form, complete?)
choosesseveral terms in form nondeterministically and appliesthem to form.
If complete?
is true, then only full scopingsare returned.function apply-terms(form, complete?
);if not(exists(term(form)))then return formelselet scoped-form :=apply-terms(apply(applicable-term (fo ),form),complete?
)inif complete?then return scoped-formelse return scoped-form \[\[ form.Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 51Jerry R. Hobbs and Sluar!
M. Shieber An Algorilhm for Generating Quantifier ScopingsThe function apply(term, form) returns a wff consistingof the given complex term term applied to a form form inwhich it occurs.
In addition, the restriction of thecomplex term is recursively scoped.function apply(term,form);let <quant var restrict> := termreturnwff(quant,var,pull(restrict,false),subst ( var, term,form)).2.4 THE DETERMINISTIC ALGORITHMFor the deterministic version of the algorithm, there arefive special language constructs.
The unary predicateempty(set) returns true if and only if set is empty.
Pairedbraces "{ ... }" constitute a set-forming operator.
Thebinary function union applies its second argument (alambda expression) to each of the elements of its firstargument (a set).
It returns a corresponding set of thevalues of the individual applications.
The binary infixoperator U returns the union of its two arguments (bothsets).
The function cross-product takes a list of sets as itsargument and returns the set of lists corresponding toeach way of taking an element from each of the sets inorder.
For example,cross-product( \[{a,b},{c,d,e}\] ) ={ \[a,c\], \[a,d\], \[a,e\], \[b,c\], \[b,d\], \[b,e\] }.The function terms(form) returns the set of all complexterms in form.
The function applicable-terms(form)returns the set of all complex terms in form that can beapplied to form.The deterministic version of the algorithm is identicalin structure to the nondeterministic version.
Each func-tion operates in the same way as its nondeterministiccounterpart, except hat they uniformly return sets ratherthan nondeterministically returning single values.The algorithm is as follows.
The function gen(form)returns a set of all valid full scopings of the formula form.function gen (form);return pull(form, true).The function pull returns a set of all valid scopings of theformula form.
If complete?
is true, only full scopings arereturned; otherwise, partial scopings are allowed as well.function pull(form, complete?
);return union(pull-opaque-args(form),iambda(pulled-opaque ).apply-terms( pulled-opaque,complete?
)).The function pull-opaque-args(form) returns a set of allwffs generated from form, but with arguments in opaqueargument positions replaced by a valid scoping of theoriginal value.
Since the recursive call to pull hascomplete?
set to false, the unchanged argument is a possi-bility even for opaque argument positions.
When appliedto any other type of expression (i.e., a term of somesort), the argument is unchanged.function pu ll-opaque-args (form)if not(wff?
(form) )then return {form}elselet predicate := predicate(form);args := arguments(form)returnunion( cross-product(map( integers( 1, length ( args) ,lambda ( arg-index ).if opaque(predicate, arg-index)then pull(args\[arg-index\], false)else pull-opaque-args(args\[arg-index\]) ) ),lambda( args-possibility).
{wff(predicate, args-possibility) } .The function apply-terms(form, complete?)
returns a set ofscopings of form constituting all of the ways of choosingseveral terms in form and applying them to form.
Ifcomplete?
is true, then only the full scopings are returned.52 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings(3)function apply-terms(form, complete?
);if empty( terms(Jbrm ) )then return \[form}elselet scoped-forms :=union(applicable-terms(form),lambda( term ).union(apply(term, form),lambda( applied-f orm ).apply-terms(applied-form, complete?
))).inif complete?then return scoped-formselse return {form} U scoped-forms.The function apply(term, form) returns a set of all wffsconsisting of the given complex term term applied to theform .form in which it occurs, with the restriction of thecomplex term recursively scoped in all possible ways.function apply(term,form);let (quant var restrict) := termin return(4) union(pull(restrict,false),lambda (pulled-restrict ).
{wff(quant,var,pulled-restrict,subst ( var, term,form)) }).3 Two EXAMPLESSince the algorithm is not completely transparent, it maybe useful to work through the deterministic version for adetailed example.
(5) Some representative of every department in mostcompanies aw a few samples.The predicate-argument structure of this sentence maybe represented as follows:(6)see(<some rand(rep(r) ,of(r,<every dand(dept(d),in(d,<most c co(c )>) )>) )>,<a-few s samp(s)>)Suppose gen is called with expression (6) as form.
Sincethis is the representation f the whole sentence, pull willbe called with complete?
equal to true.
The call to pull-opaque-args will return the original wff unchanged sincethere are no opaque operators in the wff.
We thereforecall apply-terms on the wff.In apply-terms, the call to applicable-terms returns a listof all of the unnested complex terms.
For (6), there willbe two:(7) <some rand(rep(r) ,of(r,<every dand(dept(d),in(d,<most c co(c )>) )>) )>(8) <a-few s samp(s)>Each of these complex terms will ultimately yield thewffs in which its variable is the more deeply nested of thetwo.The function apply is called for each of these complexterms, and inside apply there is a recursive call to pull onthe restriction of the complex term.
This generates allthe possible scopings for the restriction.
When apply iscalled with (6) as form and (7) as term, the result ofseoping the restriction of (7) will be the following fourwffs:(9) and(rep(r) ,of(r,<every dand(dept(d),in(d,<most c co(c )>) )>) )(10) every(d, and(dept(d), in(d, <most c co(c)>)),and(rep(r), of(r, d)))(11) most(e, co(c), every(d, and(dept(d), in(d,c)),and(rep(r), of(r,d))))(12) every(d, most(e, co(c), and(dept(d), in(d,c))),and(rep(r), of(r, d)))Because this call to pull has complete?
equal to false, theunprocessed restriction itself, wff (9), as well as thepartially scoped wff (10), is returned along with the fullyscoped forms of the restriction.
Wff (9) will ultimatelygenerate the two readings in which variables d and coutscope r. Wff (10) is also partial as it still contains acomplex term.
It will ultimately ield a reading in whichr outscopes d but is outscoped by c; the complex term forc is still" available for an application that will give it wideComputational Linguistics, Volume 13, Numbers 1-2, January-June 1987 53Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsscope.
Wffs (11) and (12) will ultimately ield readingsin which d and c are outscoped by r.Each of these wffs becomes the restriction in a quanti-fied wff constructed by apply.
Thus, from restriction(10), apply will construct the quantified wff(13) some(r, every(d, and(dept(d),in(d, <most e co(c)>)),and(rep(r), of(r, d))),see(r, <a-few s samp(s)>))In apply-terms, the tail recursion turns the remainingcomplex terms into quantifiers with wide scope.
Thus, in(13) c and s will be given wider scope than r and d. Forexample, one of the readings generated from wff (13)will bemost(c, co(c),a-few(s, samp(s),some(r, every(d, and(dept(d), in(d, c)),and(rep(r), of(r, d))),see(r, s))))Sentence (5), by the way, has 14 different readings.As an example of the operation of the algorithm on awff with opaque operators, we consider the sentenceEveryone isn't here.This has the predicate-argument structurenot(here(<every x person(x)>))where not is an operator opaque in its only argument.The call to pull-opaque-args returns the two scopingsnot(here(<every x person(x)>))not(every(x,person(x),here(x)))The call to apply-terms then turns the first of these intoevery(x,person(x),not(here(x)))Thus, the following two full scopings are generated:every(x,person(x),not(here(x)))not(every(x,person(x),here(x)))Note that because of the recursive call in pull-opaque-argsthese two readings will be generated even if this form isembedded within other transparent predicates.4 MODIFICATIONS AND EXTENSIONS4.1 RESTRICTING APPLICABLE TERMSThe notion of applicable term used above was quitesimple.
A complex term was applicable to a wff if it wasembedded in no other complex term within the wff.
Therestriction is motivated by the following consideration.Suppose the input wff isp( <q lxq(x ,  <qyyry(y )> )> )If the embedded term were first applied, yieldingq2 (Y, r2 (Y), P( < ql X r I (x~y) > ))the remaining complex term would include a free occur-fence of y so that when it is later applied, resulting in theformulaql (x, r I (xo,), qz (,Y, rz (Y), p(x)))the variable y occurs free in the restriction of q/?Thus, it is critical that a term never be applied to aform when a variable that is free in the term is boundoutside of it in the form.
The simple definition of appli-cability goes part of the way towards enforcing thisrequirement.Unfortunately, this simple definition of applicability isinadequate.
If x had itself been free in the embeddedcomplex term, as in the wffP( < ql x r I (x, < qz y rz (x, y) > ) >)the application of the outer term followed by the innerterm would still leave an unbound variable, namely x.This is because the inner term, which uses x, has beenapplied outside the scope of the binder for x.
Such struc-tures can occur, for instance, in sentences like the follow-ing, where an embedded noun phrase requires referenceto its embedding noun phrase.
5Every man that I know a child of has arrived.Every man with a picture of himself has arrived.In these two sentences the quantifier a cannot outscopeevery because the noun phrase beginning with a embeds areference to every man.
If a were to outscope very, thenhimself or the trace following child of would be outsidethe scope of every man.The definition of applicable term must be modified asfollows.
A term in a wff is applicable to the wff if andonly if all variable occurrences that are free in the termare free in the wff as well.
Our previous definition ofapplicability, that the term be unembedded in anotherterm in the wff, is a simple consequence of thisrestriction.
The versions of the algorithm given inAppendices A and B define the functions applicable-termand applicable-terms in this way.
Given this definition,the algorithm can be shown never to generate unboundvariables.
(See Appendix C.)4.2 ADDING ORDERING tlEURISTICSA full discussion of heuristic rules for guiding generationof quantifier scopings is outside of the aims of this paper.However, certain ordering heuristics can be incorporatedrelatively easily into the algorithm merely by controllingthe way in which nondeterministic choices are made.
Wediscuss a few examples here, merely to give the flavor forhow such heuristics might be added.For instance, suppose we want to favor the originalleft-to-right order in the sentence.
The function applica-ble-terms hould return the complex terms in right-to-leftorder, since quantifiers are extracted from the inside out.The union in line (3) should return form after scoped-forms.if we want to give a noun phrase wide scope when itoccurs as a prepositional phrase noun complement to afunction word, e.g., every side of a triangle, then formshould come before scoped-form in line (3) when pull hasbeen called from line (4) in apply where the first argu-54 Computational Linguistics, Volume 13, Numbers i -2 ,  January-June 1987Jerry'R.
Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsment to apply is a complex term for a noun phrase satis-fying those conditions, e.g., the complex term for everyside o f  a triangle.The modifications turn out to be quite complicated ifwe wish to order quantifiers according to lexical heuris-tics, such as having each outscope some.
Because of therecursive nature of the algorithm, there are limits to theamount of ordering that can be done in this manner.
Atthe most, we can sometimes guarantee that the best scop-ing comes first.
Of course, one can always associate ascore with each reading as it is being generated and sortthe list afterwards.4.3 NONSTANDARD INPUT STRUCTURESThe algorithm as presented will operate correctly only forinput structures that are themselves well-formed.
Forinstance, they must contain no unbound variables.Certain natural language phenomena, such as theso-called donkey sentences, exhibit structures that areill-formed with respect o the assumptions made by thisalgorithm.
For instance, the sentenceEvery man who owns a donkey beats it.has an ill-formed input structure because the pronoun hasto reach inside the scope of an existential quantifier forits antecedent.
Its predicate-argument structure might besomething likebeat(<every m and(man(m),own(m, <some d donkey(d)>))>,d)An alternative is to leave the pronoun unanalyzed, inwhich case the closest reading produced by the algorithmisevery(m, and(man(m),some(d, and(donkey(d), own(m, d)))),the(x, it(x), beat(m, x)))In fact, this is not bad if we take it(x) to mean that x isnonhuman and that x is mentioned in the prior discoursein a position determined by whatever coreference resol-ution process is used.
There is a problem if we take thequantifier the to mean that there is a unique such x andtake the sentence to mean that a man who owns manydonkeys will beat every donkey he owns.
But we can getaround this if, following the approach taken by Hobbs(1983), we take a donkey to be generic, take it to refer tothe unique generic donkey that m owns, and assume thatto beat a generic donkey is to beat all its instances.In any case, modifications to the algorithm would beneeded to handle such anaphora phenomena in all theircomplexity.5 CONCLUSIONWe have presented an algorithm for generating exactlythose quantifier scopings that are consistent with thelogical structure of English.
While this algorithm cansometimes result in a significant savings over the naiveapproach, it by no means solves the entire quantifierscoping problem, as we have already pointed out.
Therehas already been much research on the problem ofchoosing the preferred reading among these allowableones, but the methods that have been suggested need tobe specified in an implementation-free fashion moreprecisely than they have been previously, and they needto be evaluated rigorously on large bodies of naturalisticdata.
More important, methods need to be developed forusing pragmatic onsiderations and world knowledge -particularly reasoning about quantities and dependenciesamong entities - to resolve quantifier scope ambiguities,and these methods need to be integrated smoothly withthe other kinds of syntactic, semantic, and pragmaticprocessing required in the interpretation of naturallanguage texts.ACKNOWLEDGMENTSWe have profited from discussions about this work withPaul Martin and Fernando Pereira, and from thecomments of the anonymous reviewers of the paper.This research was supported by NIH Grant LM03611from the National Library of Medicine, by GrantIST-8209346 from the National Science Foundation, andby a gift from the System Development Foundation.REFERENCESBarwisc, Jon and Coopcr, Robin 1981 Generalized Quantificrs andNatural Language.
Linguistics attd Philosophy 4(2): 159-219.Cooper, Robin 1983 Quant~\[Tcation a d Syntactic Theory.
Rcidcl,Dordrecht.Cushing, Stevcn 1976 Thc Formal Semantics of Quantification.
Ph.D.dissertation.
Univcrsity of California, Los Angclcs.Grosz, Barbara J.; Appclt, Douglas E.; Martin, Paul; Pcreira, FcrnandoC.N.
; and Shinkle, Lorna 1985 The TEAM Natural-LanguageInterface System.
Final Report, Project 4865.
Artificial IntclligcnceCenter, SRI International, Menlo Park, California.Hobbs, Jcrry R. 1983 An Improper Treatment of Quantification iOrdinary English.
In Proceedings 9\[" the 21st Annual Meeting ?~/" theAssociation for Computational Linguistics.
Cambridge, Massachusetts:57-63.Keller, William 1986 Nested Cooper Storage.
Paper presented at thcWorkshop on Word Order and Parsing in Unification Grammars,Friedcnweiler, West Germany (7- I I April).Montaguc, Richard 1973 The Propcr Trcatmcnt of Quantification iOrdinary English.
In Thomason, R., Ed., Formal Philosopl?y.Selected Papers of Richard Montague.
Yale University Press, NcwHaven, Connecticut.Moore, Robert C. 1981 Problems in Logical Fornl.
In Proceedings ?~/"the 19th Annual Meet#lg of the Association .\[br Computational Linguis-tics.
Stanford, California: 117-124.Pcreira, Fernando C.N.
1983 Logic for Natural Language Analysis.Technical Note 275.
Artificial Intelligence Center, SRI International,Menlo Park, California.Woods, William 1977 Semantics and Quantification in NaturalLanguage Question Answering.
Adwmces in Computers.
Vohtme 17.Academic Press, New York: 1-87.Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 55Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier ScopingsAPPENDIX A. PROLOG IMPLEMENTATION OF THE ALGORITHMThe following is the core of a Prolog implementation f the nondeterministic algorithm which includes all but the lowestlevel of routines.
The syntax is that of Edinburgh Prologs, e.g., DEC-20 Prolog.Prolog Implementat ion of Scope Generat ion A lgor i thm/   .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.Representat ion  of wffs:A wff of the form 'p(argl, .
.
.
,argn)'  is represented as the Prolog termwff(p,\[arg1', .... argn'\]) where argi' is the encoding of thesubexpress ion argi.A constant term is represented by the homonymous Prolog constant.A complex term is represented by the Prolog termterm(quant,var , restr ict ' )  where restrict'  is the encoding of the wffthat forms the restr ict ion of the quanti f ier .. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
?
/Z gen(Form,ScopedForm)Z Form ==> a wff with in-place complex termsScopedForm <== a full scoping of Formgen(Form, ScopedForm) --pul l(Form, true, ScopedForm).Z pul l(Form, Complete?, ScopedForm)ZFormComplete?ScopedForm==> a wff with in-place complex terms==> true iff only full scopings are a l lowed<== a full or part ia l  scoping of FormAppl ies terms at various level of embedding in Form, inc ludingapply ing to the entire Form, and to opaque argument posi t ionsinside Form.pull(Form, Complete, ScopedForm) --pu l l_opaque_args(Form, Pul ledOpaque),apply terms(Pul ledOpaque,  Complete, ScopedForm).Z pull opaque_args(Form, ScopedForm)% Form =:> a term or a wff with in-place complex termsZ ScopedForm <== Form with opaque argument posi t ions recurs ive ly  scopedZ Scopes arguments of the given Form recursively.pul l_opaque args(wff (Pred,Args) ,  wff(Pred, ScopedArgs)) :- !,pu l l _opaque args(Pred, I, Args, ScopedArgs).pul l_opaque_args(Term, Term).56 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. tlobbs and Stuart M. Shieber An Algorithm for Generating Quantifier ScopingsZ pul l_opaque_args(Pred,  ArgIndex, Args, ScopedArgs)Pred ==> the predicate of the wff whose args are being scopedArgIndex ==> the index of the argument current ly being scopedArgs :=> list of args from ArgIndex onScopedArgs <:= Args with opaque argument posi t ions recurs ive ly  scopedScopes a given argument if opaque; otherwise, scopes itssubparts recursively.Z No more arguments.pull_opaque_args(_Pred,_ArgIndex,\[\],\[\]) -- !
.Z Current argument posit ion is opaque; scope it.pull  opaque_args(Pred,  ArgIndex,\[FirstArgJRestArgs\],\ [ScopedFirstArgJScopedRestArgs\])  --opaque(Pred,ArgIndex) ,  !,pu l l (F i rs tArg, fa lse ,ScopedFi rs tArg) ,Next Index is ArgIndex+1,pul l_opaque args(Pred, NextIndex, RestArgs, ScopedRestArgs) .Z Current argument is not opaque; don't scope it.pull  opaque_args(Pred, ArgIndex,\[FirstArglRestArgs\],\ [ScopedFirstArglScopedRestArgs\])  --pull  opaque args(F i rstArg,ScopedFirstArg) ,Next Index is ArgIndex+1,pull  opaque_args(Pred,  NextIndex, RestArgs, ScopedRestArgs) .Z apply terms(Form, Complete?,  ScopedForm)ZZ Form =:> a wff with in-place complex termsZ Complete?
:=> true iff only full scopings are al lowedZ ScopedForm <:: a full or part ia l  scoping of FormZZ Appl ies one or more terms to the Form alone (not to any embeddedZ forms.apply terms(Form, _Complete, Form) --not(term(Form,_Term)) ,  !.app ly terms(Form,  false, Form).apply terms(Form, Complete, ScopedForm) --app l i cab le term(Form,  Term),apply(Term, Form, Appl iedForm),apply terms(Appl iedForm, Complete, ScopedForm).Z apply(Term,Form,NewForm)Z Term :=> a complex termZ Form =:> the wff to apply Term toZ NewForm <== Form with the quant i f ier  wrapped around itapply(term(Quant ,Var ,Restr ict ) ,Body,wff(Quant, \ [Var,Pul ledRestr ict ,OutBody\]))  --pul l (Restr ict ,  false, Pul ledRestr ict) ,subst (Var , term(Quant ,Var ,Restr ic t ) ,Body,OutBody) .Z appl icable_term(Form, Term)Z Form ==> an express ion in the logical form languageZ Term <=: a top- level  term in Form (that is, a term embedded inZ no other term) which is not free in any var iable boundZ along the path from Form to the Term.Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 57Jerry R. Hohbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingsapp l i cab le_ term(Form,  Term) --app l i cab le_ term(Form,  Term, \[\]).Z app l i cab le  te rm(Form,Term,B lock ingVars )gZg Form :=> an express ion  in the log ica l  form languageZ Term <=: a top- leve l  term in Form (that is, a term embedded inZ no other  term) wh ich  is not free in any var iab le  boundZ a long the path  f rom Form to the Term.g B lock ingVars  : :>Z a l ist  of var iab les  bound a long the path  so farZ A term is an app l i cab le  top- leve l  term.. .app l i cab le  te rm(term(Q,V ,R) , te rm(Q,V ,R) ,  BVs) .-Z if it meets  the def in i t ion .not ( f ree  in(BVs, R)).Z An app l i cab le  term of the res t r i c t ion  or body of a quant i f ie r  is app l i cab leZ on ly  if the var iab le  bound by the quant i f ie r  is not free in the term.app l i cab le  te rm(wf f (Quant , \ [Var ,Rest r i c t ,Body\ ] ) ,Term,  BVs) --quant i f ie r (Quant ) ,  !,(app l i cab le_ term(Rest r i c t ,Term, \ [Var lBVs \ ] ) ;app l i cab le  term(Body,Term, \ [Var lBVs \ ] ) ) .Z An app l i cab le  term of an argument  l ist  is an app l i cab le  term of the wff.app l i cab le_ term(wf f (  P red ,Args) ,Term,  BVs) --app l i cab le  term(Args ,  Term, BVs).Z An app l i cab le  term of any argument  is an app l i cab le  term of the who le% list.app l i cab le  term(\[FIR\] ,Term, BVs) --app l i cab le  te rm(F ,Term,BVs)  ;app l i cab le  te rm(R,Term,BVs) .Z Note the absence  of a rule look ing  for app l i cab le  terms ins ide ofcomplex  terms.
This  l imits  app l i cab le  terms to be top- leve l .APPENDIX B.
COMMON LISP IMPLEMENTATION OF THE ALGORITHMThe fol lowing is the core of a COMMON LISP implementat ion of the deterministic algorithm which includes all but thelowest level of routines.
; ; ; ,~***~,~,~*****~,~*******~*****~***~**~*************~**~***~*~*~**e;;;;;; COMMON LISP Imp lementat ion  of Scope Generat ion  A lgor i thm;;;* *****************************************************************************;;;;;; Representat ion  of Wffs;;;;;; A wff  of the form 'p (arg l , .
.
.
,a rgn) '  is represented  as the;;; s -express ion  (p arg1' .. argn') where  argi' is the encod ing  of the;;; subexpress ion  argi.
;;;;;; A constant  term is represented  by the homonymous  LISP atom.
;;;;;; A complex  term is represented  by the s -express ion  ( :term quant;;; var restr ict ' )  where  restr ict '  is the encod ing  of the wff  that  forms;;; the res t r i c t ion  of the quant i f ie r .
;;;58 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings;;; Implementation notes:;;;;;; The following simple utility functions are assumed:;;;;;; map-union -- implements the binary function UNION;;; cross-product -- implements the function CROSS-PRODUCT;;; opaque -- implements the binary function OPAQUE;;; integers -- implements the binary function INTEGERS;;;;;; The infix union is implemented with CL function UNION.
;;; The binary prefix union is implemented under the name MAP-UNION;;; to avoid conf l i c t  with the CL function UNION.
;;; The function APPLY is implemented under the name APPLY-Q to avoid;;; conflict with the CL function APPLY.
;;;(defun gen (form)(pull.
form t))(defun pull (form complete?
)(map-union (pull-opaque-args form)(function lambda (pulled-opaque)(apply-terms pulled-opaque complete?
)))))(defun pull-opaque-args (form)(if (not (wff?
form))(list form)(let ((predicate (first form))(args (rest form)))(map-union (cross-product(mapcar (function (lambda (arg-index)(if (opaque predicate arg-index)(pull (nth (- arg-index I) args)nil)(pull-opaque-args (nth (- arg-index I)args))))(integers I (length args))))(function (lambda (args-possibility)(list (cons predicate args-possibility)))))))(defun apply-terms (form complete?
)(if (null (terms form))(list form)(let ((scoped-forms(map-union(applicable-terms form)(function (lambda (term)(map-union(apply-q term form)(function (lambda (applied-form)(apply-terms applied-formcomplete?
)))))(if complete?scoped-forms(adjoin form scoped-forms))))))))(defun apply-q (term form)(let ((quant (second term))(var (third term))(restrict (fourth term)))(map-union (pull restrict nil)(function (lambda (pulled-restrict)(list(list quant var pulled-restrict(subst var term form))))))))(defun applicable-terms (form)(applicable-termsl form ' ()))Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 59Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopings(.defun applicable-termsl (form blocking-vars)(cond (atom form)'())(and (term?
form)(not-free-in blocking-vars (fourth form ))(list form))(term?
form)'())(and (wff?
form)(quantifier?
(first form)))(union (applicable-termsl (third form)(cons (second form) blocking-vars))(applicable-termsl (fourth form)(cons (second form) blocking-vars))))(t (mapcan (function (lambda (arg)(applicable-termsl arg blocking-vats)))(cdr form)))))APPENDIX C. PROOFS OF ALGORITHM PROPERTIESThis appendix includes informal proofs of some impor-tant properties of the nondeterminisitc version of thepresented algorithm.
First, we present a proof of thetermination of the algorithm.
Several criteria of thepartial correctness of the algorithm are also informallyshown, especially, that the algorithm does not generatewffs with unbound variables.However, we do not prove correctness in the sense ofshowing that the algorithm is semantically sound, i.e.,that it.yields wffs with interpretations consistent with theinterpretation of the input expression, simply because wedo not provide a semantics for the input language.
(Theoutput language, of course, has a standard logical seman-tics.
)We do not attempt to prove completeness for the algo-rithm, as the concept of completeness is open to interpre-tation, depending as it does on just which scopings onedeems possible, but we expect that the algorithm iscomplete in the sense that every permutation of quantifi-ers respecting the considerations in the introduction isgenerated.
We also do not prove the nonredundancy ofthe nondeterminism in the algorithm, i.e., that the algo-rithm will not generate the same result along differentnondeterministic paths, although we believe that thealgorithm is nonredundant.C.l NOTATIONWe will use lower Greek letters (a, /3 .
.
.
.  )
as variablesranging over expressions in the logical form language.We inductively define a metric p on expressions in thelogical form language as follows:t 2 + p(r) if a is a complex term < q vr >n nO(a) ~ 1 + i_ZtO(ai) if a is a wfff(al ,  ... , a,) and_EtO(a i) > 00 otherwiseInformally, p is a measure of the embedding depth of thecomplex terms in an expression.c.2 TERMINATIONWe will give an informal proof of termination for thenondeterministic algorithm by induction on this metric p.But first, we present without proof three simple butuseful properties of the metric.Lemmal  If a is a wff, then p(a) = 0 i f  and only if acontains no complex terms.Lemma 2 If a is a wff and/3 is a subexpression of a andp(a) > O, then p(/3) < p(a)Lemma 3 If a is a wff and/3 is a subexpression f a andp(a) = O, then p(/3) = O.We now prove the following theorem, and its corollarywhich gives the termination of the algorithm.
We assumethat calls to the auxiliary functions wff, term, wff?, term?,predicate, arguments, opaque, map, exists, not, applicable-term, subst, and so forth always terminate if the computa-tion of their arguments terminates.Theorem 1.
For all expressions a, the following sixconditions hold':Condition 1: pull-opaque-args(a) terminates with result/3such that p(/3) _< p(a),Condition 2: for all complex terms t in a, apply(t,a) termi-nates with result/3 such that p(/3) < p(a),Condition 3: apply-terms(a,true) terminates with result /3such that p(/3) = O,Condition 4: apply-terms(a f lse) terminates with result/3such that p(/3) _< p(a),Condition 5: pull(a,true) terminates with result /3 suchthat p(/3) = O,Condition 6: pull(a~false) terminates with result /3 suchthat p(/3) _< p(a).60 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorilhm for Generating Quanlifier ScopingsProof."
We first prove the base case, for p(a)  = 0.
ByLemma 1, a must contain no complex terms.
Three ofthe conditions are easily proved.Condition 2: Since, by Lemma 1, there are no complexterms in a, this condit ion holds vacuously.Condition 3: Again, the absence of complex terms in acauses the call to apply-terms to return with result a,and p(a) = 0, so the condit ion holds.Condit ion 4: Similarly, and p(a)  < p(a) trivially.Condit ions 1,5, and 6: These condit ions follow directlyfrom Lemma 4 given below.Lemma 4 For  all expressions a such that p(a)  = 0,pull(a,x) and pull-opaque-args(a) terminatewith result a.Proof sketch: The proof is by a simple induction onthe length of the expression, and uses the base case forconditions 3 and 4 proved above.For the induction step for Theorem 1, we assume theinduction hypotheses that the six condit ions hold for all asuch that p(a)  < n and prove the condit ions for p(a)  = n,for n>0.
The condit ions are proved sequentially.
Inparticular, earlier condit ions for the case p(a) = n areused in the proofs of later ones.
(Since there is no use oflater conditions in earlier ones, this does not introduceany circularity in the proof.
)Condition 1: We must show that pull-opaque-args(a)terminates with result/3 such that 0(\[3) < o(a).
If a isnot a wff, then the condit ion holds vacuously, so weassume that a = f (a  I .
.
.
.
.
a~).
By definition of p,kp(/3) ___ 1 + ~P(/3i)"i= 1(The inequality is necessary because p(/3) may bezero.)
Now/3~ is either a~ or pull(a~false).
In the firstcase, p(/3) < p(a~) trivially.
In the second case, sincea~ is a subexpression of a, by Lemma 2 we have thatp(a~) < p(a)  and we can use the induction hypothesisto show the termination of the call to pull.
Also bythe induction hypothesis, p(fl,) < p(a~).Thus, we see that in either case, p(/3~) < p(a~).
Sok kp(fl) < 1 + Zp( f l i )  < 1 + Zp(a i )= p(a).i= I i= 1Condition 2: We must show that for all terms t in a,apply(t,a) terminates with result /3 such that p(/3) <p(a).
Suppose t= <qvr>.
Then /3 = apply(<q vr>, a) = q(v, 3", 6) where 3' = pull(r, false) and 6 =subst(v, <q v r>, a).Now, let p(r) = m. By Lemma 2, m < n. So by theinduction hypothesis, the computat ion of 3, terminatesand p(3') < m. Also, the computat ion of 6 is assumedto terminate (as mentioned above) with 6 missing thecomplex term t that occurs in a (and possibly othercomplex terms embedded within t).
Sop(a) _< p(a) - -p ( t )  =n-  (2+p(r ) )  =n- -2 - -m.Finally, by definit ion of p we have p(fl) < 1 + p(3,) +p(6) < 1 +m+n-2-m=n-1  <n.We will use the two condit ions just proved in theproofs of the final four conditions.Cond#ion 3: We must show that apply-terms(a,true)terminates with result /3 such that 0(/3) = 0.
ByLemma 1, we know that complex terms exist in a sothe else clause is taken.
Let t = applicable-term(a)and 3, = apply(t,a).
By the second condit ion justproved above, the latter computat ion terminates withP(3,) _< p(a) - 1 < n. Now let e = apply-terms(3,,true).
Again, by the induction hypothesis, this compu-tation terminates with p (?)
= 0.
Since complete?
=true, we return ?
as/3, so p(/3) = 0 as required.Condition 4: We must show that apply-terms(a f lse)terminates with result /3 such that p(/3) < p(a).
ByLemma 1, we know that complex terms exist in a sothe else clause is taken.
Let t = applicable-term(a)and 3' = apply(t,a).
By the second condit ion justproved above, this computat ion terminates with p(3')< p(a) - 1 < n. Now let ?
= apply-terms(3'false).Again by the induction hypothesis, this computat ionterminates with p (e )  < p(3') < n. Since complete?
=false, we return ?
or a as /3.
In either case, 0(/3) <p(a)  as required.We will use the four condit ions just proved in theproofs of the final two conditions.Condition 5: We must show that pull(a,true) terminateswith result/3 such that p(/3) = 0.
Let 3' = pull-opaque-args(a).
By the first condit ion just proved above, weknow this computat ion terminates and 0(3') < n. Now,let e = apply-terms(3",true).
Again by the third condi-tion just proved above, this computat ion terminateswith p (e )  = 0.
Since complete?
= true, we return ?as/3, so p(/3) = 0 as required.Condition 6: We must show that pull(a false) terminateswith result fl such that p(/3) < p(a).
The argument issimilar to that for condit ion 5.
Let 3' = pull-opaque-args(a).
By the first condit ion just proved above, weknow this computat ion terminates and P(3,) < n. Now,let c = apply-terms(3", false).
Again by the fourthcondit ion just proved above, this computat ion termi-nates with p (?)
< p(3') _< n. Since complete?
= false,we return either E or a as /3.
In either case, p(/3) <p(a)  as rquired.This completes the proof of the six conditions, giventhe induction hypotheses, and thus completes the induc-tive proof of the theorem.Corollary 1 For  all wffs a, gen(a) terminates with result/3 such that/3 has no complex terms as subexpressions.Proof: This follows immediately from the fifth condi-tion in Theorem 1 and Lemma 1.Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 61Jerry R. Hobbs and SIuart M. Shieber An Algorithm for Generaling Quantifier ScopingsC.3 CORRECTNESSWe consider several criteria for correctness of the algo-rithm.
Let U(a) = the set of variables that are unboundin a and V(a) = the set of variables that are vacuouslyquantif ied in a.
6 We show that if input expression a iswell-formed, that is, has no unbound variables and novacuous quantif iers (U(a)  = V(a) = ~), and if /3 =gen(a),  thenCriterion 1:/3 has no complex terms;Criterion 2:/3 has no unbound variables (U(/3) = ~);Criterion 3:/3 has no vacuous quantif iers (V(/3) = ~);Criterion 4: for every complex term t in a, there is aquantif ier in /3 that binds the same variable as t andhas the position held by t in a in its body; andCriterion 5: for every quantif ier q in /3, there is either aquantif ier in a or a complex term in a that binds thesame variable.Proof of these five statements does not constitute aproof of correctness, but provides motivation for assum-ing the correctness of the algorithm.
As unbound vari-ables in the output are the prime symptom of problemswith previous algorithms, we take these criteria to be themost critical for indicating correctness.The first criterion follows directly from Corol lary 1.The second and third criteria are a consequence of thefollowing theorem which we prove informally.Theorem 2 For  all expressions such that U(a)=u= {u I. .
.
.
.
u,,,} and V(a)=v= {v I. .
.
.
.
v~}, andfor b E {true, false} and for/3 any of gen(a), pull(a, b),pull-opaque-args( a ), apply-terms(a, b ) , andapply(applicable-term(a), U(/3) = u and V(/3) = v.Proof: Again, the proof is by induction on O(a), butwe will be less formal in demonstrat ing the wel l - founded-ness of the induction.
The base case is trivial because, asshown in the proofs of Theorem 1 and Lemma 4, thefunctions all return their argument unchanged when p(a)= 0.
For  the induction step, we will merely show thateach function maintains the unbound variables and vacu-ous quantifiers, assuming that all the others do.
Theprevious proof of termination provides the wel l - founded-ness of this proof.apply(applicable-term(a),a): We must show that ift = < qxr  > is an appl icable term in a and U(a) = uand V(a) = v then U(apply(t,a)) = u and V(apply(t,a))= v as well.The unbound variables u in a can be divided intotwo (possibly overlapping) sets u~ and u, where u,consists of those variables in u that occur in r and U,consists of those variables in u that occur outside of tin a.
Note that u = u, U u~.
Now assume x occurs in r.Then U(r) = {x} O u~ O u 0 where u 0 is the set of vari-ables bound within a but outside of t and which occurfree in r. But t is an appl icable term, and by the defi-nition of "appl icable term" Uo must be empty.
SoU(r) = {x} U ur.
(If x does not occur in r, a similarargument shows that U(r) = Ur .
)Let r t = pull(r, false) and s = subst(x,t,a).
By theinduction hypothesis, U( / )= {x} U ur.
Since s doesnot include t (which binds x) but does includex, U(s) = {x} U u~.
In forming the quantif ied wff/3 = q(x, r t, s), the unbound variables in /3 consist ofthose in r r and those in s except for x, that isu( /3 )  = \ [ ({x}  u u~) u ({x}  u ur)\]  - {x} = u~ u u~ = u.
(If x does not occur in r, similar arguments how thatU(r ' )=u r, U (s )= {x}Uu s, and U( /3)= \[({x} UU,)o u~\] - {x} = u, u Ur = U.
)Vacuous quantif ied variables can be divided simi-larly into v~ (those bound vacuously in r) and v~ (thosebound vacuously outside of t in a).
Again, v = vr U v,.Trivially, V(r) = Vr.
By induction, V(r') = Vr also.Since s does not include t, V(s) = v~.
V(/3) =V(r) U V(s) = v unless the quantif ication of x in 13 isvacuous.
Since x is guaranteed to occur in s (as itreplaces t in s), the quantif ication is clearly not vacu-ous.
So I/(/3) = v.apply-terms(a,b): This follows straightforwardly from theprevious subproof  for apply and the induction hypoth-esis for apply-terms.pull-opaque-args(a): If a is not a wff, then the proof istrivial.
Otherwise, there are two cases, depending onwhether the predicate in a, p, is or is not a quantif ier.If p is not a quantif ier, then the result fol lows imme-diately from the induction hypothesis for pull and pull-opaque-args.If p is a quantif ier, then let a = p(x,r,s).
The output/3 then is wff(p, pull-opaque-args(x), pull-opaque-args(r), pull-opaque-args(s)).
The first call topull-opaque-args merely returns x.
Now by an argu-ment similar to that given in the subproof  for apply,the unbound variables in a can be exhaustively dividedinto Ur and U, depending on whether they occur in rand s. Depending on whether x occurs in r,U(r) = {x} U u, or U(r) = u, Similarly, U(s) = {x} U U,or U(s )= u~.
Suppose the second and third calls topul l -opaque-args return r ~ and s t respectively.
By theinduction hypotheses U(r t) = U(r) and U(J )  = U(s).If the quantif ication of x in a is not vacuous, then xoccurs free in either r or s (and by induction in r r or s t)so U(/3) = {x} U ur U U~ - {x} = u.
If the quanti f icat ionof x is vacuous, then U(r t )=u~ and U( J )=U,  andU(/3)  = u.Vacuous quantif ied variables can be divided into vrand v~ similarly.
Suppose the quanti f icat ion of x isvacuous (i.e., x does not occur free in r or s).
Then VV(a) = {x} U v, Uv,.
By the induction hypothesis,V(r t) = V(r) = v~ and V(s t) = V(s) = v~.
Also byinduction, x does not occur free in r t or s t, Therefore,the quantif ication of x in /3 is also vacuous andV(/3) = {X} U V r U V s = V(a).If the quantif ication of x is not vacuous, thenv -- vr O v~ and x occurs free in either r or s. By induca-62 Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987Jerry R. Hobbs and Stuart M. Shieber An Algorithm for Generating Quantifier Scopingstion, x .Occurs free in either r p or  s p so the quant i f ica-t ion of  x in/3 is also non-vacuous.
A lso by induct ionas before,  V(r ~) = Vr and V(J)  = v~, soV(fl) = V(r') U V(s') = v r U v s = V(a).pull(a,b): This fo l lows directly, using the prev ious lyproved induct ion steps for apply-terms and pull-opaque-args.gen(a): This fo l lows directly, using the previous ly  provedinduct ion step for pull.This concludes the proof  of  the induct ion step and thetheorem.The second and third criteria fo l low f rom thepresumed wel l - fo rmedness  of  a and Theorem 2 whichdemonstrates  that gen maintains wel l - formedness.The fourth and f i fth criteria we argue informal ly  asfol lows: Since no complex  terms occur  in /3 (by Coro l -lary 1), we can assume that every  complex  term t in awas appl ied (i.e., the first a rgument  of  apply) at somet ime in the process ing of  a.
But  if it was appl ied, then itmust have been  an appl icable term occurr ing in the wff  itwas appl ied to (as the only  call to apply is of this form).Then  the call to subst in apply will not  be vacuous,  thequant i f ier  will b ind the same var iable as t and willoutscope the posit ion held by t in a.
Thus the fourthcr i ter ion holds.
A lso  note  that all quant i f iers  in /3 aree i ther  the result of  such an appl icat ion or were in aoriginally.
Thus the f i fth cr i ter ion fo l lows immediate ly  aswell.NOTES1.
William Keller (1986) has also noted this problem with Cooper'smethod.
His independent solution to the problem, stated in termsof "nested Cooper storage", resembles the one presented here.2.
These heuristics should themselves be made available in a publicforum.3.
A nondeterministic version of the algorithm, formulated by bothauthors, was presented by Hobbs (1983).4.
Note that this term is applicable according to the criterion discussedabove, whereas the embedded term binding y is not.
The fact thatwe still get both scopings even without the possibility of applyingthe embedded term first demonstrates that the restriction on appli-cable terms does not affect completeness of the algorithm.5.
This problem was pointed out to us by Fernando Pereira.6.
A variable v is vacuously quantified in an expression ~if and only ifv is bound in a subexpression of a, a quantified wff of the formq(v, r, s) and v does not occur free in r or s. This definition impliesthat variables bound by complex terms are never vacuously quanti-fied.Computational Linguistics, Volume 13, Numbers 1-2, January-June 1987 63
