Syntactic and Semantic Knowledge in theDELPHI Unification GrammarR.
BobrowRobert IngriaDavid StallardBBN Systems and Technologies Inc.10 Moulton Street, Mailstop 6/4CCambridge, MA 02138AbstractThis paper presents recent natural language work on HARC,the BBN Spoken Language System.
The HARC system in-corporates the Byblos system \[6\] as its speech recognitioncomponent and the natural anguage system Delphi, whichconsists of a bottom-up arser paired with an integrated syn-tax/semantics unification grammar, a discourse module, anda database question-answering backend.
The paper focuseson the syntactic and semantic analyses made in the grammar.IntroductionThis paper discusses the unification-based grammar compo-nent of the BBN Delphi system, the natural language compo-nent of the BBN Spoken Language System.
This grammar,previously discussed in \[4\]\[5\], is written in a variant of theDefinite Clause Grammar formalism \[17\] and simultaneouslyassigns both syntactic structure and semantic interpretationto an utterance.
The grammar comprises ome 1300 rules(including those for terminal items), and has recently beenevaluated on the ATIS air travel information domain withfavorable results \[2\].The paper has two main purposes.
The first is to presentthis grammar's treatment of a number of syntactic and se-mantic phenonomena in the ATIS domain, in the belief thatcomparison of analyses are useful in and of themselves, par-ticularly in the context of a common evaluation.
In particu-lar, we discuss the constraints imposed by subgrammars onconjunction, relaxation of subject verb agreement, optionalargument subcategorization, a d semantic interpretation ofPPs and nominal compounds.The second purpose is to argue for the necessity of a de-vice which is frequently made use of Definite Clause Gram-mar work, but which has less often been utilized in the workon unification grammar that has appeared more recently (\[19\]\[14\]).
This is the right-hand side "constraint relation" thatdoes not derive any constituent of the utterance, but ratherserves to constrain in various ways the feature assigments ofthose rule elements which do.
Constraint relation elementsare thus to be distinguished from other non-terminals whichderive empty constituents, uch as gaps or zero morphemes.While constraint relations have long been used in DCG-based workto treat, among other things, problems of quan-tifier scoping and the interaction of quanfifer scope andanaphora \[16\] [18\] we argue that there are other, more low-level issues of lexical semantics and syntax for which con-straint relations are either conceptually useful or formallynecessary, even in unification formalisms which allow fulldisjunction across features, such as \[10\] \[12\] \[11\] \[9\].The remainder of the paper is divided into sections.
Inthe next section, we first briefly review the formalism weuse.
In the two sections after that, we present syntacticanalyses and semantic analyses made by the Delphi gram-mar, with emphasis placed on the use of constraint relationelements.
Finally, in the last section we discuss the questionof whether or not the constraint elements can be compiledout of grammar rules.Grammar FormalismThe Delphi grammar formalism is a variant of DefiniteClause Grammar and is discussed in more detail in \[4\]\[5\].Left- and right-hand side rule elements have a functor (theirmajor category) and zero or more features in a fixed-arity,positional order.
Features are slots which are filled by terms.Terms can either be variables, which are atoms prefixed bycolons ":", or functional terms consisting of a functor andzero or more features, again in fixed positional order, oc-cupied by other terms.
Note that this means that constantsin Delphi are just nullary functions.
Disjunctions of purelyatomic values are allowed as terms, with the functor ":OR".The following is an example role, much simplified forexpository purposes, for handling NP conjunctions:(NP (AGR :P (PLURAL)) (REALNP :REALZ))(NP (AGR :PERSONX :NU1VLX) (REALNP :REALX))(CON J)(NP (AGR :PERSONY :NUMY) (REALNP :REALY))(P-MIN :PERSONX :PERSONY :P)(NPTYPE-FILTER :REALX :REALY :REALZ)P-MIN and NPTYPE-FILTER are constraint relations whosefunction will be discussed in the next section.This formalism maintains the term unification practice ofusing functors with obligatory, positional arguments, ratherthan functorless feature structures with optional, labelled ar-guments, as in much recent work.
There are several reasonsfor this.
First of all, we find the functor very useful as a230way of indicating just what features are allowed in a givenstructure (and it is interesting to note attempts to restore itfor just this purpose in \[13\].)
Second, argument labels con-tribute their own clutter to the role.
They would thus seemto be a notational win only if more than half the features of agiven element are "don't-cares".
In our grammar, however,we find on average that only about 3% of the feature slotsin rules are "don't-cares".We should emphasize, however, that none of the workpresented here hinges on these notational choices, and allthe points made in subsequent sections carry over just aswell to other unification otations.Syntactic Constraint AnalysesRestrictions on agreement between features ometimes de-pend on the values of still other features.
For example,English noun phrase conjunctions require that if one of theconjuncts belongs to a particular subgrammar (date, timeetc.)
then the other conjunct(s) must also belong to thatsubgrammar, but if neither of the conjuncts belongs to asubgrammar, there is no restriction.
This can be done byincluding in the NP conjunction rule a constraint relationwhich provides a case-analyzing effect that could not beprovided merely by unifying the variables ranging over thesemantic type.
This function is carried out by NPTYPE-FILTER, which we introduced above.
This relation takesas its arguments he NPTYPE feature of the first conjunct,the NPTYPE of the second conjunct, and the NPTYPE fea-ture of the conjunction as a whole.
This relation, then, canbe thought of as constraining the possible triples of thesevalues.
1 We present four instances of this rule for illustra-tion, where "~ 0" indicates production of the empty string.
(NPTYPE-FILTER (NONUN1TNP(NONUNITNP(NONUN1TNP~O(NPTYPE-FILTER (NONUNITNP(NONUN1TNP(NONUNITNP---+0(NPTYPE-FILTER (NONUNITNP(NONUNITNP(NONUN1TNP~0(NPTYPE-FILTER (NONUNITNP(NONUNITNP(NONUNITNP~0(-PRO (TIMENP)))(-PRO (TIMENP)))(-PRO (TIMENP))))(-PRO (DATENP)))(-PRO (DATENP)))(-PRO (DATENP))))(-PRO (MISCNP)))(+PRO :PRO-TYPE))(-PRO (MISCNP))))(+PRO :PRO-TYPE))(--PRO (MISCNP)))(-PRO (MISCNP))))The first two rules require that if either of the conjunctsof a conjoined NP belongs to the TIMENP or DATENPsubgrammar, than the other conjunct must belong to thatsubgrammar, as well.
The last two rules allow ordinarypronominal and non-pronominal NPs to conjoin freely.
2 InlAltematively, it can be viewed as computing a value for the NPTYPEfeature of the conjunction from the values of the individual conjuncts.2They also set the NPTYPE of the conjunction to being non-pronominal,since it cannot function as a pronoun.this example, note that while the first two rules could becollapsed into a single rule utilizing unifying variables, thethird and fourth cannot.Another use of constraint relations is to "compute" a valuefrom the feature values of the relevant consitutents, ratherthan requiring identity of features.
For example, in NP con-junction with "and" in English, the person of the conjoinedNP is first person if any of the conjuncts is first person, sec-ond person, if any of the conjuncts i  second person and noneis first person, and third person ff all the conjuncts are thirdperson) This can be easily handled by the P-MIN constraintrelation, which takes as its arguments he PERSON featureof the first conjunct, the PERSON of the second conjunct,and the PERSON feature of the conjunction as a whole.
Ithas the following solutions:(P-MIN (1ST) :P (1ST)) .-4 0(P-MIN (3RD) :P :P) ---+ 0(P-MIN (2ND) (1ST) (1ST)) ~ 0(P-MIN (2ND) (3RD) (2ND)) ~ 0(P-MIN (2ND) (2ND) (2ND)) -4 0Still another case in which constraint relations provide akind of flexibility greater than that available using standardunification is to allow the grammar to express "degrees ofgrammaticality".
For example, in standard written English,it is common for a verb to agree in number with its subject.
4What do the restrictions represent?What does restriction VU/1 mean?What do the transport codes AL and R mean?However, in spoken English, conjoined noun phrasessometimes appear with singular agreement on the verb.What does RETURN ~ and RETURN MAX mean?What does class B and class Y mean?In still looser speech, agreement disappears even withnon-conjoined subject noun phrases:List all the airlines that flies from Dallas to Boston nonstop.These facts can be handled by modifying the standardsentence rule:(ROOT-S :MOOD)(NP :AGR)(VP :AGR :MOOD)to the following:(ROOT-S :MOOD)(NP :AGR :CONJC)(VP :AGRX :MOOD)(SUBJECT-VERB-AGREEMENT :AGR :AGRX :CONJC)3Karttunen \[10\] handles such cases with a procees of generalization,rather than unification.4All of the examples in this discussion of subject-verb agreement aretaken from the ATIS corpora collected by TI and distributed by NIST.231and adding the following solutions for SUBJECT-VERB-AGREEMENT.
This is a constraint relation that takes asits arguments the agreement feature of the sentence's sub-ject NP, the agreement feature of the sentence's VP, andthe conjunction feature of the subject NP which indicateswhether it is a conjunction or not.
(SUBJECT-VERB -AGREEMENT(SUBJECT-VERB-AGREEMENT(SUBJECT-VERB -AGREEMENT(SUBJECT-VERB -AGREEMENT(AGR :P :N)(AGR :P :N):CON J)--~0(AGR :P (PLURAL))(AGR :P (SINGULAR))(+CONJ :CONJTYPE))--~0(AGR :P (PLURAL))(AGR :P (SINGULAR))( -CON J))~0(AGR :P (SINGULAR))(AGR :P (PLURAL))( -CON J))---~0The first of these solutions enforces tandard subject verbagreement: whether the subject NP is a conjunction or not,the agreement features of the subject and the VP must bethe same.
The second allows the VP to bear the singularfeature when the subject is plural, just in case the subject isa conjunction.
The last two rules allow the subject and theVP to disagree, when the NP is not a conjunction.
The state-ment about he conjunction status of the subject is necessaryin these last two solutions to make them orthogonal to thefirst two, so that a single structure will not be unnecessarilyanalyzed with more than one solution.This mechanism is superior to simply not requiring a VPto agree with its subject at all, by using distinct variablesfor the agreement features of the subject NP and the VP,since, given a large enough colpus, we can automaticallyassociate different probabilities with the different solutionsof this constraint relation.
This is particularly useful in aspoken language system, since this will allow all the pos-sibilities, with some degree of probability, but will alwaysprefer the most common solution and will only choose a lesslikely solution if a more common one is unavailable.Semant ic  Const ra in t  Ana lysesThe facility for case analysis is also used in semantic inter-pretafion, where the meaning representation f constructionsare computed in terms of values of certain features whichcannot always be known in advance.PP InterpretationPrepositional phrases, in both post-copular nd post-nominalpositions, are very common in the ATIS domain (and mostother domains as well).
Some examples:Which flights are on Delta AirlinesWhich flights are on ThursdayWhich flights are after 4 pmThe role in our grammar which generates a post-copularPP is the following:(VP :SUBJ :WFF)(V (BE))(PP :PP)(PREDICATIVE-PP :PP :SUBJ :WFF)PREDICATIVE-PP is the constraint relation in the role.
Itis responsible for specifying the formula meaning of the VPin terms of the translation of the PP (:PP) and the translationof the subject passed own from the clause (:SUB J).The PREDICATIVE-PP solution for the "flight-on-airline"sense is as follows:(PREDICATIVE-PP (PP-SEM (:OR (ON)(ABOARD)(ONBOARD))(:NP AIRLINE))(:SUBJ FLIGHT)(EQUAL (FLIGHT-AIRLINE-OF :SUBJ):NP))The first occurences of the variables :NP and :SUBJ aboveare paired with semantic types AIRLINE and FLIGHT; thisis shorthand for me actual state of affairs in which a termrepresenting a package of information (including encoding ofsemantic type) appears in the slots of the role these variablesoccur in.
This term carries quantification and semantic typeinformation, as below:(Q-TE/~w (QUmCrn~ER) (VARIABLE)(NOM (PARAMETER) (SET) (SORT)))This structure is so constructed as to not unify with anothersuch structure if its semantic type is disjoint, using a methodfor encoding semantic types as terms described in \[20\].The PP translation is also a package with the functor PP-SEM, containing the preposition and the translation of theNP object of the PP.
No local attempt is made to translatethe preposition.When parsing with the above predicate PP role, the systemsearches through adatabase of PREDICATIVE-PP solutionslike the above, much as a PROLOG-based system would.If a solution succesfully unifies, the formula is passed up asthe translation of the VP.
Recursion is allowed, as in:(PREDICATIVE-PP (PP-SEM :PREP (:NP TIME))(:SUBJ FLIGHT):WFF)(PREDICATIVE-PP (PP-SEM :PREP (:NP TIME))(DEPARTURE-TIME-OF :SUB J):WFF)This rule says that any PP relating a flight to a time shouldbe translated as if it related the departure time of the flight tothat time.
In this way, a common system of PREDICATIVE-PP solutions stipulating the meanings of various preposi-tional comparisons between times ("after", "before", "on",232"during") can be specitied just once, and used in multiplecontexts.Such a method for interpreting PPs can be compared toone that uses unification over features of constituent ele-ments instead of constraint relations, such as proposed in\[13\] and \[8\].
There, the multiple meanings of a prepositionare enumerated locally as a semantic feature of the preposi-tion, using a form of full-scale disjunction.
Type constraintsfilter out those which are not meaningful in the given con-text, just as in our work.We claim, however, that the constraint relation method issuperior exactly in view of its recursive power as describedabove.
In order to handle such constructions a "flight after4pm", "flight before 4 pm" etc.
a strictly unification-basedapproach would have to compile out all the possibilities forthe type of the clause subject (TIME, FLIGHT etc.)
andstore them as disjunctive values of the translation featureon the given preposition.
Thus in the ATIS domain therewould be (at least) two senses of the preposition "after",both expressing the "time-after" elation.
Clearly such anapproach would not capture the general relations on timesthat these prepositions express.SubcategorizationOne of the devices used by the DELPHI grammar for en-coding subcategofization is derived from GPSG \[7\].
Thisis to place a feature for subcategofization  the rule for agiven verb, and key all VP rules off this feature:(VP :SUBJ :WFF) ;for "John kicked Mary"------k(V (TRANSITIVE :WFF :SUBJ :OBJ))(hiP :OBJ)The semantics of the subject of the sentence is passed ownthrough the :SUBJ variable to the V, along with the seman-tics of the complements.
The V in turn passed back up theformula representing the semantics of the whole sentence,through the :WFF variable.Of course this mechanism requires one VP rule for everysubcategorization frame one wants to handle, and this canmn to many rules (about 60 in the DELPHI grammar).
Amore serious problem, however, arises in the case of optionalcomplements overbs, as seen in the following actual ATIStraining sentences that use the verb "arrive":Show me all flights from Boston to Denver that arrivebefore 5 PMShow me flights ... that arrive in Baltimore before noonShow me all the nonstop flights arriving from Dallasto Boston by 10 PM ...Show me flights departing Atlanta arriving San Franciscoby 5 PMShow me flights arriving into Atlanta by 10 PM from DallasWe see here that, in addition to the temporal PP that alwaysaccompanies it, "arrive" can be followed by (1) nothing else,(2) a PP with "in", (3) a "from"-PP and a "to"-PP, (4) abare noun phrase, or (5) an "into"-PP and a "from"-PP.
Theprinciple pattern that emerges i  one of complete optionalityand independence of order.
Indeed, in the fifth example, thetemporal PP, which might be more traditionally regarded asan adjunct rather than a complement, and thus as one ofthe siblings of the VP rather than one of its constituents, iinstead interposed between two PPs complements, makingthe adjunct analysis rather problematic, sThe only way the subcategorization scheme presentedabove could deal with these variations would be to enu-merate them all in separate roles.
But this would clearly beinfeasible.
The solution we have adopted constructs a right-branching tree of verbal complements, where the particularconstituents admitted to this tree are controlled by constraintrelations keying off the lexical head of the verb.
There aretwo main rules:(VP :SUBJ (AND :INITIAL-WFF :COMP-WFF))(V :LEX (INTRANSOPTCOMPS :SUBJ:INITIAL-WFF))(OPTCOMPS :LEX :SUBJ (DUMMY) :COMP-WFF)and(VP :SUBJ (AND :INIIIAL-WFF :COMP-WFF))(V :LEX (TRANSITIVEOPTCOMPS :SUBJ:OBJ:INITIAL-WFF))(NP :OBJ)(OPTCOMPS :LEX :SUBJ :OBJ :COMP-WFF)The category OPTCOMPS generates the fight-branching treeof optional complements.
It has the rules(OPTCOMPS :LEX :SUBJ :OBJ (AND :WFF1 :WFF2))(PP :PP)(OPTCOMPS :LEX :SUBJ :OBJ :WFF1)(OPTCOMP-PP :LEX :SUBJ :OBJ :PP :WFF2)and(OPTCOMPS :LEX :SUBJ :OBJ (TRUE)) ~ 0The OPTCOMP-PP is the constraint relation; it keys offthe lexical head of the verb (the variable :LEX) and com-bines the subject, object, and PP complement translations toproduce the contribution of the PP complement to the finalformula that represents he sentence meaning.
An arbitrarynumber of PP complements are provided for by the recursionof the first role above, which bottoms out in the case of thesecond role when there are no more complements.
Phrasaltypes other than PPs are accomodated by similar mles.The solution for PP complements o "arrive" such as "inAtlanta", "into Baltimore .... at Denver" etc.
follows:5To see that these PPs are truly associated with the verb rather thansomehow modifying the subject flight-NP, one need only replace the subjectwith the pronoun "it".233(OPTCOMPS (ARRIVE)(:SUBJ type FLIGHT) :ANY(EQUAL (DESTINATION-CITY :SUB J) :NP))(PP (PP-SEM (:OR (INTO) (IN) (AT)) (:NP type CITY)))(N-BAR :NOM3)(N-BAR :NOM1)(N :NOM2)(NOM-COMP-READING :NOM1 :NOM2 :NOM3)This rule says that for a flight to "arrive" INTO, IN orAT a city means that the city equals the value of the flight'sDESTINATION-CITY attribute.
Semantic type informationis here notated with a shorthand keyword "type"; in the ac-tual system apartially-specified term that packages emantictype information in a specific slot is unified into such vari-ables as :SUBJ, :OBJ and :NP.
Note also the use of disjunc-tion (the :OR) to combine different prepositions together.Other devices for encoding subcategorization have beenproposed.
One, made use of in PATR-II and described in\[19\] encodes ubcategorization infomaation as a list of thecomplement patterns that are required to follow the verb,and generates a right-branching tree of VPs, each absorbingone of the complements in the list until no more are left.The difference between the PATR-II scheme and the oneway presented here is that the complements in PATR-II arerequired and must follow one another in a predeterminedorder.
The only obvious way it could handle the optionalityand order independence s en in the "arrive" examples isjust the same brute-force method of enumerating possiblities,using lists of differing order and length.Using Unification to Encode Semantic Con-straints beyond Semantic TypeNot all constraints on meaningfulness are strictly reflectionsof the semantic type of phrase denotations.
Consider thelexical item "L" in the ATIS training set.
Seen in a numberof different database fields, it can variously denote limousineavailablity, lunch service, or other classes of service avail-able on a flight.
Yet in the following example it is clear thatits usage is relevant to just the first of these:What is transport code L?Our claim is that not just the referent of "L"--limolasineservice for ground transportation--that pl ys a role here, butalso the means by which it gets to that referent: namely, bybeing an abbreviation or code rather than a name.
That is,"transport code L" is a meaningful compound, while "trans-port code limousine" would not be.
The lexical entry forabbreviation terms like "L" reflects this by taking the formof an inverse function application: the referent of the lexicalitem "L" is the ground transportation type that has the string"L" as its abbreviation:(INVERSE-VAL* (ABBREV-OF) "L"(GROUND -TRANSPORTATION))While this has the same referent as the lexical entry for"limousine" it has a different form, one which the role ana-lyzing the construction above makes use of.Nominal compounds in the DELPHI system are generatedby the following rule:in which the constraint relation NOM-COMP-READINGcomputes the semantics of the whole conslruction from thesemantics of the head houn and the nominal modifier.
NOM-COMP-READING has different solutions for different se-mantic types of noun translation.
The relevant one here is:(NOM-COMP-READING(NOM (CONS-P (REL1)(:ARG type :ARG-SORT):PARS2)(R.EL-APPLY* :FUNCTION :NP):VAL-SORT)(NOM :PARS1 (INVERSE-VAL* :FUNCTION:TERM1 :SET):ARG-SORT)(NOM :PARS1 (INVERSE-VAL* :FUNCTION:TERM1 :SET):ARG-SORT)) ~ 0The first slot of the NOM terms above encodes the argument-taking property of relational nouns such as "code", "salary"or "speed", and has been described in an earlier paper \[20\].The rule states that an inverted attribute reference (here,"L") preceded by a relational noun (here, "code") for thatsame attribute (here, "ABBREV-OF') simply refers to thatinverted attribute reference.Our view is that the preceding nominal modifier essen-fiaUy performs a function of disambiguation: it serves todistinguish the desired sense of the head from any other pos-sible one.
This is reinforced when the whole compound--"transport code L" is considered.
Another NOM-COMP-READING role is responsible for combining "code" with"transport":(NOM-COMP-READING(NOM :PARS1 :ARG-SET :ARG-SORT)(NOM (CONS-P (REL1)(:ARG type :ARG-SORT):PARS2)(REL-APPLY* :FUNCTION :NP):VAL-SORT)(NOM (CONS-P (REL1):ARG:PARS2)(REL-APPLY* (F-RESTRICT :FUNCTION:ARG-SET):NP):VAL-SORT)) ~ 0This constrains the domain of the relational noun it modifiesto be just the set that is the translation of the modifying noun.The semantic type of the modifying noun must be unifiablewith the argument type of the head relational noun.
Afterthis unification fomas the translation of the compound "trans-port code", the resulting type constraints serve to distinguish234the correct sense of "L"--that of ground transportation--from the meal service and other senses.Our technique of allowing roles to impose restrictions onthe forms of semantic translations themselves, rather thanmerely on the semantic types of this translations, bears somediscussion because it differs from proposals made by others,such as \[14\].
In that work, the position is taken that in-specting or restricting the structure of a logical form is inad-missible on theoretical grounds, in that it violates or makesunenforceable the principle of compo@tionality.
As far astheoretical matters go, we believe that the principle of com-positionality is open to many interpretations (for example,see \[15\]) and that its most general interpretation does notexclude techniques such as ours.A more practical concem, and one which may well un-derly or justify the theoretical qualm, is that rules based onthe structure of logical form may not succeed if that structurehappens to be transformed (say through wrapping with an-other structure) into some syntactically different form whichcannot be recognized as one which the role should allow.This is not a problem for the rules presented in this sec-tion, since the operation of nominal compounding is sotightly localized, operating in a function-argument fashionthat gets to the noun meaning "first", before other modifica-tions such as postnominal djuncts.
Ultimately, though, wefeel that the real solution must lie in a different approach tomeaning representation, e in which non-denotational prop-erties of the utterance meaning are encoded or highlightedin a way that stands above the variances of syntactic logicalform.
But this is a matter for future research.Can Constraint Relations be Compiledout of Rules?A natural question to ask is whether or not constraint rela-tions can be compiled out of grammar ules, turning theminto unifications like any other over the features of "real"constituent elements.One technique for this kind of compilation is certainlywell-known in logic programming: the method of partialexecution \[16\] in which the constraint relation is solved forat the time the rule is read in, not when it is used.
The solu-tion(s) so obtained are simply unified back into the remainderof the rule to create the compiled version.
If the constraintrelation is non-deterministic here will be more than one so-lution and hence more than one compiled version of the mle.This is certainly undesirable computationally, since multiplevariants of the the same grammar rule will cause a parser todo redundant matching.
On the other hand, if the unifica-tion method used permits full disjunction the variation canbe kept "factored", and the redundant matching avoided.Such a compilation will be possible, obviously, only ifthe constraint relation can be guaranteed tohave finite num-ber of solutions, given the degree of instantiation i whichit appears in the role.
But this is actually a rather strongcondition to place on constraint relations, particularly onthose which participate in semantic interpretation.
Semanticstrategies which defer part of the semantic omputation fora constituent can have a problem with this condition, sincethere is no bound (given conjunction) on the size of mosttypes of constituents.
An example in our work would be thetreatment of PP semantics outlined earlier, in which the PPis not fully translated at its own level, but instead passed upas a package of preposition and NP translation.
The obviousextension for a conjoined PP would be as list of such struc-tures.
But since there is no limit to the number of PPs thatcan be conjoined, there is no limit to the length of the list,and thus there can be no limit to the number of solutions forthe attachment constraint.Even ff a finite number of solutions can be guaranteed,however, there are still reasons why one might not wantto compile constraint conditions out of the grammar.
Onereason is that leaving them in allows one to add solutionsto a constraint condition without re-compiling all the gram-mar mles and other constraint rules which use it (a situationexactly analogous to the macro/function distinction in Lispprogramming).
Another is that distinguishing certain con-straints from the rest of the unifications of the grammar mleenables us to intervene in the search with specific indexingmethods (say on semantic type).
This is discussed in \[3\].And a final benefit of distinguishing constraint conditionsfrom other unifications i  that relative frequency counts canmore easily be made of their different solutions, just as canbe made on semantic senses of lexical items.
This is dis-cussed in \[1\].AcknowledgementsThe work reported here was supported by the Advanced Re-search Projects Agency and was monitored by the Officeof Naval Research under Contract No.
N00014-89-C-0008.The views and conclusions contained in this document arethose of the authors and should not be interpreted as neces-sarily representing the official policies, either expressed orimplied, of the Defense Advanced Research Projects Agencyor the United States Government.References\[1\] Ayuso, D., Bobrow, R., MacLaughlin, D., Meteer, M.,Rarnshaw, L., Schwartz, R., and Weischedel, R. "To-wards Understanding Text with a Very Large Vocabu-lary", this volume.\[2\] Bates, M., Bobrow, R., Boisen, S., Ingfia, R., and Stal-lard, D. "BBN ATIS Progress Report--June 1990", thisvolume.\[3\] Bobrow, R. and Ramshaw, L. "On Deftly Introduc-ing Procedural Elements into Unification Parsing", thisvolume.\[4\] Boisen, S., Chow, Y., Haas, A., Ingria, R., Roucos,S., Scha, R., Slallard, D., and Vilain, M. Integration ofSpeech and Natural Language: Final Report.
ReportNo.
6991, BBN Systems and Technologies Corpora-tion, Cambridge, Massachusetts, 1989.235\[5\] Boisen, S., Chow, Y-L., Haas, A., Ingria, R., Roukos, \[16\]S.; and Stallard, D. "The BBN Spoken Language Sys-tem".
Proceedings of the Speech and Natural LanguageWorkshop February 1989, Morgan Kanfmann Publish-ers, Inc., San Mateo, California, 1989, pages 106--111.
\[17\]\[6\] Chow, Y.L., Dunham, M.O., Kimball, O.A., Krasner,M.A., Kubala, G.F., Makhoul, J., Price, P.J., Roucos,S., and Schwartz, R.M.
"BYBLOS: The BBN Contin-uous Speech Recognition System".
IEEE InternationalConference on Acoustics, Speech, and Signal Process-ing, Dallas, TX, April 1987, pp.
89-92, Paper No.
3.7.\[7\] Gazdar, G., Klein, E., Pullum, G., and Sag, I. Gener-alized Phrase Structure Grammar.
Harvard UniversityPress, Cambridge, Massachusetts, 1985.\[8\] Halvorsen P.-K. and Nerbonne, J.
"Unification in theSyntax/Semantics Interface", tutorial presented at the28th Annual Meeting of the Association for Compu-tational Linguistics, Pittsburgh, Pennsylvania, 6 June,1990.\[9\] Johnson, M. E. Attribute-Value Logic and the Theoryof Grammar.
Center for the Study of Language andInformation, 1989.\[18\]\[19\]\[20\]Pereira, F. C. N. and Shieber, S. M. Prolog andNatural-Language Analysis.
Center' for the Study ofLanguage and Information, Stanford, CA, 1987.Pereira, F. C. N. and Warren, D. H. D. "Definite ClauseGrammars for Language Analysis--A Survey of theFormalism and a Comparison with Augmented Tran-sition Networks".
Artificial Intelligence 13, 1980, pp.231-278.Pollack, M. E. and Pereira, F. C. N. "An IntegratedFramework for Semantic and Pragmatic Interpreta-tion".
26th Annual Meeting of the Association for Com-putational Linguistics: Proceedings of the Conference,Association for Computational Linguistics, Morris-town, NJ, 1988, pp.
75--86.Shieber, S. M. An Introduction to Unification-BasedApproaches to Grammar.
Center for the Study of Lan-guage and Information, Stanford, CA, 1986.Stallard, D. "Unification-Based Semantic Interpretationin the BBN Spoken Language System".
Proceedings ofthe Speech and Natural Language Workshop October1989, Morgan Kaufmann Publishers, Inc., San Mateo,California, 1989, pages 39-46.\[10\] Karttunen, L. "Features and Values".
Proceedings ofColing84, Association for Computational Linguistics,Morristown, NJ, 1984, pp.
28-33.\[11\] Kasper, R. T. "A Unification Method for DisjunctiveFeature Descriptions".
25th Annual Meeting of the As-sociation for Computational Linguistics: Proceedingsof the Conference, Association for Computational Lin-guistics, Morristown, NJ, 1987, pp.
235-242.\[12\] Kasper, R. T. and Rounds, W. C. "A Logical Semanticsfor Feature Structures".
24th Annual Meeting of the As-sociation for Computational Linguistics: Proceedingsof the Conference, Association for Computational Lin-guistics, Morristown, NJ, 1986, pp.
257-266.\[13\] "Moens, M., Calder, J., Klein, E., Reape, M., and Zee-vat, H. "Expressing generalizations in unification-basedgrammar formalisms".
Fourth Conference of the Eu-ropean Chapter of the Association for ComputationalLinguistics: Proceedings of the Conference, Associa-tion for Computational Linguistics, Morristown, NJ,1989, pp.
174-181.\[14\] Moore, R. C. "Unification-Based Semantic Interpre-tation".
27th Annual Meeting of the Association forComputational Linguistics: Proceedings of the Confer-ence, Association for Computational Linguistics, Mor-ristown, NJ, 1989, pp.
33-41.\[15\] Partee, B. H. "Compositionality".
Varieties of FormalSemantics: Proceedings of the fourth Amsterdam Col-loquium, September, 1982, F. Landmau and F. Velt-man (eds.
), FORIS PUBLICATIONS, Dordrecht - Hol-land/Cinnaminson - U.S.A., 1984, pp.
281-311.236
