CogentHelp:NLG meets SE in a tool for authoringdynamical ly generated on-line helpMichae l  Whi te  and Dav id  E.  Ca ldwe l lCoGenTex, Inc.840 Hanshaw RoadIthaca, NY 14850, USA(mike ,  ted}~cogentex ,  comAbstractCogentHelp is a prototype tool for au-thoring dynamically generated on-line helpfor applications with graphical user inter-faces, embodying the "evolution-friendly"properties of tools in the literate program-ming tradition.
In this paper, we describeCogentHelp, highlighting the usefulness ofcertain natural anguage generation tech-niques in supporting software-engineeringgoals for help authoring tools - -  princi-pally, quality and evolvability of help texts.1 In t roduct ionCogentHelp isa prototype tool for authoring dynam-ically generated on-line help for applications withgraphical user interfaces (GUIs).
In this paper,we describe CogentHelp, highlighting the usefulnessof certain natural anguage generation (NLG) tech-niques in supporting software-engineering (SE) goalsfor help authoring tools - -  principally, quality andevolvability of help texts.To our knowledge, CogentHelp is unique in thatit is the first operational prototype to embody the"evolution-fr iendly" properties of tools in the lit-erate programming tradition (Knuth, 1992) - -  e.g.,the by now well-known j avadoc utility for generat-ing API documentation from comments embeddedin Java source code (Friendly, 1995; cf.
also John-son and Erdem, 1995; Priestly et al, 1996; Korgen,1996) - -  in a tool for generating end user-level doc-umentation.
CogentHelp is also unusual in that itis (to date) one of the few tools to bring NLG tech-niques to bear on the problem of author ing dy-namically generated documents (cf.
Paris and Van-der Linden, 1996; Knott et al, 1996; Hirst and Di-Marco, 1995); traditionally, most applied NLG sys-tems have focused on niches where texts can be gen-erated fully automatically, such as routine reports ofvarious types (e.g.
Goldberg et al, 1994; Kukich etal., 1994) or explanations of expert system reasoning(cf.
Moore, 1995 and references therein).While striving to design highly sophisticated, fullyautomatic systems has undoubtedly ed to a deeperunderstanding of the text generation process, it hashad the unfortunate effect (to date) of limiting theuse of techniques pioneered in the NLG communityto just a few niches where high knowledge acqui-sition costs stand a chance of being balanced bysubstantial volume of needed texts (cf.
Reiter andMellish, 1993).
By joining the emerging authoringsupport crowd and endeavoring to create new op-portunities in automated ocumentation, we hopeto contribute to the broader acceptance and visi-bility of NLG technology in the overall computingcommunity.The rest of the paper is organized as follows.
InSection 2 we discuss the software ngineering goalsfor CogentHelp.
In Section 3 we provide back-ground on automated ocumentation a d identifywhere CogentHelp fits in this picture.
In Section 4we give a brief overview of the CogentHelp system.In Section 5, we highlight he NLG techniques usedin support of the software ngineering goals identi-fied in Section 2.
In Section 6 we describe Cogent-Help's authoring interface.
Finally, in Section 7 weconclude by discussing the outlook for CogentHelp'suse and further development.2 So f tware  Eng ineer ing  Goa lsFrom a software ngineering perspective, we set outto achieve three main goals in designing CogentHelp,each of which has various aspects.
The first of thesegoals is end user-oriented, whereas the latter twoare developer-oriented.The first goal is to promote quality in the resultinghelp systems, which includes promoting?
Consistency - -  the grouping of material intohelp pages, the use of formatting devices uch as257headings, bullets, and graphics, and the generalwriting style should be consistent hroughoutthe help system;?
Nav igabi l i ty  - -  the use of grouping and for-matting should make it easier to find informa-tion about a particular GUI component in thehelp system;?
Completeness  - -  all GUI components shouldbe documented;?
Re levance  - -  information should be limited tothat which is likely to be of current relevance,given the current GUI state;?
Conc iseness  - -  redundancy should be avoided;?
Coherence  - -  information about GUI compo-nents should be presented in a logical and con-textually appropriate fashion.The second goal is to facilitate evolution, whichincludes facilitating?
F ide l i ty  - -  the help author should be assistedin producing complete and up-to-date descrip-tions of GUI components;?
Reuse  - -  wherever possible, the help authorshould not have to write the same text twice.The final goal is to lower barriers to adopting thetechnology, which has principally meant providingan authoring interface which makes the benefits ofthe system available at a reasonable cost in termsof the understanding and effort required of the helpauthor.3 Automated  Documentat ionThe main idea of CogentHelp is to have developers ortechnical writers author the reference-oriented partof an application's help system 1 in small pieces, in-dexed to the GUI components themselves, insteadof in separate documents (or in one monolithic doc-ument).
CogentHelp then dynamically assemblesthese pieces into a set of well-structured help pagesfor the end user to browse.The principal advantage of this approach is that itmakes it possible to keep the reference-oriented part1By the reference-oriented part, we mean the part ofa help system which describes the functions of individ-ual windows, widgets, etc., as opposed to more generalor more task-oriented information about he application;other than providing an easy way of linking to and fromCogentHelp-generated pages, CogentHelp leaves task-oriented help entirely to the author.of an on-line help system up-to-date automatically,since both the application GUI and the documen-tation can be evolved in sync.
This benefit of gen-erating both code and documentation from a singlesource 2 has long been recognized, both in the NLGcommunity (cf.
Reiter and Mellish, 1993; Moore,1995; and references therein) and in the SE commu-nity, where it is recognized under the banner of lit-erate programming tradition (Knuth, 1992).
Otherimportant benefits stem from supporting the sepa-ration of the content of the document o be gener-ated (descriptions of individual components) fromthe structure of the document (how the content isdistributed and formatted): this allows the authorto focus on writing accurate component descriptions,and avoid much of the drudgery involved in creatinga complex hypertext document manually.To better understand where CogentHelp fits in,it is instructive to compare it with the closest ref-erence points in the NLG and SE communities.
Onthe NLG side, there is the Drafter system (Paris andVander Linden, 1996), which generates drafts of in-structions in both English and French from a singleformal representation f the user's task.
Drafter isconsiderably more ambitious in aiming to automatethe production of multilingual, task-oriented help; atthe same time, however, Drafter is more limited inthat it is not evolution-oriented, aiming only to gen-erate satisfactory initial drafts (whence its name).This is in large part due to the fact that Drafter'sinput is centered around task representations whichare not typically used for GUI-level tasks in softwareengineering practice; in contrast, nearly every GUIbuilder provides ome form of GUI resource databasewhich could be used as input to CogentHelp.On the SE side, the nearest reference pointsare a bit more distant, as CogentHelp has morein common with developer-oriented tools such asthe javadoc API documentation generator dis-tributed with Sun Microsystems' Java DevelopersKit (Friendly, 1995) than with currently availablehelp authoring tools.
While several current GUI-development environments include tools which gen-erate an initial, "skeleton" help system for an appli-cation (with topics that correspond to the widgets inthe GUI), to our knowledge CogentHelp is the firstoperational prototype to implement the "evolution-friendly" properties of a tool like javadoc in a sys-tem for generating end user-level documentation.Unlike the "skeleton generators" mentioned above,2Note that this "single source" need only be virtual- -  physically single-source code and documentation canhave its drawbacks, which are not however inherent othe approach (Priestley et al, 1996).258which require the help author to start from scratcheach time the skeleton is regenerated in response toGUI modifications, CogentHelp supports help au-thoring throughout the software life cycle.4 System OverviewCogentHelp takes as input various human-writtentext fragments (or "help snippets") indexed to GUIresource databases, which provide some useful help-related information in the form of types, labels, lo-cations and part-whole relations for GUI widgets.CogentHelp generates HTML help files, which canbe displayed on any platform for which a Webbrowser is available.
It is designed to support ef-ficient navigation through the help system, throughthe use of intelligent, functionally structured layoutas well as through an expandable/collapsible tableof contents and "thumbnail sketch" applet.
Thesepoints will be elaborated upon below.CogentHelp operates in two modes: a "static"mode, which does not make use of run-time informa-tion, and a "dynamic" mode, which uses widget run-time status information to produce more specialized,contextually appropriate messages.
The static modeis useful in the authoring process, since it displaysall available help information and has simpler archi-tectural requirements.In evolving the design of CogentHelp, we haveemployed a rapid-prototyping approach in work-ing with our TRP/ROAD 3 consortium partners atRaytheon, who are serving as a trial user group.The full CogentHelp component architecture anddependencies reflects the particular equirements ofthis group, and are as follows.
CogentHelp itselfis a hypertext server written in Java, making ithighly cross-platform.
CogentHelp currently workswith applications built using the Neuron Data cross-platform GUI builder; while it is not dependent onthis product in any conceptually substantial way, us-ing other GUI builders would require a porting ef-fort.
To retrieve run-time information, CogentHelpuses Expersoft's PowerBroker ORB for inter-processcommunication; in comparison to the Neuron Dataconnection, other IPC methods could be more eas-ily substituted.
Finally, CogentHelp displays hyper-text in Netscape Navigator, using HTTP to medi-ate access to the dynamically generated texts; sinceNetscape Navigator emains the most widely usedcross-platform browser, we have yet to investigateusing other browsers.3A DARPA-sponsored Technology Reinvestment Pro-gram for Rapid Object Application Development, led byAndersen Consulting.5 NLG TechniquesAlthough CogentHelp is by no means a typical NLGsystem - -  insofar as it is incapable of generatinguseful texts in the absence of human-authored helpsnippets - -  it does employ certain natural anguagegeneration techniques in order to support the soft-ware engineering goals described above.
These tech-niques fall into two categories, those pertaining toknowledge representation and those pertaining totext planning.5.1 Knowledge Representat ionIn developing CogentHelp, we have taken a mini-realist approach to knowledge representation follow-ing a methodology for building text generators de-veloped over several years at CoGenTex.
As willbe explained below, this approach has led us to(i) make use of what amounts to a large-grained"phrasal" lexicon and (ii) devise and implement awidget-clustering algorithm for recovering functionalgroupings, as part of an Intermediate KnowledgeRepresentation System (IKRS).5.1.1 Phrasal LexiconAs Milosavljevic et al (1996) argue, to optimizecoverage and cost it makes sense to choose an un-derlying representation which?
makes precisely those distinctions that are rele-vant for the intended range of generated texts;and?
is no more abstract han is required for the in-ference processes which need to be performedover the representation.They go on to argue that besides eliminating a greatdeal of unnecessary 'generation from first principles,'this approach complements their use of a phrasallexicon (Kukich, 1983; Hovy, 1988) at the linguisticlevel.Applying essentially the same approach to the de-sign of CogentHelp, we first determined that for theintended range of generated texts it suffices to as-sociate with each widget to be documented a smallnumber of atomic propositions and properties, iden-tifiable by type.
Next we determined that since noinference is required beyond checking for equality,these propositions and properties can be conflatedwith their linguistic rea l i za t ions -  i.e., the indexed,human-authored help snippets CogentHelp takes asinput.
While we did not originally think of Cogent-Help's collection of input help snippets as a phrasallexicon a la Milosavljevic et al, in retrospect i be-comes evident hat this collection can be viewed as259Figure 1: Sample application windowtantamount to one; of course, since these snippetsvary in size from phrases to paragraphs, the term"phrasal" is not entirely accurate.The types of snippets in current use include a one-sentence short description of the relevant GUI com-ponent; a paragraph-sized laboration on the shortdescription; various phrase-sized messages concern-ing the conditions under which it is visible or en-abled, if appropriate; and a list of references to othertopics.
In the case of the phrase-sized messages, eachof these fields is accompanied by a syntactic framewhich prompts the author to provide consistent syn-tax - -  for example, entries in the WHEN_ENABLED fieldshould fit the frameThis element is enabled whenTo facilitate equality checking and promote textreuse, a mechanism is provided enabling the authorto alias the message for one widget to that of an-other.5.1.2 IKRSTo enhance the modularity and robustness of apractical text generator, Korelsky et al (1993) ar-gue for the use of an Intermediate Knowledge Rep-resentation System (IKRS, pronounced "Icarus") tobridge the gap between what the text planner wouldlike to access and what is actually found in the infor-mation base of an application program.
A remark-ably similar idea has been independently developedby Lester and Porter (1996), under the heading ofKB Accessors.One purpose of an IKRS, Korelsky et al sug-gest, is to provide a component in which to locatedomain-level inferencing not provided by the appli-cation program.
Note that while this type of infer-encing is motivated by text planning needs, it is stillabout the domain rather than about natural lan-guage communication, and thus does not belong inthe text planner itself.In developing CogentHelp, we encountered a needfor just this sort of inferencing in order to supportsensible layout.
The problem we faced was how tologically arrange descriptions of widgets within ahelp page (or set of help pages) describing a window,which is the basic unit of organization in Cogent-Help.
As will be explained below, grouping widgetsby type was considered inadequate, because doingso would obscure functional relationships betweenwidgets of different ypes.
A naive spatial sortingwas likewise considered inadequate, as this wouldinevitably separate lements of a functional groupappearing in a certain area of the window.
Unfor-tunately, since these functional groups are often notexplicitly represented in GUI resource databases, weappeared to be at an impasse.To illustrate the problem, consider the sample ap-plication window shown in Figure 1, from a proto-type of an application under development by ourtrial user group at Raytheon.
This window, whosepurpose is to allow a manufacturing shop floor fore-man to assign operators to parts, is organized asfollows: on the left there are two list boxes for op-erators (1, 2), with buttons beneath them to accessinformation about these operators (3, 4, 5, 6); on theright there are two list boxes for parts (9, 10), withbuttons beneath them to access information aboutthese parts (11, 12); in the middle there are twobuttons for making and removing assignments (7,8); towards the bottom there is a list box showingthe assignments made so far (of which there are nonehere - -  13); and at the bottom there are standardbuttons such as Save and Done (14, 15 - -  the Helpbutton would go here).
Given this organization, con-sider first arranging descriptions by type, and alpha-betizing: besides cutting across the implicit func-tional groupings, arranging descriptions in this waywould end up putting the two View K-Factors but-tons (4, 11) in sequence, without any indication ofwhich was which!
Now consider a simple top-down,left-to-right spatial sort: again, this would inevitablyyield a rather incoherent ordering, such as the Op-erators without Work list box (1), the Hot Partslist box (9), the Assign button (7), the Operators onJobs list box (2), the Parts list box (10), the RemoveAssignment button (8), etc.The solution to this problem was to develop, aspart of our IKRS, a method of recovering these func-260tional groups using spatial cues as heuristics; the rea-son this approach might be expected to work is thatin a well-designed GUI, functionally related widgetsare usually clustered together spatially in order tomake the nd user's life a bit easier.
We began withthe fairly standard hierarchical agglomerative algo-rithm found in (Stolcke, 1996).
Stolcke's algorithmis an order n ~ one that iteratively merges smallerclusters into bigger ones until only one cluster re-mains; new clusters are formed out of the two nearestclusters in the current set, ensuring that the resultsare independent of the order in which clusters areexamined.
After some experimentation, wemodifiedthis algorithm to better suit our needs, resulting inthe following three differences: (i) to create clusterswith more than two elements, we continue addingelements to the newly created cluster until a certaindistance threshold is exceeded; (ii) we represent thenew cluster using its bounding box, rather than us-ing an average of its elements; and (iii) we restrictthe clustering to not operate across explicit groups,such as those formed using panels.With any clustering approach, there is alwaysthe tricky matter of determining a suitable distancemeasure.
After trying out a variety of features, whatwe found to work surprisingly well was a simpleweighted combination of proximity, alignment andtype identity.
In particular, in a test suite of around15 windows provided to us by our trial user group,we obtained reasonable results (no egregiously badgroupings) on all of them without undue sensitiv-ity to the exact weights.
In the case of the windowshown in Figure 1, the clustering procedure performsexactly as desired, yielding precisely the groupingsused in the description of this window given above- -  i.e.
: ( ( (1, 2), (3, 4, 5, 6) ), ( (9, 10), (11, 12) ),(7, 8), 13, (14, 15) ).Once the IKRS has heuristically recovered clus-ters of widgets likely to form a functional group,these clusters - -  as well as any explicitly representedgroups, e.g.
widgets contained within a panel of awindow - -  can be used as a basis for help layout, asdiscussed below.5.2 Text  P lann ingAt the core of CogentHelp is the text planner.
Thetext planner builds up HTML trees starting froman initial goal, using information provided by theIKRS, following the directives coded in CogentHelp'stext planning rules.
These HTML trees are then lin-earized into an ascii stream by a separate formatter,so that they can be displayed in a web browser (cf.Section 4).The text planner is constructed using Exem-261Figure 2: A sample help pageplars for Java, a lightweight framework for build-ing object-oriented text planners in Java which hasbeen developed in parallel with CogentHelp (White,1997).
In this framework, text planning rules - -  theexemplars, o-called because they are meant o cap-ture an exemplary way of achieving a communicativegoal in a given communicative context - -  are objectswhich cooperate to efficiently produce the desiredtexts.
While space precludes a detailed description,it is worth noting that Exemplars for Java supportsabstraction, specialization and content-based revi-sions, all of which have proved useful in the presenteffort.In developing the exemplars for CogentHelp, wehave made use of three NLG techniques: structuringtexts by traversing domain relations, automaticallygrouping related information, and using revisions tosimplify the handling of constraint interactions.
Thefirst two of these make life simpler for the end user,while the third makes life simpler for the developer.5.2.1 Cap i ta l i z ing  on Domain  St ructureWhen text structure follows domain structure, onecan generate text by selectively following appropri-ate links in the input (Paris, 1988; Sibun, 1992).
Inthe case at hand, we have chosen to use the groupand cluster structure combined with a top-down,left-to-right spatial sort: while such a spatial sortalone is insufficient, as we saw above, a spatial sortwhich respects functional groups turns out to workwell.Returning to the example of Section 5.1.2 (re-garding the window shown in Figure 1), travers-ing the clusters in this way yields a listing which(naturally!)
mirrors the order and groupings of theone-sentence description of the window's organiza-tion we have provided - -  that is, following a generaldescription of the window, there are descriptions ofthe two operators list boxes (1, 2), followed by de-scriptions of the four buttons providing additionalinformation on operators (3, 4, 5, 6), followed nextby the part list boxes (9, 10) and the buttons asso-ciated with them (11, 12), and so on.
This is (par-tially) illustrated in Figure 2, which shows a sampleCogentHelp-generated h lp topic.
Note that the listof widgets in the dynamic TOC on the left side ofthe page is arranged according to this traversal; con-sequently, stepping through the contents (using theTOC or the Next button) for this window will leadfrom widget to widget and cluster to cluster in a sen-sible fashion.
In the particular topic shown, the userhas reached the second button (View K-Factors) ofthe group of four buttons beneath the Operators listboxes, as can be seen from the highlighting in thethumbnail sketch applet (cf.
Section 6).The use of domain structure-driven text plan-ning is central to supporting the software engi-neering goals identified in Section 2.
Rather ob-viously, generating-by-rule h lps to achieve consis-tency, completeness and fidelity, eliminating muchmind-numbing drudgery along the way.
A bit lessobvious, perhaps, is the fact that this techniqueshould help to achieve navigability and coherence:by presenting descriptions of widgets in a naturalorder - -  i.e., in the order in which the user is apt toencounter them in scanning the GUI - -  we hope tomake it easier for the user to find desired informa-tion; and, by keeping together descriptions of wid-gets which are heuristically determined to be func-tionally related, we hope to make it easier for theuser to quickly grasp the organization of both theinterface and the on-line help.5.2.2 Group ingGrouping related information and presentingshared parts just once is a well-known NLG tech-nique for achieving conciseness and coherence (Re-iter and Mellish, 1993).
In a reference-oriented docu-ment such as an on-line help system, similar or iden-tical descriptions will often be appropriate for ele-ments which have similar or identical functions.
Toindicate these similarities, as well as to save space, itmakes sense to group these descriptions when possi-ble.As mentioned in Section 5.1.1, we allow develop-ers to alias messages to promote text reuse, as wellas to facilitate equality checking.
When the textplanner detects (via the IKRS) that a phrase-sizedmessage (such as T0_ENABLE) is the same for a groupof widgets, it generates a description that applies tothe whole group, rather than repeating the same de-scription several times in close proximity.
Note thatthis group description is made possible by the use ofa phrasal exicon, which has been designed to allowthe author's messages to make sense in a variety ofcontexts.To illustrate, let us have another look at Figure 2.In the upper right frame of the page, note that thereis the following description of how to enable all of thefour buttons below the operators list boxes, ratherthan a repetition of the same message four times inclose proximity:These commands are currently disabled.To enable them, select exactly one opera-tor in either the Free Operators list box orthe Working Operators list box.This group-level description appears here because (i)the author, realizing that these buttons are enabledunder the same conditions, entered the T0_ENABLEmessage "select exactly one operator in either theFree Operators list box or the Working Operatorslist box" for one button, and aliased this messagefor the other; and (ii) the text planner, detecting(via the IKRS) that the TO_ENABLE messages for theentire group were the same, and that these buttonswere currently disabled (a run-time fact), prepended"These commands are currently disabled.
To enablethem," to the shared message to yield what appearsin Figure 2.5.2.3 Rev is ionsWhile the central use of domain structure-driventext planning makes it possible to generate text in arelatively straightforward, top-down fashion, as vari-ations are added a one-pass top-down approach canbecome cumbersome.
The reason why is this: Inevolving the text planning rule base, it makes senseto localize decisions as much as possible; however, tohandle rule interactions in a single pass, one is forcedto centralize these decisions (which can become cum-bersome).
To simplify matters, it is often appropri-ate to generate an initial version naively, then carryout revisions on it in a subsequent pass (cf.
Robin,1994; Wanner and Hovy, 1996).In CogentHelp, interactions that are cumbersometo anticipate arise in dealing with the various op-tional phrase-sized messages whose inclusion condi-tions differ between the static and dynamic mode.To elaborate, let us consider once more the help pageshown in Figure 2.
Had the four buttons described inthe lower right frame been enabled rather than dis-abled (at run-time), the group-level T0_.ENABLE mes-sage would have simply been left out, in order to en-262hance relevance and conciseness; 4 on the other hand,had this page been generated in static mode (wheresuch run-time conditions are not known), the textplanner would have again included the description,though this time with the less specific "To enablethese commands," prepended instead.
Now, sincethe various messages associated with a widget haveslightly different inclusion conditions, it makes senseto localize these inclusion conditions to a text plan-ning rule for each message (the common parts ofthese conditions are shared via inheritance).
At thesame time, however, there is a need to know whetherany of these messages will in fact appear, in order todecide whether to include the second paragraph inthe upper right frame, as well as the italics element.In a one-pass top-down approach, this need wouldforce the various inclusion conditions to be cumber-somely centralized; with revisions, in contrast, onecan simply add the paragraph and italics elementduring the first pass, then check during a secondpass whether any of the optional messages for thisparagraph did in fact appear, removing the super-fluous HTML elements if not.6 Author ingIn informal usability tests, we have gathered muchuseful information about areas in which CogentHelpcould be improved - -  the most important of thesebeing ease of authoring.
A previous version of theauthoring interface, which relied on the resource d-itor of the Neuron Data GUI builder, proved unsat-isfactory, as it (i) required excessive clicking for theauthor to navigate from snippet o snippet, and (ii)failed to provide sufficient context, making it un-necessarily difficult for the author to adhere to theCogentHelp authoring uidelines.The current authoring interface, shown in Fig-ure 3, uses CogentHelp's existing architecture (to-gether with the HTTP  forms protocol) to allow theuser to edit the text snippets for each widget in sub-stantially the same context they would inhabit ingenerated help topics.
This design provides maxi-mal realism for the author, especially since one canswitch between editing and browsing mode at theclick of a button to preview the generated help.Another feature illustrated in Figure 3, as wellas Figure 2, owes its inspiration to our trim usergroup at Raytheon.
Our users were concerned aboutthe ease of visual navigation of help pages, andhad experimented with using manually coded (and4With a perfectly intuitive GUI, the user would neverneed to know this information, as commands would al-ways be enabled when the user expects them to be.Figure 3: CogentHelp in authoring modethus difficult to evolve) image maps superimposedover bitmaps of each application window.
This con-cern prompted us to develop an automatically gen-erated "thumbnail sketch" of the current GUI win-dow, which appears in the upper left corner of thehelp window (in a Java applet alng with the ta-ble of contents) and contains hyperlinks for each ofthe widgets on the window (these hyperlinks dis-play the corresponding help topics on the right-handside).
The automatically generated thumbnail im-ages require no intervention on the part of the helpauthor, and thus are guaranteed to be up-to-date;furthermore, their abstract nature gives them cer-tain advantages over actual bitmaps: they do notpresent information which is redundant (since theactual window in question will usually be visible) orinconsistent (static bitmaps fail to capture widgetswhich are enabled/disabled or change their labels incertain situations).7 Out lookTo date we have gathered substantial feedback onCogentHelp functionality from our trial user groupat Raytheon, especially on the need for authoringsupport and visual navigation aids.
We are opti-mistic that this group will find CogentHelp suitablefor actual use in developing a production-qualityhelp system by the end of our Rome Laboratory-sponsored software documentation SBIR project, inmid-1997.
Also by project end, we hope to portCogentHelp to a more affordable, Java-based GUIbuilder, in order to make it useful to a much broadercommunity of developers.263AcknowledgementsWe gratefully acknowledge the helpful comments and ad-vice of Ehud Reiter, Philip Resnik, Keith Vander Lin-den, Terri SooHoo, Marsha Nolan, Doug White, ColinScott, Owen Rainbow, Tanya Korelsky, Benoit Lavoieand Daryl McCullough.
This work has been supportedby SBIR award F30602-94-C-0124 from Rome Labora-tory (USAF) and by the TRP/ROAD cooperative agree-ment F30602-95-2-0005 with the sponsorship of DARPAand Rome Laboratory.ReferencesLisa Friendly.
1995.
The design of distributed hyper-linked programming documentation.
I  InternationalWorkshop on Hypermedia Design.Eli Goldberg, Norbert Driedger, and Richard Kittredge.1994.
Using natural-language processing to produceweather forecasts.
IEEE Expert, pages 45-53.Graeme Hirst and Chrysanne DiMarco.
1995.
Health-Doc: Customizing patient information and health ed-ucation by medical condition and personal characteris-tics.
In AI in Patient Education Workshop, Glasgow,Scotland, August.Eduard H. Hovy.
1988.
Generating language with aphrasal lexicon.
In D. D. McDonald and L. Bolc,editors, Natural Language Generation Systems, pages353-384.
Springer-Verlag, New York.W.
Lewis Johnson and Ali Erdem.
1995.
Interactive x-planation of software systems.
In Proceedings of theTenth Knowledge-Based Software Engineering Confer-ence (KBSE-95), pages 155-164, Boston, Mass.Alistalr Knott, Chris Mellish, Jon Oberlander, andMichael O'Donnell.
1996.
Sources of flexibility indynamic hypertext generation.
In Proceedings ofthe Eighth International Natural Language GenerationWorkshop (INLG-96), pages 151-160, HerstmonceuxCastle, Sussex, UK.D.
E. Knuth, editor.
1992.
Literate Programming.
CSLI.Tanya Korelsky, Daryl McCullough, and Owen Rambow.1993.
Knowledge requirements for the automatic gen-eration of project management reports.
In Proceedingsof the Eighth Knowledge-Based Software EngineeringConference (KBSE-93, pages 2-9, Chicago, Illinois.Susan Korgen.
1996.
Object-oriented, single-source, on-line documents that update themselves.
In Proceed-ings of The l$th Annual International Conference onComputer Documentation (SIGDOC-g6), pages 229-238.K.
Kukich, K. McKeown, J. Shaw, J. Robin, N. Mor-gan, and J. Phillips.
1994.
User-needs analysis anddesign methodology for an automated document gen-erator.
In A. Zampolli, N. Calzolari, and M. Palmer,editors, Current Issues in Computational Linguistics:In Honour of Don Walker.
Kluwer Academic Press,Boston.Karen Kukich.
1983.
Design of a knowledge-based re-port generator.
In Proceedings of the 21st AnnualMeeting of the Association for Computational Linguis-tics, Cambridge, Mass.James C. Lester and Bruce W. Porter.
1996.
Scaling upexplanation generation: Large-scale knowledge basesand empirical studies.
In Proceedings of the NationalConference on Artificial Intelligence (AAAI-96), Port-land, Oregon.Maria Milosavljevic, Adrian Tulloch, and Robert Dale.1996.
Text generation in a dynamic hypertext en-vironment.
In Proceedings of the 19th AustralasianComputer Science Conference, pages 229-238, Mel-bourne, Australia.Johanna Moore.
1995.
Participating in Ezplanatory Di-alogues.
MIT Press.Cecile Paris and Keith Vander Linden.
1996.
Drafter:An interactive support ool for writing.
IEEE Com-puter, Special Issue on Interactive Natural LanguageProcessing, July.Cecile Paris.
1988.
Tailoring object descriptions to theuser's level of expertise.
Computational Linguistics,11(3):64-78.Michael Priestley, Luc Chamberland, and Julian Jones.1996.
Rethinking the reference manual: Usingdatabase technology on the www to provide com-plete, high-volume reference information withoutoverwhelming your readers.
In Proceedings of The14th Annual International Conference on ComputerDocumentation (SIGDOC-96), pages 23-28.Owen Rainbow and Tanya Korelsky.
1992.
Applied textgeneration.
In Third Conference on Applied NaturalLanguage Processing, pages 40-47, Trento, Italy.Ehud Reiter and Chris Mellish.
1993.
Optimizing thecosts and benefits of natural anguage generation.
InProceedings of the 13th International Joint Conferenceon Artificial Intelligence (1JCAI-93), volume 2, pages1164-1169.Jacques Robin.
1994.
Revision-Based Generationof Natural Language Summaries Providing HistoricalBackground.
Ph.D. thesis, Columbia University.Penelope Sibun.
1992.
Generating text without trees.Computational Intelligence, 8(1):102-22.Andreas Stolcke.
1996.
Cluster 2.9.
URL go-pher :/ / gopher.icsi.berkeley.edu /1/ sr /local/ ftp /al /stolcke/software/cluster-2_9_tar.Z.Leo Wanner and Eduard Hovy.
1996.
The HealthDocsentence planner.
In Proceedings of the Eighth In-ternational Natural Language Generation Workshop(INLG-96), pages 1-10, Herstmonceux Castle, Sussex,UK.Michael White.
1997.
Exemplars for Java: a lightweightframework for building object-oriented text plannersin Java.
Technical report, CoGenTex, Inc.264
