Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 145?156,Honolulu, October 2008. c?2008 Association for Computational LinguisticsDependency Parsing by Belief Propagation?David A. Smith and Jason EisnerDept.
of Computer Science, Johns Hopkins UniversityBalitmore, MD 21218, USA{dasmith,eisner}@jhu.eduAbstractWe formulate dependency parsing as a graphical modelwith the novel ingredient of global constraints.
We showhow to apply loopy belief propagation (BP), a simple andeffective tool for approximate learning and inference.
Asa parsing algorithm, BP is both asymptotically and em-pirically efficient.
Even with second-order features or la-tent variables, which would make exact parsing consider-ably slower or NP-hard, BP needs only O(n3) time witha small constant factor.
Furthermore, such features sig-nificantly improve parse accuracy over exact first-ordermethods.
Incorporating additional features would in-crease the runtime additively rather than multiplicatively.1 IntroductionComputational linguists worry constantly about run-time.
Sometimes we oversimplify our models, trad-ing linguistic nuance for fast dynamic programming.Alternatively, we write down a better but intractablemodel and then use approximations.
The CL com-munity has often approximated using heavy pruningor reranking, but is beginning to adopt other meth-ods from the machine learning community, suchas Gibbs sampling, rejection sampling, and certainvariational approximations.We propose borrowing a different approximationtechnique from machine learning, namely, loopy be-lief propagation (BP).
In this paper, we show thatBP can be used to train and decode complex pars-ing models.
Our approach calls a simpler parser as asubroutine, so it still exploits the useful, well-studiedcombinatorial structure of the parsing problem.12 Overview and Related WorkWe wish to make a dependency parse?s score de-pend on higher-order features, which consider ar-?This work was supported by the Human Language Tech-nology Center of Excellence.1As do constraint relaxation (Tromble and Eisner, 2006) andforest reranking (Huang, 2008).
In contrast, generic NP-hardsolution techniques like Integer Linear Programming (Riedeland Clarke, 2006) know nothing about optimal substructure.bitrary interactions among two or more edges in theparse (and perhaps also other latent variables suchas part-of-speech tags or edge labels).
Such featurescan help accuracy?as we show.
Alas, they raise thepolynomial runtime of projective parsing, and ren-der non-projective parsing NP-hard.
Hence we seekapproximations.We will show how BP?s ?message-passing?
disci-pline offers a principled way for higher-order fea-tures to incrementally adjust the numerical edgeweights that are fed to a fast first-order parser.
Thusthe first-order parser is influenced by higher-orderinteractions among edges?but not asymptoticallyslowed down by considering the interactions itself.BP?s behavior in our setup can be understood intu-itively as follows.
Inasmuch as the first-order parserfinds that edge e is probable, the higher-order fea-tures will kick in and discourage other edges e?
to theextent that they prefer not to coexist with e.2 Thus,the next call to the first-order parser assigns lowerprobabilities to parses that contain these e?.
(Themethod is approximate because a first-order parsermust equally penalize all parses containing e?, eventhose that do not in fact contain e.)This behavior is somewhat similar to parser stack-ing (Nivre and McDonald, 2008; Martins et al,2008), in which a first-order parser derives some ofits input features from the full 1-best output of an-other parser.
In our method, a first-order parser de-rives such input features from its own previous fulloutput (but probabilistic output rather than just 1-best).
This circular process is iterated to conver-gence.
Our method also permits the parse to in-teract cheaply with other variables.
Thus first-orderparsing, part-of-speech tagging, and other tasks on acommon input could mutually influence one another.Our method and its numerical details emerge nat-urally as an instance of the well-studied loopy BPalgorithm, suggesting several potential future im-2This may be reminiscent of adjusting a Lagrange multiplieron e?
until some (hard) constraint is satisfied.145provements to accuracy (Yedidia et al, 2004; Braun-stein et al, 2005) and efficiency (Sutton and McCal-lum, 2007).Loopy BP has occasionally been used before inNLP, with good results, to handle non-local fea-tures (Sutton and McCallum, 2004) or joint decod-ing (Sutton et al, 2004).
However, our applicationto parsing requires an innovation to BP that we ex-plain in ?5?a global constraint to enforce that theparse is a tree.
The tractability of some such globalconstraints points the way toward applying BP toother computationally intensive NLP problems, suchas syntax-based alignment of parallel text.3 Graphical Models of Dependency Trees3.1 Observed and hidden variablesTo apply BP, we must formulate dependency parsingas a search for an optimal assignment to the vari-ables of a graphical model.
We encode a parse usingthe following variables:Sentence.
The n-word input sentence W is fullyobserved (not a lattice).
Let W = W0W1 ?
?
?Wn,where W0 is always the special symbol ROOT.Tags.
If desired, the variables T = T1T2 ?
?
?Tn mayspecify tags on the nwords, drawn from some tagsetT (e.g., parts of speech).
These variables are needediff the tags are to be inferred jointly with the parse.Links.
The O(n2) boolean variables {Lij : 0 ?i ?
n, 1 ?
j ?
n, i 6= j} correspond to the possiblelinks in the dependency parse.3 Lij = true is in-terpreted as meaning that there exists a dependencylink from parent i?
child j.4Link roles, etc.
It would be straightforward to addother variables, such as a binary variable Lirj that istrue iff there is a link ir?
j labeled with role r (e.g.,AGENT, PATIENT, TEMPORAL ADJUNCT).3.2 Markov random fieldsWe wish to define a probability distribution over allconfigurations, i.e., all joint assignments A to these3?Links?
are conventionally called edges, but we reserve theterm ?edge?
for describing the graphical model?s factor graph.4We could have chosen a different representation withO(n)integer variables {Pj : 1 ?
j ?
n}, writing Pj = i instead ofLij = true.
This representation can achieve the same asymp-totic runtime for BP by using sparse messages, but some con-straints and algorithms would be somewhat harder to explain.variables.
Our distribution is simply an undirectedgraphical model, or Markov random field (MRF):5p(A)def=1Z?mFm(A) (1)specified by the collection of factors Fm : A 7?R?0.
Each factor is a function that consults only asubset of A.
We say that the factor has degree dif it depends on the values of d variables in A, andthat it is unary, binary, ternary, or global if d isrespectively 1, 2, 3, or unbounded (grows with n).A factor function Fm(A) may also depend freelyon the observed variables?the input sentence Wand a known (learned) parameter vector ?.
For no-tational simplicity, we suppress these extra argu-ments when writing and drawing factor functions,and when computing their degree.
In this treatment,these observed variables are not specified by A, butinstead are absorbed into the very definition of Fm.In defining a factor Fm, we often define the cir-cumstances under which it fires.
These are the onlycircumstances that allow Fm(A) 6= 1.
When Fmdoes not fire, Fm(A) = 1 and does not affect theproduct in equation (1).3.3 Hard constraintsA hard factor Fm fires only on parsesA that violatesome specified condition.
It has value 0 on thoseparses, acting as a hard constraint to rule them out.TREE.
A hard global constraint on all the Lij vari-ables at once.
It requires that exactly n of these vari-ables be true, and that the corresponding links forma directed tree rooted at position 0.PTREE.
This stronger version of TREE requiresfurther that the tree be projective.
That is, it pro-hibits Lij and Lk` from both being true if i ?
jcrosses k ?
`.
(These links are said to cross if oneof k, ` is strictly between i and j while the other isstrictly outside that range.)EXACTLY1.
A family of O(n) hard global con-straints, indexed by 1 ?
j ?
n. EXACTLY1j re-quires that j have exactly one parent, i.e., exactlyone of the Lij variables must be true.
Note that EX-ACTLY1 is implied by TREE or PTREE.5Our overall model is properly called a dynamic MRF, sincewe must construct different-size MRFs for input sentences ofdifferent lengths.
Parameters are shared both across and withinthese MRFs, so that only finitely many parameters are needed.146ATMOST1.
A weaker version.
ATMOST1j re-quires j to have one or zero parents.NAND.
A family of hard binary constraints.NANDij,k` requires that Lij and Lk` may not both betrue.
We will be interested in certain subfamilies.NOT2.
Shorthand for the family of O(n3) bi-nary constraints {NANDij,kj}.
These are collectivelyequivalent to ATMOST1, but expressed via a largernumber of simpler constraints, which can make theBP approximation less effective (footnote 30).NO2CYCLE.
Shorthand for the family of O(n2)binary constraints {NANDij,ji}.3.4 Soft constraintsA soft factor Fm acts as a soft constraint that preferssome parses to others.
In our experiments, it is al-ways a log-linear function returning positive values:Fm(A)def= exp?h?features(Fm)?hfh(A,W,m) (2)where ?
is a learned, finite collection of weights andf is a corresponding collection of feature functions,some of which are used by Fm.
(Note that fh ispermitted to consult the observed input W .
It alsosees which factor Fm it is scoring, to support reuseof a single feature function fh and its weight ?h byunboundedly many factors in a model.)LINK.
A family of unary soft factors that judgethe links in a parse A individually.
LINKij fires iffLij = true, and then its value depends on (i, j),W , and ?.
Our experiments use the same features asMcDonald et al (2005).A first-order (or ?edge-factored?)
parsing model(McDonald et al, 2005) contains only LINK factors,along with a global TREE or PTREE factor.
Thoughthere are O(n2) link factors (one per Lij), only nof them fire on any particular parse, since the globalfactor ensures that exactly n are true.We?ll consider various higher-order soft factors:PAIR.
The binary factor PAIRij,k` fires with somevalue iff Lij and Lk` are both true.
Thus, it penal-izes or rewards a pair of links for being simultane-ously present.
This is a soft version of NAND.GRAND.
Shorthand for the family of O(n3) binaryfactors {PAIRij,jk}, which evaluate grandparent-parent-child configurations, i ?
j ?
k. For exam-ple, whether preposition j attaches to verb i mightdepend on its object k. In non-projective parsing,we might prefer (but not require) that a parent andchild be on the same side of the grandparent.SIB.
Shorthand for the family of O(n3) binary fac-tors {PAIRij,ik}, which judge whether two childrenof the same parent are compatible.
E.g., a given verbmay not like to have two noun children both to itsleft.6 The children do not need to be adjacent.CHILDSEQ.
A family of O(n) global factors.CHILDSEQi scores i?s sequence of children; henceit consults all variables of the form Lij .
The scor-ing follows the parametrization of a weighted splithead-automaton grammar (Eisner and Satta, 1999).If 5 has children 2, 7, 9 under A, then CHILDSEQiis a product of subfactors of the form PAIR5#,57,PAIR57,59, PAIR59,5# (right child sequence) andPAIR5#,52, PAIR52,5# (left child sequence).NOCROSS.
A family of O(n2) global constraints.If the parent-to-j link crosses the parent-to-` link,then NOCROSSj` fires with a value that dependsonly on j and `.
(If j and ` do not each have ex-actly one parent, NOCROSSj` fires with value 0; i.e.,it incorporates EXACTLY1j and EXACTLY1`.
)7TAGi is a unary factor that evaluates whether Ti?svalue is consistent with W (especially Wi).TAGLINKij is a ternary version of the LINKij fac-tor whose value depends on Lij , Ti and Tj (i.e., itsfeature functions consult the tag variables to decidewhether a link is likely).
One could similarly enrichthe other features above to depend on tags and/orlink roles; TAGLINK is just an illustrative example.TRIGRAM is a global factor that evaluates the tagsequence T according to a trigram model.
It is aproduct of subfactors, each of which scores a tri-gram of adjacent tags Ti?2, Ti?1, Ti, possibly alsoconsidering the word sequence W (as in CRFs).4 A Sketch of Belief PropagationMacKay (2003, chapters 16 and 26) provides anexcellent introduction to belief propagation, a gen-6A similar binary factor could directly discourage giving theverb two SUBJECTs, if the model has variables for link roles.7In effect, we have combined the O(n4) binary factorsPAIRij,k` into O(n2) groups, and made them more preciseby multiplying in EXACTLYONE constraints (see footnote 30).This will permit O(n3) total computation if we are willing tosacrifice the ability of the PAIR weights to depend on i and k.147LINKL[2,5]GRANDL[5,6]LINKTREEFigure 1: A fragment of a factor graph, illustrating a fewof the unary, binary, and global factors that affect vari-ables L25 and L56.
The GRAND factor induces a loop.eralization of the forward-backward algorithm thatis deeply studied in the graphical models literature(Yedidia et al, 2004, for example).
We brieflysketch the method in terms of our parsing task.4.1 Where BP comes fromThe basic BP idea is simple.
Variable L34 main-tains a distribution over values true and false?a?belief?
?that is periodically recalculated based onthe current distributions at other variables.8Readers familiar with Gibbs sampling can regardthis as a kind of deterministic approximation.
InGibbs sampling, L34?s value is periodically resam-pled based on the current values of other variables.Loopy BP works not with random samples but theirexpectations.
Hence it is approximate but tends toconverge much faster than Gibbs sampling will mix.It is convenient to visualize an undirected factorgraph (Fig.
1), in which each factor is connectedto the variables it depends on.
Many factors mayconnect to?and hence influence?a given variablesuch as L34.
If X is a variable or a factor, N (X)denotes its set of neighbors.4.2 What BP accomplishesGiven an input sentence W and a parameter vector?, the collection of factors Fm defines a probabil-ity distribution (1).
The parser should determine thevalues of the individual variables.
In other words,we would like to marginalize equation (1) to obtainthe distribution p(L34) over L34 = true vs. false,the distribution p(T4) over tags, etc.If the factor graph is acyclic, then BP com-putes these marginal distributions exactly.
Given8Or, more precisely?this is the tricky part?based on ver-sions of those other distributions that do not factor in L34?s re-ciprocal influence on them.
This prevents (e.g.)
L34 and T3from mutually reinforcing each other?s existing beliefs.an HMM, for example, BP reduces to the forward-backward algorithm.BP?s estimates of these distributions are called be-liefs about the variables.
BP also computes be-liefs about the factors, which are useful in learn-ing ?
(see ?7).
E.g., if the model includes the factorTAGLINKij , which is connected to variables Lij , Ti,Tj , then BP will estimate the marginal joint distribu-tion p(Lij , Ti, Tj) over (boolean, tag, tag) triples.When the factor graph has loops, BP?s beliefs areusually not the true marginals of equation (1) (whichare in general intractable to compute).
Indeed, BP?sbeliefs may not be the true marginals of any distribu-tion p(A) over assignments, i.e., they may be glob-ally inconsistent.
All BP does is to incrementallyadjust the beliefs till they are at least locally con-sistent: e.g., the beliefs at factors TAGLINKij andTAGLINKik must both imply9 the same belief aboutvariable Ti, their common neighbor.4.3 The BP algorithmThis iterated negotiation among the factors is han-dled by message passing along the edges of the fac-tor graph.
A message to or from a variable is a (pos-sibly unnormalized) probability distribution over thevalues of that variable.The variable V sends a message to factor F , say-ing ?My other neighboring factors G jointly suggestthat I have posterior distribution qV?F (assumingthat they are sending me independent evidence).
?Meanwhile, factor F sends messages to V , saying,?Based on my factor function and the messages re-ceived from my other neighboring variables U abouttheir values (and assuming that those messages areindependent), I suggest you have posterior distribu-tion rF?V over your values.
?To be more precise, BP at each iteration k (untilconvergence) updates two kinds of messages:q(k+1)V?F (v) = ?
?G?N (V )\Fr(k)G?V (v) (3)from variables to factors, andr(k+1)F?V (v) = ?
?A s.t.
A[V ]=vF (A)?U?N (F )\Vq(k)U?F (A[U ])(4)9In the sense that marginalizing the belief p(Lij , Ti, Tj) atthe factor yields the belief p(Ti) at the variable.148from factors to variables.
Each message is a proba-bility distribution over values v of V , normalized bya scaling constant ?.
Alternatively, messages may beleft as unnormalized distributions, choosing ?
6= 1only as needed to prevent over- or underflow.
Mes-sages are initialized to uniform distributions.Whenever we wish, we may compute the beliefsat V and F :b(k+1)V?
(v)def= ?
?G?N (V )r(k)G?V (v) (5)b(k+1)F?
(A)def= ?
F (A)?U?N (F )q(k)U?F (A[U ]) (6)These beliefs do not truly characterize the ex-pected behavior of Gibbs sampling (?4.1), since theproducts in (5)?
(6) make conditional independenceassumptions that are valid only if the factor graphis acyclic.
Furthermore, on cyclic (?loopy?)
graphs,BP might only converge to a local optimum (Weissand Freedman, 2001), or it might not converge at all.Still, BP often leads to good, fast approximations.5 Achieving Low Asymptotic RuntimeOne iteration of standard BP simply updates all themessages as in equations (3)?
(4): one message peredge of the factor graph.Therefore, adding new factors to the model in-creases the runtime per iteration additively, by in-creasing the number of messages to update.
Webelieve this is a compelling advantage over dy-namic programming?in which new factors usuallyincrease the runtime and space multiplicatively byexploding the number of distinct items.105.1 Propagators for local constraintsBut how long does updating each message take?
Theruntime of summing over all assignments?A in10For example, with unknown tags T , a model withPTREE+TAGLINK will take only O(n3 + n2g2) time for BP,compared to O(n3g2) time for dynamic programming (Eisner& Satta 1999).
Adding TRIGRAM, which is string-local ratherthan tree-local, will increase this only to O(n3 + n2g2 + ng3),compared to O(n3g6) for dynamic programming.Even more dramatic, adding the SIB family of O(n3)PAIRij,ik factors will add only O(n3) to the runtime of BP(Table 1).
By contrast, the runtime of dynamic programmingbecomes exponential, because each item must record its head-word?s full set of current children.equation (4) may appear prohibitive.
Crucially, how-ever, F (A) only depends on the values in A of F ?sits neighboring variables N (F ).
So this sum is pro-portional to a sum over restricted assignments to justthose variables.11For example, computing a message fromTAGLINKij ?
Ti only requires iterating over all(boolean, tag, tag) triples.12 The runtime to updatethat message is therefore O(2 ?
|T | ?
|T |).5.2 Propagators for global constraintsThe above may be tolerable for a ternary factor.
Buthow about global factors?
EXACTLY1j has n neigh-boring boolean variables: surely we cannot iterateover all 2n assignments to these!
TREE is evenworse, with 2O(n2) assignments to consider.
We willgive specialized algorithms for handling these sum-mations more efficiently.A historical note is in order.
Traditional constraintsatisfaction corresponds to the special case of (1)where all factors Fm are hard constraints (with val-ues in {0, 1}).
In that case, loopy BP reduces toan algorithm for generalized arc consistency (Mack-worth, 1977; Bessie`re and Re?gin, 1997; Dechter,2003), and updating a factor?s outgoing messages isknown as constraint propagation.
Re?gin (1994)famously introduced an efficient propagator fora global constraint, ALLDIFFERENT, by adaptingcombinatorial bipartite matching algorithms.In the same spirit, we will demonstrate efficientpropagators for our global constraints, e.g.
by adapt-ing combinatorial algorithms for weighted parsing.We are unaware of any previous work on global fac-tors in sum-product BP, although for max-productBP,13 Duchi et al (2007) independently showedthat a global 1-to-1 alignment constraint?a kindof weighted ALLDIFFERENT?permits an efficientpropagator based on weighted bipartite matching.5.3 Constraint propagators for parsingTable 1 shows our asymptotic runtimes for all fac-tors in ??3.3?3.4.
Remember that if several of these11The constant of proportionality may be folded into ?
; it isthe number of assignments to the other variables.12Separately for each value v of Ti, get v?s probability bysumming over assignments to (Lij , Ti, Tj) s.t.
Ti = v.13Max-product replaces the sums in equations (3)?
(6) withmaximizations.
This replaces the forward-backward algorithmwith its Viterbi approximation.149factor degree runtime count runtimefamily (each) (each) (total)TREE O(n2) O(n3) 1 O(n3)PTREE O(n2) O(n3) 1 O(n3)EXACTLY1 O(n) O(n) n O(n2)ATMOST1 O(n) O(n) n O(n2)NOT2 2 O(1) O(n3) O(n3)NO2CYCLE 2 O(1) O(n2) O(n2)LINK 1 O(1) O(n2) O(n2)GRAND 2 O(1) O(n3) O(n3)SIB 2 O(1) O(n3) O(n3)CHILDSEQ O(n) O(n2) O(n) O(n3)NOCROSS O(n) O(n) O(n2) O(n3)TAG 1 O(g) O(n) O(ng)TAGLINK 3 O(g2) O(n2) O(n2g2)TRIGRAM O(n) O(ng3) 1 O(ng3)Table 1: Asymptotic runtimes of the propagators for var-ious factors (where n is the sentence length and g is thesize of the tag set T ).
An iteration of standard BP propa-gates through each factor once.
Running a factor?s prop-agator will update all of its outgoing messages, based onits current incoming messages.factors are included, the total runtime is additive.14Propagating the local factors is straightforward(?5.1).
We now explain how to handle the globalfactors.
Our main trick is to work backwards frommarginal beliefs.
Let F be a factor and V be oneof its neighboring variables.
At any time, F has amarginal belief about V (see footnote 9),b(k+1)F?
(V = v) =?A s.t.
A[V ]=vb(k+1)F?
(A) (7)a sum over (6)?s products of incoming messages.
Bythe definition of rF?V in (4), and distributivity, wecan also express the marginal belief (7) as a point-wise product of outgoing and incoming messages15b(k+1)F?
(V = v) = r(k+1)F?V (v) ?
q(k)V?F (v) (8)up to a constant.
If we can quickly sum up themarginal belief (7), then (8) says we can divide outeach particular incoming message q(k)V?F to obtainits corresponding outgoing message r(k+1)F?V .14We may ignore the cost of propagators at the variables.Each outgoing message from a variable can be computed intime proportional to its size, which may be amortized againstthe cost of generating the corresponding incoming message.15E.g., the familiar product of forward and backward mes-sages that is used to extract posterior marginals from an HMM.Note that the marginal belief and both messagesare unnormalized distributions over values v of V .F and k are clear from context below, so we simplifythe notation so that (7)?
(8) becomeb(V = v) =?A s.t.
A[V ]=vb(A) = rV (v) ?
qV (v)TRIGRAM must sum over assignments to the tagsequence T .
The belief (6) in a given assignmentis a product of trigram scores (which play the roleof transition weights) and incoming messages qTj(playing the role of emission weights).
The marginalbelief (7) needed above, b(Ti = t), is found by sum-ming over assignments where Ti = t. All marginalbeliefs are computed together in O(ng3) total timeby the forward-backward algorithm.16EXACTLY1j is a sparse hard constraint.
Eventhough there are 2n assignments to its n neighboringvariables {Lij}, the factor function returns 1 on onlyn assignments and 0 on the rest.
In fact, for a given i,b(Lij = true) in (7) is defined by (6) to have exactlyone non-zero summand, in whichA puts Lij = trueand all other Li?j = false.
We compute the marginalbeliefs for all i together in O(n) total time:1.
Pre-compute pidef=?i qLij (false).172.
For each i, compute the marginal beliefb(Lij = true) as pi ?
q?Lij , where q?Lij ?
R de-notes the odds ratio qLij (true)/qLij (false).183.
The partition function b() denotes?A b(A);compute it in this case as?i b(Lij = true).4.
For each i, compute b(Lij = false) by subtrac-tion, as b()?
b(Lij = true).TREE and PTREE must sum over assignments tothe O(n2) neighboring variables {Lij}.
There arenow exponentially many non-zero summands, thosein whichA corresponds to a valid tree.
Nonetheless,16Which is itself an exact BP algorithm, but on a differentgraph?a junction tree formed from the graph of TRIGRAM sub-factors.
Each variable in the junction tree is a bigram.
If we hadsimply replaced the global TRIGRAM factor with its subfactorsin the full factor graph, we would have had to resort to General-ized BP (Yedidia et al, 2004) to obtain the same exact results.17But taking pi = 1 gives the same results, up to a constant.18As a matter of implementation, this odds ratio q?Lij can beused to represent the incoming message qLij everywhere.150we can follow the same approach as for EXACTLY1.Steps 1 and 4 are modified to iterate over all i, j suchthat Lij is a variable.
In step 3, the partition function?A b(A) is now pi times the total weight of all trees,where the weight of a given tree is the product of theq?Lij values of its n edges.
In step 2, the marginalbelief b(Lij = true) is now pi times the total weightof all trees having edge i?
j.We perform these combinatorial sums by calling afirst-order parsing algorithm, with edge weights q?ij .Thus, as outlined in ?2, a first-order parser is calledeach time we propagate through the global TREE orPTREE constraint, using edge weights that includethe first-order LINK factors but also multiply in anycurrent messages from higher-order factors.The parsing algorithm simultaneously computesthe partition function b(), and all O(n2) marginalbeliefs b(Lij = true).
For PTREE (projective), itis the inside-outside version of a dynamic program-ming algorithm (Eisner, 1996).
For TREE (non-projective), Koo et al (2007) and Smith and Smith(2007) show how to employ the matrix-tree theorem.In both cases, the total time is O(n3).19NOCROSSj` must sum over assignments to O(n)neighboring variables {Lij} and {Lk`}.
The non-zero summands are assignments where j and `each have exactly one parent.
At step 1, pidef=?i qLij (false) ?
?k qLk`(false).
At step 2, themarginal belief b(Lij = true) sums over the n non-zero assignments containing i ?
j.
It is pi ?
q?Lij ?
?k q?Lk` ?
PAIRij,k`, where PAIRij,k` is xj` if i ?
jcrosses k ?
` and is 1 otherwise.
xj` is some factorvalue defined by equation (2) to penalize or rewardthe crossing.
Steps 3?4 are just as in EXACTLY1j .The question is how to compute b(Lij = true) foreach i in only O(1) time,20 so that we can propagateeach of the O(n2) NOCROSSj` in O(n) time.
Thisis why we allowed xj` to depend only on j, `.
Wecan rewrite the sum b(Lij = true) aspi ?
q?Lij ?
(xj` ?
?crossing kq?Lk` + 1 ?
?noncrossing kq?Lk`) (9)19A dynamic algorithm could incrementally update the out-going messages if only a few incoming messages have changed(as in asynchronous BP).
In the case of TREE, dynamic matrixinverse allows us to update any row or column (i.e., messagesfrom all parents or children of a given word) and find the newinverse in O(n2) time (Sherman and Morrison, 1950).20Symmetrically, we compute b(Lk` = true) for each k.To find this in O(1) time, we precompute for each` an array of partial sums Q`[s, t]def=?s?k?t q?Lk` .SinceQ`[s, t] = Q`[s, t?1]+ q?Lt` , we can computeeach entry in O(1) time.
The total precomputationtime over all `, s, t is then O(n3), with the array Q`shared across all factors NOCROSSj?`.
The crossingsum is respectivelyQ`[0, i?1]+Q`[j+1, n],Q`[i+1, j ?
1], or 0 according to whether ` ?
(i, j), ` /?
[i, j], or ` = i.21 The non-crossing sum is Q`[0, n]minus the crossing sum.CHILDSEQi , like TRIGRAM, is propagated by aforward-backward algorithm.
In this case, the al-gorithm is easiest to describe by replacing CHILD-SEQi in the factor graph by a collection of localsubfactors, which pass messages in the ordinaryway.22 Roughly speaking,23 at each j ?
[1, n],we introduce a new variable Cij?a hidden statewhose value is the position of i?s previous child,if any (so 0 ?
Cij < j).
So the ternary sub-factor on (Cij , Lij , Ci,j+1) has value 1 if Lij =false and Ci,j+1 = Ci,j ; a sibling-bigram score(PAIRiCij ,iCi,j+1) if Lij = true and Ci,j+1 = j; and0 otherwise.
The sparsity of this factor, which is 0almost everywhere, is what gives CHILDSEQi a totalruntime of O(n2) rather than O(n3).
It is equivalentto forward-backward on an HMM with n observa-tions (the Lij) and n states per observation (the Cj),with a deterministic (thus sparse) transition function.6 Decoding TreesBP computes local beliefs, e.g.
the conditional prob-ability that a link Lij is present.
But if we wishto output a single well-formed dependency tree, weneed to find a single assignment to all the {Lij} thatsatisfies the TREE (or PTREE) constraint.Our final belief about the TREE factor is a distri-bution over such assignments, in which a tree?s prob-ability is proportional to the probability of its edgeweights q?Lij (incoming messages).
We could simplyreturn the mode of this distribution (found by usinga 1-best first-order parser) or the k-best trees, or takesamples.21There are no NOCROSSj` factors with ` = j.22We still treat CHILDSEQi as a global factor and compute allits correct outgoing messages on a single BP iteration, via serialforward and backward sweeps through the subfactors.
Handlingthe subfactors in parallel, (3)?
(4), would need O(n) iterations.23Ignoring the treatment of boundary symbols ?#?
(see ?3.4).151In our experiments, we actually take the edgeweights to be not the messages q?Lij from the links,but the full beliefs b?Lij at the links (where b?Lijdef=log bLij (true)/bLij (false)).
These are passed into afast algorithm for maximum spanning tree (Tarjan,1977) or maximum projective spanning tree (Eis-ner, 1996).
This procedure is equivalent to minimumBayes risk (MBR) parsing (Goodman, 1996) with adependency accuracy loss function.Notice that the above decoding approaches do notenforce any hard constraints other than TREE in thefinal output.
In addition, they only recover valuesof the Lij variables.
They marginalize over othervariables such as tags and link roles.
This solvesthe problem of ?nuisance?
variables (which merelyfragment probability mass among refinements of aparse).
On the other hand, it may be undesirable forvariables whose values we desire to recover.247 TrainingOur training method also uses beliefs computed byBP, but at the factors.
We choose the weight vector?
by maximizing the log-probability of training data24An alternative is to attempt to find the most probable(?MAP?)
assignment to all variables?using the max-productalgorithm (footnote 13) or one of its recent variants.
The esti-mated marginal beliefs become ?max marginals,?
which assessthe 1-best assignment consistent with each value of the variable.We can indeed build max-product propagators for our globalconstraints.
PTREE still propagates in O(n3) time: simplychange the first-order parser?s semiring (Goodman, 1999) to usemax instead of sum.
TREE requires O(n4) time: it seems thatthe O(n2) max marginals must be computed separately, eachrequiring a separate call to an O(n2) maximum spanning treealgorithm (Tarjan, 1977).If max-product BP converges, we may simply output eachvariable?s favorite value (according to its belief), if unique.However, max-product BP tends to be unstable on loopy graphs,and we may not wish to wait for full convergence in any case.
Amore robust technique for extracting an assignment is to mimicViterbi decoding, and ?follow backpointers?
of the max-productcomputation along some spanning subtree of the factor graph.A slower but potentially more stable alternative is determin-istic annealing.
Replace each factor Fm(A) with Fm(A)1/T ,where T > 0 is a temperature.
As T ?
0 (?quenches?
), thedistribution (1) retains the same mode (the MAP assignment),but becomes more sharply peaked at the mode, and sum-productBP approaches max-product BP.
Deterministic annealing runssum-product BP while gradually reducing T toward 0 as it it-erates.
By starting at a high T and reducing T slowly, it oftenmanages in practice to find a good local optimum.
We may thenextract an assignment just as we do for max-product.under equation (1), regularizing only by early stop-ping.
If all variables are observed in training, thisobjective function is convex (as for any log-linearmodel).The difficult step in computing the gradient ofour objective is finding ??
logZ, where Z in equa-tion (1) is the normalizing constant (partition func-tion) that sums over all assignments A.
(Recall thatZ, like each Fm, depends implicitly on W and ?.
)As usual for log-linear models,??
logZ =?mEp(A)[?
?Fm(A)] (10)Since ?
?Fm(A) only depends on the assignmentA?s values for variables that are connected to Fmin the factor graph, its expectation under p(A) de-pends only on the marginalization of p(A) to thosevariables jointly.
Fortunately, BP provides an esti-mate of that marginal distribution, namely, its beliefabout the factor Fm, given W and ?
(?4.2).25Note that the hard constraints do not depend on ?at all; so their summands in equation (10) will be 0.We employ stochastic gradient descent (Bottou,2003), since this does not require us to computethe objective function itself but only to (approxi-mately) estimate its gradient as explained above.
Al-ternatively, given any of the MAP decoding proce-dures from ?6, we could use an error-driven learningmethod such as the perceptron or MIRA.268 ExperimentsWe asked: (1) For projective parsing, where higher-order factors have traditionally been incorporatedinto slow but exact dynamic programming (DP),what are the comparative speed and quality of theBP approximation?
(2) How helpful are such higher-order factors?particularly for non-projective pars-ing, where BP is needed to make them tractable?
(3) Do our global constraints (e.g., TREE) contributeto the goodness of BP?s approximation?25One could use coarser estimates at earlier stages of training,by running fewer iterations of BP.26The BP framework makes it tempting to extend an MRFmodel with various sorts of latent variables, whose values arenot specified in training data.
It is straightforward to train underthese conditions.
When counting which features fire on a train-ing parse or (for error-driven training) on an current erroneousparse, we can find expected counts if these parses are not fullyobserved, by using BP to sum over latent variables.1520 10 20 30 40 50 60 700204060Sentence lengthAverageparsingtime in secondsMBR by DPViterbi DP2 iterations of BP3 iterations of BP5 iterations of BP10 iterations of BPFigure 2: Runtime of BP parser on various sentencelengths compared to O(n4) dynamic programming.8.1 DataWe trained and tested on three languages from theCoNLL Dependency Parsing Shared Task (Nivre etal., 2007).
The English data for that task wereconverted from the Penn Treebank to dependen-cies using a trace-recovery algorithm that inducedsome very slight non-projectivity?about 1% oflinks crossed other links.
Danish is a slightly morenon-projective language (3% crossing links).
Dutchis the most non-projective language in the corpus(11%).
In all cases, the test input W consists ofpart-of-speech-tagged words, so T variables werenot used.8.2 FeaturesAlthough BP makes it cheap to incorporate manynon-local features and latent variables at once, wekept our models relatively simple in this paper.Our first-order LINKij factors replicate McDon-ald et al (2005).
Following equation (2), they aredefined using binary features that look at words iand j, the distance j ?
i, and the tags (provided inW ) of words at, around, and between i and j.Our second-order features are similar.
In theGRAND factors, features fire for particular triplesof tags and of coarse tags.
A feature also fires ifthe grandparent falls between the child and parent,inducing crossing dependency links.
The CHILD-SEQ factors included features for tags, and like-wise coarse tags, on adjacent sibling pairs and0 10 20 30 40020406080100120140Sentence lengthAverageparsingtime in secondsMBR by DPViterbi DP2 iterations of BP3 iterations of BP5 iterations of BP10 iterations of BPFigure 3: Runtime of BP parser on various sentencelengths compared to O(n5) dynamic programming.
DPis so slow for length > 45 that we do not even show it.parent-sibling-sibling triples.
Each of these fea-tures also have versions that were conjoined withlink direction?pairs of directions in the grandpar-ent case?or with signed link length of the child orfarther sibling.
Lengths were binned per McDonaldet al (2005).
The NOCROSSj` factors consider thetag and coarse tag attributes of the two child wordsj and `, separately or jointly.8.3 Experimental proceduresWe trained all models using stochastic gradient de-scent (?7).
SGD initialized ~?
= 0 and ran for 10 con-secutive passes over the data; we picked the stoppingpoint that performed best on held-out data.When comparing runtimes for projective parsers,we took care to produce comparable implementa-tions.
All beliefs and dynamic programming itemswere stored and indexed using the high-level Dynalanguage,27 while all inference and propagation waswritten in C++.
The BP parser averaged 1.8 secondsper sentence for non-projective parsing and 1.5 sec-onds per sentence for projective parsing (1.2 and 0.9seconds/sentence for ?
40 words), using our stan-dard setup, which included five iterations of BP andthe final MBR tree decoding pass.In our tables, we boldface the best result in eachcolumn along with any results that are not signifi-cantly worse (paired permutation test, p < .05).27This dominates runtime, and probably slows down all ourparsers by a factor of 4?11 owing to known inefficiencies in theDyna prototype we used (Eisner et al, 2005).1530 20 40 600.00.10.20.30.4Parsing time in secondsErrorrelativetoexact MBRInput length40 words50 words60 words70 words2 iterations of BP3 iterations of BP5 iterations of BP10 iterations of BPMBR DPFigure 4: Runtime vs. search error after different num-bers of BP iterations.
This shows the simpler model ofFig.
2, where DP is still relatively fast.8.4 Faster higher-order projective parsingWe built a first-order projective parser?one thatuses only factors PTREE and LINK?and then com-pared the cost of incorporating second-order factors,GRAND and CHILDSEQ, by BP versus DP.28Under DP, the first-order runtime of O(n3) is in-creased to O(n4) with GRAND, and to O(n5) whenwe add CHILDSEQ as well.
BP keeps runtime downto O(n3)?although with a higher constant factor,since it takes several rounds to converge, and sinceit computes more than just the best parse.29Figures 2?3 compare the empirical runtimes forvarious input sentence lengths.
With only theGRAND factor, exact DP can still find the Viterbiparse (though not the MBR parse29) faster than teniterations of the asymptotically better BP (Fig.
2),at least for sentences with n ?
75.
However, oncewe add the CHILDSEQ factor, BP is always faster?dramatically so for longer sentences (Fig.
3).
Morecomplex models would widen BP?s advantage.Fig.
4 shows the tradeoff between runtime andsearch error of BP in the former case (GRAND only).To determine BP?s search error at finding the MBRparse, we measured its dependency accuracy not28We trained these parsers using exact DP, using the inside-outside algorithm to compute equation (10).
The training andtest data were English, and for this section we filtered out sen-tences with non-projective links.29Viterbi parsing in the log domain only needs the (max,+)semiring, whereas both BP and any MBR parsing must use theslower (+, log+) so that they can compute marginals.Danish Dutch English(a) TREE+LINK 85.5 87.3 88.6+NOCROSS 86.1 88.3 89.1+GRAND 86.1 88.6 89.4+CHILDSEQ 86.5 88.5 90.1(b) Proj.
DP 86.0 84.5 90.2+hill-climbing 86.1 87.6 90.2Table 2: (a) Percent unlabeled dependency accuracy forvarious non-projective BP parsers (5 iterations only),showing the cumulative contribution of different features.
(b) Accuracy for an projective DP parser with all features.For relatively non-projective languages (Danish and espe-cially Dutch), the exact projective parses can be improvedby non-projective hill-climbing?but in those cases, justrunning our non-projective BP is better and faster.against the gold standard, but against the optimalMBR parse under the model, which DP is able tofind.
After 10 iterations, the overall macro-averagedsearch error compared to O(n4) DP MBR is 0.4%;compared to O(n5) (not shown), 2.4%.
More BPiterations may help accuracy.
In future work, weplan to compare BP?s speed-accuracy curve on morecomplex projective models with the speed-accuracycurve of pruned or reranked DP.8.5 Higher-order non-projective parsingThe BP approximation can be used to improvethe accuracy of non-projective parsing by addinghigher-order features.
These would be NP-hard toincorporate exactly; DP cannot be used.We used BP with a non-projective TREE factorto train conditional log-linear parsing models of twohighly non-projective languages, Danish and Dutch,as well as slightly non-projective English (?8.1).In all three languages, the first-order non-projectiveparser greatly overpredicts the number of crossinglinks.
We thus added NOCROSS factors, as wellas GRAND and CHILDSEQ as before.
All of thesesignificantly improve the first-order baseline, thoughnot necessarily cumulatively (Table 2).Finally, Table 2 compares loopy BP to a previ-ously proposed ?hill-climbing?
method for approx-imate inference in non-projective parsing McDon-ald and Pereira (2006).
Hill-climbing decodes ourrichest non-projective model by finding the best pro-jective parse under that model?using slow, higher-order DP?and then greedily modifies words?
par-ents until the parse score (1) stops improving.154Decoding Danish Dutch EnglishNOT2 81.8 (76.7) 83.3 (75.0) 87.5 (66.4)ATMOST1 85.4 (82.2) 87.3 (86.3) 88.5 (84.6)EXACTLY1 85.7 (85.0) 87.0 (86.7) 88.6 (86.0)+ NO2CYCLE 85.0 (85.2) 86.2 (86.7) 88.5 (86.2)TREE 85.5 (85.5) 87.3 (87.3) 88.6 (88.6)PTREE 85.8 83.9 88.8Table 3: After training a non-projective first-order modelwith TREE, decoding it with weaker constraints is asymp-totically faster (except for NOT2) but usually harm-ful.
(Parenthetical numbers show that the harm is com-pounded if the weaker constraints are used in trainingas well; even though this matches training to test con-ditions, it may suffer more from BP?s approximate gradi-ents.)
Decoding the TREE model with the even strongerPTREE constraint can actually be helpful for a more pro-jective language.
All results use 5 iterations of BP.BP for non-projective languages is much fasterand more accurate than the hill-climbing method.Also, hill-climbing only produces an (approximate)1-best parse, but BP also obtains (approximate)marginals of the distribution over all parses.8.6 Importance of global hard constraintsGiven the BP architecture, do we even need the hardTREE constraint?
Or would it suffice for more localhard constraints to negotiate locally via BP?We investigated this for non-projective first-orderparsing.
Table 3 shows that global constraints areindeed important, and that it is essential to use TREEduring training.
At test time, the weaker but stillglobal EXACTLY1 may suffice (followed by MBRdecoding to eliminate cycles), for total time O(n2).Table 3 includes NOT2, which takes O(n3) time,merely to demonstrate how the BP approximationbecomes more accurate for training and decodingwhen we join the simple NOT2 constraints into moreglobal ATMOST1 constraints.
This does not changethe distribution (1), but makes BP enforce strongerlocal consistency requirements at the factors, rely-ing less on independence assumptions.
In general,one can get better BP approximations by replacing agroup of factors Fm(A) with their product.30The above experiments concern gold-standard30In the limit, one could replace the product (1) with a sin-gle all-purpose factor; then BP would be exact?but slow.
(Inconstraint satisfaction, joining constraints similarly makes arcconsistency slower but better at eliminating impossible values.
)accuracy under a given first-order, non-projectivemodel.
Flipping all three of these parameters forDanish, we confirmed the pattern by instead mea-suring search error under a higher-order, projectivemodel (PTREE+LINK+GRAND), when PTREE wasweakened during decoding.
Compared to the MBRparse under that model, the search errors from de-coding with weaker hard constraints were 2.2% forNOT2, 2.1% for EXACTLY1, 1.7% for EXACTLY1+ NO2CYCLE, and 0.0% for PTREE.9 Conclusions and Future WorkBelief propagation improves non-projective depen-dency parsing with features that would make ex-act inference intractable.
For projective parsing, itis significantly faster than exact dynamic program-ming, at the cost of small amounts of search error,We are interested in extending these ideas tophrase-structure and lattice parsing, and in try-ing other higher-order features, such as those usedin parse reranking (Charniak and Johnson, 2005;Huang, 2008) and history-based parsing (Nivre andMcDonald, 2008).
We could also introduce newvariables, e.g., nonterminal refinements (Matsuzakiet al, 2005), or secondary linksMij (not constrainedby TREE/PTREE) that augment the parse with repre-sentations of control, binding, etc.
(Sleator and Tem-perley, 1993; Buch-Kromann, 2006).Other parsing-like problems that could be at-tacked with BP appear in syntax-based machinetranslation.
Decoding is very expensive with a syn-chronous grammar composed with an n-gram lan-guage model (Chiang, 2007)?but our footnote 10suggests that BP might incorporate a languagemodel rapidly.
String alignment with synchronousgrammars is quite expensive even for simple syn-chronous formalisms like ITG (Wu, 1997)?butDuchi et al (2007) show how to incorporate bipar-tite matching into max-product BP.Finally, we can take advantage of improvementsto BP proposed in the context of other applications.For example, instead of updating all messages inparallel at every iteration, it is empirically faster toserialize updates using a priority queue (Elidan etal., 2006; Sutton and McCallum, 2007).3131These methods need alteration to handle our global propa-gators, which do update all their outgoing messages at once.155ReferencesC.
Bessie`re and J.-C. Re?gin.
1997.
Arc consistency forgeneral constraint networks: preliminary results.
InIJCAI, pages 398?404.L.
Bottou.
2003.
Stochastic learning.
In Advanced Lec-tures in Machine Learning, pages 146?168.
Springer.A.
Braunstein, M. Mezard, and R. Zecchina.
2005.
Sur-vey propagation: An algorithm for satisfiability.
Ran-dom Structures and Algorithms, 27:201?226.M.
Buch-Kromann.
2006.
Discontinuous Grammar.A Model of Human Parsing and Language Acquisi-tion?.
Dr.ling.merc.
dissertation, Copenhagen Busi-ness School.E.
Charniak and M. Johnson.
2005.
Coarse-to-fine n-best parsing and maxent discriminative reranking.
InACL, pages 173?180.D.
Chiang.
2007.
Hierarchical phrase-based translation.Computational Linguistics, 33(2):201?228.R.
Dechter.
2003.
Constraint Processing.
Morgan Kauf-mann.J.
Duchi, D. Tarlow, G. Elidan, and D. Koller.
2007.Using combinatorial optimization within max-productbelief propagation.
In NIPS 2006, pages 369?376.J.
Eisner and G. Satta.
1999.
Efficient parsing for bilex-ical context-free grammars and head automaton gram-mars.
In ACL, pages 457?480.J.
Eisner, E. Goldlust, and N. A. Smith.
2005.
Compilingcomp ling: Weighted dynamic programming and thedyna language.
In HLT-EMNLP, pages 281?290.J.
Eisner.
1996.
Three new probabilistic models for de-pendency parsing: An exploration.
In COLING.G.
Elidan, I. McGraw, and D. Koller.
2006.
Resid-ual belief propagation: Informed scheduling for asyn-chronous message passing.
In UAI.J.
T. Goodman.
1996.
Parsing algorithms and metrics.In ACL, pages 177?183.J.
Goodman.
1999.
Semiring parsing.
ComputationalLinguistics, 25(4):573?605.L.
Huang.
2008.
Forest reranking: Discriminative pars-ing with non-local features.
In ACL, pages 586?594.T.
Koo, A. Globerson, X. Carreras, and M. Collins.
2007.Structured prediction models via the Matrix-Tree The-orem.
In EMNLP-CoNLL.D.
MacKay.
2003.
Information Theory, Inference, andLearning Algorithms.
Cambridge.A.
Mackworth.
1977.
Consistency in networks of rela-tions.
Artificial Intelligence, 8(1):99?118.A.
F. T. Martins, D. Das, N. A. Smith, and E. P. Xing.2008.
Stacking dependency parsers.
In EMNLP.T.
Matsuzaki, Y. Miyao, and J. Tsujii.
2005.
Probabilis-tic CFG with latent annotations.
In ACL, pages 75?82.R.
McDonald and F. Pereira.
2006.
Online learningof approximate dependency parsing algorithms.
InEACL.R.
McDonald, K. Crammer, and F. Pereira.
2005.
Onlinelarge-margin training of dependency parsers.
In ACL.J.
Nivre and R. McDonald.
2008.
Integrating graph-based and transition-based dependency parsers.
InACL.J.
Nivre, J.
Hall, S. Ku?bler, R. McDonald, J. Nilsson,S.
Riedel, and D. Yuret.
2007.
The CoNLL 2007shared task on dependency parsing.
In Proceedingsof the CoNLL Shared Task Session of EMNLP-CoNLL.J.-C. Re?gin.
1994.
A filtering algorithm for constraintsof difference in csps.
In AAAI, pages 362?367.S.
Riedel and J. Clarke.
2006.
Incremental integer linearprogramming for non-projective dependency parsing.In EMNLP, pages 129?137.J.
Sherman and W. J. Morrison.
1950.
Adjustment of aninverse matrix corresponding to a change in one ele-ment of a given matrix.
Ann.
Math.
Stat., 21:124?127.D.
Sleator and D. Temperley.
1993.
Parsing English witha link grammar.
In IWPT, pages 277?291, August.D.
A. Smith and N. A. Smith.
2007.
Probabilistic mod-els of nonprojective dependency trees.
In EMNLP-CoNLL.C.
Sutton and A. McCallum.
2004.
Collective segmenta-tion and labeling of distant entities in information ex-traction.
In ICML Workshop on Statistical RelationalLearning.C.
Sutton and A. McCallum.
2007.
Improved dynamicschedules for belief propagation.
In UAI.C.
Sutton, K. Rohanimanesh, and A. McCallum.
2004.Dynamic conditional random fields: Factorized prob-abilistic models for labeling and segmenting sequencedata.
In ICML.R.
E. Tarjan.
1977.
Finding optimum branchings.
Net-works, 7:25?35.R.
W. Tromble and J. Eisner.
2006.
A fast finite-staterelaxation method for enforcing global constraints onsequence decoding.
In HLT-NAACL, pages 423?430.Y.
Weiss and W. T. Freedman.
2001.
On the optimal-ity of solutions of the max-product belief propagationalgorithm in arbitrary graphs.
IEEE Transactions onInformation Theory, 47.D.
Wu.
1997.
Stochastic inversion transduction gram-mars and bilingual parsing of parallel corpora.
CL,23(3):377?404.J.
S. Yedidia, W. T. Freeman, and Y. Weiss.
2004.
Con-structing free-energy approximations and generalizedbelief approximation algorithms.
MERL TR2004-040, Mitsubishi Electric Research Laboratories.156
