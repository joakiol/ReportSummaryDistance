Parsing Akkadian Verbs with PrologAaron MacksDepartment of Computer ScienceBrandeis UniversityWaltham, MA.
02454aaronm@cs.brandeis.eduAbstractT h i s  p a p e r  d e s c r i b e s  aparsing/generation system for finiteverbal forms in Akkadian, with thepossible addition of suffixes,implemented in Prolog.
The workdescribed provides the framework andengine to interpret the D, N, and Gstems along with accusative, dativeand ventive endings.1 IntroductionThe goal of this research is to create a parsercapable of taking a finite Akkadian verb, withsome subset of  direct-object, indirect-object,and ventive suffixes and returning the verb form,suffix form if applicable, and the radical stem.With the exception of the GUI, a Java wrapperrunning through a web-server, the program iswritten entirely in Prolog.
The Definite ClauseGrammar (DCG) rules that are used are anexpansion of regular context-free grammars;they define a set of one or more expansions froma set of variables to a complete form.
Theprogram also functions as a generator of finiteverbal forms, as the rules can both generate andrecognize forms.2 Parser designThe form to be parsed is input into the Prolog1interpreter as a character string of the finite verbform, comma delineated, and with long(macron) and elided (circumflex) vowelsrepresented by double and triple vowels,1The program is designed to work with the SWI-Prolog interpreter, http://www.swi-prolog.org, andcompatability with other intperpreters, especially inthe nonstandardized interpretation of DCG rules, isnot anticipated.respectively.
This form, referred to as theProlog Normal Form (PlNF), can either be inputmanually by the user or generated by thesoftware from a character string input by theuser.
In the Prolog interpreter, backtracking isused to test for any possible finite form, withand without suffixes.
When a matching form isfound, a text string describing the form and thethree radicals are returned, bound to variables toallow other programs to use this parsing engine.The parser is designed to handle any strong rootand almost any weak root, but quadriliteral anddoubly-weak roots are too irregular for aprogram of this scope.
The program uses theampersand (@)2 to represent a generic weakradical, and simply the letters for W, Y, and Nroots.
In this manner weak roots are indicated inthe form string as well as the three radicals, inmost cases.2.1  VowelsAlthough vowels are quite important inAkkadian, in almost no cases are they needed touniquely identify the stem.
Due to this and thefact that knowing the vowel classes for eachverb stem would limit the parser to those verbswhich had been explicitly added to a dictionary,the program was designed from the beginning toignore vowels when possible.
Three main setsof rules were build, the vs , vl, and vdl forrecognizing short, long, and doubly-long vowelsrespectively.
These are used in rules when theverb, rather than the form, determines the vowel;in the others the vowels are hard-coded into therules.
As the program developed, needs werefound for some other minor vowel rules,including the interchangeable ?a/e?
for certainweak verbs and the interchangeable ?u/i?
forsome imperative forms.
These allow only2The only other non-standard symbol needed was forthe Shin, which is represented as the dollar sign ($).specified vowels, and not entire classes to berecognized.
There are 22 vowel rules in theparser at the moment, but the chance that moreare needed is quite small.The parser works on verbs that have beennormalized, but the normalization processusually takes into account the form of the verbwhen determining vowel length from aninscription.
This leads to a recursive problemthat the parser works with normalized verbs todetermine their forms; however the form mustfrequently be know in order to normalize theverb.
This problem is partially ameliorated bythe addition of wildcards to the vowel structure.Instead of forcing the user to know the vowellength, they can input the value and an asteriskand the program tests for all possible vowellengths.
As the value of the vowel would beknown from an inscription, the decision wasmade not to allow a free wildcard, only to parsethe three possible lengths of a given vowel.
Anexample would be parsing the string idda*k,which gives responses from parsing iddak (G-preterite or durative), idd?k (N-preterite) andidd?k (N-durative).2.2 Initial parsing functionsThe central program is executed with acommand, within the Prolog interpreter of theform:?- verb(A, B, C, Type, [i,p,r,u,s]).
(Figure 1.
Parsing a finite form, the A,B,C are bound to theradicals and Type to the returned string describing the type.The ??-?
is the Prolog prompt.
)This calls the main ?verb?
function, whichthen calls a parser for each stem twice, oncewith and once without the suffix interpreter.Each call begins by loading and compiling theappropriate source file, although in operation thecompiled code is cached, thus not requiringmultiple recompilation per session.
This allowsany new stem, as currently the parser onlyunderstands the G, D and N stems, to be addedas a separate file with only two lines of codeadded to the main program.
Each call to a stemparser then further breaks down the form, tryingto parse it using one of the different tenseparsers, i.e., D-durative or G-imperative, whichthen calls the various DCG rules to interpretstrong and weak verb stems.
All of the higherfunctions are standard Prolog declarations, alldesigned to call the proper DCG rules, which dothe actual parsing/generation.
Thesedeclarations, as they are called incrementallyfrom verb  can add, by concatenation,information to the  type-string which is returnedby the main program.The verb function is then wrapped with afunction, akkadian which takes as input thefinite verb as a string and returns it parsed andnormalized for each successful parse, takingcare of the vowel wildcards and correctlyseparating the string into the PlNF for the verbfunction.The nature of the DCG interpreter in Prologallows it to parse a string  to the end, or parse aprefix of that string and return the suffix.
Eachof the paradigm parsers is called twice, with thefirst pass forcing it to return no suffix and thesecond binding the suffix to a new variable.This bound variable is then passed to the suffixparser which can try combinations ofAccusative, Dative and Ventive endings.
If asuffix is successfully parsed, a string describingits type is returned and concatenated onto theverb type string.
The parser is designed toignore the conjunctive suffix ?ma, but thiscurrently is under development and does notalways work.As the program currently stands, thewrapper declarations are represented by 137declarations and the suffix parser by 45 DCGrules.2.3 Finite verb rulesThe bulk of the work in the verb parsing, andprogramming, consists of the DCG rules whichrecognize the verb and bind the radicals to thevariables (the A, B, and C in Fig.
1).
It takesapproximately 200 rules to parse a stem, whichprovides recognition of the preterite, durative,perfect, imperative, precative, and vetitive, inthe first N, first W, active and stative, and first,second and third Aleph.
As they are currentlyimplemented, the forms are reduced to a basetype,  ei ther explici t ly,  as in thestrnbasepret rule for the N preterite, orimplicitly by using other, previously declaredforms.
The modified forms are described usingthe rules for the base forms.
An example is theplural G strong durative, where only one newrule was needed:strgdur(Ca, Cb, Cc, [3,m,p]) -->strgdur(Ca, Cb, Cc, [3,c,s]), [uu].strgdur(Ca, Cb, Cc, [3,f,p]) -->strgdur(Ca, Cb, Cc, [3,c,s]), [aa].strgdur(Ca, Cb, Cc, [2,c,p]) -->strgdur(Ca, Cb, Cc, [2,m,s]), [aa].strgdur(Ca, Cb, Cc, [1,c,p]) --> [n],[i], Ca, [a], Cb, Cb, vs, Cc.
(Figure 2.
Plural G Durative rules.
They represent, innormalized form: iparrus?3, iparrus?, taparrus?
andniparrus.
)In the DCG, a bracketed letter is a literal, acapitol letter is a variable and a lowercaseanother DCG, usually another form of thecurrent verb or a vowel rule.
The rule itselftakes the form of: name(argument[s])-->rule[s], where the arguments can be eitherdefined in the rule(such as [2,c,p]) or variablesto be bound by the rule itself; the rule is somestring of bracketed literals, variables or anotherrule.2.4 GenerationWithin the Prolog interpretation of DCG rules,there is no defined sense of direction, so that thesame rule-base, which can recognize a finiteverb form, can also generate that form.
Some ofthe more bizarre functions which handle string-to-PlNF conversion had to be rewritten, butfewer than five in the entire program.
Due tothe manner in which the vowels are handled (?2.1), multiple forms are usually generated, withdifferent theme vowels.
Although somewhatinconvenient, the correct form can easily befound with the help of a dictionary.
To generatea finite form using the low-level function, onecalls the program with variables bound to thethree radicals and the type, leaving the verbstring unbound.
?- verb(p,r,s,['G', 'Preterite', 3, c,s],Plnf).
(Figure 3.
Generating a finite form, returned by the variablePlnf).In this case, the four values, ipras, ipris,iprus, ipres, are returned, but the correct iprus iseasily identified by the user.
Generation is mostcommonly not called at this low level, butthrough the makeverb wrapper function.
Thistakes the three radicals for the verb and a listrepresenting the type, and creates both a PlNFrepresentation of the verb and a normalizedstring version.
As this function was tuned towork with the Web interface, characters such as3Due to the difficulty of typesetting the macronusually used in representing the long vowel, theumlaut, (?
), will be used instead.long vowels and the letter ?shin?
are output asHTML codes.The low-level generation, however, is quiteuseful for its ability to take wildcard commands,which currently cannot be input using the Webinterface.
?- verb(p,r,s,['G', _, 3, c,s],String).
(Figure 4.
Generate any G-stem in the third, commonsingular form.
The _ represents a non-binding variable.
)3 InterfaceThe user interface is a HTML form which thenpasses its input to a cgi-bin script which formatsthem properly for a Java wrapper to the Prologinterpreter.3.1 HTML User InterfaceThe user interface consists of two HTML forms,one for parsing and one for generation, whichare on the same page4.
Both are quite simple,with the parser presenting the user with a textinput area for the finite verb.
The generatorpresents the user with a text area for inputtingthe stem, and selectors for the stem, tense andperson.The forms submit their data to a smallUNIX shell script which formats them asarguments and passes them to the java parsingengine on the back-end processor.
Due to thefact that parsing, especially with wildcardexpansion, is computationally intensive, andProlog is an interpreted language and thereforesomewhat slow, the web-server, a PII-266system, passes the actual work off to a backend,a dual Athlon 1900+ system.
Computation timeis indicated at the bottom of the page returnedby the parser; it can process approximately tenforms per second.3.2 Java WrappersThe actual execution of the parsing from theweb forms is done by a pair of java classeswhich interface between the shell script and theProlog parser.
Some code was needed tointerpret the variables returned by the forms, andalthough Prolog code exists for this purpose, itwas complex, and Java code to both interface4The parser/generator, at its present state is athttp://wiglaf.cs-i.brandeis.edu/akkadian .with the script and the Prolog was readilyavailable, making its selection easy.
There aretwo Java classes, parseAkk and akkadian.The akkadian class does all of the work ofinterfacing with the Prolog, using the JPL5system and returning the HTML formattedanswers or error messages, while theparseAkk class does the reformatting of thecgi-bin variables into useful Java types6.
Theakkadian class can be used as a command-lineprogram for testing and quick parsing, but as itreturnes partial HTML, this use is no longersupported.4 State of the programThe program is a work in progress, but this isthe state as of April, 2002.4.1 State and flow diagramIn the state diagram, the background colorrepresents the code which is in the mainprogram  file (akk.pl) while the lighter blocksare the  subordinate stem files (dstam.pl,nstem.pl and gstem.pl).
Areas which are dashedare incomplete work in progress, and those withnotes are incomplete pending more research toderive the forms.The arrows in the flow diagram seemmisleading, but every one of the verb rule-setscan have a suffix, so the joining of paths fromthe two different files is not incorrect.The code can currently parse and generatebased on all of the strong and singly-weak tri-radical G, D and N stems, with and withoutsuffixes.
Due to disagreements amonggrammarians, the second-weak D stem is parsedand generated correctly, but does not accept allof the grammatical variations given in thevarious grammars.
When there is disagreement,the weight is given to Huehnergard?s Grammar.5http://sourceforge.net/projects/jpl/, A Java interfaceto Prolog, it currently only supports the SWI prologas the imbedded interpreter.6Code adapted from Hall?s Guide to CGIProgramming in Java.
(Figure 5.
The current flow of the program.
Arrowsrepresent the paths that the parser can take, in some casesindicating how rules are reused.
)4.2 ExamplesBrief examples of the program parsing andgenerating finite verb forms.
The is takenverbatim from the web interface.
The examplesfor the G stem (Figures 6 and 7) are from thethird weak infinitive Qab?
(to speak), and are asconjugated in the Codex Hammurabi[Richardson, 2000]:Stem q-b-@Parse G Precative ThirdWeak 3 c sNormalized form liqbi(Figure 6.
Parsing liqbi: Third common singular GPrecative[RICH, 126])Stem q-b-@Parse G Durative ThirdWeak 3 m pNormalized form iqabbuuuma(Figure 7.
Parsing iqabb?-ma: Third masculine plural  GDurative[RICH, 44], showing successful avoidance of the?ma suffix)Stem n-d-@Parse G Durative Third Weak3 m p Accusative 3fsNormalized form inadduuu$i(Figure 8.
Parsing innadd?$i: third weak G-durative, thirdmasculine plural with a third feminine singular accusativeending [RICH, 74].
)Stem m-l-@Parse D Preterite ThirdWeak 2 m s Ventive 2f sNormalized form tumallinikkimStem m-l-@Pare D Preterite ThirdWeak 2 f s Ventive 2f sNormalized form tumalliiinikkimStem m-l-@Parse D Durative Third Weak2 f s Ventive 2 f sNormalized form tumalliiinikkim(Figure 9.
Parsing tumalli*nikkim, showing vowelwildcards.
It parses into a third weak D-preterite, secondmasculine singular with a short ?i?
Third Weak D-durativeor D-preterite second feminine singular, with a double-long??
?, all with second feminine singular ventive ending.
Thesystem took 0.473 seconds to parse all the forms.
)An important note to figure 9, a form inAkkadian can arise from two convergent streamsof conjugation, and in this case the verb formtumall?nimakkim  can be either preterite ordurative.5 Conclusion and future workThe idea behind this research was not tosimulate the evolution of Akkadian, eitherhistorically as is done in comparative Semiticstudies, or to use some sort of theoretical, two-stage morphological rules as in [Kataja, 1988].Rather the goal was to create a system whichcould be used by researchers and students tohelp in understanding Akkadian texts.
Thecomplexities and many weak variants of theverb stems prevent the two-stage rules from everyielding a useful parser, and there are manyunneeded complexities in the historicalevolution.
This system as it evolved is, perhaps,needlessly intricate, but it works quickly andwell and adding new verb stems can be done inabout 8 hours of work.Work continues on the parser, in teachingAssyriologists to use it in their daily work, inchecking for errors in the rules, and in addingmore verbal forms.
Currently the effort isdirected to add the $-stem, the last of the simplestems, to the parser and teach members of theDepartment of Near Eastern and Judaic Studiesat Brandeis University to allow them to makeuse of the program.
Future plans begin withwork to add wildcards to the generation part ofthe web interface, to allow the generation of, forinstance, all G preterite forms.
This would,among other thing, aid in testing the accuracy ofthe generated forms, and by extension, theparser itself.
They also include adding some ofthe more common derived stems, from each ofthe four simple stems there are three derivedstems, a ?t?, an ?n?
and a ?tn?, for example, the Gyields the Gt, Gn and Gtn.
Suffix generationneeds to be added to the Web interface andalong with that some assimilation rules shouldbe added.
In the language, if a finite form endingwith a semi-weak is followed by a suffixbeginning with a Shin, the weak assimilates, forexample ?m$?
becomes ?$$?.6 AcknowledgementsThe author would like to thank Professor JamesPustejovsky for his assistance and guidance,Professor Jacques Cohen for his advice onProlog and Professors David Wright, TzviAbusch and Dr. Kathryn Kravitz of theDepartment of Near Eastern and Judaic Studiesat Brandeis University for their assistance withAkkadian grammar.ReferencesBuccellati, Giorgio.
A Structural Grammar ofBabylonian.
Weisbaden: Harrassowitz Verlag.1996.Hall, Marty Guide to CGI Programming inJava.
http://www.apl.jhu.edu/~hall/java/CGI-with-Java.html.
1998Huehnergard, John.
A Grammar of Akkadian.Atlanta, Georgia: Scholars Press.
1997.Kataja , Laura and K. Koskenniemi.
1988).
?Finite-state description of Semitic morphology:a case study in Ancient Akkadian.?
Proceedingsof the International Conference onComputational Linguistics (COLING88), pages313--315.Miller, Douglas B An Akkadian Handbook.Winona Lake, Ind.
Eisenbrauns, 1996.Richardson, M. E. J. H a m m u r a b i ?
sLaws:Text, Translation and Glossary.
Sheffield,England: Sheffield Academic Press.
2000.Von Soden, Wolfram and Werner R. Meyer.Grundriss der Akkadischen Grammatik.
Rome :Editrice Pontificio Istituto Biblico.
1995.
