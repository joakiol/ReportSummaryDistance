The Formal and Processing Models of CLGLuis DAMASNelma MOREIRAUniversity of Porto, Campo Alegre 823P-4000 Portoluis@nccup.ctt.ptGiovanni B. VARILECECJean Monnet Bldg.
B4fl)01L-2920 Luxembourgnino@eurokom.ieAbst rac t :  We present the formal?
processing model of CLG, a logic grammarformalism based on complex constraintresolution.
In particular, we show how tomonotonically extend terms and their unificationto constrained terms and their resolution.
Thesimple CLG constraint rewrite scheme ispresented and its consequence for CLG'smultiple delay model explained.Keywords :  Grammatical formalisms,Complex constraint resolution.IntroductionCLG is a family of grammar formalismsbased on complex constraint resolution designed,implemented and tested over the last three years.CLG grammars consist of the description ofglobal and local constraints of linguistic objectsas described in \[1\] and \[2\].For the more recent members of the CLGfamily, global constraints consist of sortdeclarations ~md the definition of relation betweensorts, while local constraints consist of partiallexical and phrasal descriptions.
The sortsdefinable in CLG are closed, in a way akin to theones used by UCG 13\].
Relations over sortsrepresent the statement of linguistic principles inthe spirit of HPSG \[4\].The constraint language is a classical firstorder language with the usual unary and binarylogical connectives, i.e.
negation (-), conjunction(&), disjunction (I), material implication (---)),equivalence (,-)) and a restricted form ofquanti f icat ion ('7' and Zl) over finitelyinstantiatable domains.
The interpretation f these?onneclives in CLG is strictly classical as inSmolka's FL 16\] and Johnson's AVL \[5\], unlikethe intuitionistic interpretation of negation ofMoshier and Rounds \[7\].
A more detaileddescription of CLG including its denotationalsemantics can be found in 121.In this paper we present the tormal processingmodel of CLG, which has been influenced by theConstraint Logic Programming paradigm 18\] 191.We show in what way it extends pure unilicationbased formalisms and how it achieves a soundimplementation of classically interpreted firstorder logic while maintaining practicalcomputational behaviour by resorting to a simpleset of constraint rewrite rules and a lazyevaluation model for constraints satisfaction thusavoiding the problem mentioned in I10\]concerning the non-monotonic properties ofnegation and implication intcrpretcd in theHerbrand universe.The paper is organized as follows: in the firstpart we show how we extend term unification toaccommodate complex constraint resolution.
Wethen explain what rewrites are involved in CLGconstraint resolution, proceeding to show whatthe benefits of the delayed evaluation model ofCLG are.
We conclude by discussing some of theissues involved in our approach and compare it toother approaches based on standard first orderlogics.From Unification to ConstraintSolvingWe will first show how to extend a unilicationbased parsing algorithm for a grammar formalismbased on an equational theory, to an algorithm fora formalism with complex constraints attached torules.Assume a countable set V of variables x, y,z, ... and a countable set F of function symbolsf, g, h .
.
.
.
each one equipped with an arityexpressed as W. Let T he the term algebra over Fand V, and TO be the corresponding set ofground terms.- 173  -Assume lurthermorc that rules are of thc form:t ----> tl ...tnfor t ,  tl ..... tn are in Tand that the parsing algorithm relies solely on theunification algorithm for its operation, applying itto terms andeither computing a unifier of thoseterms or failing.Associating with a term t its usual denotationI I tB={St  E TO}(where S denotes a substitution of terms forvariables) the unifier t of two terms t '  and t"has tile following important propertyI\[ t \]1 = \[I t'\]l n Ht"\]lNext we introduce constraints over terms inT.
For the moment we will assume thatconstraints c include at least atomic equalityconstraints between terms and formulas builtfrom the atomic constraints using the standardlogic operators, namely disjunction, conjunctionand negation, and that a notion of validity can bedefined for closed formulas (see however \[2\] foran extended constraint language).We will extend terms to constrained terms t:c,where c is a constraint involving only variablesoccurring in t, and takeIlt:cll ={St  ~W0 I I - -Sc}as its denotation.Now, given constrained terms t:c, t':c' andt":c" we say that t:c is a unifier oft':c' and t":c"ifflit :c \]l = \[\[t':c'\]ln I\[t":c"\]\].It is easy to see that there is at least onealgorithm which given two constrained termseither fails, if they do not admit a unifier, or elsereturns one unifier of the given terms.
As a matterof fact it is enough to apply the unificationalgorithm to t' and t" to obtain an unifyingsubstitution S and to return S(t':c'&c").We can then annotate the rules of our formalismwith constraints and use any algorithm forcomputing the unifier of the constrained terms toobtain a new parsing algorithm for the extendedtormalism.
It is interesting to note that, if weused the trivial algorithm described above forcomputing the unifier of constrained terms, wewould obtain exactly the same terms as in theequational case but annotated with theconjunction of all the constraints attached to theinstances of the rules involved in the derivation.One of the obvious drawbacks of using such astrategy for computing unifiers is that there is noguarantee that the denotation of S(t':c'&c") isnot empty since S(c'&c") may be unsatisfiable.We will now give two properties of unifierswhich can be used to derive more interestingalgorithms.Assume t:c is an unifier of t':c' and t":c" andc is logically equivalent to d, then t:d is also aunifier.
Similarly if, for some variable x andterm r, we can derive x=r from c, then \[r/x\](t:c)is also a unifier for t':c' and t":c", where \[r/xldenotes ubstitution of r for x.It is obvious that by using an algorithmsimilar to the one used by Jonhson 151 forreducing the constraint c to normal form, it ispossible to find all the equalities of the form x=rwhich can be derived from c, and also decide if cis satisfiable.
This strategy, however, suffersfrom the inherent NP hardness, and, for practicalimplementations we prefer to use, at mostunification steps, an incomplete algorithmreserving the complete algorithm for specialpoints in the computation process which includenecessarily the final step.Rewriting and DelayingConstraintsIn this section we present a slightly simplifiedversion of the constraint rewriting system whichis at the core of the CLG model.
As will beapparent from these rules they attempt a partialrewrite to conjunctive rather than to the morecommon disjunctive normal form.
Some of thereasons for this choice will be explained below.Another point worthwhile mentioning here isthat linguistic descriptions and l inguist icrepresentations are pairs consisting of a partialequational description of an object andconstraints (cf.
\[2\]) in contrast o \[12,14\] whereconstraints are kept within linguistic objects.174 -Thc  CLG const ra int  language inc ludesexpress ions  invo lv ing  paths wh ich  a l low, 'eference to a specif ic argument  o f  a complexterm in order  to avoid the need for introducingexistential quanti f iers and extraneous variableswhen spec i fy ing constraints on arguments  o fterms.We define paths p, values v and constraints cas fol lows (,q~antification is omitted Ibr reasonsof  simplicity):p ::= <empty>p.
tn..~:iV :~= tt.p_Lc ::= t .p.
f  nV = V-'-Cc&cc I cIn the above def init ions ni denotes the i -thprojection while the superscript in I n indicates thearity o f  f as before.
As an example,  if t denotesf (a,g (c,d))the fol lowing constraints are satisfied:t.f 2 t.l'2.rc2.g 2t.f2.rq = a t.12.rt2.g2.r(:2 = dWe can now state the CLG rewriting rules forvalues:Rewriting Valuesf (.t I ..... tn ).Pa..ni.p --+ ti.
pf (tl ..... tn).gk' .rt i  --+ J_ i f t  n?gkand for  const ra ints  (keep ing  in mind thatimplication and equiwdence are just shorthands):Rewriting Constraintslrue & c Cfalse I cN false --+-true --+true I c --~false & c --+~(c Ic ' )_l_,f kf (t I ..... tn ).fng(tl  ..... tn).f k "+v= v' -~ falsev = v' --+ trueCCt ruefalsetruefalse~C & ~C'falsetruefalse if f k ~e gnif either v or v' is _1_if v and v' are the same valuev = v' --+ false if v and v' are atomic and v~v'f01  ..... tn )=f (u~ ..... un)t l=Ul  & ... & tn=Unf ( t l  ..... tn )  =g(u l  ..... Un) ~ falseWe wil l  use set notat ion  to denote  aconjunct ion o f  the constraints in the set.
Usingthis notation we can state the fo l lowing rules forrewriting constrained terms:Rewriting Constrained Termst :{ .... false .... } --+ FA ILt :{  .... true .... } ---) t :{ ....... }t :{  .... e l&C2 .... } ---4 t :{ .... C l ,C2 .
.
.
}t :{ .... x.p - t',...} ---) \[p(t') / X \] t:{ ....... }t :  { .... x .p=y.q  .... }\ [p (z ) /x  ,q  ( z ) /y  \] t :{ ....... }t :{ .... x.p.fk .... }\[P ( f ( z l  ..... zk)) / x I t :{ ....... }where z ,Zl ..... Zn are new var iables and p(...)which can be defined is by:<empty> (x) = xfn.nl .p (x )  = fn (z I .....
zi-?, p (x) ..... Zn )returns a new gener ic  term t such that theconstraint t.p = x is satisfied.175 -The above is a slight simplification:constraints associated with terms come in fact inpairs, the second element of which is omittedhere for the sake of simplicity and containsessentially negated literals and inequations.
Thereason for this is that we want to give the systema certain inferencing capability without having toresort to expensive xhaustive pairwise searchthrough the constraint set.It should also be mentioned that after oneconstraint in a set is rewritten it will only berewritten again if some variable occurring in it isinstantiated.Complet ing RewritesAs "already mentioned the set of rewrite rulesgiven above is not complete in the sense that it isnot sufficient to reduce all constraints toconjunctive normal form, although CLG has acomplete set of rewrite rules available to be usedwhenever needed.
At least at the end ofprocessing, representations are reduced toconjunctive form.Sets of rules for rewriting first order logicformulae to conjunctive normal form can befound in the literature \[1!\].
The specific set ofcomplete rewrites currently used in CLG includese.g.
:(1) c l ( c '&c" ) - -~  (c lc ' )&(c lc" )(2) -(c&c') ~clNc'(3) (clc')&(-clc")----~ c' lc"There are various reasons for not using themat every unification step.
The application of thedistributive law (1) is avoided since it contributesto the P-Space completeness of the reduction tonormal form: in general we avoid using ruleswhich are input length increasing.As for the de Morgan law (2), we do not useit because by itself it does neither help to detectfailure nor does it contribute to add positiveequational information.Lastly, the cut rule (3) is just too expensive tobe used in a systematic way.Our current experience shows that the numberof constraints which need the complete set ofrewrite rules to be solved is usually nil orextremely small even for non-trivial grammars\[11.Discuss ionThe three main characteristics of the CLGprocessing model are the use of constrained termsto represent partial descriptions, the lack ofsystematic rewriting of constraints to normalform and the lazy evaluation of complexconstraints.The choice of constrained terms instead of themore common sets of constraints i motivated bymethodological rather than theoretical reasons.The two representations are logically equivalentbut CLG's commitment to naturally extendunification to constraint resolution makes thelatter better suited if, as in the present case, wewant to use existing algorithms where they haveshown successful.The alternative, to develop new algorithmsand data structures for complex constraintresolution (including equation solving)\[12,13,14\] is less attractive.
It is preferable tosplit the problem into its well understoodequational subpart and the more speculativecomplex constraint resolution.It is also worthwhile noting that termsconstitute a very compact representation forsetsof equations and naturally suggest he use ofconjunctive forms, another distinguishingcharacteristics of  CLG.
Furthermore, conjunctiveforms constitute a compact way of representingpartial objects in that they localise ambiguity.We already have discussed the reasons foravoiding systematic rewrites of constraints tonormal form.
This in no way affects thesoundness of the system although it may preventearly failure.
Even so it is computationally moreeffective than resorting to normal form reductionNote that CLG is not a priori committed tocheck whether newly added constraints will leadto inconsistency.
However it is often possible tocheck such inconsistencies at little cost withoutfull reduction to normal form.
A solvability checkis only performed for a limited number of easilytestable situations, mainly for the case of negatedliterals, of which a separate list is kept asmentioned above.- 176  -It has to be pointed out though, that in orderto guarantee the global completeness o f  therewrites, as opposed to potential localincompleteness, CLG completes the rewrite tonormalized form at the latest at the very end ofprocessing.
Nevertheless this decision is not acommitment.
Rather, a rewrite to normal formcould be carried out with the frequency deemednecessary.
Our present experience howevershows that a full rewrite at the end is sufficient.Finally, the way  constraint resolution isdelayed is a dircct consequence of the rewritesavailable at run-time.
Every constraint whichcannot at a given point in time be reduced withone of the above rules is just left untouched inthat cycle of constraint evaluation, awaiting forfurther instantiations to make it a candidate forreduction.A last note on some consequences theseproperties have for the user: as with othercomplex constraint based systems, in CLG thereis no guarantee that all constraints will always besolved, not even after the last rewrite to normallotto.
As a result (a) the system does not failbecause all constraints have not been resolvedand (b) the intermediate and final data structureare also partial descriptions, being potentiallyannotated with unresolved constraints, anddenote not a single, but a class of representations.The first consequence is clearly a desirableproperty, for it is unreasonable to think thatgrammatical descriptions will ever be complete tothe point where all and only the constraints whichare needed will be expressed in a grammar and alland only the infon~ation which is needed tosatisl'y these constraints will be available at theappropriate moment.As for the second consequence, We havefound unresolved constraints to be the bestpossible source of information about the state ofthe computation and the incompleteness ofgrammatical description.Relation to Other WorkAlthough in this paper we have presented aspecific (subset ol) constraint language and aspecific incomplete set of rewrite rules, neither isintegral part of CLG's theoretical framework.In fact the basic ideas behind the CLGprocessing model can be carried over to otherframeworks, uch as the feature logic of Smolka16,15t, by replacing the unification of terms withthe unification of the set of equational constraintsand by either edefining the constraint language ina suitable way (e.g.
redefining the notion of path)or else by translating the non-atomic formulae ofthe feature logic.Finally, note that the processing modeldescribed in this paper can, and eventuallyshould, be complemented with techniques fromconstraint logic programming \[16J to handlecases such as constraints on finite domainvariables where the completeness of theconstraint handling is computalionally tractable.ConclusionsWe have shown how, starting from a purclyunification based framework, it is possible toextend its expressive power by introducing aconstraint language for restricting the ways inwhich partial objects can be instantiated, and haveprovided a gcneral strategy for processing in theextended framework.We have also prcscntcd and justified the useof partial rewrite rulcs which, whilc maintainingthe essential  formal propert ies,  arccomputational ly effect ive with availabletechnologies.We justified the use of conjunctive forms as abetter option than their disjunctive counterparts aa means for providing amongst other things acompact representation f partial objects.Finally we have emphasized the importance oflazy evaluation of complex constraints in order toensure computational tractability.AcknowledgementThe work reported herein has been carried outwithin the framework of the Eurotra R&Dprogramme f inanced by the EuropeanCommunities.
The opinions exposed are the soleresponsibility of the authors.References\[1\] Damas, Luis and Giovanni B. Varile, 1989.
"CLG: A grammar formalism based onconstraint resolution", in EPIA '89, E.M.Morgado and J.P. Martins (eds.
), Lecture177 -Notes in Artificial Intelligence 390, Springer,Berlin.~2\] Balari, Sergio, Luis Damas, Nelma Moreiraand Giovanni B. Varile, 1990.
"CLG:Constraint Logic Grammars", Proceedings ofthe 13th International Conference onComputational Linguistics, H.
Karlgren(ed.
), Helsinki.\[3\] Moens, M., J. Calder, E. Klein, M.!
Reapeand H. Zeevat, 1989.
"Expressinggeneralizations in unification-basedformalisms", in Proceedings of the fourthconference of the European Chapter of theACL, ACL.14\] Pollard, Carl J. and Ivan A.
Sag, 1987.
"Information-Based Syntax and Semantics 1:Fundamentals", Center for the Study ofLanguage and Information, Stanford, CA.\[5\] Johnson, Mark, 1988.
"Attribute-Value Logicand the Theory of Grammar", Center for theStudy of Language and Information,Stanford, CA.161 Smolka, G. 1989.
"Feature Constraint Logicsfor Unification Grammars", LILOG Report93, IWBS, IBM Deutschland.\[7\] Moshier, M. Drew and William C. Rounds,1986.
"A logic for partially specified datastructures", manuscript, ElectricalEngineering and Computer ScienceDepartment, University of Michigan, AnnArbor, MI.\[81 Jaffar, J., J-L. Lassez, 1988.
"Fromunification to constraints", in  LogicProgramming 1987, G. Goos & J.
Hartmanis(eds.
), Lecture Notes in Computer Science315, Springer, Berlin.\[91 Cohen, Jacques, 1990.
"Constraint LogicProgramming Languages", in CACM, July1990,volume 33, No.
7.\[10\] Doerre, Jochen, Andreas Eisele, 1990.
"Feature Logic with Disjunctive Unification",Proceedings of the i l3th InternationalConference on Computational Linguistics, H.Karlgren (ed.
), Helsinki.\[11\] Hilbert, D., P. Bernays, 1934 & 1968.
"Grundlagen der Mathematik I.
& II",Springer, Berlin.\[12\] Carpenter, B., C. Pollard, A. Franz (toappear).
"The Specification andImplementation of Constraint-BasedUnfication Grammars".\[13\] Kasper, Robert, 1987, "A UnificationMethod for Disjunctive Feature Description",Proceedings of the 25th Annual Meeting ofthe ACL, ACL.\[14\] Carpenter, Bob, 1990.
"The Logic of TypedFeature Structures: Inheritance, (In)equationsand Extensionality", unpublished Ms.\[151 Smolka, Gert, 1988.
"A Feature Logic withSubsorts", LILOG Report 33, IWBS, IBMDeutschland.\[16\] Van Hentenryck, P., M. Dincbas, 1986.
"Domains in Logic Programming", Proceedingsof the AAAI, Philadelphia, PA.178 -
