Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 423?433,Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational LinguisticsLarge-scale Semantic Parsing via Schema Matching and LexiconExtensionQingqing CaiTemple UniversityComputer and Information Sciencesqingqing.cai@temple.eduAlexander YatesTemple UniversityComputer and Information Sciencesyates@temple.eduAbstractSupervised training procedures for seman-tic parsers produce high-quality semanticparsers, but they have difficulty scalingto large databases because of the sheernumber of logical constants for whichthey must see labeled training data.
Wepresent a technique for developing seman-tic parsers for large databases based ona reduction to standard supervised train-ing algorithms, schema matching, and pat-tern learning.
Leveraging techniques fromeach of these areas, we develop a semanticparser for Freebase that is capable of pars-ing questions with an F1 that improves by0.42 over a purely-supervised learning al-gorithm.1 IntroductionSemantic parsing is the task of translating naturallanguage utterances to a formal meaning represen-tation language (Chen et al, 2010; Liang et al,2009; Clarke et al, 2010; Liang et al, 2011; Artziand Zettlemoyer, 2011).
There has been recent in-terest in producing such semantic parsers for large,heterogeneous databases like Freebase (Krishna-murthy and Mitchell, 2012; Cai and Yates, 2013)and Yago2 (Yahya et al, 2012), which has driventhe development of semi-supervised and distantly-supervised training methods for semantic parsing.Previous purely-supervised approaches have beenlimited to smaller domains and databases, such asthe GeoQuery database, in part because of the costof labeling enough samples to cover all of the log-ical constants involved in a domain.This paper investigates a reduction of the prob-lem of building a semantic parser to three stan-dard problems in semantics and machine learning:supervised training of a semantic parser, schemamatching, and pattern learning.
Figure 1 providesa visualization of our system architecture.
Weapply an existing supervised training algorithmfor semantic parsing to a labeled data set.
We(sentence, logical form) Training dataTest questionsFreebase Web Relations Extracted from WebSupervised Semantic Parser Learning MATCHERLEXTENDER Freebase PCCG Grammar and Lexicon (word, Freebase symbol) correspondencesHigh-Coverage Freebase PCCG Grammar and LexiconFigure 1: We reduce the task of learning a large-scale semantic parser to a combination of 1) astandard supervised algorithm for learning seman-tic parsers; 2) our MATCHER algorithm for find-ing correspondences between words and databasesymbols; and 3) our LEXTENDER algorithm forintegrating (word, database symbol) matches intoa semantic parsing lexicon.apply schema matching techniques to the prob-lem of finding correspondences between Englishwords w and ontological symbols s. And we ap-ply pattern learning techniques to incorporate new(w, s) pairs into the lexicon of the trained seman-tic parser.This reduction allows us to apply standard tech-niques from each problem area, which in com-bination provide a large improvement over thepurely-supervised approaches.
On a dataset of917 questions taken from 81 domains of the Free-base database, a standard learning algorithm forsemantic parsing yields a parser with an F1 of0.21, in large part because of the number of log-ical symbols that appear during testing but neverappear during training.
Our techniques can extendthis parser to new logical symbols through schemamatching, and yield a semantic parser with an F1of 0.63 on the same task.
On a more challengingtask where training and test data are divided so thatall logical constants in test are never observed dur-423ing training, our approach yields a semantic parserwith an F1 of 0.6, whereas the purely supervisedapproach cannot parse a single test question cor-rectly.
These results indicate that it is possible toautomatically extend semantic parsers to symbolsfor which little or no training data has been ob-served.The rest of this paper is organized as follows.The next section discusses related work.
Section 3describes our MATCHER algorithm for performingschema matching between a knowledge base andtext.
Section 4 explains how we use MATCHER?sschema matching to extend a standard semanticparser to logical symbols for which it has seen nolabeled training data.
Section 5 analyzes the per-formance of MATCHER and our semantic parser.Section 6 concludes.2 Previous WorkTwo existing systems translate between naturallanguage questions and database queries overlarge-scale databases.
Yahya et al (2012) re-port on a system for translating natural languagequeries to SPARQL queries over the Yago2 (Hof-fart et al, 2013) database.
Yago2 consists ofinformation extracted from Wikipedia, WordNet,and other resources using manually-defined ex-traction patterns.
The manual extraction patternspre-define a link between natural language termsand Yago2 relations.
Our techniques automatethe process of identifying matches between tex-tual phrases and database relation symbols, in or-der to scale up to databases with more relations,like Freebase.
A more minor difference betweenYahya et al?s work and ours is that their systemhandles SPARQL queries, which do not handle ag-gregation queries like argmax and count.
Werely on an existing semantic parsing technologyto learn the language that will translate into suchaggregation queries.
On the other hand, their testquestions involve more conjunctions and complexsemantics than ours.
Developing a dataset withmore complicated semantics in the queries is partof our ongoing efforts.Krishnamurthy and Mitchell (2012) also cre-ate a semantic parser for Freebase covering 77of Freebase?s over 2000 relations.
Like ourwork, their technique uses distant supervision todrive training over a collection of sentences gath-ered from the Web, and they do not require anymanually-labeled training data.
However, theirtechnique does require manual specification ofrules that construct CCG lexical entries from de-pendency parses.
In comparison, we fully auto-mate the process of constructing CCG lexical en-tries for the semantic parser by making it a pre-diction task.
We also leverage synonym-matchingtechniques for comparing relations extracted fromtext with Freebase relations.
Finally, we test ourresults on a dataset of 917 questions coveringover 600 Freebase relations, a more extensive testthan the 50 questions used by Krishnamurthy andMitchell.Numerous methods exist for comparing two re-lations based on their sets of tuples.
For instance,the DIRT system (Lin and Pantel, 2001) uses themutual information between the (X,Y ) argumentpairs for two binary relations to measure the sim-ilarity between them, and clusters relations ac-cordingly.
More recent examples of similar tech-niques include the Resolver system (Yates and Et-zioni, 2009) and Poon and Domingos?s USP sys-tem (Poon and Domingos, 2009).
Our techniquesfor comparing relations fit into this line of work,but they are novel in their application of thesetechniques to the task of comparing database re-lations and relations extracted from text.Schema matching (Rahm and Bernstein, 2001;Ehrig et al, 2004; Giunchiglia et al, 2005) is atask from the database and knowledge representa-tion community in which systems attempt to iden-tify a ?common schema?
that covers the relationsdefined in a set of databases or ontologies, and themapping between each individual database and thecommon schema.
Owing to the complexity of thegeneral case, researchers have resorted to definingstandard similarity metrics between relations andattributes, as well as machine learning algorithmsfor learning and predicting matches between rela-tions (Doan et al, 2004; Wick et al, 2008b; Wicket al, 2008a; Nottelmann and Straccia, 2007;Berlin and Motro, 2006).
These techniques con-sider only matches between relational databases,whereas we apply these ideas to matches betweenFreebase and extracted relations.
Schema match-ing in the database sense often considers com-plex matches between relations (Dhamanka et al,2004), whereas as our techniques are currently re-stricted to matches involving one database relationand one relation extracted from text.4243 Textual Schema Matching3.1 Problem FormulationThe textual schema matching task is to identifynatural language words and phrases that corre-spond with each relation and entity in a fixedschema for a relational database.
To formalize thistask, we first introduce some notation.A schema S = (E,R,C, I) consists of aset of entities E, a set of relations R, a set ofcategories C, and a set of instances I .
Categoriesare one-argument predicates (e.g., film(e)), andrelations are two- (or more-) argument predicates(e.g., directed by(e1, e2)).
Instances areknown tuples of entities that make a relationor category true, such as film(Titanic)or directed by(Titanic, JamesCameron).
For a given r ?
R (or c ?
C),IS(r) indicates the set of known instances of r inschema S (and likewise for IS(c)).
Examples ofsuch schemas include Freebase (Bollacker et al,2008) and Yago2 (Hoffart et al, 2013).
We say aschema is a textual schema if it has been extractedfrom free text, such as the Nell (Carlson et al,2010) and ReVerb (Fader et al, 2011) extracteddatabases.Given a textual schema T and a databaseschema D, the textual schema matching task is toidentify an alignment or matching M ?
RT ?RDsuch that (rT , rD) ?
M if and only if rT canbe used to refer to rD in normal language usage.The problem would be greatly simplified ifM were a 1-1 function, but in practice mostdatabase relations can be referred to in manyways by natural language users: for instance,film actor can be referenced by the Englishverbs ?played,?
?acted,?
and ?starred,?
alongwith morphological variants of them.
In addi-tion, many English verbs can refer to severaldifferent relations in Freebase: ?make?
can referto computer processor manufactureror distilled spirits producer, amongmany others.
Our MATCHER algorithm for textualschema matching handles this by producing aconfidence score for every possible (rT , rD) pair,which downstream applications can then use toreason about the possible alignments.Even worse than the ambiguities in alignment,some textual relations do not correspond withany database relation exactly, but instead theycorrespond with a projection of a relation, or ajoin between multiple relations, or another com-plex view of a database schema.
As a sim-ple example, ?actress?
corresponds to a subsetof the Freebase film actor relation that inter-sects with the set {x: gender(x, female)}.MATCHER can only determine that ?actress?aligns with film actor or not; it cannot pro-duce an alignment between ?actress?
and a join offilm actor and gender.
These more complexalignments are an important consideration for fu-ture work, but as our experiments will show, quiteuseful alignments can be produced without han-dling these more complex cases.3.2 Identifying candidate matchesMATCHER uses a generate-and-test architecturefor determining M .
It uses a Web search engineto issue queries for a database relation rD consist-ing of all the entities in a tuple t ?
ID(rD).
1000tuples for each rD are randomly chosen for issu-ing queries.
The system then retrieves matchingsnippets from the search engine results.
It usesthe top 10 results for each search engine query.
Itthen counts the frequency of each word type in theset of retrieved snippets for rD.
The top 500 non-stopword word types are chosen as candidates formatches with rD.
We denote the candidate set forrD as C(rD).MATCHER?s threshold of 500 candidates forC(rD) results in a maximum possible recall of justless than 0.8 for the alignments in our dataset, buteven if we double the threshold to 1000, the re-call improves only slightly to 0.82.
We thereforesettled on 500 as a point with an acceptable upperbound on recall, while also producing an accept-able number of candidate terms for further pro-cessing.3.3 Pattern-based match selectionThe candidate pool C(rD) of 500 word types issignificantly smaller than the set of all textual re-lations, but it is also extremely noisy.
The can-didates may include non-relation words, or otherfrequent but unrelated words.
They may also in-clude words that are highly related to rD, but notactually corresponding textual relations.
For in-stance, the candidate set for film director inFreebase includes words like ?directed,?
but alsowords like ?film,?
?movie,?
?written,?
?produced,?and ?starring.?
We use a series of filters based onsynonym-detection techniques to help select thetrue matching candidates from C(rD).425Pattern Condition Example1.
?rT in E?
rT ends with ?-ed?
and E hastype datetime or location?founded in 1989?2.
?rT by E?
rT ends with ?-ed?
?invented by Edison?3.
?rT such as E?
rT ends with ?-s?
?directors such as Tarantino?4.
?E is a(n) rT ?
all cases ?Paul Rudd is an actor?Table 1: Patterns used by MATCHER as evidence of a match between rD and rT .
E represents an entityrandomly selected from the tuples in ID(rD).The first type of evidence we consider foridentifying true matches from C(rD) consists ofpattern-matching.
Relation words that express rDwill often be found in complex grammatical con-structions, and often they will be separated fromtheir entity arguments by long-distance dependen-cies.
However, over a large corpus, one would ex-pect that in at least some cases, the relation wordwill appear in a simple, relatively-unambiguousgrammatical construction that connects rT withentities from rD.
For instance, entities e from therelationship automotive designer appear inthe pattern ?designed by e?
more than 100 timesas often as the next most-common patterns, ?con-sidered by e?
and ?worked by e.?MATCHER use searches over the Web to countthe number of instances where a candidate rT ap-pears in simple patterns that involve entities fromrD.
Greater counts for these patterns yield greaterevidence of a correct match between rD and rT .Table 1 provides a list of patterns that we consider.For each rD and each rT ?
C(rD), MATCHERrandomly selects 10 entities from rD?s tuples toinclude in its pattern queries.
Two of the patternsare targeted at past-tense verbs, and the other twopatterns at nominal relation words.MATCHER computes statistics similar to point-wise mutual information (PMI) (Turney, 2001) tomeasure how related rD and rT are, for each pat-tern p. Let c(p, rD, rT ) indicate the sum of all thecounts for a particular pattern p, database relation,and textual relation:fp(rT , rD) =c(p, rD, rT )?r?Dc(p, r?D, rT ) ?
?r?Tc(p, rD, r?T )For the sum over all r?D, we use all r?D in Freebasefor which rT was extracted as a candidate.One downside of the pattern-matching evidenceis the sheer number of queries it requires.
Freebasecurrently has over 2,000 relations.
For each rD,we have up to 500 candidate rT , up to 4 patterns,and up to 10 entities per pattern.
To cover all ofFreebase, MATCHER needs 2, 000?500?4?10 =40 million queries, or just over 1.25 years if itissues 1 query per second (we covered approxi-mately one-quarter of Freebase?s relations in ourexperiments).
Using more patterns and more en-tities per pattern are desirable for accumulatingmore evidence about candidate matches, but thereis a trade-off with the time required to issue thenecessary queries.3.4 Comparing database relations withextracted relationsOpen Information Extraction (Open IE) systems(Banko et al, 2007) can often provide a large set ofextracted tuples for a given rT , which MATCHERcan then use to make much more comprehensivecomparisons with the full tuple set for rD than thepattern-matching technique allows.MATCHER employs a form of PMI to computethe degree of relatedness between rD and rT .
Inits simplest form, MATCHER computes:PMI(rT , rD) =|ID(rD) ?
IT (rT )||ID(rD)| ?
|IT (rT )|(1)While this PMI statistic is already quite useful, wehave found that in practice there are many caseswhere an exact match between tuples in ID(rD)and tuples in IT (rT ) is too strict of a criterion.MATCHER uses a variety of approximate matchesto compute variations of this statistic.
Consideredas predictors for the true matches inM , these vari-ations of the PMI statistic have a lower precision,in that they are more likely to have high valuesfor incorrect matches.
However, they also have ahigher recall: that is, they will have a high valuefor correct candidates in C(rD) when the strictversion of PMI does not.
Table 2 lists all the vari-ations used by MATCHER.426Statistics for (rT , rD)s?
(rT , rD) =?tD?ID(rD)?tT?IT (rT )?
(tD, tT )|ID(rD)|?|IT (rT )|s??
(rT , rD) = s?
(rT ,rD)?r?Ds?
(r?D, rT )s??
(rT , rD) = |IT (rT )||ID(rD)|Table 2: MATCHER statistics: for each ?
func-tion for comparing two tuples (given in Table 3),MATCHER computes the statistics above to com-pare rD and rT .
The PMI statistic in Equation1 corresponds to s?
where ?
=strict match over?
=full tuples.?
(t1, t2) for comparing tuples t1, t2strict match:{1, if ?
(t1) = ??
(t2)0, otherwise.type match:????
?1, if ?kcat(?
(t1)k)= cat(??
(t2)k)0, otherwise.Table 3: MATCHER?s ?
functions for computingwhether two tuples are similar.
cat maps an entityto a category (or type) in the schema.
MATCHERhas a different ?
function for each possible com-bination of ?
and ??
functions, which are given inTable 4.MATCHER uses an API for the ReVerb OpenIE system1 (Fader et al, 2011) to collect I(rT ),for each rT .
The API for ReVerb allows for rela-tional queries in which some subset of the entitystrings, entity categories, and relation string arespecified.
The API returns all matching triples;types must match exactly, but relation or argumentstrings in the query will match any relation or ar-gument that contains the query string as a sub-string.
MATCHER queries ReVerb with three dif-ferent types of queries for each rT , specifying thetypes for both arguments, or just the type of thefirst argument, or just the second argument.
Typesfor arguments are taken from the types of argu-ments for a potentially matching rD in Freebase.To avoid overwhelming the ReVerb servers, forour experiments we limited MATCHER to queries1http://openie.cs.washington.edu/?
(t) for tuple t = (e1, .
.
.
, en)?iei (projection to one dimension)(e1, .
.
.
, en) (full tuple)??(?)(e?
(1), .
.
.
, e?
(n)) (permutation)Table 4: MATCHER?s ?
functions for projectingor permuting a tuple.
?
indicates a permutation ofthe indices.for the top 80 rT ?
C(rD), when they are rankedaccording to frequency during the candidate iden-tification process.3.5 Regression models for scoring candidatesPattern statistics, the ReVerb statistics from Ta-ble 2, and the count of rT during the candidateidentification step all provide evidence for correctmatches between rD and rT .
MATCHER uses a re-gression model to combine these various statisticsinto a score for (rT , rD).
The regression modelis a linear regression with least-squares parameterestimation; we experimented with support vectorregression models with non-linear kernels, withno significant improvements in accuracy.
Section5 explains the dataset we use to train this model.Unlike a classifier, MATCHER does not output anysingle matching M .
However, downstream appli-cations can easily convert MATCHER?s output intoa matchingM by, for instance, selecting the topKcandidate rT values for each rD, or by selecting all(rT , rD) pairs with a score over a chosen thresh-old.
Our experiments analyze MATCHER?s suc-cess by comparing its performance across a rangeof different values for the number of rT matchesfor each rD.4 Extending a Semantic Parser Using aSchema AlignmentAn alignment between textual relations anddatabase relations has many possible uses: for ex-ample, it might be used to allow queries over adatabase to be answered using additional infor-mation stored in an extracted relation store, orit might be used to deduce clusters of synony-mous relation words in English.
Here, we de-scribe an application in which we build a question-answering system for Freebase by extending astandard learning technique for semantic parsingwith schema alignment information.As a starting point, we used the UBL system427developed by Kwiatkowski et al (2010) to learna semantic parser based on probabilistic Com-binatory Categorial Grammar (PCCG).
Sourcecode for UBL is freely available.
Its authorsfound that it achieves results competitive with thestate-of-the-art on a variety of standard semanticparsing data sets, including Geo250 English (0.85F1).
Using a fixed CCG grammar and a procedurebased on unification in second-order logic, UBLlearns a lexicon ?
from the training data whichincludes entries like:Example Lexical EntriesNew York City ` NP : new yorkneighborhoods in `S\NP/NP : ?x?y.neighborhoods(x, y)Example CCG Grammar RulesX/Y : f Y : g ?
X : f(g)Y : g X\Y : f ?
X : f(g)Using ?, UBL selects a logical form zfor a sentence S by selecting the z with themost likely parse derivations y: h(S) =arg maxz?y p(y, z|x; ?,?).
The probabilisticmodel is a log-linear model with features for lex-ical entries used in the parse, as well as indi-cator features for relation-argument pairs in thelogical form, to capture selectional preferences.Inference (parsing) and parameter estimation aredriven by standard dynamic programming algo-rithms (Clark and Curran, 2007), while lexiconinduction is based on a novel search procedurethrough the space of possible higher-order logicunification operations that yield the desired logi-cal form for a training sentence.Our Freebase data covers 81 of the 86 core do-mains in Freebase, and 635 of its over 2000 re-lations, but we wish to develop a semantic parserthat can scale to all of Freebase.
UBL gets us partof the way there, by inducing a PCCG grammar, aswell as lexical entries for function words that mustbe handled in all domains.
It can also learn lexicalentries for relations rD that appear in the trainingdata.
However, UBL has no way to learn lexicalentries for the many valid (rT , rD) pairs that donot appear during training.We use MATCHER?s learned alignment to ex-tend the semantic parser that we get from UBLby automatically adding in lexical entries for Free-base relations.
Essentially, for each (rT , rD) fromMATCHER?s output, we wish to construct a lexi-cal entry that states that rT ?s semantics resembles?x?y.rD(x, y).
However, this simple process iscomplicated by the fact that the semantic parser re-quires two additional types of information for eachlexical entry: a syntactic category, and a weight.Furthermore, for many cases the appropriate se-mantics are significantly more complex than thispattern.To extend the learned semantic parser to a se-mantic parser for all of Freebase, we introduce aprediction task, which we call semantic lexicon ex-tension: given a matching M together with scoresfor each pair in M , predict the syntactic categorySyn, lambda-calculus semantics Sem, and weightW for a full lexical entry for each (rT , rD) ?
M .One advantage of the reduction approach to learn-ing a semantic parser is that we can automaticallyconstruct training examples for this prediction taskfrom the other components in the reduction.
Weuse the output lexical entries learned by UBL as(potentially noisy) examples of true lexical entriesfor (rT , rD) pairs where rT matches the word inone of UBL?s lexical entries, and rD forms partof the semantics in the same lexical entry.
For(rT , rD) pairs in M where rD occurs in UBL?slexical entries, but not paired with rT , we createdummy ?negative?
lexical entries with very lowweights, one for each possible syntactic categoryobserved in all lexical entries.
Note that in or-der to train LEXTENDER, we need the output ofMATCHER for the relations in UBL?s training data,as well as UBL?s output lexicon from the trainingdata.Our system for this prediction task, which wecall LEXTENDER (for Lexicon eXtender), factorsinto three components: P (Sem|rD, rT , score),P (Syn|Sem, rD, rT , score), andP (W |Syn, Sem, rD, rT , score).
This factoriza-tion is trivial in that it introduces no independenceassumptions, but it helps in designing modelsfor the task.
We set the event space for randomvariable Sem to be the set of all lambda calculusexpressions observed in UBL?s output lexicon,modulo the names of specific Freebase relations.For instance, if the lexicon includes two entrieswhose semantics are ?x?y .
film actor(x, y) and?x?y .
book author(x, y), the event space wouldinclude the single expression in which relationsfilm actor and book author were replaced by428a new variable: ?p?x?y.p(x, y).
The finalsemantics for a lexical entry is then constructedby substituting rD for p, or more formally, by afunction application Sem(rD).
The event spacefor Syn consists of all syntactic categories inUBL?s output lexicon, and W ranges over R.LEXTENDER?s model for Sem and Syn areNa?
?ve Bayes classifiers (NBC), with features forthe part-of-speech for rT (taken from a POS tag-ger), the suffix of rT , the number of arguments ofrD, and the argument types of rD.
For Syn, weadd a feature for the predicted value of Sem.
ForW , we use a linear regression model whose fea-tures are the score from MATCHER, the probabili-ties from the Syn and Sem NBC models, and theaverage weight of all lexical entries in UBL withmatching syntax and semantics.
Using the pre-dictions from these models, LEXTENDER extendsUBL?s learned lexicon with all possible lexical en-tries with their predicted weights, although typi-cally only a few lexical entries have high enoughweight to make a difference during parsing.
Prun-ing entries with low weights could improve thememory and time requirements for parsing, butthese were not an issue in our experiments, so wedid not investigate this further.5 ExperimentsWe conducted experiments to test the ability ofMATCHER and LEXTENDER to produce a se-mantic parser for Freebase.
We first analyzeMATCHER on the task of finding matches betweenFreebase relations and textual relations.
We thencompare the performance of the semantic parserlearned by UBL with its extension provided byLEXTENDER on a dataset of English questionsposed to Freebase.5.1 Experimental SetupFreebase (Bollacker et al, 2008) is a free,online, user-contributed, relational database(www.freebase.com) covering many differentdomains of knowledge.
The full schema andcontents are available for download.
The ?Free-base Commons?
subset of Freebase, which is ourfocus, consists of 86 domains, an average of 25relations per domain (total of 2134 relations),and 615,000 known instances per domain (53million instances total).
As a reference point,the GeoQuery database ?
which is a standardbenchmark database for semantic parsing ?Examples1.
What are the neighborhoods in NewYork City?
?x .
neighborhoods(new york, x)2.
How many countries use the rupee?count(x) .
countries used(rupee, x)3.
How many Peabody Award winners arethere?count(x) .
?y .
award honor(y) ?award winner(y, x) ?award(y, peabody award)Figure 2: Example questions with their logicalforms.
The logical forms make use of Freebasesymbols as logical constants, as well as a few ad-ditional symbols such as count and argmin, toallow for aggregation queries.contains a single domain (geography), 8 relations,and 880 total instances.Our dataset contains 917 questions (on aver-age, 6.3 words per question) and a meaning repre-sentation for each question written in a variant oflambda calculus2.
81 domains are represented inthe data set, and the lambda calculus forms contain635 distinct Freebase relations.
The most com-mon domains, film and business, each tookup no more than 6% of the overall dataset.
Sev-eral examples are listed in Fig.
2.
The ques-tions were provided by two native English speak-ers.
No restrictions were placed on the type ofquestions they should produce, except that theyshould produce questions for multiple domains.By inspection, a large majority of the questionsappear to be answerable from Freebase, althoughno instructions were given to restrict questionsto this sort.
We also created a dataset of align-ments from these annotated questions by creatingan alignment for each Freebase relation mentionedin the logical form for a question, paired with amanually-selected word from the question.5.2 Alignment TestsWe measured the precision and recall ofMATCHER?s output against the manually la-beled data.
Let M be the set of (rT , rD) matchesproduced by the system, and G the set of matchesin the gold-standard manual data.
We define2The data is available from the second author?s website.42900.10.20.30.40.50.60 0.2 0.4 0.6 0.8 1PrecisionRecallAlignment PredictionsMatcherExtractionsPatternFrequencyFigure 3: MATCHER?s Pattern features and Extrac-tions features complement one another, so that incombination they outperform either subset on itsown, especially at the high-recall end of the curve.precision and recall as:P = |M ?G||M | , R =|M ?G||G|Figure 3 shows a Precision-Recall (PR) curvefor MATCHER and three baselines: a ?Frequency?model that ranks candidate matches for rD by theirfrequency during the candidate identification step;a ?Pattern?
model that uses MATCHER?s linear re-gression model for ranking, but is restricted toonly the pattern-based features; and an ?Extrac-tions?
model that similarly restricts the rankingmodel to ReVerb features.
We have three folds inour data; the alignments for relation rD in one foldare predicted by models trained on the other twofolds.
Once all of the alignments in all three foldsare scored, we generate points on the PR curve byapplying a threshold to the model?s ranking, andtreating all alignments above the threshold as theset of predicted alignments.All regression models for learning alignmentsoutperform the Frequency ranking by a wide mar-gin.
The Pattern model outperforms the Extrac-tions model at the high-precision, low-recall endof the curve.
At the high-recall points, the Pat-tern model drops quickly in precision.
However,the combination of the two kinds of features inMATCHER yields improved precision at all levelsof recall.5.3 Semantic Parsing TestsWhile our alignment tests can tell us in relativeterms how well different models are performing,it is difficult to assess these models in absoluteterms, since alignments are not typical applica-tions that people care about in their own right.
Wenow compare our alignments on a semantic pars-ing task for Freebase.In a first semantic parsing experiment, we trainUBL, MATCHER, and LEXTENDER on a randomsample of 70% of the questions, and test themon the remaining 30%.
In a second test, we fo-cus on the hard case where all questions from thetest set contain logical constants that have neverbeen seen before during training.
We split thedata into 3 folds, making sure that no Freebase do-main has symbols appearing in questions in morethan one fold.
We then perform 3-fold cross-validation for all of our supervised models.
Wevaried the number of matches that the alignmentmodel (MATCHER, Pattern, Extractions, or Fre-quency) could make for each Freebase relation,and measured semantic parsing performance as afunction of the number of matches.Figure 4 shows the F1 scores for these se-mantic parsers, judged by exact match betweenthe top-scoring logical form from the parser andthe manually-produced logical form.
Exact-matchtests are overly-strict, in the sense that the sys-tem may be judged incorrect even when the log-ical form that is produced is logically equivalentto the correct logical form.
However, by inspec-tion such cases appear to be very rare in our data,and the exact-match criterion is often used in othersemantic parsing experimental settings.The semantic parsers produced byMATCHER+LEXTENDER and the other alignmenttechniques significantly outperform the baselinesemantic parser learned by UBL, which achievesan overall F1 of 0.21 on these questions in the70/30 split of the data, and an F1 of 0 in thecross-domain experiment.
Purely-supervisedapproaches to this data are severely limited, sincethey have almost no chance of correctly parsingquestions that refer to logical symbols that neverappeared during training.
However, MATCHERand LEXTENDER combine with UBL to producean effective semantic parser.
The best semanticparser we tested, which was produced by UBL,MATCHER, and LEXTENDER with 9 matches perFreebase relation, had a precision of 0.67 and arecall of 0.59 on the 70/30 split experiment.The difference in alignment performance be-tween MATCHER, Pattern, and Extractions carriesover to semantic parsing.
MATCHER drops in F1with more matches as additional matches tend tobe low-quality and low-probability, whereas Pat-43000.10.20.30.40.50.60.70 5 1 0 1 5 2 0 2 5 3 0F1 for exact matchof logical formsNumber of Matches per Freebase RelationSemantic Parsing (70/30 Split)MatcherPatternExtractionsFrequencyBaseline00.10.20.30.40.50.60.70 5 1 0 1 5 2 0 2 5 3 0F1 for exact matchof logical formsNumber of Matches per Freebase RelationSemantic Parsing (Cross -Domain)MatcherExtractionsPatternFrequencyFigure 4: Semantic parsers produced by UBL+MATCHER+LEXTENDER outperform the purely-supervised baseline semantic parser on a random 70/30 split of the data (left) by as much as0.42 in F1.
In the case of this split and in the case of a cross-domain experiment (right),UBL+MATCHER+LEXTENDER outperforms UBL+Pattern+LEXTENDER by as much as 0.06 in F1.tern and Extractions keep improving as more low-probability alignments are added.
Interestingly,the Extractions model begins to overtake the Pat-tern model in F1 at higher numbers of matches,and all three models trend toward convergence inF1 with increasing numbers of matches.
Neverthe-less, MATCHER clearly improves over both, andreaches a higher F1 than either Pattern or Extrac-tions using a small number of matches, which cor-responds to a smaller lexicon and a leaner model.To place these results in context, many differentsemantic parsers for databases like GeoQuery andATIS (including parsers produced by UBL) haveachieved F1 scores of 0.85 and higher.
However,in all such tests, the test questions refer to logi-cal constants that also appeared during training, al-lowing supervised techniques for learning seman-tic parsers to achieve strong accuracy.
As we haveargued, Freebase is large enough that is difficultto produce enough labeled training data to coverall of its logical constants.
An unsupervised se-mantic parser for GeoQuery has achieved an F1score of 0.66 (Goldwasser et al, 2011), impres-sive in its own right and slightly better than our F1score.
However, this parser was given questionswhich it knew a priori to contain words that re-fer to the logical constants in the database.
OurMATCHER and LEXTENDER systems address adifferent challenge: how to learn a semantic parserfor Freebase given the Web and a set of initial la-beled questions.6 ConclusionScaling semantic parsing to large databases re-quires an engineering effort to handle largedatasets, but also novel algorithms to extend se-mantic parsing models to testing examples thatlook significantly different from labeled trainingdata.
The MATCHER and LEXTENDER algo-rithms represent an initial investigation into suchtechniques, with early results indicating that se-mantic parsers can handle Freebase questions on alarge variety of domains with an F1 of 0.63.We hope that our techniques and datasets willspur further research into this area.
In particu-lar, more research is needed to handle more com-plex matches between database and textual rela-tions, and to handle more complex natural lan-guage queries.
As mentioned in section 3.1, wordslike ?actress?
cannot be addressed by the cur-rent methodology, since MATCHER assumes thata word maps to a single Freebase relation, butthe closest Freebase equivalent to the meaning of?actress?
involves the two relations film actorand gender.
Another limitation is that our cur-rent methodology focuses on finding matches fornouns and verbs.
Other important limitations ofthe current methodology include:?
the assumption that function words have nodomain-specific meaning, which prepositionsin particular can violate;?
low accuracy when there are few relevant re-sults among the set of extracted relations;?
and the restriction to a single database (Free-base) for finding answers.While significant challenges remain, the reductionof large-scale semantic parsing to a combinationof schema matching and supervised learning of-fers a new path toward building high-coverage se-mantic parsers.431ReferencesYoav Artzi and Luke Zettlemoyer.
2011.
Bootstrap-ping Semantic Parsers from Conversations.
In Pro-ceedings of the Conference on Empirical Methods inNatural Language Processing (EMNLP).M.
Banko, M. J. Cafarella, S. Soderland, M. Broad-head, and O. Etzioni.
2007.
Open information ex-traction from the web.
In IJCAI.Jacob Berlin and Amihai Motro.
2006.
Databaseschema matching using machine learning with fea-ture selection.
In Advanced Information SystemsEngineering.
Springer.Kurt Bollacker, Colin Evans, Praveen Paritosh, TimSturge, and Jamie Taylor.
2008.
Freebase: A col-laboratively created graph database for structuringhuman knowledge.
In Proceedings of the Interna-tional Conference on Management of Data (SIG-MOD), pages 1247?1250.Qingqing Cai and Alexander Yates.
2013.
SemanticParsing Freebase: Towards Open-Domain SemanticParsing.
In Second Joint Conference on Lexical andComputational Semantics.Andrew Carlson, Justin Betteridge, Bryan Kisiel, BurrSettles, Estevam R. Hruschka Jr., and Tom M.Mitchell.
2010.
Toward an Architecture for Never-Ending Language Learning.
In Proceedings of theTwenty-Fourth Conference on Artificial Intelligence(AAAI 2010).David L. Chen, Joohyun Kim, and Raymond J.Mooney.
2010.
Training a MultilingualSportscaster: Using Perceptual Context to LearnLanguage.
Journal of Artificial Intelligence Re-search, 37:397?435.Stephen Clark and James R. Curran.
2007.
Wide-coverage efficient statistical parsing with ccg andlog-linear models.
Computational Linguistics,33(4):493?552.J.
Clarke, D. Goldwasser, M. Chang, and D. Roth.2010.
Driving semantic parsing from the world?s re-sponse.
In Computational Natural Language Learn-ing (CoNLL).R.
Dhamanka, Y. Lee, A. Doan, A. Halevy, andP.
Domingos.
2004. iMAP: Discovering ComplexSemantic Matches between Database Schemas.
InSIGMOD.A.
Doan, J. Madhavan, P. Domingos, and A. Halevy.2004.
Ontology Matching: A Machine LearningApproach.
In S. Staab and R. Studer, editors, Hand-book on Ontologies in Information Systems, pages397?416.
Springer-Verlag.M.
Ehrig, P. Haase, N. Stojanovic, and M. Hefke.2004.
Similarity for ontologies-a comprehensiveframework.
In Workshop Enterprise Modelling andOntology: Ingredients for Interoperability, PAKM.Anthony Fader, Stephen Soderland, and Oren Etzioni.2011.
Identifying Relations for Open InformationExtraction.
In Conference on Empirical Methods inNatural Language Processing (EMNLP).Fausto Giunchiglia, Pavel Shvaiko, and MikalaiYatskevich.
2005.
Semantic schema matching.On the Move to Meaningful Internet Systems 2005:CoopIS, DOA, and ODBASE, pages 347?365.D.
Goldwasser, R. Reichart, J. Clarke, and D. Roth.2011.
Confidence driven unsupervised semanticparsing.
In Association for Computational Linguis-tics (ACL).Johannes Hoffart, Fabian M. Suchanek, KlausBerberich, and Gerhard Weikum.
2013.
YAGO2:A Spatially and Temporally Enhanced Knowl-edge Base from Wikipedia.
Artificial Intelligence,194:28?61, January.Jayant Krishnamurthy and Tom Mitchell.
2012.Weakly Supervised Training of Semantic Parsers.
InProceedings of the Conference on Empirical Meth-ods in Natural Language Processing (EMNLP).Tom Kwiatkowski, Luke Zettlemoyer, Sharon Goldwa-ter, and Mark Steedman.
2010.
Inducing Probabilis-tic CCG Grammars from Logical Form with Higher-order Unification.
In Proceedings of the Conferenceon Empirical Methods in Natural Language Pro-cessing (EMNLP).P.
Liang, M. I. Jordan, and D. Klein.
2009.
Learningsemantic correspondences with less supervision.
InAssociation for Computational Linguistics and In-ternational Joint Conference on Natural LanguageProcessing (ACL-IJCNLP).P.
Liang, M. I. Jordan, and D. Klein.
2011.
Learn-ing dependency-based compositional semantics.
InAssociation for Computational Linguistics (ACL).D.
Lin and P. Pantel.
2001.
DIRT ?
Discovery of In-ference Rules from Text.
In KDD.Henrik Nottelmann and Umberto Straccia.
2007.
In-formation retrieval and machine learning for proba-bilistic schema matching.
Information processing &management, 43(3):552?576.Hoifung Poon and Pedro Domingos.
2009.
Unsu-pervised semantic parsing.
In Proceedings of the2009 Conference on Empirical Methods in Natu-ral Language Processing, EMNLP ?09, pages 1?10,Stroudsburg, PA, USA.
Association for Computa-tional Linguistics.E.
Rahm and P.A.
Bernstein.
2001.
A survey of ap-proaches to automatic schema matching.
The VLDBJournal, 10:334?350.P.
D. Turney.
2001.
Mining the Web for Synonyms:PMI-IR versus LSA on TOEFL.
In Procs.
of theTwelfth European Conference on Machine Learning(ECML), pages 491?502, Freiburg, Germany.432M.
Wick, K. Rohanimanesh, A. McCallum, and A.H.Doan.
2008a.
A discriminative approach to ontol-ogy mapping.
In International Workshop on NewTrends in Information Integration (NTII) at VLDBWS.M.L.
Wick, K. Rohanimanesh, K. Schultz, and A. Mc-Callum.
2008b.
A unified approach for schemamatching, coreference and canonicalization.
In Pro-ceeding of the 14th ACM SIGKDD internationalconference on Knowledge discovery and data min-ing.Mohamed Yahya, Klaus Berberich, Shady Elbas-suoni, Maya Ramanath, Volker Tresp, and GerhardWeikum.
2012.
Natural Language Questions for theWeb of Data.
In Proceedings of the Conference onEmpirical Methods in Natural Language Processing(EMNLP).Alexander Yates and Oren Etzioni.
2009.
Unsuper-vised methods for determining object and relationsynonyms on the web.
Journal of Artificial Intelli-gence Research (JAIR), 34:255?296, March.433
