Multiple Defau l t  Inher i tance  in a Un i f i ca t ion -BasedGraham RussellJohn Carroll*Susan Warwick-ArmstrongISSCO, 54 route des Acacias,1227 Geneva, Switzerlandelu@dlvsun.unige.chLex iconAbstractA formalism is presented for lexical specification inunification-based grammars which exploits defeasi-ble multiple inheritance to express regularity, sub-regularity, and exceptions in classifying the prop-erties of words.
Such systems are in the generalcase intractable; the present proposal represents anattempt to reduce complexity while retaining suf-ficient expressive power for the task at hand.
Illus-trative examples are given of morphological analy-ses from English and German.1 In t roduct ionThe primary task of a computational lexicon is toassociate character strings representing word formswith information able to constrain the distributionof those word forms within a sentence.
1 The or-ganization of a lexicon requires the ability, on theone hand, to make general statements about classesof words, and, on the other, to express excep-tions to such statements affecting individual wordsand subclasses of words.
These considerationshave provoked interest in applying to the lexiconAI knowledge representation techniques involvingthe notions of inheritance and default.
2 The sys-*current address: Cambridge University Computer Lab-oratory, New Museums Site, Pembroke Street, CambridgeCB2 3QG, UK.OWe are indebted to Af-.al Ballim, Mark Johnson, andanonymous referees for valuable comments on this paper.t in the general case, the relation between forms and in-formation is many-to-many (rather than one-to-many as of-ten assumed) and this observation has influenced the choiceof facilities incorporated within the system.
See 3.2 belowfor an example of how distinct forms share identical mor-phosyntactic specifications.2See e.g.
Daelemaus and Gazdar eds.
(1990), and thereferences in Gazdar (1990).
The work of Hudson (1984)extends this general approach to sentence syntax.tem described here is part of the ELU s unificationgrammar development environment intended forresearch in machine translation, comprising parser,generator, transfer mechanism and lexical compo-nents.
The user language resembles that of PATR-II (Shieber, 1986), but provides a larger range ofdata types and more powerful means of stating re-lations between them.
Among the requirementsimposed by the context within which this systemis used are (i) the ability to both analyse and gen-erate complex word forms, (ii) full integration withexisting parts of the ELU environment, and (iii) theability to accommodate a relatively large numberof words.2 C lasses  and  Inher i tanceAn ELU lexicon consists of a number of 'classes',each of which is a structured collection of con-straint equations and macro calls encoding infor-mation common to a set of words, together withlinks to other more general 'superc\]asses'.
For ex-ample, if an 'intransitive' class is used to expressthe common syntactic properties hared by all in-transitive verbs, then particular instances of in-transitive verbs can be made to inherit this infor-mation by specifying the 'intransitive' class as oneof their superclasses - it then becomes unneces-saw to specify the relevant properties individuallyfor each such verb.
The lexicon may be thoughtof as a tangled hierarchy of classes linked by in-heritance paths, with, at the most specific level,lexicai classes and, at the most general, classes forwhich no superclasses have been defined, and whichtherefore inherit no information from elsewhere.S "Environnement Linguistique d'Unlfication" - see Esti-val (1990), and, for a description of the earlier UD systemon which E~u is based, Johnson and Rosner (1989).215Lexical entries are themselves classes, 4 and any in-formation they contain is standardly specific to anindividual word; lexical and non-lexical classes dif-fer in that analysis and generation take only theformer as entry points to the lexicon.Inheritance of a feature value from a superclassmay be overridden by a conflicting value for thatfeature in a more specific lass.
This means, for ex-ample, that it is possible to place in the class whichexpresses general properties of verbs an equationsuch as '<* aux> = no' (i.e.
"typical verbs are notauxiliaries"), while placing the contradictory spec-ification '<* aux> = yes'  in s subclass from whichonly anTiliaries inherit.
The ability to encode ex-ceptional properties of lexical items is extremelyattractive from the linguistic point of view; thelower the position in the hierarchy at which theproperty appears, the more exceptional it may beconsidered.A class definition consists of the compiler direc-tive '#Class'  (for a non-lexicai class) or '#Word'(for a lexical class), followed by the name of thatclass, a possibly empty list of direct superclasses,a possible empty 'main' or default equation set,and sere or more 'variant' equation sets.
The su-perclass declaration states from which classes thecurrent class inherits; if more than one such super-class is specified, their order is significant, morespecific classes appearing to the left of more gen-eral ones.
If the current class is one of the mostgeneral in the lexicon, it inherits no information,and its superclass list is empty.Following the superclass declaration are sere ormore equations representing default information,which we refer to as the 'main' equation set.
Thesemay be overridden by eontlleting information ina more specific class.
Each equation in a mainset functions as an independent constraint, in amsnner which will be clarified below.Variant equation sets, loosely speaking, corre-spend to alternatives at the same conceptual levelin the hiersrchy, and in msny cases reflect the tra-ditional ides of 'paradigm'.
Equations within avariant set are absolute constraints, in contrast othose in the main set; if they conflict with informs-tion in a more specific class, failure of unificationoccurs in the normal way.
Also, unlike the mainset, each variant set functions as a single, possiblycomplex, constraint (see section 2.2).
A feature4Thus  no dist inct ion is made between classes and  'in-stances' ,  as in e.g.
KL -ONE (Schmolse and  Lipkis, 1983)structure is created for each variant set that suc-cessfully unifies with the single structure arisingfrom the main set.
Each variant set is precededby the vertical bar ' \['.
The order of variant setswithin a class is not significant, although, if a mainset is employed, it must precede any variant sets.The following simplified example illustrates theform and interaction of class definitions.
In equs.tions, unification variables have initial capitals,and negation of constants is indicated by ' '.
'kk'is the string concatenation operator - an equationof the form X = Y kk Z unifies X nondeterministi-cally with the result of concatenating ?
and Z.#Word wa lk  ( In t rans i t i ve  Verb)<stem>= wa lk#Class  In t rans i t i ve  ()<sub?at> = \ [Sub J \ ]<$nbJ  ca t> =np#Class Verb ()<aOX> m no<cat> m VI<tense> = past<~onO = <stem> kk  edI=presont<form>= <steuO kk  si<aSr> = "s83<tense> - present<form> = <stem>The lexiesl class walk is declared as havingtwo direct superclasses, In t rans i t ive  and Verb;its main set contains just one equation, whichsets the value of the feature stem to be walk.In t rans i t ive  has no direct superclasses, and itsmain equation set assigns to the value of subcata list with one element, a feature structure inwhich the value of cat  is rip.
Neither walknor In t rans i t ive  has sny variant equation sets.Verb, by contrast, has three, in addition to twomain set equations.
The latter assign, by default,the values of cat  and aux.
The three variants ac-counted for by this example are the past tense verb,in which the value of form unifies with the resultof concatenatin 8 the value of stem with the string'ed', the third person singular form, in which thesuffix string is 's', and the form representing othercombinations of person and number in the presenttense; in the last case, the form value is simplyidentical to the stem value.
55We ignore for the moment  the quest ion of mor-phogrsphemic  effects in suf l lxst ion - see sect ion 3.3 below.2162.1 C lass  P recedenceIn an ELU lexicon, a class may inherit directly frommore than one superclass, thus permitting 'multi-ple inheritance' (Touretsky, 1986: 7ft.
), in contrastto 'simple inheritance' in which direct inheritanceis allowed from only one superclass at a time.
Themain advantage that multiple inheritance offersover simple inheritance is the ability to inherit sev-eral (orthogonal or complementary) sets of proper-ties from classes in more than one path through thehierarchy.
In the lexical context, it has often beenobserved that morphological nd syntactic proper-ties are essentially disjoint; the subeategorisationclass of a verb is not predictable from its conjuga-tion class, and vice versa, for example.
Multipleinheritance permits the two types of informationto be separated by isolating them in distinct sub-hierarchies.The question to be resolved in systems em-ploying multiple inheritance is that of precedence:which of several superclasses with conflicting prop-erties is to be inherited from?
ELU employs theclass precedence algorithm of the Common LispObject System (CLOS) to compute a total order-ing on the superclasses of a lexicsl class, s Theresulting 'class precedence list' (CPL) contains theclass itself and all of its superclasses, from mostspecific to most general, and forms the basis forthe defaulting behaviour of the lexicon.
As an ex-ample, consider the following lexicon:#Word It (B D) #Class B (C)ZClass C (Y) #Class D (E)#Class E (P) #Class F ()Here, the superclass declarations embody the or-derin 8 constraints A < B, A < D, B < D, B < C, C <F, D < E, and E < F; from these are derived a to-tal order assigning to the lexical class A the CPL(A ,B ,C ,D ,E ,F ) .2.2 Inher i tance  o f  P roper t iesA lexical class such as walk in the example abovecorresponds to a family offeature structures.
Here,as in most analyses, members of this family rep-resent morphosyntactically distinct realizations ofa single basic lexeme.
Consulting the lexicon in-volves determining membership of the set of fea-ture structures associated with a given lexical class;s See Steele (1990: 782ff.)
for details of the aIgorithm, andKeene (1989:118ff.)
for discussion.
In circumstances whereno such total ordering is possible, the system reports anerror.the precedence relation encoded in the CPL con-trols the order in which defeasible information isconsidered, each class in the CPL adding first de-fault and then non-default information to each FSproduced by the previous class.More formally, we define default eztension, su-perclass eztension, and global ez~e~sion asfollows: 7(1) The default eztension of a FS ~ with respectto a set of FSs ?
isif U ({~b} U ~) :f: _1_, and .1_ otherwise.
(2) The superclass ez~ension of a FS ~b with re-spect to a class c having a main equation setM and variant sets V l , .
.
.v ,  is the setI ~be J.
},where M s is the smallest set of FSs such thateach m E M describes ome m ~ E M s, ?~s isthe default extension of~b with respect o M e,and v~ is the feature structure described byvl.
We refer to this set as E(~b, c).
(3) The global eztensio~, of a lexlcvd class havingthe CPL (c l , .
.
.
c , )  is F~, where Fo = {T},andr ,>0= U{~ IVY, ~ r ,_ l ,  ?
= E(~, c,)}.With regard to (I), each of the FSs in W that canunify with ~b does so - those that cannot, becausethey conflict with information already present, areignored.
The condition requiring ~ to be unifiablewith the result of unifying the elements of ?
takesaccount of the potential order-sensitivity of the de-faulting operation - only those main sets havingthis property can be applied without regard to or-def.
If this condition is met then the applicationof defaults always succeeds, producing a featurestructure which, if no member of the default setis applicable, is identical to ~b.
This interpretationof default unification is essentially that of Bouma(1990).The superclass extension E(~, c) is formed byapplying to ~ any default equations in the main setof c, and then applying to the result each variantset in c; for variant sets Vl,.. .
v,,, the result of this7'A U B' here denotes the unification of A and B, 'T'denotes the most general, 'empty' FS, which unifies with allothers, and '_L' denotes the inconsistent FS, equated withfailure of unification.217second stage is the set of FSs {@1,...@~}, whereeach ~ is the result of successfully unifying ~b withsome different vj.To speak in procedural terms, the global exten-sion of a lexicai class L with the CPL C is com-puted as follows: T is the empty FS which is inputto C; each c~ in C yields as its superelass extensiona set of FSs, each member of which is input to theremainder of C, (c~+l, .
.
.c , ) .
The global exten-sion of L is then the yield of the most general classin its CPL - expressed in a slightly different way,the global extension of L is the result of applyingto T the CPL of L.It is possible to exert quite fine control over in-heritance; one property may override another whenassigned in a main equation set, but cause failurewhen assigned in a variant set.
Normally, variantsets are defined so as to be mutually exclusive; a FSthat unifies with more than one of the variant setsis in effect multiplied, s The inheritance systemsof Calder (1989) and Flickinger (1987) make useof lexical rules - the ELU lexicon does not providesuch devices, although some of their functionalitymay be reproduced by the variant set mechanism.The approach described here differs from someprevious proposals for default inheritance inunification-based lexicons in that the process ofbuilding FSs is monotonic - classes may add infor-mation to a FS, but are unable to remove or alterit.
Thus, given a CPL (c i , .
.
.
c . )
,  any FS F admit-ted by a class c~ subsumes every FS that can be cre-ated by applying to F the classes (c~ + I , .
.
.
c,~), mn.
Karttunen (1986) and Shieber (1986) describesystems in which FSs may be modified by defaultstatements in such a way that this property doesnot automatically hold.
These schemes permitdefault statements to override the effect of ear-lier statements, whereas default information in theELU lexicon may itself be overridden.We now turn to some examples illustrating ther61e of defeasible inheritance in the lexicon.3 Example Analyses3.1  German Separab le  VerbsTwo large classes of German verbs are the sep-arable and inseparable prefixed compound verbs.The former are of interest syntactically because,as their name suggests, the prefix is a boundSSee 3.2 below for a case where such multiple matchesare desirable.morpheme only in certain syntactic environments,namely when the verb is untensed or head of averb-final clause.
9 Members of both classes sharemorphological, but not necessarily syntactic, prop-erties of the verb which corresponds in form totheir stem.
The separable-prefix verb weglau/en('run away') and inseparable verlau/en ('elapse')are two such verbs, which the lexicon should beable to relate to their apparent stem lau/en ('run').Since word definitions are classes, they can beinherited from like any non-lexical class.
Thus thelexical classes ver lau fen  and weglaufen may in-herit from lanfen,  itself a lexical class: x?# Word woglau~on (we s lau~on)<s~ = weg laufen# Word vorlaufsn (vet laufsn)<S~ i vor la~en# Class we s ( separab le )<morph pro l ix> = wog# C lass  vet  (non_sopLTabls)<morph prefix> = vet# Word lau~en (verb)Base_stun= lauf<smu> = laufon# Class non_separab le  ()Prof lx = <morphprefix># Class sspazab lo  OlPref ix  = <morphprsfix><lyn  4~v> = no<sya in ,  l> = "tn,fIProflx = ' '<syn I nv> =yos.<syn ia~l> = "la.fI# ClassPre f ix  = <moxphpro f ix><synin~l> =~verb O<cat> m vPre f ix  = ' '<morph pref~x> =Pref ix &&<syn 4.e1> = inf<form> = P_be && onI<form> = P_bs  k& ?<syn inf l> = prss_Indic_s8_l9Within the syntactic analysis assumed here, the distri-but ion of verbs is controlled by a binary feature inv, whosevalue in these contexts is no.lea  number of simplifications have been made here;\]aufen is in reality a member of a subclass of the strongverbs, and the verb class itself has been truncated, so thatit accounts for only bare infinitive and first person singu-lar present tense indicative forms.
Past participle formationalso interacts with the presence of separable and inseparableprefixes.218The lexical classes weglaufen and ver lau fen  eachhave two immediate superclasses, containing in-formation connected with the prefix and stem.The classes weg and vet  set the value of themorph:pre f ix  path of the verb (overriding thevalue given in the main set of verb), and specify in-heritance from the separab le  and non.separableclasses respectively.
The former of these unifies thevariable P re f ix  with either the empty string (inthe case of tensed 'inverted' verbs) or the value ofmorph : p re f ix  (for other variants), while the lat-ter sets the value uniquely for all forms of the verbin question.
As the value of sere is fixed in the mainequation set ofweglaufen and ver laufen,  the cor-responding equation in lau fen  is overridden, butBase.stem unifies with lauf .
Finally, in verb, themain set supplies default values for P re f ix  andmorph : p re f ix  (which in the cases under consid-eration will not be applicable), unifies P_bs withthe result of concatenating the strings P re f ix  andBase_stem, and for each value of syn in f l  assignsto form the concatenation of P_bs with the appro-priate sufftx string.Values for sere (antics) are provided in main setequations; those in weglaufen and ver lau fen  arethus correctly able to override that in laufen.3 .2  Eng l i sh  I r regu lar  VerbsIn most cases, lexical items that realize certainmorphosyntactic properties in irregular forms donot also have regular realizations of those proper-ties; thus *sinked is not a well-formed alternativeto sank or sunk, on the analogy of e.g.
walked.This phenomenon has frequently been discussedin both theoretical and computational morphol-ogy, under the title of 'blocking', and it appears toprovide clear motivation for a default-based hier-archical approach to lexical organization.
11 Thereare exceptions to this general rule, however, andinheritance mechanisms must be sufficiently flexi-ble to permit deviation from the strict behaviourillustrated above.Consider the small class of English verbs includ-ing dream, lean, learn and burn; these have, formany speakers, alternate past finite and past par-ticiple forms: e.g.
dreamed and dreamt.
The fol-lowing fragment produces the correct pairings ofstrings and feature structures, the written form ofthe word being encoded as the value of the forml lSee e.g.
Calder (1989).feature: 12#Word walk (verb)<bass> = walk#Word s ink  (verb)<bass> = s inkP_Fin_Form = s i l kPSP_Form = sunk#Word dream (dua l -pas t  verb)<base> = dream#Class  dua l -pas t  0IPSP_Form = <base> k& tP_Fin_Form = <bass> &k t~morph> = past t in l t s /pas tnon~in i t sI#C lass  verb  ( )<oat> = vPSP_Porm = <bass> It& sdP_F in_Form = <bass> &k odJ<morplO = present_nones3<~orm~ = <bass><morph> = prsssnt_ss3<~orm> = <bass> &k s~rph~ - p ts tnon:e in i to<form> = PSP_Fozm<nOXl~lO .
p ts t f ln l t s<fo~O = p_F4e_Fo~nThe main set equations in s/nk override those in itssuperclass verb, so that the variants in the latterclass which give rise to past participle and pasttensed forms associate the appropriate informationwith the strings sunk and sank, respectively.
Theclass walk, on the other hand, contains nothing topre-empt he equations in verb, and so its pastforms are constructed from its value for base andthe suffix string ed.The lex/cai class dream differs from these in hay-ing as one of its direct superclasses dua l -past ,which contains two variant sets, the second ofwhich is empty (recall that variant sets are pre-ceded by the vertical bar ' I ' ) .
Moreover, this classis more specific than the other superclass verb,and so its equations assigning to PaP_Form andP_Fin_Form the string formed by concatenatingthe value of base and t have precedence over thecontradictory statements in the main set of verb.Note that this set alo includes a disjunctive con-straint to the effect that the value of morph in thisFS must be either past f in i te  or pastnonf in i te .The dual_past class thus describes two featureIZAgain, the analysis ketched here is simplified; severalvariants within the verb class have been omitted, and all in-fleetional information is embodied as the value of the singlefeature morph.219structures, but adds no information to the sec-ond.
The absence of contradictory specificationspermits the equations in the main set of verb toapply, in addition to those in the first variant setof dua l -past .
The second, empty, variant set indua l -past  permits this class also to inherit all theproperties of its superclass, i.e.
those of regularverbs like walk; among these is that of forming thetwo past forms by suffixing ed to the stem, whichproduces the regular dreamed past forms.3.3 Word-Form ManipulationThe string concatenation operator '&&' allows thelexicon writer to manipulate word forms with ELUequations and macros.
In particular, &t can beused to add or remove prefixes and suE3xes, andalso to effect internal modifications, such as Ger-man Umlaut, by removing a string of charactersfrom one end, changing the remainder, and thenreplacing the first string.
In this section we showbriefly how unification, string concatenation, anddefensible inheritance combine to permit the anal-ysis of some of the numerous orthographic changesthat accompany English inflectional sufftxation.The inflectional paradigms of English nouns,verbs, and adjectives are complicated by a num-ber of orthographic effects; big, hop, etc.
undergoa doubling of the final stem character in e.g.
big-ger, hopped, stems such as/oz,  bush, and arch takean epenthetic ?
before the plural or third singu-lar present suiflx s, stem-final ie becomes y beforethe present participle suifL~ ing, and so on.
Pe-ripheral alternations of this kind are accomplishedquite straightforwardly b  macros like those in thefollowing lexicon fragment (in which invocations ofuser-defined macros are introduced by ' :  ,):isFinal_Sibi lant(Str in s)$ t r in$= _ I~eh/c~/e/x /sFtnal_Y(Striag,Prefiz)String = ~reftx I~ yPre f ix= &kb/c/4/~/g/h/j/k/i/m/n/p/r/s/t/v/w/x/z# Word t ry  (verb_spe11~)<base> = t ry# Word watch  (verb_spe\ ] .
I /a  8)<base> = watch13As before, this is s somewhat sbbre~sted version of sfull descrip~on; the verb and vo~bJpolliag classes requireadditional variant sets to account for other morphosyntsc~cprope~|es.
Other st~ng-predicste macros, in particular OK,must be defined in order to ester for the ~ range of spellingchanges observed in verbal inflee~on.# Class verb_spe l l ing  (verb)I!F ina l _T (<base>,P)Base_P_PSP = P && iBase_3SG = P &k ieJ!F~al_Sibi lant(<baee>)Base_3SG = <base> k& ?I!OK(<base>)#Class verb ()<cat> = vBase_3SG = <base>Baso_P_PSP = <bass>PSP_Form- Baso_P_PSP k& odSG3_Fozmffi Base_3SG k& sJ!
Sing3<form> = SG3_FormI; PastNonFin<form> = PSP_FormTwo macros definitions are shown here; Final_?is true of a pair of strings S t r ing  and Pre f ix  iffS t r ing  consists of P re f ix  followed by y and thefinal character of P re f ix  is one of the set denotedby the disjunction b /c .
.
,  z, while F ina l _S ib i lantis true of a given string iff that string terminates insh, ch, s, z, or z. OK is a macro which is true of onlythose strings to which neither F ina l .S ib i lant  norFinal_Y apply.The class verb Jpe l l J .ng  contains three variantequation sets, the first two of which assign values tovariables according to the form of the string whichis the value of the base feature.
If  Final_?
is appli-cable, Base.P-PSP is unified with the concatenationof the second argument to the macro (e.g.
tr) andis, while Base_3SG is unified with e.g.
tr and i.I f  F J .na1.S lb i lant  is applicable, then Base.3SG isunified with the concatenation of the value of base(e.g.
watch) and e. I f  neither of these is applica-ble (because the base string does not match thepatterns in the macro definitions), the variablesare bound not within this class, but in the mainequation set of its superc\]ass verb.
Here, their val-ues are unified directly with that of base,  and theeventual values of the form feature result from con-catenation of the appropriate suiflx strings, givingvalues of watched, watches, tried, and tries.4 SummaryThe lexicon system presented above is fully inte-grated into the ELU environment; in particular,the result of analysis and the starting point forgeneration is the same type of feature structure asthat produced by ELU grammars, and the equa-220tions within classes are of the same sort as thoseused elsewhere in a linguistic description, beingable to exploit re-entrancy, negation, disjunction,direct manipulation of lists, etc.For the purpose of experimenting with the struc-ture of the class hierarchy and the distribution ofinformation within individual classes, the lexicon isheld in memory, and is accessed irectly by meansof an exhaustive search.
Once a stable descrip-tion is achieved, and the coverage of the lexicon in-creases, amore efficient access mechanism exists, inwhich possible word-forms are pre-computed, andused to index into a disk file of class definitions.We have presented an implemented treatment ofa framework for lexical description which is bothpractical from the perspective of efficiency and at-tractive in its reflection of the natural organiza-tion of a lexicon into nested and intersecting en-eralizations and exceptions.
The system extendstraditional unification with a multiple default in-heritance mechanism, for which a declarative se-mantics is provided.ReferencesBoums, G. (1990) "Defaults in Unification Gram-mar," Proceedings of the ~Sth Annual Meetingof the Association for Computational Linguis-tics, Pittsburgh, June 6th-9th.
165-172.Calder, J.
(1989) "Paradigmatic Morphology,"Proceedings of the Fourth Conference of theEuropean Chapter of the Association forComputational Linguistics, Manchester, April10th-12th.
$8-65.Daelemans, W. and G. Gazdar, eds.
(1990) Inher-itance in Natural Language Processing: Work-shop Proceedings.
ITK, Tilbut8 University.Estival, D. (1990) "ELU User Manual".
TechnicalReport 1, ISSCO, Geneva.Flickinger, D. P. (1987) "Lexical Rules in the Hier-archical Lexicon," PhD Thesis, Stanford Uni-versity.Gasdar, G. (1990) "An Introduction to DATR,"in R. Evans and G. Gasdar (eds.)
The DATRPapers: February I990.
Cognitive Science Re-search Paper CSRP 139, School of Cognitiveand Computing Sciences, University of Sussex.1-14.Hudson, R. A.
(1984) Word Grammar.
Oxford:Blackwell.Johnson, R. and M. Rosner (1989) "A Rich Envi-ronment for Experimentation with UnificationGrammars," Proceedings ofthe Fourth Confer-ence of the European Chapter of the Associ-ation .for Computational Linguistics, Manch-ester, April 10th-12th.
182-189.Karttunen, L. (1986) "D-PATR: A DevelopmentEnvironment for Unification-Based Gram-mars," Proceedings of the llth lnterna.tional Conference on Computational Linguis.tics, Bonn, August 25th-29th.
74-80.Keene, S. (1989) Object-Oriented Programmingin Common Lisp.
Reading, Massachussetts:Addison-Wesley.Schmolse, J. G. and T. A. Lipkis (1983) "Classifi-cation in the KL-ONE Knowledge Representa-tion System," Proceedings of the Eighth Inter-national Joint Conference on Artificial Intelli-gence, Karlsruhe, West Germany.
330-332.Shieber, S. M. (1986) An Introduction to Unifi-cation-Based Approaches to Grammar.
CSLILecture Notes no.
4, Stanford University.Steele, G. L. (1990) Common Lisp: The Lan-guage (second edition).
Bedford, Massachus-setts: Digital Press.Touretsky, D. S. (1986) The Mathematics of Inher-itance Systems.
London: Pitman Publishing.221
