The FINITE STRING Newslet terS i te  Repor tControl l ing Complex  Systems of LinguisticRulesRod JohnsonUniversity of Manchester Institute of Science andTechnology, U.K.Steven KrauwerRijksuniversiteit, Utrecht, HollandMike RosnerFondazione dalle Molle, ISSCO, University of Geneva,SwitzerlandNino VarileCommission of the European Communities,Luxembourg\[Most of the ideas in this paper evolved during workon design studies for the EEC Machine TranslationProject Eurotra.
We are grateful to the Commissionof the European Communities for permission to pub-lish these ideas, and to our Eurotra colleagues - par-ticularly Maghi King, Dieter Maas, Bente Maegaard,and Serge Perschke - for many useful contributions,which have been influential in moulding our currentthinking.\]IntroductionIn this paper we discuss some of the design decisionswe have made in defining a software environment fora large scale Machine Translation (MT) project.
Ageneral purpose MT system intended for commercialapplication should ideally have many features, such asrobustness and transparency, in common with anylarge industrial software implementation.
At the sametime, consideration of the way in which a good MTsystem is built and maintained suggests an approachmore characteristic of AI programs and Expert Systems(ES) in particular.
There may be conflicts between thetight style of top-down design and implementationadvocated by designers of conventional industrial soft-ware and the rather empirical, heuristic style of devel-opment typical of more loosely structured knowledge-based systems.
Our suggested solution to these con-flicts involves an enhanced form of controlled Pro-duction System (PS), which combines maximal tran-sparency and modularity with the advantages of thecharacteristically declarative and locally unstructuredorganisation of the typical PS architecture.
Althoughour ideas derive originally from our current preoccupa-tion with MT system design, the general principles wehave adopted should be equally valid for the construc-tion of any large language processing system.Production SystemsThe advantages and disadvantages of the PS style ofprogramming are well known - a good review is Davisand King (1977), although they say relatively littleabout the use of PS for linguistic problems.
The PSarchitecture is particularly suited to knowledge-basedsystems which depend on having access to largeamounts of relatively homogeneous, factual knowl-edge.
It is also easy, in principle, to add to and sub-tract from the knowledge base since factual knowledgeis intended to be decoupled from procedural applica-tion.
In this regard, a PS has obvious attractions forapplications in MT.A typical PS used to represent linguistic computa-tions might have the following organisation: the database would be some collection of tree structures; therules would consist just of a pair of structural descrip-tions; and the interpreter would repeatedly match theleft-hand sides of rules against the data base, buildingright-hand structures every time there is a successfulmatch.
The paradigm example of a PS in MT is proba-bly Colmerauer 's  (1970) Q-system, in which theTAUM METEO system is written (Chandioux 1976).In theory, the PS style of programming looks veryattractive for MT.
In practice, however, as a PS be-comes large it becomes increasingly difficult to con-trol.
Supposedly independent rules begin to interact inunforeseen ways, often with obscure consequences.When it becomes necessary to modify the behaviour ofthe interpreter - as inevitably happens - users areforced to introduce the necessary control informationinto rules.
Because all communication between rulestakes place through the data base, rules become com-plicated by extra tests on and assignments to arbitraryflags which have no meaning for anyone but the userresponsible for their introduction, but which, oncecreated, survive permanently in the data base.
In theend, the PS becomes even more complex and obfusca-tory than the corresponding procedural program it wasintended to replace.For the purposes of MT, these observations are par-ticularly disturbing.
General purpose MT systems arede facto large, and thus particularly prone to the dan-gers we have just described.
Nor is there any reasonto suppose that a single interpretation scheme will beappropriate for all the tasks necessary for MT - stringmanipulation, phrase structure analysis, arbitrary treetransductions, dictionary lookup, plausibility weightingof conflicting analyses, and so on.
After all, we wantto offer users flexibility and naturalness of expression,American Journal of Computational Linguistics, Volume 9, Numbers 3-4, July-December 1983 199The FINITE STRING Newsletter Controlling Complex Systems of Linguistic Rulesand these features are not really consistent with asingle way of doing things.Thus, although we see the appeal of a PS architecturefor MT, we have to concede that it not only fails tosatisfy the requirements of any conventional industrialsoftware, it does not even provide users with the flexi-bility they need to solve the kinds of ill-defined, open-ended problems that habitually arise in MT.
In therest of this paper, we describe a solution that main-tains the declarative, empirical style, characteristic of aPS, within a f ramework conducive to the top-down,modular construction of robust systems.Homogene i tyThe first requirement we had, especially given thepeculiar context in which we are working, was to de-fine a degree of homogeneity over the whole system.So as not to conflict with the equally important criteri-on of experimental f exibility, this homogeneity is lim-ited to rather superficial aspects of the system design.Thus we have imposed a uniform rule syntax, suchthat any interpreter in the system must be defined tooperate with that syntax or a subset of it.
Similarly,we have constrained the class of structures that rulescan be written to manipulate.
The nature of theseconstraints - which are in fact less restrictive thanthey seem - will be discussed elsewhere ( Johnson,Krauwer, Rosner and Varile, in preparation), and weshall not discuss them further here.Enhancing PS Control  Faci l i t iesThe poverty of the control structure of a typical PS isevident if we consider a chain of Q-systems, represent-ing the interpreter as a rule-applying automaton de-fined by the regular expressions(1) Q = P1,P2 ..... Pn(2) Pi = (ril I riEl"" I r i j l ' " ) *  (j = 1,2 ..... ni)where the Pi are the individual Q-systems and rij is thejth rule of the ith Q-system.
The interpretation of theregular expressions i as follows:(1) Execute Q by executing the Pi in sequentialorder.
(2) Execute each Pi by iteratively applying all itsrules in parallel until no applicable rule can befound.Expressed in this way, the available control strategiesbecome clear: we can apply packets of rules in se-quence, and, within a rule packet, we can apply rulesiteratively in parallel.
Nothing else is possible.There is, however, no reason why we should not beable to generalise these three basic control notions ofsequential, parallel, and iterated application to producemuch richer and more interesting control strategies.The idea of a regular control language, which we haveadopted in our design, is similar in spirit to the generalscheme developed by Georgeff  (1979, 1982) for char-acterising PS control.The basic control construct in our model is a process,which may either be simple (composed only of rules)or complex (constructed out of other processes).
An-other name for a simple process, in our terminology, isa grammar.
A complex process is defined by writingdown a regular expression over the names of otherprocesses in the system, for exampleP = A,B,CQ -- x lv l zR = (P IQ)*This simple generalisation gives us a far more powerfulrange of strategic options than does a simple PS likethe Q-system.
However, it still leaves a number ofimportant open questions, especially about what goeson inside a grammar and what data processes are actu-ally applied to.
We address these questions in the nexttwo sections.Limit ing Side EffectsOne of the most serious problems with a large PS isthe impossibil ity of predicting what information willactually be present in the data base at any given time.It is this, more than any other aspect of PS design, thatcauses rule-writers to include in their rules all kinds ofextraneous tests simply to avoid spurious rule applica-tion in situations where the rule is not intended toapply.Now, given the kind of control organisation de-scribed in the last section, we can observe that, whenwe define a process in terms of a collection of embed-ded processes or grammars, the only important aspectsof the behaviour of the embedded processes are thekinds of structure they accept as input and the kindsof structure they produce as output.
To achieve theeffect we need we introduce the notion of a filter.Every process or grammar has associated with it a pairof filters, which are syntactically just structural de-scriptions like the lhs of a rule.
The input filter, orexpectation of the process, is used to supply to theprocess just those structures that can be successfullymatched: if nothing in the data base matches the ex-pectation, the process is simply not invoked.
Whenthe process terminates, the output filter, or goal of theprocesses, allows to pass to the calling process justthose structures built by the process that match thegoal.The effect of the introduction of filters into a con-trolled PS is quite dramatic.
Side effects may appearbut never survive the process in which they are creat-ed.
It becomes possible to test modules in isolation,simply by simulating data base states on which theyare supposed to operate.
In the same way, processescan be designed top down, with fairly strong guaran-200 American Journal of Computational Linguistics, Volume 9, Numbers 3-4, July-December 1983The FINITE STRING Newsletter Controlling Complex Systems of Linguistic Rulestees that each process will do what it was supposed todo, provided its component parts deliver what they aresupposed to deliver.
Errors are easier to trace becausethe behaviour of a process can be unequivocally de-fined.If to this we add the important side benefit thatprocesses automatically become self-documenting, it isapparent that with this device we have been able tocapture almost all of the advantages of structured pro-gramming, without losing the essentially declarativespirit of the enterprise.Modifying the InterpreterAs we have remarked above, the semantics of a rule ina PS depends ultimately on the characteristics of theinterpreter that applies it.
It is important hat a gener-al and flexible system would be able to accommodatea wide variety of different task-oriented interpretationschemes.
Within the framework we have been devel-oping, it should not be difficult to implement safelyvirtually any interpreter that satisfies the homogeneitycriteria stated above.
As far as neighbouring process-es are concerned, the internal behaviour of a grammaris of no interest provided it operates on and produceswell-formed structures.
As it happens, we have so faronly considered implementation of one parameter-driven interpreter which applies rules according to thesame principles as those that govern the application ofprocesses discussed above ( 'Enhancing PS ControlFacilities').
It appears that this interpreter is likely tobe adequate for a wide variety of structure-processingtasks in the immediate future.
When new interpretersare required, we do not anticipate serious difficultiesin integrating them into the system.ConclusionIn designing a software environment o support MTsystems - a kind of meta-MT-system - we have at-tempted to provide a basic, declarative, problem-oriented architecture that is readily accessible to po-tential users.
Our guiding theme has been to try toseparate factual from control information without los-ing the declarative ssence of a good PS.
By addingfilters to a controlled PS, we have been able to incor-porate most of the principles of structured program-ming into a declarative framework.
The design princi-ples adopted should lead relatively painlessly to theconstruction of robust, modular, and easily extendibleMT systems, while retaining the desirable flexibility forloosely structured experimental construction character-istic of a PS.ReferencesChandioux, J.
1976 METEO: Un Syst6me Op6rationnel pour laTraduction Automatique Des Bulletins M6t~orologiques destin6sau Grand Public.
META 21: 127-133.Colmerauer, A.
1970 Les Syst~mes-Q.
Internal publication #43.University of Montreial.Davis, R. and King, J.J. 1977 An Overview of Production Sys-tems.
In Elcock and D. Michie, Eds., Machine Intelligence 8.Ellis Horwood: 300-332.Georgeff, M. 1979 A Framework for Control in Production Sys-tems.
AI Memo #322.
Stanford University.Georgeff, M. 1982 Procedural Control in Production Systems.Artificial Intelligence 18:175-201.Johnson, R.L.
; Krauwer, S.; Rosner, M.A.
; and Varile, G.B.
AFlexible Data Model for Linguistics Representation.
(in prepa-ration)American Journal of Computational Linguistics, Volume 9, Numbers 3-4, July-December 1983 201
