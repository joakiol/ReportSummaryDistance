18"1965 International Conference on ComputationalLinguistics"A Heuristic Approach to NaturalLanguage ProcessingDenis M. Manelski andShell Oil Company50 West 50th StreetNew York 20, New YorkGilbert K. I~ l .eeNorthwestern UniversityTechnological InstituteEvanston, IllinoisManelskl & Krulee1ABSTRACTThis paper is concerned with the design of a processor capable offormalizing English language descriptions of problems in the sententlalcalculus.
The emphasis is on the design of a system with natural languageprocessing capabilities, but the formal languages specified are orientedto the problem context.A series of automata are specified to carry out the necessaryfunctions.
The automata identifythe premises in the problem strings~specify the appropriate logical connectives among the premises and deter-mine which premises are meaning-equivalent.
The syntax of each automaton isdefined and examples are used to illustrate their functioning.The automata accept statements in the language L1, the set ofEnglish statements of problems in the sententlal calculus.
The individualpremises p @ L1 are recognized by the syntax~, where ~ is chosen so thatthe language L2 recognized by it is a subset of L1.
Furthermore, thestrings in L2 are restricted to the declarative sentences.
Once the premisesand their logical connectives have been identified, those that are meaning-equivalent are located in two additional steps.
First the L2 descriptionof the string is mapped into a string in L3.
The L3 language consistsof a limited set of canonical forms that ease the problem of establishingmeaning equivalence of premises.
Finally, the automaton appliesheuristically a sequence of problem-orlented and meaning-preservingtransformations in order to establish meaning-equivalence.
Two premisesare taken to be meaning-equivalent if one can be deduced from the other.Otherwise~ they are taken to be not meaning-equlvalent.Manelskl &Krulee2A HEURISTIC APPROACH TO NATURALLANGUAGE PROCESSING 1IntroductionThe recent evolution of programming languages has tended toimprove communication between man and computer.
The use of mnemonics~automatic storage allocation~ English-like operators (such as in COBOL)and problem-oriented languages has greatly facilitated the task of theprogrammer.
Thus, the solution algorithm for a large class of computa-tional problems can be defined with relative ease in languages such asFORTRAN and ALGOL, specifically designed for these classes of problems.This paper describes an attempt to further simplify the communica-tion between programmer and computer by defining a system which can producea formal description from its natural (verbal) input.
2In order to study this approach a specific problem area waschosen, the propositional or statement calculus.
It will be evident thatthe problem area chosen has influenced the design of the system; nonethelessit should be clear that the linguistic capabilities of the system aregeneral rather than specific to the problem context.In designing this processor, two major abilities are required.First, the processor must be able to identify each elementary premise andall logical connectives.
It must also determine which premises are to betaken as equivalent.i This research was supported by Grant G-17951 of the National ScienceFoundation.
A majority of the system has been programmed in the listprocessing language IPL-V (Newell, 1961).2 For a more complete description and some program listings see Manelski,196~.Manelski & Krulee3The processor is composed of th ree  series coupled automata(see Fig.
1).
The first automaton, A1, accepts as its inputs the languageL1, where L1 is the set of all English language statements of problems inthe propositional calculus.
This automaton is concerned with the identi-fication of the premises and logical connectives of a problem.
This isachieved by using a syntax ~ capable of recognizing strings in L2.
whereL2 is a subset of L1.
The syntax ~ consists of a hierarchy of syntaxes;a phrase structure syntax ~idesigned to recognize a subset of Englishcomposed of simple declarative sentences and the set of' transformationsspecified by~ T.IThe equivalent premises are identified by the automata A2 andA3.
The automaton A2 maps a premise, identified by AI~ into a canonicalform specified by the syntax C that defines the language L3.
This stepis designed to facilitate the distinction of equivalent premises.
FinallyA3 applies a sequence of meaning preserving transformations from the setTO = ~TI,T2,... ~ Tm~ on the string (~r,~'s ~ L3 such that if:TiTj'''T% (~r) :~swith T k C TOthe two strings are considered meaning equivalent.
Should the systembe unable to find a deduction satisfying these conditions or under certainother heuristically chosen criteria the strin6~s are asslnned to representdifferent premises.In order to test the system described in this paper, problemswere drawn from Stoll (1961).
Some will be used later to illustrate thecapabilities and inadequacies of the present system.1 Chomsky's discussion of transformations and the inadequacies of variousmodels for natural languages can be found in the monograph "SyntacticStructure s".96 ~ 'r~u~~J N,k/I1 F-~ U~ ,,,4 UP,I ,1~ 0~t~4ZOI1(~?Q.<or~u), GJ?
)0k~u,IJr,n.<.Manelski &Krulee5Each of the automata will be discussed in two ways, first interms of its syntax.
Finally the information flow for its implementationas a computer program will be outlined.Characteristics of the Natural Language Processor (AI)The automaton A1, as mentioned in the previous section, consistsof two completely different syntactic mechanisms.
The system includes aphrase structure syntax designed to recognize an extremely restrictedsubset of the English language, simple declarative sentences.
The syntaxof the processor also includes a limited set of transformations chosento enhance the power of the language generated, but also specificallychosen for the problem context.If we consider the syntax of A1, ~ , as consisting o f~ l  andT we have defined a hierarchy of languages:L1 ~ L2 ~ I~lHere L1 consists of all the legal problem statements; L2 consists of theset of strings recognized by~ ; and L~l consists of all the stringsrecognized by the syutax ~.
Thus, the syntax ~ of the automaton A1is really composed of two disjoint sets of rewriting rules,~l and ~T.The syntax ~l is a phrase structure crammar designed to generate orrecognize a subset of English Composed of simple declarative sentences.The syntax ~T contains a set of transformations designed for the purposesof isolating premises and specifying logical connectives.
This hierarchycan be visualized in Figure 2.II I I I1?6,F:l.~ure 2Manelski & Krulee7Initially~ we shall describe the class of sentences recognizedby 91~ and then characterize the strings recognized by P. From thefollowing discussion it will be made clear that we are building arecognizer rather than a generator.
The automaton A1 will not performsyntactic analysis below the level of the alphabet (i.e., words) of thelanguage.
Thus~ the processor w?uld recognize:The bridge was highThe bridges was highas the same sentence since the differences are at a level below thatspecified by its syntax.The processor consists of an alphabet A, where:A = N u D u PN u ADJ u VEQu VTRu V INu  VFAC U VAUXo PREPu ADVu THANu ADJCwith the sets representing:N: nounD: determinerPN: pronounADJ: adjectiveVEQ: verb equationalVTR: verb transitiveVIN: verb intransitiveVFAC : verb factitiveVAUX: verb auxiliaryPREP: prepos it ionADV: adverbADJC: comparative adjectiveTHAN: ThanManelski &Kru lee8Although the task of the assignment of word classes is that ofthe linguist, in general, if X i and Xj are sets comprising A we expectxi x j for i Jwhere ~ represents the empty set.
The occurrence of an element of thealphabet in more than one word class is known as homography and iscommon to the natural languages.For purposes of derivation, we distinguish between the elementsof the alphabet, to be known as the "terminal" elements, and the symbolsthe nonterminals.from the syntax such as S, NP, ADJ, etc., which will be referred to asThe word assignments might be as shown in Table 1.N ..D =PN =ADJ =VMEQ =V~R =VMINTR =VMFAC -VAUXPRP =ADV =AI~C =man, boy, house,...a, the,...he, they,...blue, large,...is, are,...hit, hits,...rained, went,...appoint, call,...will, should, ...in, to, ...quickly, slowly,...larger, better,...Table 1Although the processor is limited in the size of the available dictionary ,for purposes of discussion no limitations will be assumed.In addition it is necessary to specify the syntax of therecognizer, which uses the rewriting rules of the axiomatic ~system ~l inTable 2.
Examining the syntax ~l, we see that it meets all the requirementsof a phrase structure grammar.
Also, ~l  generates several classes of stringscharacterized by the verb type.
Since this classification will be funda-mental to the design of A2, we shall give some examples in L2 and latershow the mapping of A2.Manelski &Kru.lee9Syntax ~i for Processor A1i) S -~NP + VP2) NP- ,D+ NNPN3) NP-~NP + PRP4) PRP-~ PREP + NP5) N-~ADJ  + N6) AOJ-~AOJ + ADJ7) PADJC-~ ADJC + than +8) NP~ NP+ NP9) VP-~ VEQ + PREDEQVTR + PREDTRVITR + PADVVFAC + PREDFAC10) VEQ -~ VMEQll) VMEQ -~VAUX + VMEQ12) PREDEQ~ NPADJPRPPADJC13) VITR-~ VMITR14) VMITR -~ VAUX + VMITR15) PADV~ADVNPRP16) PADV~ PADV + PADV17) VTR-~ VMrR18) VM~R -~ VAUX + VM~R19) PREDTR ~ NPNP + PADVNP+ PRPNP+NP20) VFAC ~- VMFAC21) VMFAC-~ VAUX + VMFAC22) PREDFAC -~ NPNP+NPNP+ PADVNPsentence, noun phrase, verb phrasedeterminer, nounpronounprepositional phraseprepositionadjectivecomparative adjectival phrase, compara-tive adjectiveverb equational, equational predicateverb transitive, transitive predicateverb intransitive, adverbial phraseverb factitive, factitive predicatemain verb, equationalverb auxiliarymain verb, intransitiveemptymain verb, transitivemain verb~ factitiveTable 2Manelski &KruleelOThe syntax~l identifies four verb types, equational verbs,intransitive verbs, transitive verbs, and factitive verbs with theircorresponding predicates.
The following examples show some of thepossible sentences:Equational verb:(i) John is home.
(ii) John is tall.
(iii) John is by the house.
(iv) John is taller than Peter.A derivation of (ii) in the syntax~l is(S(NP(N John)) (VP(VEQ(VMEQ is)) (PREDEQ(ADJ tall) )) )Intransitive verb:(i) The Dodgers win.
(ii) The Dodgers win seldom.
(iii) The Dodgers win money.
(iv) The Dodgers win at home.The derivation of (i) is(S(NP(D The)(N Dodgers))(VP(VITR win)(PADV?
)))Transitive verb:(i) John loves Mary.
(ii) John loves the winnings from the track.The derivation for (it isJohn) loves) MaryS) 555Fact it ire verb:(i) John called home.
(il) John called his friend a fool.F~nelski & KruleeiiThe derivation of (i) is(S(~P(N John) ) (VP(VFAC(V~FAC called) ) (PREDFAC(~P(N Mary) ) ) ) )Several types of sentences will not be recognized by~l.
Some of thesecould be included by additional productions.
Some additional types ofsentences will be recognized when ~T is added to the syntax.
Othersentence forms are not considered necessary within the original problemconte}~.
Let us list some of the sentences in LI that are outside ofthe capabilities of recognition with ~i.Imperative sentences:Go home.Interrogative sentences:Is John coming home?Passive sentences:Home is where John should be.Conditional sentences:If John should come home...Compound sentences:John will go home and Mary will stay.Complex sentences:John, should he so desire, will go home.In order to make the processor A1 useful in the problemcontext, it is necessary to increase the class of strings in L2.
Incontrast to the syntax ~i, which uses the rewriting rules on the non-terminals in the deduction string, the transformation set rT is designedto operate on the derivations in ~i.
Generally, transformations haveManelski &Krulee12been discussed in terms of generators.
Attention has been focused onincreasing the class of strings that a formal language can generate (39).However, our problem is to use ~T in order to simplify the class ofstrings that ~l will have to recognize.
Thus, our transformation set rTshould decompose the stringJohn will go home and Mary will stay.into the following simpler strings:(1) John will go home.
(il) will stay.Since we are interested in formalizing the natural languageinputs as statements in the sententlal calculus, the transformationswill also give us information as to the appropriate logical connectivesfor the premise.
Thus, in the previous example our processor could beexpected to define a statement of the form:P ;kgIn order to explore the powerful linguistic possibilities oftransformations, a limited number were chosen.
We shall now define thetransformations and show how the linguistic capabilities of A1 have beenincreased.The transformation set~T presently contains as its axioms:T = ~TNOT, TCOM, TCOND~In order to specify a transformation, we must not only definethe structural changes it produces but also the class of strings towhich it is applicable.
The transformations~ as defined in~T wereadapted for A1.
Since we are not interested in generating grammaticallyManelski & Krulee13correct English sentences, but rather mapping the input strings into aform recognizable to ~l, it is possible to omit the transformationsfor tenses because they operate at a level lower than that of theterminals.
By implication~ 1 will process strings that are notgrammatically correct.
Thus, if A1 were presented with the sentence:If it were cold tomorrow~ ....the transformation TCOND will give as its output:It were cold tomorrow.This premise would still be processed althouch it is grammaticallyincorrect.Another difference between the transformations as specifiedby Chomsky~ and those used by A1 is in the direction of the mapping.The ~T transformations have L2 as their domain and the kernel stringsgenerated by ~l as their range.
This is the inverse of the mappingsconsidered by Chomsky (1957).TNOT: is defined on strings of the form( i)..+ NP+ VAUX+ not+VMTR+...( ii)..+NP+VAUX+never+VM~R+...(iii) .
.+ NP+V~EQ+not+...(iv) .
.+ NP+VMEQ~ never+...(v)..+NP+VAUX+not+VMEQ+...( vi)..+ NP+ VAUX+ never+ VMEQ*...(vii)..+NP+VAUX+not+VITR+...( vi ii)..+ NP+ VAUX+ never*VITR+.
?.
( ix)..+NP+ never+VITR+ ...Manelskl &Krulee14( x)..+NP+VAUX+ never+VTR+...( xi)..+ NP+VAUX+never+VTR...( x?
i )..+ NP+ never+VTR+...( xill)..+ NP+VAUX+ not+VFAC+...(xiv) .. + NP+VAUX+ never+ VFAC+...( xv)..+ NP+ never+VFAC+...Should a str ing~ 1 correspond to one of the above patterns TNOT(0-1)becomes:( i)..+NP+VAUX+VMrR+.... ( ii)..+ NP+ VAUX+ ~ ...(iii)..+~+nmQ+...(iv)..+~+VME~...(v)..+~P+VAUX+VME~...(vi)..+ NP+VAUX+VMEQ+...( vii)..+ NP+VAUX+VITB+...( viii)..+ NP+VAUX+VITR+...( ix)..+ ~P+vI~+...(x)..+NP+VAUX+VTR+...(xi)..+ NP+VAUX+VTR+...( xll)..+~+VTR+...(xiii)..+NP+VAUX+VFAC+...(xiv)..+NP+VAUX+VFAC+ ...(xv)..+NP+VFAC+...Examples of some of the cases follow:Manelski & Krulee15~'l: John will never hit Mary.TNOT(~): John will hit Mary.
(~2: Today is not cold.TNOT~--2) : Today is cold.~3: Tomorrow will not be cold.TNOT~3): Tomorrow will be cold.~-4: John never suffers.TNOT(q-4) : John suffers.TCOM: operates on strings in the following domain only:(i) ?
.+Sl+and+S2+ ?
?
?
( ii)..+Sl+ ,+ s2+...( i i i ) .
.+S I+oreS2+.
.
.
( iv)..+Sl+then+S2+...(v i )  Either +Sl+Or+S2+...(vii) Therefore+,+Either+Sl+or+S2+ ?.
;The range of the function is any string with the following format:S IS 2Here the information between "SI" and "$2" is used by the processor onlyto establish the Boolean connectives for the statements.
Some exampleswill show the effect of TCOM On strings ~'in the domain of thet rans format ion.~'i: Either Sally and Bob are the same age or Sally is older than Bob.TCOM~I): Sally and Bob are the same age.Sally is older than Bob.Manelski &Krulee16~2:  The races are fixed or the gambling houses are crooked?TCOM(~): The races are fixed.The gambling houses are crooked.TCOND: is defined over strings wlth the following configuration:( i)..+ If+ Sl+...+, then+ $2+ ....( li)..+If+Sl+...+ ,+$2+ ....and has as its range the following forms:?
.+S l+ .
.
.?
.+S2+.
.
.As in the other transformations its application defines the logicalconnectives for A1.We can see the effect of TCOND on the following strings:~ i :  If the Dodgers win~ then Los Angeles will celebrate?TCOND(~I) : The Dodgers win.Los Angeles will celebrate?The definitions of the syntactic elements used in establishingthe domain o f~T are given by the phrase-structure grammar ~i.
Anotherconvention used in the discussion is to allow a series of dots ( .... )to refer to any syntactic structure.
It is also implied that thetransformations may be concatenated as necessary.To illustrate their use, we utilize the following examples:~i:  If the then Los Angeles will celebrate, and Dodgers wln~if the White Box win, Chicago will celebrate.TCOND(~I): The Dodgers win.Los Angeles will celebrate and if the White Sox win,Chicago wlll celebrate.Manelski & Krulee17TCOM(TCOND~ 1)) : The Dodgers will win.Los Angeles will celebrate.If the White Sox win, Chicago will celebrate.Dodgers will win.Los Angeles will celebrate.The }~nite Sox win.Chicago will celebrate.~'2: If I miss my appointment and start to feel downcast, thenI should not go home.TCOND(~2): I miss my appointment and start to feel downcast.I should not go home.TCOM(TCOND(~): I miss my appointment.Start to feel downcast.I should not go home.TNOT(TCOM(TCOND(~2)): I miss my appointment.Start to feel downcast.I should go home.In this example the resultant strings are not recognizable by~i.
Thus~ "start to feel do~ncast" has its subject implied by thepreceding string, and could be thought of as "I start to feel downcast".Some of the difficulties caused by the transformations can be overcomeby AI.Manelski & K_rulee18Description of the Natural Language Processor (Al~In order to design a processor of the type described in theprevious section it is necessary to specify therelationship betweenthe recognition rules ~l  of the phrase structure grammar and the rewritingrules ~T of the set of transformations.
Clearly ~l and~T are inter-dependent since the input cannot always be analyzed in terms of thesyntax~ \].
and because the rewriting rules o f~T are defined in terms of1.
Perhaps an example illustrates this point more effectively.
Considerthe inp~ string:If John went to the store then Mary went home.This is clearly a case in which we sho~d apply TCOND~ T in order toobtain:S1 - John went to the store.$2 - Mary went home.However, the processor cannot find S1 and S2 because they are defined interms of ~ 1 which cannot determine S1 and $2 since it cannot analyzestrings such as "If John went to the store...".
This vicious circle hasbeen resolved by determining heuristically when the transformationsshould be applied.
If the strings resulting from the application ofthe transformations cannot be analyzed by ~i~ the system attempts toapply the transformations again.The general hierarchy of the programs can be found in Figure \]~- .The program DO embodies the essential features of the automaton AI.
Abrief description of the various sub-routines involved will serve toillustrate the workings of the processor and the difficulties that itmight encounter.Manelski & Krulee19The automaton A1 can be considered as having two quite distinctfunctions.
Initially, certain key words are marked in the problem input(giving rise to the hypothesized input string) and later the set oftransformations are used in conjunction with the marked words to generatepossible premises (to be called "input strings").The necessary information can be more fully explained byconsidering a program DO designed to implement A1 (see Figure 3).
Theprogram DO initially calls the sub-routine D15 which performs a left-to-right scan on the problem string.
All elements of the set MTO (whereMTO = ~if, then, and~ or, not, never, either, therefore.then, ~}the last two elements are the symbols ", then" and ",") are marked.After marking, the problem string becomes both the input string (i.s.
)and the hypothesized input string (h.i.s.).
The syntactic analysis ofan h.i.s, is attempted by EO.
Failing to find a satisfactory parsing~control is transferred by D2 to DI; otherwise control goes to DI3.
Thesub-routine D13 searches for an additional h.i.s.
; on finding one, itdeletes the successfully parsed string from the i.s.
and the list ofh.i.s.
Should no other h.i.s, be found, the executive calls D14 whichhalts the program.
After performing the necessary output functions, D1scans the h.i.s, currently being processed.
If any marked words arefound, control is passed to D3; otherwise the transfer is to Dll.
Dllerases the previous h.i.s, and replaces them (i.e., all of them) withthe i.s.
Should D1 find that some of the words are marked, the processor20.DOz StartDISz mark a~l words in MTO .
.~ '  .
~'~.
/ t' D2.
Was a sat i s fac tory  pars ing/ .'
.
found for scrlng?
/ !/ ~  \ Dl6: stop ~~ D13Z are .y  additional | ( ~  /pu~ .tring.?
S ~o \ '~/  No .
DI~ are there any markedDI0z Try Co fill In~~.
~ s ized input: s t r ing?Yes / D9: Does s t r ingii~ Copy Input string as ~ .
begin withhypothesized sCrlns?D31 For TNOT?
........ ~>YesNoD4z For TCOND?
.
.
.
.YesDSz For TCOM?
xes)'Nor ?D6z Apply TNOTD7: Apply TCOND~D8: Apply TCOMNoS copFigure 3Manelski & Krulee21attempts to apply the transformations TNOT, TCOND, or TCOM by using thetest routines D3, D4 or D5 in transferring control to D6, D7 or DS~respectively.
D3 transfers control to D6 when "no__~t" or "never" (theunderlining is used in this section to indicate the symbols as marked.
)are in the h.i.s.
; D6 deletes the marked symbol from the h.i.s.
Thesub-routine D5 is only applied when the h.i.s, begins with "if"" it inturn transfers control to D7 which deletes the first of the marked" " .
.
.
.
then" that it finds in the h.i.s.
symbols "then", "therefore , ?
or ~_While removing the marking from the corresponding symbol in the i.s.two new h.i.s, are created by dividing the list at the location of themarked symbol.
D5 and D8 are similar to D4 and D7; however, division ofthe  h .
i .
s ,  is  done  on  "and" ,  "o r "  o r  w i th  the  symbo l  "e i ther"  be ingerased  f rom the  beg inn ing  o f  the  h .
i .
s ,  i f  i t  is p resent .
The  rout inesD6, D7 and D8 t rans fer  cont ro l  to  D9  wh ich  is ca l led  to  tes t  whether  theh .
i .
s .
,  be ing  processed ,  beg ins  w i th  a verb :  i f  th i s  cond i t ion  ex is ts  HOat tempts  to  precede  it  w i th  the  f i r s t  noun  or  p ronoun o f  the  prev ioush .
i .
s .
Shou ld  i t  not  be  poss ib le  fo r  the  processor  to  car ry  out  th i soperat ion ,  the  program pr in ts  out  the  syntact i c  ana lys i s  i t  hasaccomplished and halts.
Both DIO and D9 transfer to EO.Some examples will clarify the logic of DO.
Let the inputstr ing~ 1 be:(~'l: John and went home.
MaryManelski & Krulee22The branching of the problem would beDO:D15:EO:DI3:DI4:transfers control to DI5.marks the word 'and"; the h.i.s, is "John and Mary wenthome (the underlining indicates the marked word).parses "John and Mary" went home.there are no additional h.i.s.stop.
(:DO:DI5:EO:D2:DI:D3:D4:D5:D8:D9:John went home and Mary went to the store.transfers to DI5.the i.s.
and h.i.s, become John went home and Mary wentto the store.fails to parse the sentence.transfers to D1.transfers control to D3.control parses to D4.transfers control to D5.transfers control to D8.the i.s.
becomesJohn went home and Mary went to the store.while the h.i.s, becomeJohn went home.Mary went to the store.after testing the h.i.s, at the top of the pushdown list(John went home) transfers control to EO.Manelski & Krulee23EO:D2:DI3:EO:I)2"DI3:DI4:3DO:DI5:EO:D2:DI:D3:D4:D7:09:successfully parses the current h.l.s.transfers control to DI3.locates the next h.i.s.successfully parses the h.i.s, at the top of thepushdown list (Mary went to the store).transfers the processor to D13.cannot locate any additional h.i.s.prints the results of the parsing.If John, Peter and Paul were at the game,...calls D15.marhs the problem string as "If John~ Peter an__~d Paulwere at the gs~ne~, .... ' which is copied as the h.i.s.fails to find a deduction for the h.i.s.transfers control to DI.transfers control to D3.transfers control to D4.transfers control to D7.the marked words have the structure required for TCONDand changes the i.s.
to"l_~f John, Peter an__~d Paul were at the game~ .... "and the h.i.s, become"John""Peter and Paul were at the game...."the h.i.s, does not begin with a verb.Manelskl &Kru lee24EO:D2:DI:DII:EO:D2:DB:D4:D7:D9:EO:D2:DI:DII:EO:D2:D3:D4:fails to find a parsing.transfers control to D1.the h.i.s.
"John" has no marked words.the "previous i.s.
becomes the h.l.s.
"If John, Peter an__~d Paul were at the game,..."fails to find a parsing.transfers control to D3.calls sub-routine D4.Ir finds the marked "If" and "?
calling for TCOND.the h.l.s, become"John, Peter""Paul were at the gam2A..."and the i.s.
is marked as"If John, Peter and Paul were at the game&..."the h.l.s, does not begin with a verb.a satisfactory parsing cannot be found.transfers the processor to D1.there are no marked words in the h.i.s.the h.i.s, becomes"If John, Peter and Paul were at the gamez..."fails to flnd a parsing.transfers control to D3.calls D4.finds the "If" and "2" for TCOND.Manelski & Krulee25D7: the new h.i.s, is formed"John, Peter and Paul were at the game" (the remainderof the sentence is a separate h.i.s.
).the i.s.
is changed to"If John, Peter and Paul were at the game,..."D9: transfers the processor to EO.E0: analyzes the first h.i.s.
The program would thenanalyze the remainder of the sentence.As indicated in the above examples the parsing of the i.s.
isattempted by sub-routine E0, using the syntax specified in Table 2.
Thepresently implemented version of EO uses a bottom-to-top search in thesense that the parsing tree always begins by analyzing the input string1 rather than the set of productions.
In addition, the sub-routine is"predictive" in utilizing the productions to and establishing the nextsyntactic element.Syntax of the Predicate Forms (A2)The automaton A2 has as its domain the strings of L2.
However,its syntax is based on Reichenbach's methods of linguistic analysis.
Inthis section we will define a convenient formalism~ the predicate form,and discuss its syntax.
Later we will discuss how the processor discoversthe L3 (predicate function) mapping of an L2 string.
In defining thesyntax C of A2, it will be shown that U1  was designed in order to simplifyiFor a review of current parsing algorithms see Bobrow.M~nelski &KavA lee26the mapping into a predicate form.
As in~l ,  the patterns that can bespecified by a predicate form depend on the verb.
Thus, the forms fallinto four basic categories; equational, intransitive, transitive andfactitive forms.Equational Forms -PRED(ARG) Examples:PRED (~))PRED(ARG, ARG)Intransitive FormsPRED(ARG)John is home.
John is tall.There is a man.John is taller than Peter.The Dodgers win.The Dodgers win seldom.Transitive Fornm -PRED(ARG, ARG ) Tall John loves Mary.PRED(ARG, ARG, ARG) John saw Peter at the track.Factitive Forms -PRED(ARG, ARG, ARG) John elected Peter the chairman.With one exception the verb types used in the above classifica-tion follow conventional definitions.
However, following Sledd, factitiveverbs are also included.
Factitive verbs are transitive verbs that takean object complement.The following predicate functions show the L3 mappings of theexamples.
In order to avoid using Church's Lambda notation to bind thevariables, the convention of using upper case letters for the nonterminalelements and following them by the variables in lower case letters, isutilized to fully define the predicate function.Manelski & Krulee27(i)....... (ii)(iii)(iv)(v)(vi)(vii)(viii)(i~)PRED is home (ARG John)PRED is tall (ARG John)FRED is a man (ARG~PRED is taller than (ARG John, ARG Peter)PRED win (ARG The Dodgers)PRED win seldom (ARG The Dodgers)PRED loves (ARG Tall Johns ARG Mary)PRED saw at the track (ARG John, ARG Peter)PRED elected (ARG John, ARG Peter, ~LRG the chairman)One special characteristic of the mapping should be noted.
It is notnecessary that elements be contiguous for them to be bound to the samevariable.
Thus, the verb "saw" and the preposition "at the track" arenot contiguous in the string yet appear so in the function.
Thischaracteristic of the syntax has influenced the design of the processor,as will be made explicit in a later section.Using the syntax C shown in Table 3, and the same conventions forSyntax C for Predicate FormsI) PRED-~ PRED (PREDMOD)2) PREDMOD-~ PREDMOD, PREDMOD3) ARG --~ ARG (ARGMOD)4) ARGMOD-~ ARGMOD, ARGMODTable 3binding the variables, results in the following predicate functions forthe previous examples:Manelski & Krulee28(i)-(iv) identical(v) PRED win (ARG Dodgers (ARGMOD the)(vi) FRED win (PREDMOD seldom) (ARG Dodgers (ARGMOD The)(vii) FRED loves (ARe John (ARGMOD Tall), Mary)(viii) FRED saw (PREDMOD at the track)(ARG John, ARG Peter)(ix) PRED elected (ARG John, ARG Peter, ARG chairman(ARaMOD t e))The mapping from L2 to L3 has not been formalized by the syntax C.However, this syntax is implicit in the processor and will be describedin the same section.Description of the Canonical Form Processor (A?
)The predicate forms have been designed to mechanize efficientlythe problems of pattern recognition and of equivalence of strings byproviding a limited number of canonical forms or patterns to describe alarge number of natural language strings.
The syntax implicit in theprocessor for canonical reduction is quite simple as is shown in Table 4.It should be noted that the mapping presupposes a description in L2.Another implication is the necessity to order the arguments.
The orderingof arguments is not made explicit by the rewriting rules given; however,the ordering is implicit in the processor.
The rule followed in orderingarguments is simply defining each one as it is found in a left to rightscan of the L2 description.Manelski & Krulee291) PR O(?
)PRED(ARG)PRED(AR% ARG)PRED(ARG, ARG, ARG)2) NP--~ ARO3) VMEQ -~ PRED4) VMITR -~PRED5) VHrR-~ PRED6) VMEQ + ADJC ~ PRED7) VFAC -~ PRED8) ADJ -~ ARGMOD9) THAN (deleted)10) PREDEQ-~ ARGii) PADV--~ PREDMOD12) PRP --@ PREDMODTable 4The flow diagram of FO, designed to behave like the automaton~,  is described in Figure 4.
Although the syntax does not give a completedescription of how the L2 to L3 mapping should be carried out, it willbecome clear in the descriptions of the subroutines.
F1 is essentiallya hypothesis generator.
It examines the L2 input and decides on anappropriate canonical form.
Should it find the string L2 to havean equational verb, the possible canonical forms are:PRED(~)PRED(ARG)PRED(ARG, ARG) ?Manelski &Kru lee3oIntransitive verbs restrict us to the form:'~hen the string has a transitive verb, we choose between the canonicalforms:PRED(ARG, ARG)PRED(ARG, ARG, ARG).Finally problem strings with factitive verbs must follow the form:PRED(ARG, ARG, ARG)Sub-routine F1 searches the string and locates the main verb.The verb class is noted in order to establish the appropriate forms.When no verb is located, control is transferred to FlO, which notifiesthe programmer of the difficulty and stops.
Once a verb has beenlocated Fll generates a predicate form.
F12 copies the form as thecurrent prediction.
The next sub-routine is F2; it binds the words ofthe problem string to the form.
Thus, the words of each NP are bound toan ARG in accordance with a left-to-right scan of the problem string.~.2nen a one-to-one correspondence is established between the NPs and theARGs the processor transfers to F14.
F14 leaves all the names of theARGs on a pushdown list.
The next sub-routine is F13 which tests whetherthe pushdown list string named by the ARG is empty.
Should the llst beempty F6 is the next sub-routine; otherwise it is F~.
F4 tests whetherthere are any variables beside an N or PN in the ARG named on the push-down list.
If there are not the processor returns to F13.
Whenadditional words are found F5 rewrites the predicate form as~a ~ ~G(A~MOD)F13:F6:FT:F8:FO: ?
Star~F1: locatemain verb8 ~w me.
31 .~ ~ -'--->F~o.
~r~ ~Ow"Yll: generate a prediction ~ .
.YI2: copy prediction as - ~current predicate form ~ noI.
~ ~ F2: Bind the ARGs.
Does the number ofFI4: place names of variables foralocate verb and bind ?5: modify form and b:Lu~/are there variables for , > Yg: modii~ canonical forma PRE~0D?
Yes and bind variablenO ~Pr ln~ and  s topYlG.
4 "Manelski &Krulee32and erases the additional variables from the ARG and binds them to theARGMOD.
Following the execution of F5 the processor returns to F13.F6 locates the verb.
For transitive, intransitive, and factitive verbsall the words in VTR, VITR and VFAC are bound to the PRED of the form.For equational verbs, the processor searches to see if it is followed byan ADJC or a PRP; if it is, the ADJC or a PRP becomes part of the PRED.F7 searches for a PADV or a PRP on the tree of a PREDTR.
The wordsnamed by the PADV or PRP are bound to the PREDMOD.
Sub-routine F8 thenprints the L3 mapping of the problem string and halts the processor.The following example illustrates the flow of the program:InputS" l~  L2 = (S(NP(ADJ Big)(N John)) (VP(VEQ(VMEQ is) )(PREDEQ(PADJC(ADJC smarter) (THAN thanl(NP(N Paul))))))Fl: locates the main verb "is".
The available predicateforms are:PRED(~)PRED(ARG)PRED(ARG, ARG)FII: The form PRED(~) is generated.FI2: PRED(~) is the current form.F2: Since NP "Big John" is localized this predicate form isnot appropriate.
The executive returns to FII.FII: The form PRED(ARG) is generated.FI2: PRED(ARG) is the current form.F2: Since the NPs ~'Big John" and "Paul" are localized thisform is inappropriate.
Control returns to FII.Manelski & Krulee33FII:FI2:F2:FI4:FI3:F4:FI5:FI3:F4:F15:FI3:F6:The form PRED(AR%ARG) is generated.PRED(AR%ARG) is the current form.The NPs are in one-to-one correspondence with the ARGs.The variables are bound asPRED (ARG Big John, ARG Paul)and the executive transfers to F14.The names of the ARGs are placed in a pushdown list.Since the pushdown list is not empty control passes to F4.The first ARG in the pushdown list names 'Maul".
Thereis no ARGMOD so control passes to F15.Pops up the ARG naming "Paul".There is still an ARG name on the pushdown list.The ARG names "Big John"; so the output becomesPRED(~C Big John (ARG Mod)), ~a Paul)and then the var iab les  are rearranged asPRED(ARG John (tLRGMOD Big) ), ARG Paul) .Pops up the last ARG name.Since the pushdown list is empty the executive programcalls F6.Since L2 has a VEQ the PRED is bound asPRED is (ARG John (ARGMOD Big), ARG Paul)and then a further search is  made for an ADJC or PRP.The f~)JC naming "larger" is found so the predicatefunction becomes PRED is larger (ARG John (ARGMOD Big),ARG Paul) .Manelskl &Kru lee34FT: Since a PADV cannot be located and the verb is nottransitive (so there can be no PREDTR) the processorcalls sub-routlne F8.F8: The  predicate function is printed and the processorhalts.Recognition of Equivalent Strings (A3)Meaning equivalence is determined by A3 which attempts toapply a set of heuristically determined transformations in order toeliminate the differences between the strings ~-i and ~'j.
The set oftransformations TO was chosen on the basis that it is found useful in alarge class of problems taken from Stoll.
The set TO does not correctlysolve all premise equivalence problems.
Some examples will be givenwhere it is inadequate.The recognition of meaning equivalence is postponed until themapping to L3 is complete.
L3 was chosen to determine the patternclasses because the language not only orders the structure of L2~ butalso shows the dependencies between the elements of the language, andpermits us to manipulate easily the L3 representations ofG" i andO"j.The actual recognition of equivalence is determined by theset of transformations TO.Definition: The strings ~'l and~-2~ ~ L 3 are said to be"meaning equivalent" when we can find:(Ti(Tj'" "(Tm~l) 1) =6"2where the Ti~ Tj~...T m belong to the set TO.
Where:TO =~ TPRN, TIMP, TTIME, TSYN~Manelski & Krulee35The domain and the range of TPRN are the ARGs of the predicate forms.The transformation replaces the current ARG with the corresponding oneof the preceding premise.
A necessary condition for the application ofTPRN is that the first ARG be a pronoun in its L2 representation.
Forexample, let:i: John loves music.~'2: He dressed quickly.Their representation isPRED loves (ARG John, ARG music)PRED dressed (PREMOD quickly)(ARG He)The transformation TPRN~'-2) results inPRED dressed (PREDMOD quicl~ly)(ARG John)The implied transformation, TIMP, has a domain of the predicatefunctions with a null argument.
The transformation replaces the missingargument with that of the preceding premise.
For:~l: Dodgers won pennant.
The the: lost the serieswith a representation ofPRED won (ARG Dodgers (ARGMOD the), ARG Pennant(ARGMOD the))PRED lost (ARGO, ARG series (ARGMOD the)).TIMP (~-2) results in "the predicate functionPRED lost (ARG Dodgers, ARG series (ARGMOD the)).The time transformation, TTIME~ has as its domain the predicates.The range is also the predicates.
This transformation eliminates auxiliaryverbs and replaces the main verb with its root.
The main verb is deter-mined by the L2 representation of the string.
An example would be:Manelski & Krulee36~-l: John should go home.with ~,n L3 representationPRED should go (ARG John, ARG home)Thus TTIME ~l )becomesPRED go (ARG John, ARG home)The synonym transformation, TSYN, has a domain of the wordsWi~ L2.
Its range is also the words Wi~ L2.
The transformation isdefined by replacing any W i by its synonym as defined in the dictionaryof the processor.
The effect of TSY~ can be seen on~-le L1.~--l: John is happy.which has an L3 representationPRED is happy (ARG John)after TSYN(~'I) the predicate function might appear asPRED is glad (ARG John)This approach can certainly lead to difficulties.Some problems in semantics have been avoided.
A word can takeon various meanings depending on the context, as in:The bug crawled along the leaf.~ne b_~ in the program was found.He likes to bug me.The word bug takes on a different meaning in each sentence.
The mistakesthat transformations can lead to should be evident.
In some contexts theTSYN might be appropriate while in others it is not.Another type of difficulty that has not been considered inthe derivation of meaning equivalent strings is the following: OneManelski & Krulee37possible transformation contracts a number of arguments in the L3representation of a string.
Thus~l ,  0" 2 ~ L2.~l :  John hits the ball with the bat.~'2: John bats the ball.would have their respective representations as follows in L3:PRED hits (ARG John) ARG ball (ARGMOD the), ARG bat (ARGMOD the))PREO bats (ARG John, ARG ball (ARGMOD the))lBy changing the predicate, a 3 ARG function becomes a 2 ARGfunction with the same meaning.
By working with the set TO, the greatmajority of problems in Stoll are amenable to solution.
However, theprocessor is not capable of doing justice to the human abilities oflinguistic resolution.
One noticeable characteristic of utilizing TOas a recognition device is its tendency to err by not recognizingequivalent strings rather than by un~iustified recognition.Although this section defines the scope and effect of TO, itis also necessary to specify under what conditions the automaton attemptsto apply one of the transformations, and under what conditions theprocessor will stop trying to match the strings.
The criteria forapplying a member of TO, and the decision to halt, will.
be made explicitin the next section.i Example thanks to D. Kuck.Manelski & Krulee38Structure of the Equivalence Recognizer (A3)The flow chart (seeFigure 5) of GO was intended to implementA3.
Clearly, meaning equivalence, as defined by GO, can only be under-stood in light of the problem context.
Thus, in the formalization ofthe sentential calculus, we shall consider 1 and 2i: John will go home.2: John went home.as meaning equivalent, because in this problem context meaning is timeinvariant.
Obviously this is not true in conversational English.
Theprogram GO initially calls GI whose function is to test the number of~RGs in the problem strings.
Failing to find the number of ARGs to bethe same, control is passed to G3.
G3 is one of a set of sub-routines,including G13, G17, GI4 and GI5, designed to notify the programmer thatthe strings were not found to be meaning equivalent and briefly indicatethe reason.
Should the problem strings have the same number of ARGscontrol is passed to G4 which tests for equality of PREDs.
When thisrequirement is not met G5 is executed by dropping any VAUX and attemptingto find the root of the main verb.
If the existing differences are noteliminated by G5 the executive transfers control to G6.
This sub-routine,like G22, G21 and G20, attempts to eliminate the differences betweenstrings by using a dictionary search.
Sub-routine G7 tests the PREDMODsfor equality.
Uhen any differences in the PRtVDMODs are reconciled theexecutive program calls G8.
It also tests for identity in the sub-strings.In this case the matching is of the first ARG of each string, the secondARG of each string~ etc...until aGI7: prints"PREDMOD DIFF"G22: , re  nothe PREI~OD6synonyms ?
<L.
HIYesGO:GI:G2:GT:startinitialize storageDo a~ ana ~2 have the sameno.
uf ARGs?Yesare the FRED's of" o I  and sathe same?Inoare the PREDMODs of al and 02the same?
~ YesGS: are the ARGs of al and a2G3: Print "DIFF NOARGs"39@ "~no GS: eliminate roots..@ G~: are-~) and auxiliary Ithe FREDs Iverbs  J of a~.
and I/ a2 the // same ?
NdYes J /  /' ~ G6: are the ~'Gg:YesGI2:PRED'sYes~.~ stringssynonymsthe same?G21: are theree?noGI3: Po in t"PREDI DI~7PRED2"Print "ARGs DIFF".are the ARGMODS of ?I and "amthe same??
GIO: are there any \print "PREMH EQUIV," ' wor~ permutations?transformations used,and the strings on which GI6: Have G6 and GIO reducedthey are used the differences between/same differencesGIS: ,:pm?nt '~GDS DIYF" .FIG.
S ",Manelski &Kru lee4odifference is found in the strings.
A difference in the strings leadsthe processor to execute G20, GlO~ and G16.
As previously mentioned~G20 searches for synonyms.
G10 attempts to reduce differences byfinding permutations of the differing ARGMODs.
Finally, G16 keepstrack of the number of differences in the strings (based on the orderand symbols on each ARGMOD list).
~ When all differences are eliminatedcontrol is passed to a print routine, G12.
Should the number of differ-ences remain constant on successive executions of the G20, G10 and G16loop~ the processor calls sub-routine G15.
If the number of differencesis decreasing the loop is repeated.The following example illustrates the logic of the system:~J~ l: PRED is (ARG John(ARGMOD Big tall), ARG home)~'2: PRED is (ARG John (ARGMOD Tall large), ARG home)GO: Calls GI.GI: Initializes storage.G2: Both~" 1 andS- 2 have two ARGs so the executive calls G4.G4: Since both the ARGs have the PRED "is" control istransferred to GT.GT: There are no PREDMODs so the processor continues to G8.GS: ARGs are checked in order, firstQ- 1 andS- 2 are shownto have the same ARG "John"~ then the second ARGs areboth identified as "home".
Since no difference existsthe processor calls G9.G9: In the first ARG~DD the difference count is 2 since "Bigtall" and "Tall large" are both different symbols.
Nosecond ARC~MOD is located for e i ther~ 1 or~" 2.
Theexecutive program calls G20.Manelski & Kru.lee41G20:GIO:GI6:G20:GIG:G16:GI2:Attempts to locate "Tall' as a synonym for f'big" and"large" as a synonym for "tall", and fails in both cases.Notes that the difference count can be decreased byrearranging the ARGMODs as "Big tall" and "Large tall".Since the number of differences has decreased from 2 toi the executive returns to G20.This time the synonym "Large' is located for "Big"(assuming that the synonym is stored in the dictionaryDO).Since no differences are located by GI0 it cannot performany permutations.The differences between the ARGMODs of G- I and~ 2 havebeen eliminated so a transfer is made to GI2.The print out "PR~4S EQUIV" is followed by the fact thatthe transformation TGYN was necessary on "Big" and TPERMon "Tall large".Manelski &Kru leeh2SummaryThis completes our description of a processing system forproblems in the statement calculus.
The  system accepts problems asthey are normally written in English and attempts to produce aformalized equivalent as its outpu t .
It makes uses of a series ofautomata, the first of which attempts to identify the elementarypremises and the logical connectives.
Two additional automata areused in order to compare premises and to determine whether or not theyshould be identified as equivalent.
As a first step, each premise ismapped into a canonical form which simplifies the identification ofequivalent premises.
In the second step~ pairs of premises are compared.This automata makes use of a number of meaning-preserving transformations.In a sense, two premises are equivalent if one can be derived from theother with the aid of these transformations.
Otherwise, the premises areevaluated as not equivalent.
Although this processor is limited to aparticular class of problems~ it was designed with two purposes in mind:as an attempt to simplify the problems of communications betweenprogrammer and computer and to clarify those processes by means of whichmeaning is extracted from natural language.Manelski & ~ee43GLOSSARY OF ABBREVIATIONSh.i.s.i.s.l.h.s.n.w.f.s.p.o.s.r.h.s.hypothesized input stringinput stringleft-hand sidenot a well formed stringpart of speechright-hand sideManelski &Krulee44R  CESBobrow, D., "Syntactic Analysis of English by Computer - A Survey",Proceedings of the FJCC, 1963.Carnap, R., Introduction to Symbolic Logic and its Applications.New York: Dover, 1958.Chomsky, N., Syntactic Structures.
's-Gravenhage: Mouton, 1957.Green, B. F., Jr., Wolf, A. K., Chomsky, C., and Laughery, K., "Baseball:an Automatic Question-Answerer'.
Proceedings, Western Joint ComputerConference.
May, 1961, pp.
219-224.Krulee, G. K., Kuck, D. J., Landi, D. M., and Manelski, D. M., "NaturalLanguage Inputs for a Problem-Solving System".
Behavioral Science?July, 1964, pp.
281-288.?
"A Proolem Solver with Formal Descriptive Kuck, D. J , and Krulee, G. K.,Inputs".
Computers and Information Science.
Baltimore: Spartan,1964, pp.
344-374.Manelski, D. M., "A Heuristic Approach to Natural Language Processing",Unpublished Ph.D. thesis, Northwestern University, 1964.Newell, A.
(Ed.
), Information Processing Language-V Manual.
EnglewoodCliffs: Prentice-Hall, 1961.Newell, A., and Shaw, J. C., '!Programming the Logic Theory Machine".Proceedings~ Western Joint Computer Conference.
February, 1957,pp.
23O-24O.Reichenbach, H., Elements of Symbolic Logic.
New York: MacMillan, 1938.Manelski & Krulee45Sledd, J.~ A Short Introduction to English Grammar, Chicago: Scott,Fore smart, 1959.Stoll, R. R., Sets Logic and Axiomatic Theories.
San Francisco: W. H.Freeman, 1961.Walker, D. E., and Bartlett, J. M., "The Structure of Language for Manand Computer: Problems in Formalization"~ I nformati.on SystemScience and Engineering.
New York: McGraw-Hill, 1963.
