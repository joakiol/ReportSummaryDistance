FROM WATER TO WINE:GENERATING NATURAL LANGUAGE TEXTFROM TODAY'S  APPL ICATIONS PROGRAMS 1David D. McDonald2 Harrison AvenueNorthampton, MA 01060MCDONALD@CS.UMASS.EDUMarie W. MeteerBBN Laboratories10 Moulton St.Cambridge MA 02338MMETEER@G.BBN.COMABSTRACTIn this paper we present a means of compensatingfor the semantic deficits of linguistically naiveunderlying application programs without com-promising principled grammatical treatments innatural anguage generation.
We present a methodfor building an interface from today's underlyingapplication programs to the linguistic realizationcomponent Mumble-86.
The goal of the paper is notto discuss how Mumble works, but to describe howone exploits its capabilities.
We provide examplesfrom current generation projects using Mumble astheir linguistic component.INTRODUCTIONWork in artificial intelligence has two goals: onthe one hand to do concrete work that can be used inactual systems today, on the other to establish strongtheoretical foundations that will allow us to buildmore sophist icated systems tomorrow.Unfortunately, since the field is so young and so fewproblems are well understood, these two goals areoften at odds.Natural anguage generation is no exception.
Theyears of research in linguistics have made problemsin syntax comparatively well understood.Nevertheless, we should not restrict ourselves to justgenerating single, isolated sentences until theproblems of lexical semantics, discourse structure,and conceptual modeling are understood as well.
Wemust find ways to facilitate both efforts,modularizing our systems o that the parts that handlewell understood processes need not be compromisedto accomodate weaknesses in other parts of thesystem.
This paper is on how to support suchmodularity in a natural anguage generator.1 This work was supported in part by DARPA contractsN00014-87-K0238 at the Univerisity of Massachusetts andDAAA 15-87-C0006 CDRLA002 at BBN Laboratories, and bythe Rome Air Development Center contract number AF30602-81-C-0169, task number I74398 at the University ofMassachusetts.In the present case, the well understood process islinguistic realization, and the weaknesses are in theconceptual models and representations of theprograms underlying the generator.
To bridge thisgap, we present a specification language, to beused as input to the linguistic realization componentMumble-86.
2 This language provides the designer ofa planning component with a vocabulary of linguisticresources (i.e.
words, phrases, syntact icconstructions) and a straightforward means ofdirecting their composition.
The specificationlanguage facilitates interfacing Mumble to a widerange of underlying programs and planners.
Forsimple programs not built with language in mind, weshow a straightforward means of using predefinedtemplates to map underlying objects to complexlinguistic structures.
For systems with moresophistication in text planning, we show how thecompositionality and flexibility of the specificationlanguage can be used to make their task easier.
Whatis template driven at one end of the range can be builtcompositionally atthe other; what is stipulated at oneend can be reasoned about at the other.A MOTIVATING EXAMPLEConsider the description "53rd MechanizedDivision".
In most programs today a sufficientrepresentation f the object it names could be just thesymbol 53RD-MECHANIZED-DIVISION.
The printname of the symbol conveys all the information that aperson reading the code needs to know, without itactually playing a role in the program's reasoning.
Ifall we cared about were a single communicativecontext, we might consider implementing the linkbetween the symbol and the description as though thephrase were one long word without any internalstructure.
This expedient treatment would severely2 For a comprehensive description ofMumble-86, see Meteer,McDonald, Anderson, Forster, Gay, Huetmer, & Sibun 1987.41limit our options, however.
Indefinite references,such as "a mechanized ivision", and subsequentreferences, "the division", would have to be handledseparately.
Pronominalization would not be possiblesince there are no associated features uch as number,gender, and person.
Furthermore, since an artificialword would have no internal syntactic structure, aspeech production program would have noinformation on which to base intonation.
A bettertreatment is to introduce into the interface itself someof the generality and structure that the underlyingrepresentation is missing.In the ALBM interface being developed at BBN,we associate an object like 53RD-MECHANIZED-DMSION with the application of a general template toan explicit set of arguments as shown below:(define-default-specification'53rd-mechanized-division:template-name armed-forces-unit-name:arguments ("53rd" "Mechanized" "Division") )FIGURE 1By going to this slightly greater effort, we havesupplied a hook for handling subsequent reference orother abstractions ("the 53rd and 42nd mechanizeddivisions") without first requiring that the underlyingprogram contain the necessary semantic distinctionsand linguistic information.
We return to thisexample later and show how the template named inFigure 1 builds an input specification for Mumble.MUMBLE'S PLACEIN THE GENERATION PROCESS.A key question is what information the inputspecifications toMumble represent.
This amounts toasking how we take the generation process to divideinto subprocesses---what decisions have already beenmade and are reflected in the specifications, andwhich ones remain.
Since we have positioned thelevel of the specification language so as to fit thedecomposition reflected in our own work and toexpedite the use of Mumble-86 by other researchers,the answer can be given quite precisely.
For a morecomplete discussion of our approach and how itcontrasts with other work, see (McDonald, Meteer, &Pustejovsky, 1987).
Overall we can divide thegeneration process into three coarse stages:Under ly ing program- -  Developed inde-pendently of the generator per se, this will be theexpert diagnostician, cooperative database, ICAItutor, etc.
that the human users want to talk with.Some event within this underlying program willdetermine the goals the utterances are to achieve andinitiate the generation process.P lanning -- This process determines how thegoals can be achieved in a given context.
Thisincludes selecting the information to becommunicated (or omitted), determining whatperspectives and rhetorical organization theinformation should be given, and choosing a mappingfor the information onto the linguistic resources thatthe language provides (i.e.
open-class words andsyntactic onstructions).Rea l i za t ion - -Th is  process carries out theplanner's pecifications to produce an actual text.
Ithas the responsibility for insuring that the text isgrammatical, and will handle the bulk if not all of thesyntactic and morphological decision making.In these terms, Mumble-86 is a realizationcomponent.
3 As such, we expect any system that usesit to be able to supply the following kinds ofinformation about each utterance that it wantsproduced, couching the information in terms of ourspecification language.
Mumble-86 is agnostic as towhether this information was assembled by atheoretically interesting planning component ormerely stipulated in predefined templates.
(a) The units from which the utterance is to becomposed.
The mapping for each unit to its intendedlinguistic resource will either have been alreadymade or will be fully defined for later execution.
(b) The functional relationships among the units,e.g.
predication, head, modifier, given, theme, etc.,that direct or constrain the units' organization withinthe text.
(c) Lexical choice.
As the primary means ofdelimiting what information is or is notcommunicated and what perspectives andconnotations are presented, all open class words arechoosen by the planner.3 We also refer to Mumble as a "linguistic component",reflecting the fact that all of the planners and underlyingprograms that have been used with Mumble to date haveconcentrated onconceptual issues and left all of the linguisticefforts to it; this designation may have to change in the comingyears as the semantic and discourse l vel contributions of earliercomponents become more significant.42We see our specification language as providing amedium for the results of a planner's decisions.
Thesyntax of the language provides a flexible,compositional notation by which a planner may viewthe potential inguistic form of the utterance it isconstructing without having to understand the myriaddetails entailed by descriptions at the level of thesurface structure.
In the next section, we describe thesyntax of the specification language.
We then look athow predefined templates can be used to abstractaway some of the details to make it easier for aplanner to construct them.THE INPUT SPECIFICATION LANGUAGEMumble's input specifications may be seen asexpressions over a vocabulary of elementary termsand a syntax for their composition.
In defining thislanguage, our choice of terms and compositionaloperators was driven by what appears to be mostuseful at the linguistic level.
The simplestexpressions in the language, kernel specifications,represent the choice of a class of phrases with alexical head and the specification of its arguments.This reflects our belief that one almost never choosesjust to use a certain word, but rather to describe anaction with a verb and a specific set arguments forexample (see also Kegl, 1987).
The result ofrealizing a kernel is a phrasal unit comparable to anelementary tree of a Tree Adjoining Grammar.
(SeeJoshi, 1987, for a discussion of properties of a TAGwhich make them well suited to generation.
)Formally, a kernel consists of a realization functionand a list of arguments which are applied to it, wherea realization function is typically a class of phrasesdistinguished by the characteristics of the syntacticcontexts in which they may appear.
Executing therealization function consists of choosing among thephrases and instantiating the choice.Larger, more complex utterances are formed bycomposing kernels: joining them syntacticallyaccording to the relationships between them.
Thisprocess is analogous to adjunction in a TAG.
InMumble, these compositional expressions are calledbundles.
They have three major parts:(1) The head is either a kernel or a bundle; it isrealized first, as an "initial tree" into which otherspecifications are attached; every bundle must have ahead.
(2) Further-specifications have two parts, aspecification (either a kernel or a bundle) and anattachment function, which constrains where the newtree may be adjoined to the surface structure alreadybuilt; these correspond to the "auxiliary trees" of aTAG; a bundle may have any number of furtherspecifications.
(3) Accessor ies  contain information aboutlanguage-specific syntactic details, such as tense andnumber.
Each bundle type has a specific set ofobligatory and optional accessories associated with it.Note that bundles are not constrained as to the size ofthe text they produce: they may produce a singlenoun phrase or an entire paragraph.Figure 2 shows a representation of the inputspecification for the description "53rd MechanizedDivision" discussed at the beginning of the paper.
Inthe next section we describe how this specificationcould be built from an object in the underlyingprogram.#<bundle general-np:head #<kernel :realization-functionnp-common-noun:arguments ("division") >:further-specifications((:specification#<kernel :realization-function adjective:arguments ("53rd")>:attachment-function restrictive-modifier)(:specification#<kernel:realization-function adjective:arguments ("mechanized")>:attachment-function restrictive-modifier)):accessories (:number singular:gender neuter:person third:determiner-policy no-determiner >FIGURE 2Specifications are implemented as structuredobjects, indicated by the "#< ... >" convention ofCommonLisp; the first symbol after the "<" gives theobject's type.
Other symbols are either object names(e.g.
"general-np"), or in a few cases print forms ofwhole objects (such as the accessories and theirvalues).
Strings in double quotes (e.g.
"53rd")designate words.43DIRECT MAPPING: THE SIMPLE CASEThe granularity and vocabulary of the inputspecification language are designed to be well suitedfor generating natural language.
In principle thesemantic organization could match the structure ofthe specification language xactly.
If this were thecase, the mapping between units in the underlyingapplication program and the specifications to thegenerator would be direct and one to one.
However,we cannot assume that today's underlying programwill have the same granularity or be able to reason inthe same vocabulary.
For example, while theaccessories NUMBER, GENDER, and PERSON in thespecification above are necessary to determine thecorrect pronoun, few underlying programs workingwith mechanized divisions would bother to representtheir gender.
Rather than force a planner to deal inthese terms, we provide a framework for buildingspecifications piecemeal by applying templates thatcan be specialized to the application.
Templates areabstractions of specifications, which stipulate some ofthe terms in the specification and parameterizeothers.
An object in the underlying program may bemapped to a template through a default specification,as illustrated in Figure 1 and repeated below alongwith the template ARMED-FORCES=UNIT-NAME:(define-default-specification'53rd-mechanized-division: template-name armed-forces-unit-name:arguments ("53rd" "Mechanized" "Division") )(define-specification-templatearmed-forces-unit-name(number type size)(let ((K (make-a-kernel 'np-common-noun size))(B (make-a-bundle 'general-np)))(set-bundle-head B K)(neuter-&-third-person B)(singular B)(no-determiner B)(add-specializing-description(property-realized-as-an-adjective number)S)(add-specializing-description(property-realized-as-an-adjective type)B)B))FIGURE 3As a formal entity, this template is essentially aprocedure for assembling the data structures thatmake up a specification.
It is a Lisp program anddraws on a set of predefined functions (e.g.
set-bundle-head, no-determiner) to simplify thestatement of the necessary actions.
Every template isrequired to provide all of the elements that make up aproperly formed realization specification.
In thiscase a bundle for a noun phrase is being assembled,and so there must be a kernel built for the head of thebundle and values given for all the accessories thatbundles of that type require.
Since the phrasesspecified by this particular template are compositionslinguistically, i.e.
they involve the adjunction of twomodifiers to the inital np-common-noun, the templateincludes operations ("add-specializing-description")that add the sources of the modifiers using the properattachment function.These same techniques may be used to generatelonger texts.
The following example differs from thelast one in three ways:(1) The templates are building larger structures:discourse units which produce multiple sentences andclause bundles which produce complex sentences.
(2) Default mappings are defined between classesof objects and templates rather than having to define amapping for each instance of the class.
(3) Templates can be called explicitly from othertemplates with a dynamically chosen set ofarguments.The example is from one of the generation tasksin the ALBM domain: to produce a "missionrestatement" paragraph describing the essential tasksin some operation.
These tasks are presented to thegenerator as a simple list of TASK-OBJECTS,expressing the who, what, when, where, and why ofthe task, along with a dependency graph representingthe relations between them.
Figure 4 shows anexample of a task object and a portion of a missionrestatment paragraph produced by our currentprototype of the text planner.#<unit TO1.
ATTACK 4parent : #<unit TASK.OBJECT>slots :unit : #<unit 10TH-CORP>action: #<unit ATTACK>objective : #<unit NORTHEAST>intent : #<unit SECURE.
OBJECTIVES> >"lOth (U.S.) Corps attacks to the northeast osecure objectives, l Oth (U.S.) Corps exploits eastof Thuringer Wald.
"FIGURE 44 For brevity and clarity we use a textbook frame style ratherthan showing the actual KEE underlying representati~m; we alsoshow only the slots which directly impact this discussion.44Our prototype text planner takes advantage of theuniformity of the objects in the underlying programthat motivates the text and the uniformity in the formof the paragraphs tobe produced.
These uniformitiesallow us to use predefined templates for theseparagraphs in much the same way as McKeown usedschemas to produce the overall organization ofdefinitions of data base attributes (McKeown, 1985).Note that there are two very important assumptionsinherent in this approach: First, the informationneeded is explicitly represented in data structures inthe underlying program.
Second, those datastructures are stable, that is, in the lifetime of theproject, the structures will not change, or if they do,then the specific templates that access them mustchange as well.
(define-default-specification(k:unit 'K::task.object):template-name express-task:arguments ())(define-specification-template express-task 5 ()(let* ((r-fn (instantiate-mapping(k:unit(k:get.value self 'k::action))))(agent (instantiate-mapping(k:unit(k:get.value self 'k::unit))))(k (make-a-kernel r-fn agent))(loc (when(k:get.value self 'K::objective)(make-a-further-specification'location-modifier(instantiate-mapping(k:unit(k:get.value self'K::objective)))(intent (when(k:get.value self 'K::intent)(make-a-further-specification'rationale-modifier(k:unit(k:get.value self'K::intent))))))(funcall-template 'current-event-with-modifiersk loc intent)))FIGURE 55 Self is bound to the instance being mapped at the time themapping occurs; in this case, it is bound to the unit tol.attack.The top level function for generating the missionparagraph builds a discourse unit bundle with thefirst task-object as the head of the bundle and the restas an ordered list of further-specifications.
Since therelations between the task objects in this example issimply sequential-temporal, thedefault attachmentfunction "new sentence" is used, resulting asequenceof separate sentences, one for each task.Figure 5 shows the default specifications for theclass task-object and the template it references.This template is a specialist which picks out theinformation from the task object o be included in themission paragraph.
Note that the modularity of thetask objects is different from that of the actualsentences which express them.
The action and unitcombine to form the matrix of the sentence and otherslots function as adjuncts, such as the location andintent.
The template shown in Figure 6 combinesthese elements into a clause bundle and sets theaccessories tounmarked (not a question or command)and simple present tense.
These features arestipulated as part of the style of these paragraphsrather than stemming from anything in theunderlying representation.
(define-template current-event-with-modifiers(event &rest modifiers)(let ((b (make-a-bundle 'general-clause))(set-bundle-head b event)(present-tense b)(unmarked b)(dolist (m modifers)(add-already-built-further-specification m b)b))FIGURE 6In the examples described above, our use oftemplates is a shorthand for building realizationspecifications.
As such it is appropriate for the verysimple text planning that typifies today's generationapplications: Already formed objects andexpressions in the underlying application programcan be associated directly with semi-custom templateswith the English words introduced as arguments.
Inmore complex text planning where, for example, thesame objects are presented from differentperspectives depending on the communicat ivesituation, there is unlikely to already be anyexpression with the right properties, and it will be theplanner's task to construct one.
Here too, our facilityfor mapping objects to specifications will be veryuseful.45COMPOSING SPECIFICATIONSIn this section we look ahead to the developmentof general planners with the ability to dynamicallyselect and orchestrate information from theunderlying program to fit the occasion.
One of aplanner's prime abilities will be to appreciate thefunctions and consequences of alternative forms andcombinations by which the same body of informationcan be communicated.
Our specification languagepermits uch alternatives to be simply stated.
We cansee this in an illustration taken from our ongoingwork with the KRS system in use at the Rome AirDevelopment Center.
KRS ("Chris") is a rule basedsystem for mission planning.
Its in terna lrepresentation is based on instantiating relationsrepresented aslists of symbols: for example the threerelations shown below in Figure 7 ("facts" in thelefthand side of one of KRS's production rules),along with their English realizations as given by thedirect replacement generator presently included withKRS.
(target OCAI002 BE50318)(POWA BE50318 BES0318-Search-Radar)(IS-A BES0318-Search-Radar Electronics)The target of OCAIO02 is BE50318.
Part ofBE50318 is BE50318-Search-Radar.
BE50318-Search-Radar radiates.HGURE 7While perhaps good enough to serve its purpose(i.e.
as part of the KRS rule-editor), this text isunnatural--no person would ever say it.
Stylisticallyit is chunky and awkward, but more importantly, itactually mis-communicates the relative value of thethree facts by giving them equal weight in theutterance.A sophisticated text planner would want to conveynot just propositional information but also to indicateits rhetorical significance, e.g.
what is important,what is unusual.
In the present case, the fact about heassignment of the target was specified by the user andis thus a given.
The fact that the target has a searchradar may or may not already be known.
The factthat this particular adar is known to be active is themost significant, since it is this fact that has an impacton the planning of the mission (i.e.
there now have tobe radar-suppression aircraft included).Depending on whether or not the existence of thesearch radar is known, a much improved renderingof the three facts could be one of these two:"The target has an active search radar""The target's earch radar is active"Given that we will have already establ ishedmappings to suitable templates for each of the threefacts independently, the specification of a singlesentence xpressing all three becomes a matter ofcombining them into a single specification, varyingtheir positions as bundle heads or furtherspecifications and specifying the appropriateattachment functions.
This ability to combine partswithout affecting their internal structure is one of themost powerful aspects of our specification language.The specification for "The target has an activesearch radar" (Figure 8) would be built by using thesecond fact, "part of', as the backbone of the bundle,supplying the head and thereby the main verb has.The first fact-- (target .. .
8Es0310)--is then foldedin as the way of describing BE50318 (interpreting thefact as ascribing the functional role of "target" to itssecond argument, he "battle element"), and the thirdfact--(?sa .. .
electronics)--becomes a modifier inthe description of the search radar.Alternatively, to specify "The target's searchradar is active" (Figure 9), one would position thethird fact as the head of the bundle and use the firsttwo as the characterization of the search radar.
Asindicated on the two figures, these specifications areassembled from exactly the same three partialspecifications, but combined in different orders withdifferent attachment functions.Note that the pretty-pr int ing of thesespecifications i a little simpler than the earlier onesso as to conserve space, and that it includes anotherfield--"underlying-object"--to make the origins ofthe different parts of the specification clearer.One other point that may be unexpected is the factthat the Figures include two instances of thespecification for the search radar, one as the secondargument to have as we would expect, and a secondembedded within the first as part of the "clause"specification for (ISA .
.
.
electronics).
O f  course,if this second instance were missing--say as the resultof some planning-level abbreviation i  recognitionthat only the adjective within that specification wasgoing to actually appear in the final text--then theSpecifications in the two figures would not just besimple rearrangements of the same parts (ageneralization we consider valuable); instead wehave the selection of the adjective done as part ofrealization as one of the normal choices for simplepredications, under control of the position where thespecification is attached, i.e.
as a modifier to an NP.46#<bundle general-clause:underlying-object (POWA ... search-radar):head#<kernel HAVE-as-possession( #<bundle general-np:underlying-object BE50318:head #<kernel NP-common-noun k k("target")> k k:accessories (:number s ingu la r~:gender neuter:person third:determiner-policyalways-definite)> k#<bundle general-np:underlying-object BE50318-search-radar k:head #<kernel NP-common-noun("radar")>:accessories (:number singular:gender neuter:person third:determiner-policyalways-definite):further-specifications((:specification#<kernel cor~aon-noun("search")>:attachment-function classifier)(:specification#<bundle general-clause:underlying-object (ISA...electronics):head#<kernel predication_to-be(#<bundle general-np:underlying-objectBE50318-search-radar:head #<kernel NP-conunon-noun("radar")>:accessories :number singular:gender neuter:person third:determiner-policyalways-definite):further-specifications((:specification#<kernel con~non-noun("search")>:attachment-functionclassifier))>#<kernel ADJP-adjective("active")>) >>:attachment-function restrictive-modifier))> )>:accessories(:unmarked:tense-modal present)>#<bundle general-clause:underlying-object (ISA...electronics):head#<kernel predication_to-be( #<bundle general-np:underlying-object BES0318-search-radar:head#<kernel NP-common-noun("radar")>:accessories (:number singular:gender neuter:person third:determiner-policyalways-definite):further-specifications((:specification#<kernel common-noun("search")>:attachment-function classifier))(:specification#<kernel HAVE-as-possession( #<bundle general-np:underlying-object BE50318:head #<kernel NP-common-noun("target")>:accessories (:number singular:gender neuter:person third:determiner-policyalways-definite)>#<bundle general-np:underlying-objectBE50318-search-radar:head #<kernel NP-com~aon-noun("radar")>:accessories (:number singular:gender neuter:person third:determiner-policyalways-definite):further-specifications((:specification#<kernel common-noun("search")>:attachment-functionclassifier)):attachment-function possessive ))>#<kernel ADJP-adjective("active")>)>:accessories(:unmarked:tense-modal present)>'The target has an active search radar."
"The target's earch radar is active.
"FIGURE 8 HGURE 947CONCLUSIONThe specification language has been completelyimplemented and used in-house since the fall of 1986.The templates and the specifics of how objects andexpressions in underlying applications and plannersare to be linked to Mumble-86 have evolved over thattime and may continue to evolve somewhat as we getmore experience with other applications.
Mumble-86 itself is currently being used both for applicationsand as a research tool at a variety of sites includingthe University of Massachusetts, BBN Labs, RADC,and University of Pennsylvania.As part of an excercise in learning how to useMumble-86, two researchers from RADC, SharonWalter and Doug White, recently extended theprogram to generate in KRS's domain.
It took themonly two days to learn the specification language,build input specifications, and make the necessarygrammatical and lexical extensions to generateseveral sentences in their domain, including thoseshown in Figure 7.
Neither had used Mumble-86before.In conclusion we would like to emphasize twomain points.
The first is the importance ofmodularity in design and portability of the modulesso that research can concentrate on new and hardproblems without having to waste effort reinventingthe wheel.
Mumble-86 has been developed to be justsuch a portable module.
It has the responsibility forall syntactic decisions without making presumptionsabout he semantic model of the application programthat uses it.Our second point is that a designer should notcompromise the integrity of a well developed moduleto accomodate one which is less well developed whenthe two are brought together in the same system.This is the purpose of the input specification languagewe have introduced in this paper.
In developing thislanguage, we have clarified what decisions have to bemade outside Mumble-86 and which decisions are itsresponsibility, thus circumscribing its sphere ofinfluence and making it more useful as a domainindependent linguistic component and as a tool forresearch in text planning and discourse structure.REFERENCESJoshi, Aravind K. (1987a) "The Relevance of Tree AdjoiningGrammar to Generation", in Kempen (ed.
), p. 233-252.Joshi, Aravind K. (1987b) "Word-Order Variation in NaturalLanguage Generation", AAAI-87 Proceedings, p. 550-555.Kegl, Judy, (1987) "The Boundary Between WordKnowledge and World Knowledge", Proceedings ofTheoretical Issues in Natural Language Processing",Memoranda in Computer and Cognitive Science, NewMexico State University, p. 26-31.Kempen (ed.)
(1987) Natural Language Generation, MartinusNijoff Publishers, Dordrecht, The Netherlands.McDonald, David D., Marie W. Meteer, & James D.Pustejovsky (1987) "Factors Contributing toEfficiency inNatural Language Generation", in Kempen (ed.
), p. 159-182.McKeown, Kathleen R. (1985) "Discourse Strategies forGenerating Natural Language Text", Artificial Intelligence27, p. 1-42.Meteer, Marie W., David D. McDonald, Scott Anderson,David Forster, Linda Gay, Alison Heuttner, & PenelopeSibun, "Mumble-86: Design and Implementation", UMassTechnical Report 87-87, 173 pages.48
