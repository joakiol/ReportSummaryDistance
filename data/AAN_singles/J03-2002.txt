c?
2003 Association for Computational LinguisticsImplementing the Binding andAccommodation Theory for AnaphoraResolution and Presupposition ProjectionJohan Bos?University of EdinburghComputational aspects of Van der Sandt?s binding and accommodation theory (BAT) for presup-position projection and anaphora resolution are presented and discussed in this article.
BAT isreformulated to meet requirements for computational implementation, which include operationson discourse representation structures (renaming and merging), the representation of presupposi-tions (allowing for selective binding and determining free and bound variables), and a formulationof the acceptability constraints imposed by BAT.
An efficient presupposition resolution algorithmis presented, and several further improvements such as preferences for binding and accommoda-tion are discussed and integrated in this algorithm.
Finally, innovative use of first-order theoremprovers to carry out consistency checking of discourse representations is investigated.1.
IntroductionThe last decade has seen an increase of formal interest in combining what werepreviously thought as of being two distinct phenomena: anaphora and presupposi-tion.
In particular what I will refer to as binding and accommodation theory (BAT)(Van der Sandt and Geurts 1991; Van der Sandt 1992; Geurts 1999), in which presup-positional expressions are essentially analyzed as rich anaphora, played an importantrole here.
Not only does this theory help us gain new insights into the nature of pre-suppositions, it also accounts for an impressive range of problems related to linguisticbehavior of presuppositions.In this paper I will put BAT in a computational perspective.
The time is ripe toenter into this endeavor for two major reasons.
First, because BAT is stipulated inthe now well established and extensively formulated discourse representation theory(DRT) (Kamp and Reyle 1993), we have at our disposal a formalism covering a widerange of linguistic phenomena, including anaphora, plurals, tense, aspect, and scopeambiguities.
Second, recent results in automated deduction, especially the performanceof first-order theorem provers, open the doors for implementing a genuine inferencecomponent within a wider context of discourse processing (Blackburn et al 2001).This is important, because in BAT, reasoning is required for correctly dealing withpresuppositional phenomena.I start by giving an overview of linguistic aspects of the problems introducedby presuppositional expressions, summarize DRT, and show how BAT accounts forpresuppositional expressions (Section 2).
I then explain what constitutes a proper rep-resentation for presuppositions, give examples of lexical entries for presuppositiontriggers within a compositional framework, and introduce formal tools required for?
Division of Informatics, 2 Buccleuch Place, Edinburgh EH8 9LW, Scotland UK.
E-mail:jbos@cogsci.ed.ac.uk.180Computational Linguistics Volume 29, Number 2resolving presuppositions (Section 3).
After presenting this formal machinery, I presentan efficient version of the presupposition resolution algorithm in Section 4 and im-plement the various acceptability constraints imposed by BAT.
Finally, in Section 5,I discuss implementational issues and report on the performance of the algorithmagainst a corpus of route instructions, and I investigate the use of general-purposefirst-order theorem provers to carry out inference tasks imposed by BAT.2.
PreliminariesTo make this article self-contained, I will start by outlining the nature of presuppo-sitions and what kind of problems they impose that need to be solved by any natu-ral language understanding component performing discourse processing.
Then I willpresent BAT and show how it accounts for these problems.
Because BAT is presentedas an extension of DRT, part of this section will be devoted to summarizing the mainfeatures of DRT.2.1 Introducing PresuppositionsPresuppositions are those pieces of information that are taken for granted in a con-versation or discourse.
For instance, to make sense of (1),(1) Vincent and Jules managed to clean the car.we assume the existence of a car, two persons (named Jules and Vincent), and that thetwo persons found the car difficult to clean.
These implications deviate from ordinaryentailments.
Note that example (1) entails that the car is clean, whereas example (2),(2) If Vincent and Jules managed to clean the car, Jimmie would feel morecomfortable.does not, although example (2) includes some of the implications of example (1),namely, the existence of the two persons (Jules and Vincent) and the car, and thatthe two persons had difficulties in cleaning the car.
The propositions that are stillimplied, even after embedding in the conditional, are called presuppositions.
This isthe crucial property of presuppositions: They are the result of implications that ?sur-vive?
under negation and modal operators, in the antecedent of conditionals, and inquestions (Van der Sandt 1992).In English, most presuppositions in discourse are lexically driven.
This meansthat there are certain lexical items that give rise to presuppositions, whereas othersdo not.
In example (2), for instance, it is the definite article the that introduces thepresupposition that there is a car and the implicative verb to manage that introducesthe presupposition that Jules and Vincent had a hard time cleaning the car.
Suchexpressions are called presupposition triggers, and in the examples that follow, I willunderline ones relevant to each example.Presuppositions are an important linguistic device in conversation, because whenconveyed in utterances, they put constraints on the discourse context.
An appropriatecontext for example (1) is, for instance, example (3):(3) Jules and Vincent were driving in a car on their way to Jimmie.
Due toan accident, it was completely covered with blood, and they had to cleanit in short time before Bonnie (Jimmie?s girlfriend) would find out.Finally, Vincent and Jules managed to clean the car.181Bos Implementing Binding and Accommodation TheoryWhereas the discourse in example (1), in isolation, presupposes the existence of a car,a context as set up in example (3) does not, for the trivial reason that there is a carintroduced in the context itself.
So (linguistic) contexts may contain information that?cancels?
the presuppositions of a new contribution to the discourse or conversation.Therefore, terminological use in the literature on presupposition includes part-time orelementary presuppositions, to signify that presuppositions, once introduced by thetrigger sentence, may be canceled by a context.In contrast, consider the discourse in example (4), which is perceived as slightlyodd.
This perception of oddness is caused by the incompatibility between the contextas set up by the first two sentences (namely, that there is a clean car) and the presuppo-sition introduced by the third sentence (that Jules and Vincent had difficulties cleaningthe car).
The concept of incompatibility, or better, inconsistency, plays a central rolein BAT, the theory of presuppositions in which I will base the resolution algorithmpresented in this article.
(4) Jules and Vincent were looking after a car.
The car was not dirty at all.But Vincent and Jules managed to clean the car.2.2 The Binding Problem, the Projection Problem, and AccommodationBy and large, there are three important themes related to presupposition: the bindingproblem, the projection problem, and accommodation.
Almost all of the theoreticalliterature on presuppositions deals with these issues, and any computational account ofpresupposition has to say something about them.
Let?s first turn to the presuppositionbinding problem.
An example like (5),(5) A boxer nearly escaped from his apartment.will clarify what comprises the binding problem.
The trigger his induces the presuppo-sition that a male individual has an apartment.
However, it does not presuppose thatjust any male person has an apartment, nor that some boxer or other creature ownsan apartment.
It is the boxer who escaped who has an apartment.
That is, the existen-tially quantified noun phrase a boxer ties together two types of information: ordinaryasserted information (namely, that a boxer nearly escaped from an apartment) and pre-suppositional information (the apartment mentioned in the assertion belongs to theboxer mentioned in the assertion).
As assertions and presuppositions obey differentlaws, it is no trivial matter to tie them together, and many accounts of presuppositionhave been shipwrecked on this rock (Van der Sandt 1992, pages 337?340).The presupposition projection problem manifests itself in complex sentences.Presupposition triggers occurring in complex sentences, such as conditionals or dis-junctive sentences, sometimes are projected onto the context, but sometimes disappear.For instance, example (6)(6) If Mia dates Vincent, then her husband is out of town.is a sentence presupposing that Mia has a husband.
But the similarly constructedsentence in example (7) does not carry this presupposition:(7) If Mia is married, then her husband is out of town.182Computational Linguistics Volume 29, Number 2This sentence does not presuppose that Mia has a husband.
It is the bringing about ofMia?s marital status in the antecedent of the conditional that neutralizes the presuppo-sition of Mia?s being married.
Hence, in complex sentences there is no systematic wayfor dealing with presupposition triggers, as sometimes subparts of complex sentencescarry presuppositions that are canceled in the main sentence.Finally, let us consider presuppositional accommodation, as characterised by Kart-tunen (1974) and later formalized by Lewis (1979).
I believe that accommodation playsa role in two related but different linguistic situations.
The first of these is one in whichpresuppositions assert new information to the common ground without violating dis-course coherency.
The second situation is one best described as a hearer?s discourse?repair strategy.?
Examples (8) and (9) illustrate the first type:(8) Vincent informed his boss.
(9) Butch didn?t realize there was a difference between a tummy and apotbelly.The presuppositions conveyed by these utterances are that Vincent has a boss andthat there is a difference between a tummy and a potbelly.
Hearers have no problemsaccommodating these presuppositions into the common ground, even in cases in whichthe context includes no previous mention of them.
Only if the discourse built up so faris incompatible with Vincent?s having a boss (maybe he is a freelancer), then a hearerwould probably refuse to accept example (8).
But with the absence of informationas to whether Vincent has a boss, the hearer adjusts his or her presuppositions tomake sense of the new utterance or sentence.
This is referred to as presuppositionalaccommodation.Thus, presuppositions are, under certain circumstances, able to present new infor-mation to the discourse.
However, the level of acceptance of accommodation differsconsiderably from context to context and according to the type of trigger used (Beaver2002) and also depends on whether the hearer has access to context or not.
Presup-positions triggered by genitive constructions (as in example (8)) and factives (as inexample (9)) are known to accommodate easily.
Most other presupposition triggers donot allow accommodation, because doing so would lead to incoherent discourse.
Con-sider the following dialogue between Butch and his girlfriend after Butch has foughta match:(10) Fabian: What about the man you fought?Butch: Floyd retired too.Butch?s utterance in this dialogue presupposes that someone distinct from Floyd re-tired, a presupposition that is trivially true, as many people have retired already.
Butspoken without the knowledge that Butch ended his career, example (10) is odd, anda hearer will most likely start a clarification dialogue in such cases.
However, exam-ple (10) is completely acceptable when one knows that Butch decided to retire afterhis fight with Floyd.Nevertheless, although hearing example (10) in an ongoing dialogue without anymention of Butch?s planning to retire will certainly raise some eyebrows, somebodywho just joins an ongoing conversation and hears it will probably accommodate theassociating presupposition, expecting that one of the topics addressed in this conver-sation was the retirement of somebody different from Floyd.
This is when the other183Bos Implementing Binding and Accommodation Theoryrole of presuppositional accommodation comes into play, constituting a situation inwhich hearers don?t have access to the context and use accommodation as a repairstrategy.2.3 Discourse Representation TheoryPresupposition is a genuine discourse phenomenon.
It should not come as a surprisethat an adequate semantic theory for presuppositions would benefit from a formulationin a dynamic theory of meaning.
Indeed, BAT is set in DRT (Kamp 1981; Kamp andReyle 1993; Van Eijck and Kamp 1997), and because it heavily depends on it, I willbriefly summarize the most prominent features of DRT here.DRT is one of several formal semantic frameworks designed to deal with theproblems related to discourse anaphora, but it is certainly unrivaled with respect toits impressive coverage of linguistic phenomena.
Alternative formalisms for discoursesemantics are file change semantics (Heim 1982) and dynamic predicate logic (Groe-nendijk and Stokhof 1991).
The latter uses the syntax of ordinary first-order predicatelogic, but with a different ?context change potential?
semantics, allowing existentialquantifiers to bind variables outside their syntactic scope.The linguistic phenomena that led to the development of dynamic theories suchas DRT were mainly centered on the problems introduced by anaphora and indefi-nite noun phrases.
Because anaphora are able to operate on an intersentential level,the traditional method of assigning closed formulas to sentences caused problems fordiscourse processing, and one had to resort to a number of ad hoc techniques for con-structing the first-order formulas for natural language discourses.
An appropriate first-order logic formula for the sentence A woman snorts would be ?x(WOMAN(x)?SNORT(x)),but if one continues the discourse with She collapses, there is a need to alter the for-mula into something of the form: ?x(WOMAN(x) ?
SNORT(x) ?
COLLAPSE(x)).
In otherwords, one has to extend the scope of the existential quantifier introduced in thetranslation of the first sentence to cover elements introduced in the second sentence.The so-called donkey sentences of Geach (donkeys and farmers were the main char-acters in the example sentences of Geach, which led to increased study of indefinitenoun phrases and pronouns within formal semantics) caused similar composition-ality problems.
Although indefinite noun phrases normally invoke existential quan-tification, a proper first-order translation of Every woman that gets a foot massage en-joys it would result in a formula in which the variable introduced by the pronounit is bound by the universal quantifier stemming from a foot massage, as shown byexample (11):(11) ?x?y(WOMAN(x) ?
FOOT-MASSAGE(y) ?
GET(x, y) ?
ENJOY(x, y))DRT deals with these problems by introducing an intermediate level of semanticrepresentation: discourse representation structures (DRSs).
DRSs are pairwise struc-tures consisting of a set of discourse referents, which stand for the entities that areintroduced in the discourse, and a set of conditions, which describe the propertiesof these entities.
Discourse referents function like quantifiers, in that they are able tobind variables appearing in DRS-conditions.
However, the quantificational force of dis-course referents depends on their structural embedding.
DRSs are recursive structures,and DRSs embedded in the antecedent of an implicational condition give universalquantification to their discourse referents, whereas all other contexts assign existen-tial quantification (the translation from DRSs to formulas of first-order logic given inSection 3 illustrates this nicely).184Computational Linguistics Volume 29, Number 2Traditionally, a DRS is presented as a boxlike structure, with discourse referentsin the top part and conditions in the lower part of the box.
The DRS for the examplegiven earlier is shown in example (12).
(12) A woman snorts.
She collapses.x yWOMAN(x)SNORT(x)y=xCOLLAPSE(y)Here x and y are discourse referents for a woman and she, respectively.
The anaphoriclink between she and a woman is established by the condition y = x, and illustratesthe role of discourse referents: They introduce discourse entities to which pronounspotentially can refer.
In other words, discourse referents are candidate antecedents forfuture anaphoric reference.The key idea underlying DRT is that discourse referents appearing in embeddedDRSs are not available as antecedents for pronouns.
The internal structure of DRSsplays a central role in determining the possibility of anaphoric links between pro-nouns and their potential antecedents.
Indefinite noun phrases always introduce theirdiscourse referents locally1 and hence are not accessible from outside a negation orimplication.
This is shown in the following examples, in which pronouns markedwith an asterisk have no proper anaphoric antecedent (narrow-scope interpretationof the indefinite noun phrases is assumed in the examples, because in certain cir-cumstances a wide-scope interpretation of indefinite noun phrases allows anaphoriclinks):(13) Butch has a valuable watch.
He keeps it in his apartment.Butch has no valuable watch.
He keeps it?
in his apartment.If Butch has a valuable watch, he will take care of it.
He keeps it?
in hisapartment.Mia ordered a five dollar shake.
Vincent tasted it.Mia didn?t order a five dollar shake.
Vincent tasted it?.In the utterances of example (13), the discourse referents for a valuable watch and afive dollar shake are introduced in subordinated DRSs, excluding anaphoric links topronouns in subsequent sentences.
The DRS in example (14) shows how DRT dealswith these observations: Because the discourse referent y introduced for a five dollarshake is part of an embedded DRS (introduced by negation), it is not accessible for u,the referent introduced for the pronoun it:1 I am disregarding wide-scope or specific readings here.185Bos Implementing Binding and Accommodation Theory(14) Mia didn?t order a five dollar shake.
Vincent tasted it?.x z uMIA(x)?yFIVE-DOLLAR-SHAKE(y)ORDER(x, y)VINCENT(z)TASTE(z, u)u=?
?In other words, negation blocks anaphoric links.
Similar anaphoric behavior is shownby disjunctive clauses (Kamp and Reyle 1993, page 185) and implicational sentences.The latter introduce DRS-conditions of the form B ?
B?, where discourse referentsdeclared in B are accessible from B?.
Example (15) illustrates this:(15) If Butch has a valuable watch, he will take care of it.
He keeps it?
in hisapartment.x u vBUTCH(x)yVALUABLE-WATCH(y)HAVE(x, y)?u vWILL-TAKE-CARE-OF(u, v)u = xv = yAPARTMENT(z)KEEP-IN-HIS-APARTMENT(u, v)u = xv =?
?The accessibility relation in DRT governs possible links between anaphoric expres-sions and their potential antecedents.
It is defined on the structure of DRSs, which isnormally stated in terms of subordination, a transitive relation.
A DRS B subordinatesa DRS B?
if B?
appears as a condition of B as argument of a negation, disjunction, orantecedent of a conditional, or if they form a DRS-condition of the form B ?
B?.
Iwill merely make use of the term accessibility path, a list of DRSs, ordered by DRSsubordination, to express accessible discourse referents for anaphoric expressions.Finally, let us consider proper names.
Proper names, once introduced in discourse,always seem available for future anaphoric reference, and so do first- and second-person pronouns.
Therefore, in DRT, their discourse referents are introduced at theglobal level of DRS, even in cases in which they are realized as part of a subordinatedcontext, as for the proper name Butch in Example (15).2.4 Binding and Accommodation TheoryIn BAT, presuppositions obey similar principles as anaphora do: Presuppositions areresolved to an antecedent, and moreover, resolution of presuppositions is constrainedby discourse structure in the same way DRT defines accessibility of antecedents forordinary pronouns.
According to Van der Sandt, the main difference between presup-186Computational Linguistics Volume 29, Number 2positions and pronouns is that the former have descriptive content, which the latterlack.To integrate presuppositions into the representation of discourse, Van der Sandtintroduces sentence-DRSs, DRSs that are defined as a triple of a set of discourse ref-erents, a set of conditions, and a (possibly empty) set of DRSs (Van der Sandt 1992,page 354).
This set is referred to as the A-structure, the set of anaphoric DRSs.
This def-inition is recursive, so it allows embedded anaphoric structures inside other anaphoricstructures.
Sentence-DRSs are preliminary representations, and no model-theoretic in-terpretation is defined for these structures.
A completely resolved sentence-DRS (henceall of its A-structures are empty) is identical to an ordinary DRS, and is called a properDRS.Throughout this section and the next one, I will depict sentence-DRSs as boxesdivided into three parts, with the discourse referents at the top, the conditions atthe bottom left, and the A-structure at the bottom right.
Given this definition andnotation of sentence-DRSs, let us consider some examples of presupposition triggersand explain BAT.
For instance, Butch?s utterance in example (10) will be associatedwith the following DRS:(16) Floyd retired too.xFLOYD(x)RETIRE(x)?
x=yyRETIRE(y)This sentence-DRS (let us call it B) contains a presuppositional expression, namely, theone triggered by the particle too.
Given a context associated with another DRS C, B isresolved by merging C with B (merging here meaning taking the unions of the sets ofdiscourse referents, conditions, and A-structures), followed by resolving all membersof the A-structure to accessible discourse referents.
The resolution process, as Van derSandt (1992) formulates it in his article, is here only informally described, by meansof giving an example.
Assume that in the previous context DRS C just describes thatButch retired; then merging C with B yields a DRS in which the sets of discoursereferents, conditions, and A-structures from both DRSs are unified:(17) Butch retired.
Floyd retired too.u xBUTCH(u)RETIRE(u)FLOYD(x)RETIRE(x)?
x=yyRETIRE(y)In principle, sentence-DRSs can have any number of anaphoric entities in theirA-structures.
In our example, the A-structure consists of one DRS.
Now, resolving187Bos Implementing Binding and Accommodation Theoryelements of the A-structure is subject to either binding or accommodation.
Let usfirst look at binding.
Members of the A-structure can be bound by an accessible an-tecedent.
Note that elements of the A-structure are resolved only if their A-structuresare empty.
Nested anaphoric structures are thus resolved by resolving the most deeplynested anaphoric DRS first.
Binding proceeds by identifying the discourse referentswith established referents and transferring their associating conditions to the bindingsite (Van der Sandt 1992, page 357).Now let us consider accommodation.
This option resolves a member of the A-structure by creating an antecedent and becomes available if no suitable antecedentfor an anaphoric expression can be found.
Accommodation is accomplished by trans-ferring the anaphoric referent, including its conditions, to the accommodation site(which, as with binding, must be an accessible DRS).Going back to our example, we resolve the anaphoric DRS by appealing to thebinding option.
The anaphoric discourse referent x is identified by the accessible dis-course referent y, and all the conditions belonging to y are transferred to the bindingsite.
This gives us the following DRS:(18)u x yBUTCH(u)RETIRE(u)FLOYD(x)RETIRE(y)u=yRETIRE(x)?
x=yThis DRS contains an empty A-structure and hence is a proper DRS.
Note that ac-commodation would yield a similar DRS, with the only difference being the lack ofthe equality condition.
Further, according to BAT, accommodation can be applied toany level of discourse, and to indicate these possibilities for accommodation at vari-ous levels, the concepts of global, intermediate, and local accommodation are used,corresponding to the various landing sites for a presupposition.
Hence, in more com-plicated examples, binding and accommodation give rise to several possibilities, andVan der Sandt?s algorithm will yield a large number of potential solutions.
These so-lutions are filtered by a number of constraints, some of which I will introduce below,when I discuss how BAT deals with the binding problem and presupposition projec-tion.
These acceptability constraints will be discussed and implemented in detail inSection 4.3.BAT tackles the projection problem by imposing several constraints with respectto consistency and informativeness.
The local versions of these constraints imposethe requirement that sub-DRSs (DRSs that are embedded in conditions of DRSs) beinformative and consistent with respect to the information that subordinates them.These acceptability constraints can be viewed as the pragmatic component of BAT,because there is a clear correspondence to the Gricean conversational maxims (?do notsay what you believe to be false,?
?do not say things that are irrelevant,?
and so on).
Asan illustration of local informativeness, consider example (19).
Global accommodationof her husband is impossible here, because the sentence does not presuppose that Miais married.
BAT predicts this, because example (19) violates local informativeness: Theantecedent DRS of the conditional does not contain new information with respect to188Computational Linguistics Volume 29, Number 2the global DRS (using background knowledge that women who have husbands aremarried).
(19) If Mia is married then her husband is out of town.
(global accommodation)x yMIA(x)HUSBAND(y)OF(y,x)MARRIED(x) ?
OUT-OF-TOWN(y)Whereas the acceptability constraints rule out example (19) as a possible inter-pretation, there are other possible interpretations because of the availability of otheraccommodation sites for Mia?s husband.
One of these possibilities, intermediate ac-commodation, is shown in example (20) (a third possibility, not shown here, is localaccommodation, in which the consequence of the implicational condition is the land-ing site for the presupposition).
Intermediate accommodation does not violate localinformativeness here: All the sub-DRSs are informative with respect to their globalcontext.
(20) If Mia is married then her husband is out of town.
(intermediateaccommodation)xMIA(x)yHUSBAND(y)OF(y,x)MARRIED(x)?OUT-OF-TOWN(y)BAT masters the binding problem by combining presupposition and assertioninto one semantic representation that allows shared use of discourse referents.
Thisis shown by the DRS for example (21) (in which his has already been resolved to theboxer, and his apartment is still subject to resolution):(21) A boxer escaped from his apartment.xBOXER(x)NEARLY-ESCAPE-FROM(x,y)yAPARTMENT(y)OF(y,x)The shared representation solves the binding problem, but as a direct consequence,accommodation might result in ill-formed DRSs.
To overcome this, there is a furtheracceptability constraint on resolution, known as the free variable trap, which imposesthe requirement that DRSs resulting from the resolution algorithm not contain freevariables.
This prevents global accommodation of his apartment in example (22).189Bos Implementing Binding and Accommodation Theory(22) Every boxer escaped from his apartment.xBOXER(x) ?
ESCAPE-FROM(x,y)yAPARTMENT(y)OF(y,x)To sum up, BAT gives us three important insights with respect to resolving pre-suppositions.
First of all, the resolution algorithm used in BAT is nondeterministic,so several ways of interpreting presuppositions are possible.
In most cases, there isa clear preference for certain of these interpretations, but in others, presuppositionspresent genuine ambiguities.
Second, presuppositional binding involves compatibilitywith, rather than entailment of, its antecedent.
This ?matching?
feature enables pre-suppositions to add information to the discourse, even if they are bound to an an-tecedent rather than accommodated.
Finally, by treating presupposition on a par withanaphora, BAT kills two birds with one stone.
The resolution algorithm will coverboth anaphora and presuppositions, and additional resources for resolution (such asmechanisms for preference ranking) will help in dealing with both anaphora andpresupposition.3.
Representing Discourse and PresuppositionsThis section is concerned with proper representations for discourse and presupposi-tion, with the interpretation of discourse (aiming to being able to perform inferences),and further provides tools necessary for discourse processing and presupposition res-olution.
I will start with some formalities and define the syntax of standard DRSs andthe syntax of ?-DRSs (DRSs that contain unresolved presuppositions).
I will argue thatthe representation for sentence-DRSs, as originally introduced for presuppositions inBAT, is insufficient for several interpretation tasks and introduce a new format.3.1 Representing and Interpreting DiscourseDRSs capture the semantic content of a discourse.
They form the medium for discourseunderstanding, because they come with a model-theoretical interpretation.
The inter-pretation given here is one via a translation to first-order logic.
This is advantageousfrom a practical and computational perspective, because one can use automated the-orem provers for first-order logic to implement some of the acceptability constraintsimposed by BAT or indeed carry out other kinds of inferences not related to anaphoraresolution and presupposition accommodation.The syntax of DRSs and DRS-conditions is defined by simultaneuous recursion,with respect to a set of first-order variables and a vocabulary describing the predicatesymbols and their respective arities.DefinitionThe syntax of DRSs and DRS-conditions is defined according to the following sevenclauses:1.
If {x1 .
.
.
xn} is a finite set of variables, and {?1 .
.
.
?m} is a finite set ofDRS-conditions, then the ordered pair ?
{x1 .
.
.
xn}, {?1 .
.
.
?m}?
is a basicDRS.190Computational Linguistics Volume 29, Number 22.
If R is a relation symbol for an n-place predicate and x1 .
.
.
xn arevariables, then R(x1, .
.
.
, xn) is a basic DRS-condition.3.
If x1 and x2 are variables, then x1 = x2 is a basic DRS-condition.4.
Every basic DRS-condition is a DRS-condition.5.
If B is a DRS, then ?B, ?B, and ?B are DRS-conditions.6.
If B1 and B2 are DRSs, then B1 ?
B2, and B1 ?
B2 are DRS-conditions.7.
If x is a variable and B is a DRS, then x : B is a DRS-condition.Given a DRS B = ?D, C?, D is called the domain of B, members of C are theconditions of B, and members of D are called B?s discourse referents.
Clause 1 ofthe definition defines DRSs in the standard way.
The basic conditions (clauses 2?3)are defined just as in standard DRT.
Clause 5 introduces negation and the modaloperators, and clause 6 disjunction and implication.
Clause 7 is nonstandard; it in-troduces a modal operator that explicitly associates variables ranging over possi-ble worlds with DRSs.
It is therefore related to constructs used in hybrid logics(Blackburn 2000).
We will use it in our fragment of English to represent sententialcomplements.DRSs are interpreted in an indirect manner, with the help of a translation functionthat maps DRSs to first-order formulas (under the same vocabulary of predicate sym-bols and with respect to the same set of variables).
This translation is implementedas the function (.,.)
fo, from first-order variables (ranging over possible worlds) andDRSs to ordinary first-order formula syntax.
The complete translation is shown in thefollowing definition.DefinitionThe translation (.,.)
fo from DRSs to first-order logic is defined according to the follow-ing nine clauses:1.
(w,x1 .
.
.
xn?1 .
.
.
?m) fodef= ?x1 ?
?
?
?xn((w, ?1) fo ?
?
?
?
?
(w, ?m) fo)2.
(w, R(x1, .
.
.
, xn)) fodef= R(w, x1, .
.
.
, xn)3.
(w, x1 = x2) fodef= x1 = x24.
(w,?B) fo def= ?
(w, B) fo5.
(w, B1 ?
B2) fo def= (w, B1) fo ?
(w, B2) fo6.
(w,x1 .
.
.
xn?1 .
.
.
?m?
B) fo def= ?x1 ?
?
?
?xn(((w, ?1) fo ?
?
?
?
?
(w, ?m) fo) ?
(w, B) fo)7.
(w,?B) fo def= ?v(R(w, v) ?
(v, B) fo)8.
(w,?B) fo def= ?v(R(w, v) ?
(v, B) fo)9.
(w, v : B) fo def= (R(w, v) ?
(v, B) fo)191Bos Implementing Binding and Accommodation TheoryThis translation from DRSs to first-order logic is based on the one given in Kampand Reyle (1993) extended with Moore?s proposal for modal operators (Moore 1980).It behaves linearly on the size of the input, so the computational overhead is keptlow.
I will use it to implement the acceptability constraints imposed by BAT on pre-supposition resolution that require inference, to wit, the check for consistency andinformativeness.3.2 Representing PresuppositionsWhat is a proper representation for elementary presuppositions?
There seems to becommon agreement, in most of the accounts in presupposition theory, that presuppo-sitions represent expressions of propositional type.
Hence, to use a DRS to representa single presupposition seems a natural choice.But there are further issues that play a role in deciding a suitable representationfor presuppositions.
Two operations on DRSs used in BAT are merge reduction andpresuppositional binding,2 and both require a precise definition of free and bound vari-ables.
However, sentence-DRSs allow ?ambiguous?
bindings.
Consider, for instance,the DRS in example (23) (again I will underline the relevant presupposition triggersin the following examples):(23) A man smiles.
The woman smokes.xMAN(x)SMILE(x)SMOKE(x)xWOMAN(x)This sentence-DRS contains an A-structure with a single DRS.
It is unclear whether theoccurrence of variable x in the condition SMOKE(x) is bound by the discourse referentx in the outermost DRS or by the discourse referent declared in the DRS within theA-structure.
Following the definition of sentence-DRSs, the discourse referent x in theA-structure does not in fact bind the occurrences of x in the main DRS.
Furthermore,given the fact that A-structures can host more than one DRS, situations with ambiguousbindings might appear easily.These unintuitive and ambiguous bindings are unpleasant and force one to recon-sider representing unresolved anaphoric expressions in DRT.
The representation that Iprefer uses a new operator, ?, combining two DRSs to form a new DRS.
This disallowsambiguous bindings while keeping the same expressive power:(24) A man smiles.
The woman smokes.
(xMAN(x)SMILE(x);(xWOMAN(x)?SMOKE(x)))2 I am considering presuppositional binding in which, after identifying the antecedent discourse referent,all bound occurrences of the anaphoric discourse referents are replaced by the variable name of theantecedent referent.
This operation is preferred to adding an equality condition between the antecedentand anaphoric referent to the DRS, for two reasons: It decreases the search space for findingantecedents during subsequent instances of presupposition resolution, and it makes the inferenceproblems derived from these DRSs less difficult.192Computational Linguistics Volume 29, Number 2I believe that the representation in example (24) is more intuitive as well, because it ispresupposition that comes first in an utterance.
The ?
operator reflects this, because itsleft argument is the presuppositional part, and its right argument the assertive part.Like A-structures, the ?
operator allows recursion and therefore nested presupposi-tions.I would like to address another representational issue here.
In Van der Sandt?s(1992) original formulation of BAT, all discourse referents appearing in the domainof a DRS in the A-structure are anaphoric.
This leads to unexpected behavior, asexemplified by the sentence-DRSs for the two sentences in example (25):(25) The boy with a gun fires.FIRE(x)x yBOY(x)WITH(x, y)GUN(y)The boy with the gun fires.FIRE(x)xBOY(x)WITH(x, y)yGUN(y)The sentences in (25) contain noun phrases with restricted relative clauses.
In the firstexample the relative clause contains an indefinite noun phrase a gun, whereas in thealmost identical second example, it contains a definite (hence presuppositional) nounphrase.
These two sentence-DRSs do not, however, reflect the difference in meaningof the utterances they represent.
The indefinite noun phrase a gun gets an anaphoricinterpretation, because it is part of the A-structure.
The anaphoric potential of the twoutterances, according to the sentence-DRSs for the two utterances in example (25),is almost identical, the only difference being that the DRS for the second utteranceallows binding or accommodation on two different levels (instead of one level) ofdiscourse structure.
Summing up, A-structures do not allow for selective binding,with the unwanted side effect that indefinite noun phrases are turned into definiteones.To allow for selective binding, I introduce the notion of principal anaphoricreferent.
The operator ?
is indexed with the principal anaphoric referent to indi-cate which discourse referent of a presuppositional DRS is anaphoric.
In fact, I as-sume that each presupposition trigger has a unique principal anaphoric referent.3Now let us consider the DRSs for the same utterances in (25) in the newformats:3 Although this seems a small and innocent adjustment to the representation of elementarypresuppositions, it has great impact on our understanding what characterizes presuppositions.
Underthis view, presuppositions are not merely DRSs, but they are DRSs plus an additional pointer, in theform of a distinguished discourse referent, to a context.193Bos Implementing Binding and Accommodation Theory(26) The boy with a gun fires.
The boy with the gun fires.
(x yBOY(x)GUN(y)WITH(x,y)?xFIRE(x)) ((yGUN(y)?yxBOY(x)WITH (x,y))?xFIRE(x))Although the entire DRS of the left-hand side of the ?-operator is said to be pre-suppositional, resolution will affect only the principal discourse referent.
For The boywith a gun, this is x, and only x is identified with an antecedent discourse referent;y, introduced for the indefinite noun phrase a gun, is not treated as anaphoric.
Thisis in contrast to the DRS for The boy with the gun, which contains nested ?-DRSs.
Inshort, ?
allows selective binding, whereas Van der Sandt?s A-structures are based onunselective binding.I will refer to this new format for DRSs, encoding unresolved anaphoric DRSs,as ?-DRSs.
Like sentence-DRSs, ?-DRSs are intermediate representations and haveno interpretation.
The best way to view them is as underspecified representationsencoding the ambiguities of anaphoric expressions in a compact manner.
The syntaxof ?-DRSs is defined as follows:DefinitionThe syntax of ?-DRSs is defined on the basis of the following four clauses:1.
If {x1 .
.
.
xn} is a finite ordered set of variables and {?1 .
.
.
?m} is a finiteordered set of ?-DRS-conditions, then the ordered pair?
{x1 .
.
.
xn}, {?1 .
.
.
?m}?
is a basic ?-DRS.2.
Every basic ?-DRS is an ?-DRS.3.
If B1 and B2 are ?-DRSs, then so is (B1;B2).4.
If B1 and B2 are ?-DRSs, and x is a discourse referent declared in thedomain of B1, then (B1 ?x B2) is an ?-DRS.Note that in clause 1 of the definition, ordered sets are used rather then plain setsfor discourse referents and DRS-conditions; this will make definition of the resolutionalgorithm easier.
DRS merging (clause 4) is used in many alternative formulations ofDRT (Muskens 1996; Van Eijck and Kamp 1997; Kuschert 1999).
The merge employedhere, ?
;?, is adopted from Muskens and behaves semantically the same as dynamicconjunction in dynamic predicate logic (Groenendijk and Stokhof 1991).The syntax of ?-DRS-conditions is defined as follows:DefinitionThe syntax of ?-DRS-conditions is defined according to the following four clauses:1.
Every basic DRS-condition is an ?-DRS-condition.2.
If B is an ?-DRS, then ?B, ?B, and ?B are ?-DRS-conditions.3.
If B1 and B2 are ?-DRSs, then B1 ?
B2 and B1 ?
B2 are ?-DRS-conditions.4.
If x is a variable and B is an ?-DRS, then x : B is an ?-DRS-condition.194Computational Linguistics Volume 29, Number 2So the syntax for ?-DRSs subsumes the syntax of DRSs.
I will refer to ?-DRSs thatcontain no DRSs of the form (B ?i B?)
as presupposition-free.
All other ?-DRSs arereferred to as presupposition-containing.
(The same terminology will be used for ?-DRS-conditions.)
It is easy to show that presupposition-free ?-DRSs are proper DRSs.In Table 1, I give several examples of lexical entries of presupposition triggers,assuming a compositional semantics in the Montagovian tradition based on Muskens?s(1996) compositional DRT (Muskens, 1996).
The syntactic categories used in the tableare N (noun), DET (determiner), NP (noun phrase), ADJ (adjective), and V (verb).Further, p and q are used to denote variables ranging over properties, and s to denotevariables ranging over propositions.
The table lists various kinds of presuppositiontriggers, including the definite determiner, a proper name (Mia), a factive verb (torealize), a sortally restricted predicate (bachelor), and the iterative adjective other.3.3 Operations on Discourse RepresentationsIn this section I will formulate two operations on discourse representations requiredfor presupposition resolution: renaming and merging.
Furthermore, I will introducethe concepts of free and bound variables in discourse representations, because we needto implement the free-variable constraint.
This will also give us a better understandingof the problems that arise in renaming and merging.A free variable in this context is an occurrence of a variable in a DRS that isnot declared as a discourse referent in the domain of the immediate DRS in which itoccurs or in the domain of a superordinated DRS; all other variables are bound.
Tobe more precise, I define two functions, FREE and BOUND, that compute the free andbound variables for DRSs and DRS-conditions:DefinitionFree and bound variables in ?-DRSs are defined according to the following nineclauses:1.
FREE(?
{x1 .
.
.
xn}, {?1 .
.
.
?m}?)
= (FREE(?1) ?
.
.
.
?
FREE(?m))\{x1 .
.
.
xn};BOUND(?
{x1 .
.
.
xn}, {?1 .
.
.
?m}?)
= {x1 .
.
.
xn}2.
FREE(B?B?)
= (FREE(B) ?
FREE(B?))\BOUND(B);BOUND(B?B?)
= BOUND(B) ?
BOUND(B?)3.
FREE(B; B?)
= (FREE(B) ?
FREE(B?
))\BOUND(B);BOUND(B; B?)
= BOUND(B) ?
BOUND(B?)4.
FREE(R(x1, .
.
.
, xn)) = {x1, .
.
.
, xn};BOUND(R(x1, .
.
.
, xn)) = ?5.
FREE(x=y)= {x, y};BOUND(x=y)= ?6.
FREE(B ?
B?)
= (FREE(B) ?
FREE(B?
))\BOUND(B);BOUND(B ?
B?)
= ?7.
FREE(B ?
B?)
= FREE(B?)
?
FREE(B);BOUND(B ?
B?)
= ?8.
FREE(?)
= FREE(B) if ?
is of the form ?B, ?B, ?B;BOUND(?)
= ?
if ?
is of the form ?B, ?B, ?B9.
FREE(x : B) = {x} ?
FREE(B);BOUND(x : B) = ?195Bos Implementing Binding and Accommodation TheoryTable 1Lexical entries for various presupposition triggers and presupposition-free expressions.Category Lexical Semantics ExampleN ?x.BOXER(x)boxerN ?x.
(yMALE(y)y=x?y ?MARRIED(x)) bachelorDET ?p.?q.
((x;p(x));q(x)) aDET ?p.?q.(x;p(x))?
q(x) everyDET ?p.?q.
((x;p(x))?xq(x)) theDET ?p.?q.
((xFEMALE(x)?x((yOF(y,x);p(y))?yq(y)))) herNP ?p.
(xBODY(x);p(x)) somebodyNP ?p.
(xMIA(x)?xp(x)) MiaNP ?p.
(xFEMALE(x)?xp(x)) sheADJ ?p.?x.
(BLUE(x);p(x)) blueADJ ?p.?x.
((y;p(y))?y ( ?x=y;p(x))) otherV ?s.
?x.bb:sBELIEVE(x,b)believesV ?s.?x.
(bb:s?bREALIZE(x,b)) realizes196Computational Linguistics Volume 29, Number 2For renaming variables in DRSs, a (total) function r is used whose arguments areprovided by an auxiliary (total) function ?
that maps a variable to a stringed sequenceof a copy of itself.
The use of ?
makes the values r assigns to a variable x sensitiveto the number of occurrences of x in a DRS: ?
(x) = x if x has not appeared (bound)so far in a DRS, ?
(x) = xx if x has appeared (bound) once, xxx if x has appeared(bound) twice, and so on.
Putting it differently, ?
is a counter.
It counts the number ofoccurrences of declarations of discourse referents in a DRS.
On the basis of that count,the renaming function r maps a variable onto a new, previously unused occurrence.The renaming function r maps a sequence of variables to a new, fresh discoursevariable.
The function r is injective, meaning that distinct argument sequences to rproduce distinct values.
In other words, the values r assigns to x, y, z, xx, yy, zz, xxx,yyy, zzz, and so on are all different.
In sum, with the help of r and ?, we make explicitthat two discourse referents declared under the same name in two different domainsin a DRS get two different names.
The definition of renaming in DRS (where for a setof discourse referents U, UPDATE(?, U, ??)
holds just if ?x(??
(x) = ?
(x) ?
x /?
U) and?x(??
(x) = ?
(x)x ?
x ?
U) hold) is as follows:DefinitionDRS renaming is defined according to the following eight clauses:1.
RENAME(?, ?
{x1 .
.
.
xn}, {C1 .
.
.
Cm}?)
=??
?, ?{r(??
(x1)) .
.
.
r(??
(xn))}, {C?1 .
.
.
C?m}?
?if UPDATE(?, {x1, .
.
.
, xn}, ??)
and RENAME(?
?, Ci) = ???
?, C?i?
for some ???2.
RENAME(?, (B1; B2)) = ???
?, (B?1; B?2)?if RENAME(?, B1) = ??
?, B?1?
and RENAME(?
?, B2) = ???
?, B?2?3.
RENAME(?,(B1 ?x B2) = ???
?,(B?1 ?r(??
(x))B?2)?if RENAME(?, B1) = ??
?, B?1?
and RENAME(?
?, B2) = ???
?, B?2?4.
RENAME(?, R(x1, .
.
.
, xn)) = ?
?, R(r(?
(x1)), .
.
.
, r(?(xn)))?5.
RENAME(?, x = y) = ?
?, r(?
(x)) = r(?(y))?6.
RENAME(?, B1 ?
B2) = ?
?, B?1 ?
B?2?if RENAME(?, B1) = ??
?, B?1?
and RENAME(?
?, B2) = ???
?, B?2?
for some ???7.
RENAME(?, B1 ?
B2) = ?
?, B?1 ?
B?2?if RENAME(?, B1) = ??
?, B?1?
and RENAME(?, B2) = ???
?, B?2?
for some ??
and???8.
RENAME(?,?B) = ?
?, ?B??
if RENAME(?, B) = ??
?, B??
for some ?
?The function RENAME maps an ordered pair consisting of a ?-function and a DRS toa new ?-function and the translated DRS.
Clauses 1?3 of the definition handle DRSs,clauses 4?8 handle the DRS-conditions.
With respect to variables not declared in auniverse of a DRS, ?
remains unchanged.
For variables that are declared as discoursereferents in a DRS, ?
increases the values for these variables by one.
Clauses 2, 3, and6 show that the ?-function produced by the first DRS is passed through to the secondDRS, following the definition of DRS-subordination.With the renaming function at our disposal, we now can define pure DRSs asDRSs that have undergone renaming.
The conversion of a DRSs potentially changes itsdiscourse meaning, and this is actually the key function of renaming: maximizing the197Bos Implementing Binding and Accommodation Theorycontext change potential of a DRS.
To preserve the logical meaning while renaming,we need to put restrictions on the use of renaming.
As DRSs can bind variables outsidetheir scope (for instance, through use of the merge operator), applying the renamingprocedure only to a DRS B that is actually part of another DRS B?
would possibly affectthe logical meaning of a DRS.
Therefore, only complete DRSs should be renamed; thatis, if a sub-DRSs is renamed, any DRS that superordinates it must be renamed too.Let me now relate this to practical discourse processing.
Assume that processing atext proceeds in an incremental way, starting with processing the first sentence, until aDRS is eventually derived for the entire text.
At some point during this process, aftercompleting the analysis of a sentence, part of the text is translated into a DRS.
At thisstage of processing, the obtained DRS is complete (it is not part of another DRS, as therest of the text is still unanalyzed), and it can be renamed without changing its logicalmeaning, while maximizing its context change potential.
The rest of the discourse isthen processed with respect to the renamed DRS.Hence, given a pure DRS, we can replace a DRS (B; B?)
with a new DRS that isconstructed by taking the unions of the discourse referents and the conditions of Band B?, respectively.
We will specify the merging of DRSs with the help of a functionMERGE from DRSs to DRSs.
This function is defined recursively:DefinitionMerge reduction for pure DRSs is defined according to the following two clauses:1.
MERGE(?DB, CB?)
= ?DB, CB?2.
MERGE((B; B?))
= ?DMERGE(B) ?
DMERGE(B?
), CMERGE(B) ?
CMERGE(B?
)?Carrying out merge reduction simplifies the DRS structure and facilitates use of thestandard accessibility definition.
Moreover, using MERGE, it is straightforward to definethe set of discourse referents within a universe of a pure DRS B, namely, UMERGE(B).I will make use of this when I implement pronoun and presupposition resolution inthe next section.
Finally, merge reduction yields DRSs that can be transformed intofirst-order logic using the translation function given in Section 3.1.4.
Presupposition ResolutionIn this section I will reformulate Van der Sandt?s presupposition resolution algorithmin terms of ?-DRSs with the aim of reducing the generate-and-test nature of Van derSandt?s original formulation.
Even for relative simple examples, the search space ofpossible interpretations is vast.
Consider the following example:(27) If Bonnie finds a corpse in her house, the dead body will frighten her.Without applying any acceptability constraints, resolving the four triggers in exam-ple (27) will yield 1,280 different solutions.
If binding is preferred to accommodation,the example will still give rise to 525 possible interpretations.
It is clear that a generate-and-test approach, in which the acceptability constraints are applied to completely re-solved DRSs, will be extremely inefficient.
The algorithm implemented in this sectionapplies, as far as possible, the acceptability constraints to partially resolved DRSs, andthereby reduces the search space.198Computational Linguistics Volume 29, Number 2To deal with the different anaphoric behavior of noun phrases in English, I willpropose a typology of noun phrases reflecting their properties with respect to bindingand accommodation.
Further, I will precisely formulate the acceptability constraintsimposed by the resolution algorithm and outline how to add preference ranking tothe solutions generated by the algorithm.4.1 The Resolution AlgorithmPresupposition resolution in discourse processing is assumed to take place on anutterance-by-utterance basis.
Therefore, the resolution algorithm takes as input theDRS constructed for the discourse so far and an ?-DRS for the new utterance andoutputs a new DRS.
The algorithm is recursive in nature, and given an ?-DRS A withn presupposition triggers, each step in the resolution process will resolve one triggerand decrease n by one, until A is presupposition-free (i.e., n = 0).The idea behind the resolution algorithm is to detect any violations of the accept-ability constraints as soon as possible in the process of resolution, thereby restrictingthe search space.
After each resolution step the acceptability constraints are checked forviolation.
Some of the acceptability constraints, however, are not defined for ?-DRSsand can be applied only to the finally resolved DRS.I will present the algorithm in a notation borrowed from logic programming, usingnegation as failure, backtracking for efficiency, and unification for term manipulation.Given the definition below, it is straightforward to implement the algorithm usinga programming language like PROLOG.
DRSs are represented as an ordered pair oflists, and PROLOG-style variables are used to represent discourse referents and first-order variables.
Further, I will use the following notational conventions: A, B, and Care used to denote DRSs, L and M to denote DRS-conditions, and P and Q to denoteaccessibility paths.The main predicate of the algorithm consists of the following two clauses:resolve(C,B,B) ?
presup-free(B), consistent(B), informative(C,B).resolve(C,B,E) ?
alfa(B-D,[]-[A|P]), move(A,P,D), resolve(C,D,E).The first resolve clause terminates the recursion if all presuppositions are resolved, thenchecks the resulting DRS for consistency and informativeness (see Section 4.3).
Thesecond, recursive resolve clause makes use of two further predicates that I introducenow: alfa, for determining the first presupposition trigger in the ?-DRS, and move,which either binds or accommodates the trigger to an accessible level of discourse.Let us consider first alfa, which is defined for a pair of ?-DRSs (or ?-DRS-conditions) and a pair of accessibility paths.
(Recall that an accessibility path is alist of levels of DRSs, starting with the presupposition trigger and ending with theglobal level of discourse.)
This is the definition for ?-DRSs:alfa((A?B)-(C?B),P-Q) ?
alfa(A-C,P-Q).alfa((A?B)-(C;B),P-[A,acc(C)|P]) ?
presup-free(A).alfa((A;B)-(C;B),P-Q) ?
alfa(A-C,P-Q).alfa((A;B)-(X;C),P-Q) ?
presup-free(A), alfa(B-C,[bin(A,X)|P]-Q).alfa(?U,L?-(A;R),P-Q) ?
alfa(L-M,[acc(A),bin(?U,M?,R)|P]-Q).What alfa effectively does is traverse the DRS structure, thereby building up the accessi-bility path, until it hits a presupposition trigger.
The accessibility path is constructed asa list of binding or accommodation sites.
Binding sites are marked as bin(A,B), whereA is the original site (i.e., a DRS) and B the result of binding.
Accommodation sites199Bos Implementing Binding and Accommodation Theoryare marked as acc(A), where A is the result of accommodation.
For instance, considerthe two clauses for the DRS merge in the definition above, in which the input DRS isof the form (A;B).
If A contains a presupposition, then alfa(A-C,P-Q) holds, and theresulting DRS will be set to (C;B).
If A is presupposition-free, B will be traversed forpresuppositions (resulting in C) and a binding site X for A will be introduced on theaccessibility path represented by P and Q.
Possible binding sites are also introducedby basic DRSs.
Basic DRSs furthermore introduce a possible accommodation site incase one of their complex conditions contain ?-DRSs.
The clauses for DRS-conditionsare defined as follows:alfa([X|L]-[X|M],P-Q) ?
basic(X), alfa(L-M,P-Q).alfa([?B|L]-[?C|L],P-Q) ?
alfa(B-C,P-Q).alfa([?B|L]-[?C|L],P-Q) ?
alfa(B-C,P-Q).alfa([?B|L]-[?C|L],P-Q) ?
alfa(B-C,P-Q).alfa([x:B|L]-[x:C|L],P-Q) ?
alfa(B-C,P-Q).alfa([B?A|L]-[C?A|L],P-Q) ?
alfa(B-C,P-Q).alfa([A?B|L]-[A?C|L],P-Q) ?
presup-free(A), alfa(B-C,P-Q).alfa([B?A|L]-[C?A|L],P-Q) ?
alfa(B-C,P-Q).alfa([A?B|L]-[(E;D)?C|L],P-Q)?
presup-free(A), presup-free(A), alfa(B-C,[bin(A,E),acc(D)|P]-Q).Note that, because we use ordered sets of DRS-conditions, the predicate alfa behavesin a deterministic way, and it returns the first presuppositional DRS that itself ispresupposition-free.
Further note that the accessibility path reflects the accessibilityrelation defined in DRT, which is mirrored by the clauses for alfa.
For instance, notethe difference in definition between the implicational and disjunctional condition.The accessibility path returned by alfa forms a skeleton for a resolved DRS, whichwill be instantiated based on the decision as to whether to bind or accommodate thepresupposition, and on which level.
For a site encoded by acc(A), accommodationinvolves identifying the presuppositional DRS with A.
For binding, it involves match-ing the presupposition with DRS A resulting in a new DRS B for a site of the formbin(A,B).
This process is implemented by the predicates move, bind, accommodate, andskip.
Let us first consider move.
As BAT dictates, resolution involves either binding oraccommodation:move(A,P,B) ?
bind(A,P), ?sortal-violation(B), ?binding-violation(B).move(A,P,B) ?
accommodate(A,P), ?free-variables(B).The first clause of move binds the presupposition to a DRS on the accessibility pathand then checks the acceptability constraints (see Section 4.3 for the definition of theseconstraints).
The second clause invokes accommodation, followed by a check on freevariables (again, see Section 4.3).
Let us first consider binding.
Binding is possible onlyon binding sites, where the presuppositional information is matched with the DRS onthe binding site, resulting in a new DRS.
Binding is defined recursively, for there mightbe several appropriate binding sites:bind(?D,L?X,[bin(?D?,L??,?D?D?,L?L??
)|P]) ?
X?D?, skip(P).bind(A,[S|P]) ?
bind(A,P), skip([S]).Accommodation is very similar to binding, but only accommodation sites on theaccessibility path are relevant and come into question.
Accommodation now boils200Computational Linguistics Volume 29, Number 2down to unification of the presuppositional information with the DRS on the accom-modation site.
Again, there might be several accommodation sites (corresponding toglobal, local, or intermediate levels of discourse), so a recursive definition is appropri-ate:accommodate(A,[acc(A)|P]) ?
skip(P).accommodate(A,[S|P]) ?
accommodate(A,P), skip([S]).Finally, we need to define skip.
This function takes care of all accommodation andbinding sites that were not selected as antecedent for the presupposition trigger.
Fora possible accommodation site, this will result in identifying its DRS with an emptyDRS, and for a binding site, the resulting DRS will be unchanged with respect to itsoriginal one:skip([]) ?
true.skip([acc(?
?, ??
)|P]) ?
skip(P).skip([bin(A,A)|P]) ?
skip(P).This is the core of the algorithm, but various extensions are possible.
In the follow-ing section I will take different types of presuppositional triggers into account, be-cause some expressions allow for accommodation and others do not, and some canbe resolved only at the global level of discourse, whereas others are not sensitive tosubordinated levels.
Furthermore, I will formulate the acceptability constraints andinvestigate means to account for preferences in solutions.
(As it stands, the algorithmwill produce a set of solutions, all equal to one another.
But as noted in the discussionof BAT, there are sometimes clear preferences for certain solutions.
)4.2 Classifying Presupposition TriggersThe resolution algorithm, as formulated in the previous section, does not discriminateamong different types of anaphoric expressions.
With regard to noun phrases, it is wellknown that the choice of referring expression affects coherence in discourse (Grosz,Joshi, and Weinstein 1995).
Perhaps related to this observation is the fact that pronouns,definite descriptions, and proper names all vary in terms of their capacity for bindingand accommodation.
The performance of the algorithm would strongly benefit fromtaking these differences into account, because it would further narrow down the searchspace.With respect to accommodation, some noun phrases allow accommodation onany level, whereas others accommodate only globally.
Third-person anaphoric pro-nouns normally do not allow accommodation, with the exception of discourse-initialoccurrences.
Reflexive pronouns do not have the ability to accommodate, for they areintrinsically anaphoric.
Definite descriptions, especially genitive constructions, havethe power to accommodate on all levels (see example (7)).
Proper names allow ac-commodation only on the global level.
If one also considers first- and second-personpronouns, which belong to the family of deictic expressions, it can be concluded thatthis class of expressions does not allow accommodation at all, simply because deicticexpressions refer to objects presumed in the context of interpretation.For binding, the differences among noun phrases are not so marked.
Most of themallow binding on all levels of discourse structure, with the exception of proper names.44 However, Geurts (1997) claims that proper names are able to bind nonglobally; he uses examples suchas If a child is christened ?Bambi,?
and Disney Inc. hear about it, then they will sue Bambi?s parents.201Bos Implementing Binding and Accommodation TheoryTable 2Binding and accommodation behavior of different ?-types for noun phrases.Local Global?-type Binding/Accommodation Binding/Accommodation Descriptionref yes/no yes/no reflexive pronounspro yes/no yes/yes third-person nonreflexivepronounsnam no/no yes/yes proper namesdei no/no yes/no first- and second-personnonreflexive pronounsdef yes/yes yes/yes definite descriptionsAntecedents of deictic expressions are assumed to be available at the global level ofdiscourse, for they are part of the current context of interpretation, and so referenceto objects at subordinated levels of discourse is not an option for deictic expressions.To account for the different referential behavior of noun phrases, we classify themin terms of ?-types.
The ?-types for English noun phrases and their properties arelisted in Table 2.
To integrate these properties into the resolution algorithm, we needa way to determine whether we resolve a particular presupposition at a global ornonglobal level of discourse.
Given an accessibility path, it is unequivocal to definethe conditions for operating on a global level of discourse, because subordinated levelsof DRS introduce an accommodation site, which we represent as acc(A) for a DRS A, onthe accessibility path.
Therefore, a binding site is global if there is no accommodationsite on the remainder of its accessibility path:global(P) ?
?
acc(A)?P.With this machinery we are able to revise the definition for accommodation, bymaking it sensitive to different ?-types.
This results in the following clauses:accommodate(Anam,[acc(A)|P]) ?
global(P), skip(P).accommodate(Apro,[acc(A)|P]) ?
global(P), skip(P).accommodate(Adef,[acc(A)|P]) ?
skip(P).Similarly, we can revise the definition of binding by making it sensitive to different?-types.
This yields the following clauses:bind(?D,L?namX ,[bin(?D?,L??,?D?D?,L?L??)|P])?
global(P),X?D?,skip(P).bind(?D,L?deiX ,[bin(?D?,L??,?D?D?,L?L??
)|P]) ?
global(P),X?D?,skip(P).bind(?D,L?proX ,[bin(?D?,L??,?D?D?,L?L??
)|P]) ?
X?D?, skip(P).bind(?D,L?refX ,[bin(?D?,L??,?D?D?,L?L??
)|P]) ?
X?D?, skip(P).bind(?D,L?defX ,[bin(?D?,L??,?D?D?,L?L??
)|P]) ?
X?D?, skip(P).This might be a rather rocky approximation to discriminating among different nounphrases, but it will greatly improve the performance of the algorithm.
Whether afiner classification is required, or whether further types to deal with other kinds ofpresupposition triggers (such as factives) are needed, remains subject for future corpusstudies.202Computational Linguistics Volume 29, Number 24.3 Acceptability ConstraintsThe resolution algorithm imposes several acceptability constraints on resolved or par-tially resolved DRSs.
For completely resolved DRSs, there are constraints on consis-tency and informativeness.
For partially resolved DRSs (i.e., ?-DRSs), there are con-straints on sortal compatibility, binding, and the occurrences of free variables.
Let usfirst consider consistency and informativeness.As an illustration of the constraints on consistency, suppose we have a DRS B.If we can prove that ?
?w(w,B) fo is valid, then we know that B is inconsistent.
If, onthe other hand, we find that ?w(w,B) fo is satisfiable, we know that B is consistent.
Interms of our previous formulation of the resolution algorithm, this translates asconsistent(B) ?
proof(?
?w(w,B) fo), fail.consistent(B) ?
satisfiable(?w(w,B) fo).Now let us consider informativeness, with respect to a DRS A representing theprevious discourse and a new DRS B.
If we prove that ?w((w,A) fo?
(w,B) fo), we knowthat B is not informative with respect to A.
On the other hand, if we are able toshow that both ?w((w,A) fo ?
(w,B) fo) and ?w((w,A) fo ?
?
(w,B) fo) are satisfiable for-mulas, we can say that B is informative with respect to A.
This can be coded asfollows:informative(A,B) ?
proof(?w((w,A) fo ?
(w,B) fo)), fail.informative(A,B) ?
satisfiable(?w((w,A) fo?
(w,B) fo)),satisfiable(?w((w,A) fo ?
?
(w,B) fo)).The constraint on sortal compatibility can be seen as a local consistency check.It takes place after binding, and it uses a sortal ontology to ensure that discoursereferents with different sorts are not identified with each other.
This eliminates anypossibility for anaphoric expressions that describe entities to refer to discourse ref-erents for temporal information or possible worlds and so cuts the search space ofantecedents enormously.
In terms of the algorithm, sortal-violation(B) will hold for aDRS B if there is an accessibility path in B with a discourse referent that has inconsistentproperties.The binding constraint is a linguistic confinement primarily dealing with restric-tions of antecedents of anaphoric object noun phrases.
Binding constraints are similarto the C-command constraints found in linguistic theory, but I will give a simplifiedformulation here and deal with (di)transitive verbs only.
Binding constraints deal withtwo complementary cases.
First of all, it checks whether a reflexive pronoun in objectposition is bound to the subject noun phrase.
Second, it checks whether a nonreflexiveanaphoric noun phrase in object position is not bound to the subject noun phrase.Finally, there is the constraint on bound variables for ?-DRSs.
With the help ofthe definition of free and bound variables given in Section 3.3, it is straightforward toinclude this constraint in the resolution algorithm.
This can be accomplished efficientlyby traversing the DRS in a top-down manner, collecting bound variables on eachaccessibility path.
Free variables are then detected when one of the variables occurringin a basic condition is not a member of the set of bound variables collected on thataccessibility path.4.4 PreferencesIn this section I will investigate how to account for ranking interpretations.
The resolu-tion algorithm will produce a set of solutions without stating any preferences among203Bos Implementing Binding and Accommodation Theorycandidates in the solution set produced.
In general, it has been noted that in mostcases, binding is strongly preferred to accommodation (Van der Sandt 1992), and thatglobal accommodation is preferred to local accommodation (Heim 1983).
This mesheswell with a claim put forward in theories of discourse coherency that the inferencedemands placed on a hearer correlate positively with the perceived coherency of adiscourse (Grosz, Joshi, and Weinstein 1995), because it makes perfect sense to ascribea higher inference load to accommodation than binding.Given the resolution algorithm as defined here, one way to invoke a rankingmechanism among potential solutions is to include scores and make them sensitive todifferent ?-types.
Scores could be represented as numbers between 0 and 1, reflectingthe rank of the solution in the solution set.
Starting with a score of 1 for a particularsolution, accommodation will decrease the score (for instance, by multiplying the cur-rent score by 0.1), whereas binding will not.
Cases of nonglobal accommodation willfurther lower the score.Van der Sandt?s constraints on local informativeness and local consistency arefurther criteria for preference ranking.
Unlike the global versions of informative-ness and consistency, the local constraints cannot be ?hard?
constraints, for if theywere, they would rule out otherwise fine solutions.
Put differently, rejection of DRSson the basis of violating the local informativeness constraint seems inappropriate.I will illustrate this observation with the discourse and its translation in a DRS(example (28)).
(28) Mia likes every woman.xMIA(x)yWOMAN(y)?LIKE(x, y)The DRS in example (28) violates the local informativeness constraint.
The sub-DRScontaining the information that there is a woman is already expressed by the su-perordinated DRS, given the background knowledge that Mia is a woman.
From agrammatical point of view, however, example (28) is a legitimate sentence.
Rejectingit on the basis of violating local informativeness seems unjustified.
On the other hand,the local constraints help in dealing with the presupposition project problem.
There-fore, we take a suggestion made by Beaver (2002) and use the local constraints as afurther criterion for ranking potential solutions of the resolution algorithm.
This rank-ing could be realized by decreasing the score of a particular DRS each time it violateslocal informativeness or local consistency.Incidentally, Van der Sandt does not give a precise formulation of local informa-tiveness and local consistency, and it is not straightforward what would constitute aprecise formulation (Beaver 1997, 2002).
I will give a novel formulation of the localconstraints with the help of a function that, given a DRS, returns a set of pairs of DRSsand the DRSs that they subordinate.
Given this function, it is straightforward to definelocal informativeness and local consistency.
This function, supersub, is defined, usingPROLOG notation, as follows (the definition given here is restricted to the clauses forimplication, negation and basic conditions; clauses for the remaining conditions can204Computational Linguistics Volume 29, Number 2be easily derived from these):supersub(?D,[Sub?B|L]?,A-(A;?D,L?
),Sub) ?
true.supersub(?D,[B?Sub|L]?,A-(A;?D,L?
;B),Sub) ?
true.supersub(?D,[Sub?B|L]?,A-Sup,Sub) ?
supersub(B,(A;?D,L?
)-Sup,Sub).supersub(?D,[B?C|L]?,A-Sup,Sub) ?
supersub(C,((?D,L?;B);A)-Sup,Sub).supersub(?D,[Sub?B|L]?,A-(A;?D,L?
),Sub) ?
true.supersub(?D,[B?Sub|L]?,A-(A;?D,L?
;B)),Sub) ?
true.supersub(?D,[Sub?B|L]?,A-Sup,Sub) ?
supersub(B,(A;?D,L?
)-Sup,Sub).supersub(?D,[B?Sub|L]?,A-Sup,Sub) ?
supersub(B,(A;?D,L?)-Sup,Sub).supersub(?D,[?Sub|L]?,A-(A;?D,L?
),Sub) ?
true.supersub(?D,[?B|L]?,A-Sup,Sub) ?
supersub(B,(A;?D,L?)-Sup,Sub).supersub(?D,[X|L]?,A-(?D,[C]?
;B),Sub) ?
basic(X),supersub(?
?,L?,A-B,Sub).The supersub predicate is recursively defined to handle arbitrarily deeply embed-ded sub-DRSs.
The crucial step in supersub is removing the conditions that contain thesubordinated DRS.
Applying supersub to example (28), we get the following two pairs:?super-DRS:xMIA(x), sub-DRS:yWOMAN(y)?
?super-DRS:x yMIA(x)WOMAN(y), sub-DRS:LIKE(x, y)?We can now formulate the local constraints in terms of informativeness as follows:A pair ?super-DRS: A, sub-DRS B?
is locally informative if (A;B) is informative withrespect to A and locally consistent if (A;??,[?B]?)
is informative with respect to A.Adding the local constraints as further criteria for ranking potential readings pro-duced by the resolution algorithm will give accurate predictions for the interpretationof many problematic cases discussed in Section 2.2.
Testing the local constraints in-volves first-order theorem proving, and it is useful to add some heuristics to obtainmore efficient implementations.
A valuable heuristic is one that distinguishes subor-dinated levels of discourse in the old DRS (i.e., the DRS capturing the portion of thediscourse processed so far) from subordinated levels of discourse in the DRS of thenewly processed utterance.
This avoids repeated application of local constraints to thesame subordinated levels of discourse over and over again.5.
Implementation and PerformanceThe resolution algorithm is implemented as part of a natural language understandingsystem.
I will describe the general architecture underlying this system and the imple-mentation of the algorithm and the acceptability constraints and present performanceresults obtained from applying the algorithm to a corpus of route instructions.5.1 ArchitectureOpen Agent Architecture (OAA) (Cheyer and Martin 2001) is used as prototyping en-vironment to implement the presupposition resolution component as part of a naturallanguage understanding system.
OAA is a collection of software agents that commu-nicate with each other via a facilitator, a piece of middleware that distributes requeststo appropriate agents and returns the responses to the requester.
OAA makes it conve-nient to combine different components that are required in natural language process-205Bos Implementing Binding and Accommodation Theorying, such as speech recognition or parsing, the presupposition resolution component,and theorem provers, because OAA agents can be implemented in different program-ming languages and run simultaneously on different machines (Bos and Oka 2002).The resolution component is realized as an OAA agent implemented in PROLOG.5.2 Acceptability ConstraintsTo implement inference, a theorem prover as well as a model builder is used, bothencapsulated as OAA agents.
The theorem-proving agent is used to find a counterprooffor the DRS translated into first-order logic.
The model-building agent is used to checkwhether the same DRS is satisfiable.
So, although we are faced with the limitations forreasoning with first-order logic (validity is undecidable in first-order logic, and modelgeneration is restricted to finite models), these limitations are reduced to a minimum.For each inference problem, the two inference agents attack the problem in parallel,and as soon as one of them finds an answer (a model or a counterproof), their task iscompleted.The three acceptability constraints that do not require first-order inference (properbinding, bound variables, and sortal compatibility) are not implemented as separateagents but instead are part of the resolution agent.
Proper binding is checked via a neo-Davidsonian semantics to describe events in terms of their thematic relations (Parsons1990).
Binding is violated when a (di)transitive verb has a reflexive pronoun as objectand the discourse referents for the agent and patient denote different objects, or whena (di)transitive verb has a nonreflexive object and the discourse referents for agent andpatient denote the same object.
The check for free variables is rather straightforward,given the definitions in Section 3.Sortal violations are detected using a conceptual ontology.
Based on WordNet(Fellbaum 1998), this ontology is substantially adapted and extended to deal withanaphora resolution in BAT.
As usual, it reflects background knowledge in the formof inheritance (is-a) and disjointness.
The three (disjoint) top concepts in this ontologyare GROUP (a collection of things), SITUATION (a condition in which certain proposi-tions hold or do not hold), and THING (an individual object that is talked about).
Thelast is further divided into ABSTRACTION (a thing without mass) and ENTITY (a thingwith mass).
The concept ENTITY has two subconcepts: OBJECT (a nonliving entity) andORGANISM (a living entity).
OBJECTS are divided into ARTIFACTS (human-made things),NATURAL-OBJECTS (things that are found in nature), and SUBSTANCES (things that areindivisible).
The subconcepts of ORGANISM are HUMAN, ANIMAL, and PLANT.In the case of English pronouns, there is a need to distinguish between third-personsingular male, female, and neuter pronouns, as well as, of course, plural pronouns.The plural pronouns are the easiest to deal with and introduce a discourse referentwith condition GROUP; hence they cannot bind to situations or things.
Three mutuallydisjoint concepts are used for singular pronouns: MALE (for he), FEMALE (for she), andUNISEX (for concepts that disallow binding of he and she).
The neuter pronoun it comeswith the feature NONHUMAN, so we allow it to refer to any nonhuman entity (this isobviously not entirely accurate, as in certain situations, it can be used to refer topersons).
To prevent reference from singular pronouns to plural entities, we furtherdefine GROUP disjoint from MALE, FEMALE, and NONHUMAN.The sortal violation checker is implemented in PROLOG, where the inheritanceinformation is stored in the PROLOG database by clauses of the following form:sort(ENTITY(X)) ?
sort(ORGANISM(X)).sort(ENTITY(X)) ?
sort(OBJECT(X)).sort(ORGANISM(X)) ?
sort(HUMAN(X)).sort(ORGANISM(X)) ?
sort(ANIMAL(X)).206Computational Linguistics Volume 29, Number 2sort(ORGANISM(X)) ?
sort(PLANT(X)).sort(MALE(X)) ?
sort(MAN(X)).sort(FEMALE(X)) ?
sort(WOMAN(X)).Disjointness relations are implemented by clauses of the following form:inconsistent ?
sort(ORGANISM(X)), sort(OBJECT(X)).inconsistent ?
sort(HUMAN(X)), sort(ANIMAL(X)).inconsistent ?
sort(MALE(X)), sort(FEMALE(X)).For each sortal compatibility check, the discourse referents are skolemized, andthe basic conditions of the resolved DRSs are asserted to the database.
The followingclause links these basic conditions to sorts:sort(S) ?
basic(S).The PROLOG inference engine then attempts to prove a sortal incompatibility by tryingto find an instance of a discourse referent that has two conflicting properties, withinthe transitive closure of the is-a relation, here implemented via the predicate sort.
Usingnegation as failure, sorts are compatible if ?inconsistent can be proven.
Consider thefollowing example illustrating sortal incompatibility:(29) Suppose the result of binding is a DRS in which the two basic conditionsMAN(X) and WOMAN(X) are applied to the same variables.
Asserting thisto the database as basic(MAN(a)) and basic(WOMAN(a)), it is possible toconclude sort(MAN(a)) as well as sort(WOMAN(a)).
From this, we are ableto conclude sort(MALE(a)) and sort(FEMALE(a)), and we can prove thatinconsistent holds.Summarizing, the sortal compatibility check is used as a filter for the more generalconsistency check, for which fully fledged first-order theorem proving is used.
If it isimpossible to prove inconsistent, it is assumed that the antecedent discourse referentis compatible with its binder.
As I will show in the next section, this filter reduces thesearch space in resolution enormously.5.3 PerformanceThe resolution algorithm was tested on a corpus of route instructions collected ina scenario in which somebody explains to a mobile robot how to reach a certaindestination.
The corpus, collected in the IBL project (Lauria et al 2001), comprises283 utterances in 72 different route instructions, spoken by 24 different native Englishspeakers.
A typical sequence is the following:(30) Instructor: Go to the university!Robot: How do I get to the university?Instructor: Go straight ahead until you reach the post office.
Just pastthe post office turn left over the bridge.
Keep walking, there will be abuilding on the right and a building on your left.
Keep walking untilyou come to a train station on the left hand side and the university isopposite the train station.The corpus was processed on utterance-by-utterance basis, starting with a newDRS for each new route instruction.
Only the first (consistent) solution returned by207Bos Implementing Binding and Accommodation TheoryTable 3Occurrences of triggers in 283 utterances taken from spoken route instructions.
?-type n Percentage Average per utteranceref 1 0.1 0.04pro 42 4.7 0.15nam 50 5.6 0.18dei 380 42.3 1.34def 425 47.3 1.50Total 898 100.0 3.17Table 4Average CPU times for DRS resolution relative to the number of processed utterances.Number of utterances 1 2 3 4 5 6 7 8 9CPU time 0.542 0.709 1.140 1.654 1.177 1.495 6.037 2.462 0.773n 68 60 54 41 27 12 8 4 3the resolution algorithm was considered for subsequent processing of the route in-struction.
A total of 898 referential expressions appeared in the 283 utterances of thecorpus.
As Table 3 shows, pronouns and proper names are relatively rare in theseroute instructions, but on average there are 1.5 definite noun phrases per utterance.The average number of accommodation sites for a presupposition trigger in thiscorpus was 7.5.
(This relatively high number can perhaps be attributed to the way DRSsare nested into each other in representing route instructions and the way utterancegrounding is realized in the DRS.
Discussion of these issues, however, falls outsidethe scope of this article.)
The average number of potential antecedents (i.e., accessiblediscourse referents) for binding a presupposition trigger was 16.7.
These statisticsillustrate the immense search space in presupposition resolution.The implemented resolution algorithm performs with an average CPU time (mea-sured on a Sun Blade 100 workstation with 1 GB memory and a 500 MHz processor)of 1.21 seconds to transform an unresolved ?-DRS into a proper DRS (disregarding theconsistency checking; see below).
Table 4 shows the average CPU times for DRS reso-lution relative to the number of processed utterances and so illustrates the dependenceof processing time on the size of the DRS capturing the previous discourse.To find out which of the acceptability constraints contribute the most in narrow-ing down the search space, the number of attempts and success/failure rate werecomputed for sortal compatibility, proper binding, and bound variables, after a pre-suppositional DRS has been resolved or accommodated.
Most of the credit for reduc-ing the size of the search space goes to checking for sortal violations, which weredetected 8,111 times in 8,303 attempts (97%).
Only 99 (1.04% of 9,466 cases) ?-DRSswere found to contain free variables.
Similarly rare were cases of binding violation(73 occurrences in 9,156 considered cases).
Still, it pays off to verify these constraintson partially resolved ?-DRSs.
For instance, the average CPU time for resolving a DRSthat violated the bound variable constraint during resolution was 2.5 seconds (n = 35)when this constraint was checked partially, but 15.0 seconds when it was checked onfully resolved representations.Finally, let us consider the findings regarding the use of first-order inference en-gines to implement consistency checking of DRSs.
This is a very hard task: Dialogues208Computational Linguistics Volume 29, Number 2such as that in example (30) generate up to several hundred thousand clauses.
More-over, off-the-shelf provers are not designed for linguistic problems.
Instead, they aremostly tuned to mathematical problems.Several theorem provers and model builders were put to the test, including Hansde Nivelle?s (1998) BLIKSEM, which is optimized for the ?guarded?
fragment of first-order logic, Bill McCune?s OTTER and MACE (McCune and Padmanabhan 1996; Mc-Cune 1998), and the theorem prover SPASS (Weidenbach et al 1999).
For this particulartask the model builder MACE and the theorem prover SPASS clearly outperformedthe other inference engines; they were able to find an answer within 30 seconds for66% of the 283 inference problems assigned to them (the majority of the DRSs beingconsistent) in CPU times varying from 2.5 to 29.9 seconds (average 13.0 secs).These results are perhaps too limited to justify the inclusion of first-order theo-rem proving in today?s natural language understanding components.
Nevertheless, Ibelieve that first-order theorem provers will play an important future role in com-putational semantics for three reasons.
First of all, automated theorem proving is apromising, emerging field.
Moreover, most of the first-order inference engines, albeitgeneral purpose, are designed to cope with nonlinguistic problems, and cooperationof computational linguists with researchers in the area of automated deduction mightimprove the performance of these inference engines on linguistic inference problems.Second, the current approach is nonincremental.
After a new utterance is combinedwith the previous DRS, the complete newly constructed DRS is translated to first-orderlogic and checked for consistency, without appealing to previous inference results atall.
It is likely that inference-based natural language understanding would benefit froman incremental approach, particularly with regard to model building.
Third, there isroom for improvement in the formulation of the inference problem itself.
Future workshould address the use of sorted logics, include experimenting with other modal for-mulations, and consider the use of discourse structure to limit the size of DRSs to bechecked for consistency.6.
ConclusionThe implementation of BAT presented in this article covers a wide spectrum of ref-erential expressions, ranging from simple pronouns to rich presupposition triggers.Compared to Van der Sandt?s (1992) original formulation of BAT, the implementa-tion discussed here offers improvements on both the representational and inferentiallevels.
Representational aspects of my reformulation of BAT include a new syntaxfor unresolved DRSs, which allows for selective binding and moreover provides ameans of defining free and bound variables on these structures and hence enables usto implement the free-variable constraint on partially resolved DRSs.
The inferentialaspects involve a formulation of the acceptability constraints concerning consistencyand informativeness, in particular the local versions of these, and an implementationof these constraints using general-purpose theorem provers for first-order logic.The core of the algorithm is realized as a PROLOG agent within the OAA envi-ronment.
Off-the-shelf first-order theorem provers are used as agents to perform therequired reasoning tasks.
Results of tests conducted on a corpus of spoken route in-structions suggest that the core of the algorithm performs reasonably well, certainlywhen one considers the enormous search space that is involved in presuppositionresolution.
The importance of reducing the search space is demonstrated in an exper-iment in which the free-variable constraint, imposed on partially resolved representa-tions, shows a substantial increase in performance compared to when it is imposed oncompletely resolved representations.
Furthermore, to distinguish among the different209Bos Implementing Binding and Accommodation Theoryanaphoric natures of various presuppositional expressions, a classification of ?-typesfor presuppositions triggered by noun phrases is proposed and used to increase effi-ciency in the implementation of the resolution algorithm.Although the algorithm presented in this article already includes a number ofheuristics to state preferences among a number of candidates of resolved discourserepresentations, it could further benefit from suggestions made in centering theory(Grosz, Joshi, and Weinstein 1995) to express salience among discourse referents.
Inthe terminology of centering, discourse referents can naturally be seen as centers, withforward-looking centers being a subset of the accessible discourse referents and theunique backward-looking center being a designated discourse referent resembling thefocus of discourse.
These aspects of centering theory will enable us to include a notionof coherence in BAT, but how to establish the ranking of forward-looking centers (toreflect relative prominence) in a DRT-based formalism remains a subject of futureresearch.AcknowledgmentsThe research reported in this articleoriginated at the Department ofComputational Linguistics at the Universityof the Saarland in Germany and was furtherdeveloped at the Institute forCommunicating and Collaborative Systemsat the University of Edinburgh.
I wish tothank Patrick Blackburn and ManfredPinkal for supervision, discussion, andadvice.
I am grateful to David Beaver, HansKamp, Ewan Klein, Michael Kohlhase, Hansde Nivelle, and Rob van der Sandt for theirvaluable suggestions, which greatlyimproved the presupposition resolutionalgorithm presented in this work.
TetsushiOka helped design and implemented theinference agents in the Open AgentArchitecture.
The corpus of routeinstruction was collected and transcribed byGuido Bugmann, Stasha Lauria, TheoKyriacou, and Joe Frankel (as part of theIBL project, under grants GR/M90023 andGR/M90160).
Finally, I would like to thanktwo anonymous reviewers for this journalfor their valuable suggestions.ReferencesBeaver, David I.
1997.
Presupposition.
InJohan Van Benthem and AliceTer Meulen, editors, Handbook of Logic andLanguage.
Elsevier, Amsterdam, and MITPress, Cambridge, pages 939?1008.Beaver, David I.
2002.
PresuppositionProjection in DRT: A critical assessment.In David Beaver, Luis Casillas, BradyClark, and Stefan Kaufmann, editors, TheConstruction of Meaning.
StanfordUniversity Press, Stanford, California,pages 23?43.Blackburn, Patrick.
2000.
Representation,reasoning, and relational structures: Ahybrid logic manifesto.
Logic Journal of theIGPL, 8(3):339?365.Blackburn, Patrick, Johan Bos, MichaelKohlhase, and Hans de Nivelle.
2001.Inference and computational semantics.In Harry Bunt, Reinhard Muskens, andElias Thijsse, editors, Computing Meaning,volume 2.
Kluwer, Dordrecht,pages 11?28.Bos, Johan and Tetsushi Oka.
2002.
Aninference-based approach to dialoguesystem design.
In Proceedings of COLING2002.Cheyer, Adam and David Martin.
2001.
TheOpen Agent Architecture.
Journal ofAutonomous Agents and Multi-AgentSystems, 4(1/2):143?148.de Nivelle, Hans.
1998.
A resolutiondecision procedure for the guardedfragment.
In C. Kirchner and H. Kirchner,editors, 15th International Conference onAutomated Deduction, CADE-15.Springer-Verlag, Berlin, pages 191?204.Fellbaum, Christiane, editor.
1998.
WordNet.An Electronic Lexical Database.
MIT Press,Cambridge.Geurts, Bart.
1997.
Good news about thedescription theory of names.
Journal ofSemantics, 14:319?348.Geurts, Bart.
1999.
Presuppositions andPronouns.
Elsevier, London.Groenendijk, Jeroen and Martin Stokhof.1991.
Dynamic predicate logic.
Linguisticsand Philosophy, 14:39?100.Grosz, Barbara J., Aravind K. Joshi, andScott Weinstein.
1995.
Centering: Aframework for modeling the localcoherence of discourse.
ComputationalLinguistics, 21(2):203?225.Heim, Irene.
1982.
The Semantics of Definiteand Indefinite Noun Phrases.
Ph.D. thesis,University of Massachusetts,Amherst.210Computational Linguistics Volume 29, Number 2Heim, Irene.
1983.
On the projectionproblem for presuppositions.
InM.
Barlow, D. Flickinger, andM.
Westcoat, editors, Proceedings of theSecond Annual West Coast Conference onFormal Linguistics, pages 114?126.Kamp, Hans.
1981.
A theory of truth andsemantic representation.
In JeroenGroenendijk, Theo M. V. Janssen, andMartin Stokhof, editors, FormalMethods in the Study of Language, pages277?322.Kamp, Hans and Uwe Reyle.
1993.
FromDiscourse to Logic: An Introduction toModeltheoretic Semantics of NaturalLanguage, Formal Logic and DRT.
Kluwer,Dordrecht, the Netherlands.Karttunen, L. 1974.
Presuppositions andlinguistic context.
Theoretical Linguistics,1:181?194.Kuschert, Susanna.
1999.
Dynamic Meaningand Accommodation.
Ph.D. thesis,Universita?t des Saarlandes, Saarbruecken,Germany.Lauria, Stanislao, Guido Bugmann,Theocharis Kyriacou, Johan Bos, andEwan Klein.
2001.
Training personalrobots using natural languageinstruction.
IEEE Intelligent Systems,16(5):38?45.Lewis, David.
1979.
Scorekeeping in alanguage game.
In R. Ba?uerle, U. Egli,and A. von Stechow, editors, Semanticsfrom Different Points of View, volume 6 ofSpringer Series in Language andCommunication.
Springer-Verlag, Berlin,pages 172?187.McCune, W. 1998.
Automatic proofs andcounterexamples for some ortholatticeidentities.
Information Processing Letters,65(6):285?291.McCune, W. and R. Padmanabhan.
1996.Automated Deduction in Equational Logic andCubic Curves.
Lecture Notes in ComputerScience (AI subseries).
Springer-Verlag,New York.Moore, Robert C. 1980.
Reasoning aboutknowledge and action.
Technical Report181, SRI International, Menlo Park,California.Muskens, Reinhard.
1996.
CombiningMontague semantics and discourserepresentation.
Linguistics and Philosophy,19:143?186.Parsons, Terence.
1990.
Events in theSemantics of English: A Study in SubatomicSemantics.
MIT Press, Cambridge.Van der Sandt, Rob A.
1992.
Presuppositionprojection as anaphora resolution.
Journalof Semantics, 9:333?377.Van der Sandt, Rob A. and Bart Geurts.1991.
Presupposition, anaphora, andlexical content.
Technical Report 185, IBM,Wissenschaftliches Zentrum, Institut fu?rWissensbasierte Systeme, August.Van Eijck, Jan and Hans Kamp.
1997.Representing discourse in context.
InJohan Van Benthem and AliceTer Meulen, editors, Handbook of Logic andLanguage.
Elsevier, Amsterdam, and MITPress, Cambridge, pages 179?240.Weidenbach, Christoph, Bijan Afshordel,Uwe Brahm, Christian Cohrs, ThorstenEngel, Enno Keen, Christian Theobalt,and Dalibor Topic.
1999.
Systemdescription: Spass version 1.0.0.
In HaraldGanzinger, editor, 16th InternationalConference on Automated Deduction,CADE-16, volume 1632 of Lecture Notes inArtificial Intelligence.
Springer, Berlin,pages 314?318.
