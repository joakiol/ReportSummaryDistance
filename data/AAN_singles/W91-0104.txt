Inherently Reversible Grammars,Logic Programmingand ComputabilityMarc DymetmanCCRIT, Communications Canada1575 boulevard ChomedeyLaval (QuEbec) HTV 2X2, Canadadymetman@ccrit.doc.caABSTRACTThis paper attempts to clarify two distinct notionsof "reversibility": (i) Uniformity of implementa-tion of parsing and generation, and (it) reversibil-ity as an inherent (or intrinsic) property of gram-mars.
On the one hand, we explain why gram-mars specified as definite programs (or the vari-ous related "unification grammars") lead to uni-formity of implementation.
On the other hand, wedefine different intrinsic reversibility properties forsuch grammars--the most important being finitereversibility, which says that both parsing and gen-eration are finitely enumerable (see text ) - -  and giveexamples and counter-examples of grammars whichpossess or do not possess these intrinsic properties.We also show that, under a certain "moderation"condition on linguistic description, finite enumer-ability of parsing is equivalent to finite enumerabil-ity of generation.1 In t roduct ionFrom the linguist's point of view, a grammar is aformal device which defines a recursively enumer-able set of well-formed linguistic structures, eachhaving, among other aspects, a phonological con-tent (or, when dealing with written text, a stringcontent) and a semantic ontent.
Such a device iscompletely neutral as regards its uses for parsing(recovering semantic content from string content)or generation (recovering string content from se-mantic content).From the computational linguist's point of view,on the other hand, the problem is how to imple-ment such a grammar both as a parsing programand as a generation program, in such a way thatthese programs exactly reflect the content of thegrammar.
This we will call the reversibility prob-lem.Let us assume, for specificity, that the grammarhas been presented as a definite program (a Prologprogram)J Then the reversibility problem has asimple solution: use a complete interpreter for defi-nite programs--for instance a top-down interpreterhaving a breadth-first search procedure2--and di-rectly use the grammar as the program both forparsing and for generation.
In the parsing mode,for any given string x, the program will enumerateall semantics Yl,Y2,... assigned to it by the gram-mar, and similarly, in the generation mode, for anygiven semantics y, the program will enumerate allsemantics xl, x2, .
.
,  assigned to it by the grammar.This is a striking property of definite programs:they are reversible in the sense that they naturallylead to uniformity of implementation f the parsingand generation modes (see ?4).So the reversibility problem is solved, and we canspend the next few years skimming through Fodor's(not Jerry's) guides in travel bookstores?Not quite.
First, the standard depth-first inter-preter for definite programs is an incomplete one,and this problem must be circumvented in someway.
Second, and more crucially, even when us-ing a complete interpreter, parsing (and similarlygeneration) does not in general terminate: the pro-gram may well enumerate Yl,Y2,... ad infinitum.This is even true if, in fact, there are only a finitenumber of solutions Yl,Y2,.. .
,  Yk, or even, in theextreme case, no solution at all: the program maynot be "aware" that it has at some point alreadyexhausted all the solutions that it will eventually1We could have made some other  choice, for instancesome unification grammar formalism.
The advantage of us-ing definite programs in the present  discussion is that theyembody the whole unification paradigm in its purest form,that unification of terms is conceptually simpler (and lessprone to misunderstandings) than unification of DAGs, andthat the denotational nd operational semantics of definiteprograms have been thoroughly studied.2See e.g.
\[7, p. 59\] and section ?2.1.3.
See also \[19\] in thisvolume for a related approach.20find, and go on eternally looking for new solutions.The source of this problem can be more or lesssevere: It may simply be due to the grarnmar'simplementation as,a certain program, or it may beintrinsic to the grammar.If it is not intrinsic to the grammar, one mayattempt some kind of program transformation onthe grammar- - for  qnstance a local transformationas goal reordering in clause bodies \[4, 16\], or aglobal transformation as left-recursion elimination\[5, 3\] 3 - - in  order 'to get a parsing program whichdisplays a finite behavior.
4 If  such a transforma-tion is possible in principle, we say that, intrinsi-cally, the grammar has a finitely enumerable pars-ing problem.
5 One.example of a class of grammarswhich respect his crucial condition is provided byoffline-parsable DCGs, once compiled as definiteprograms (see \[9\]).
6We have limited the former discussion to the caseof parsing.
The case of generation is treated in aparallel fashion, and one can similarly define theconditions in which a grammar is said to have an in-trinsically finitely enumerable generation problem.When a grammar is such that it has a finitely enu-merable parsing problem and a finitely enumerablegeneration problem, we call the grammar inherentlyfinitely reversible.When this is the; case, it is by definition possibleto find a program Pp for parsing and a (not nec-essarily identical) program Pa for generation suchthat, for any string z, Pp enumerates all associatedsemantics y and terminates, and, for any seman-tics y, Pg enumerates all associated strings z andterminates.Inherent finite reversibility is the concept which,in my opinion, permit us to capture formally theintuitive notion that a certain grammar is, or isnot, "reversible".3Or more generally, any transformation exploiting the-orerns provable of the: grammar.
Another  instance of thistechnique is provided by the addit ion of conservative guidesin \[5\], which "strengthen" the grammar on the basis of prop-erties inferable from " ' its form.4 Another popular approach is to use a special-purposeinterpreter, exploiting\[ propert ies of the grammar known apriori.
\[18\] and \[14\] use this approach in the case of gener-ation (see below).
:5The description is simplified; see ?3 for the exactdefinition.
?See also \[17\] for a discussion of oifttine-parsability in thecontext of generation.2 Def in i te  programs andcomputat ion2.1 Denotat ional  and operational se-mantics of a definite program;complete and incomplete inter-pretersA definite program P is a finite set of clauses of theform (non-unit clauses):p(T1,..., T,)px(Tlx, .
.
.
,Tin,)'" "pro(Tin1,...
,Tmn.
)or of the form (unit clauses):p(Tx,.
.
.
,  Tn)where the the P,Pi are predicate symbols and theTi, T/j are terms over a certain Herbrand universeof ground terms H.We will suppose that, among the predicates pdefined by P,  one, r, is privileged and plays therole of the "main predicate" in the program.
Wewill assume that r is of arity one.
72.1 .1  Denotat iona l  semant icsThe denotational, or declarative, semantics of pro-gram P can be defined as the least fixed point of acertain operator on Herbrand interpretations whichwe will not describe here (see \[7\]).
Informally, thedenotations of the predicate symbols p are definedas n-ary relations p(zx, .
.
.
,  Xn) over H, built as thelimit of a bottom-up rocess which starts from theunit clauses and uses the non-unit clauses to addnew instances to each relation.In particular, this process defines the unary rela-tion r(x) on H, which we shall call the denotationalsemantics of the main predicate r relative to pro-gram P.Let T be a term over H; We define the special-ization of r(X) on T as the relation rT(x) on Hdefined by:def rT(~) =-- r(~) ^  x E Zwhere ff is the relation of subsumption.
In case theterm T is a variable X,  we say that X is the trivialspecialization, and we note that the relation rx (z )is identical to the relation r(z).7This assumption permits  to simplify tile exposit ion, butis not otherwise necessary.212.1.2 Operat iona l  semant icsWhile the denotational semantics of P is an in-trinsic property of P, its operational semantics isdefined relative to some interpreter.For our purposes, we will informally define aninterpreter as a computational mechanism:intpr(  P, r (T )  )which is input a definite program P, as well as aquery ?
r (T) - -where  r is P 's  main predicate andT a term over H- -and  which outputs a f inite orinfinite "list of answers":T1,T2 , .
.
.
,Tk  .
.
.
.The Tk's are terms over H,  ground or not, whoseground instances provide the "solutions" to query?r(T).
I f  the list of answers is infinite, the inter-preter will not stop; If  it is finite the interpretermay or may not stop: if it does, we will say thatthe interpreter terminates on query ?r(T).Consider now the relation r~ on H defined by:r~(x) def _= xET1Vz~T2V.
.
.VxETk  V .
.
.We say that r~r is the operational semantics of themain predicate r of P, for specialization T,  relativeto interpreter intpr.Keeping the same notations as above, considernow the denotational semantics r(x) of r relativeto P, and consider its specialization rT(x).Interpreter intpr  is said to be sound iff one has,for any P, r, T:w e H r (x) rr(x);and to be complete iff:Vx ?
H r r (x )  ~ r~(x).Soundness is a minimal requirement for an in-terpreter, and we will always assume it, but com-pleteness is a requirement which is not always metin practice.2.1.3 Complete  and  incomplete  inter -p re tersThe "standard" interpreter for definite programsuses a top-down, depth-first search algorithm.
Itis sound but not complete.
Its non-completeness idue to the fact that it is depth-first: if its search-tree contains infinite branches, the interpreter willbe "caught" in the first one and will never explorethe branches- -maybe l ading to success--to theright of this branch in the search-tree \[7, pp.
59-60\].By contrast, a top-down, breadth-first inter-preter, i.e.
one which explores nondeterministicchoices (between the different clauses competing forresolution of the same atomic goal) in parallel s iscomplete \[7, pp.
59\].The nffive bottom-up interpreter, which inessence directly calculates the denotational seman-tics of P,  and filters a posteriori the semantics r(x)through the constraint that the solutions unify withT, is also a complete algorithm.2.2 Computat iona l  behav ior  of adef in i te  program relat ive to aninterpreterWe now consider a program P, having r as mainpredicate, the denotation of r relative to P beingthe relation r (x)  on H. We also consider a special-ization T, i.e.
a term on H.We will compare the denotational content of Pto its computational behavior, and describe threepossibilities: (i) P enumerates r on T,  (it) P dis-covers r on T,  and (iii) P finitely enumerates r onT.
The interpreter is supposed to be fixed before-hand.We say that:?
P enumerates r on specialization Ti f f :Vx e H r~(x)  ~ rT(x),in other words, iff its list of answers:T1,T~,...Tk,...exactly "covers" the denotational semanticsrT  .9?
P discovers r on specialization Ti f f :1.
P enumerates r on T;2.
If r T is the uniformly false relation on H,then P terminates on T.
l??
P f initely enumerates r on specialization Tif f :1.
P enumerates r on T;s Or, alternatively, uses a .fair search rule, i.e.
one which"shares its attention" among all paths in the search-tree.9This will always he the case if the interpreter is soundand complete,  as seen in ?2.1.2.10 Therefore, when rT is tmifornaly false, the list of answersis empty, and the program is "aware" of this fact (i.e.
itterminates).22I2.
P terminates on T J  1We simply say that P enumerates (discovers,finitely enumerates) r iff P enumerates (discovers,finitely enumerates) r on the trivial specializationX.We have the obvious entailments:P finitely enumerates r on T ~ P discovers (1)r on T ~ P enumerates r on T.It is often the case that one is interested in thecomputational properties of a given definite pro-gram relative to a certain class of specializations.For instance, when using a grammar- -g iven as adefinite program--for  parsing, one will consider allqueries where some' of the variables are ground (thestring to parse) and others (the semantic form) arenot, and one will want to consider the computa-tional properties Of the program relative to thisclass of specializations.
When using the definiteprogram for generation, one will be interested inanother class of specializations, and will want toconsider the computational properties of the pro-gram relative to that class of specializations.Let S = {T} be a set of (not necessarily ground)terms on H, inde?ed by a finite or infinite set I.We call S a class of specializations.
We say that:?
P enumerates r on S iff, for all T E S, Penumerates r on T;?
P discovers r On S iff, for all T E S, P discov-ers r on T;?
P finitely enumerates r on S iff, for all T E S,P finitely enumerates r on T.The mutual entailments between these proper-ties are similar to the ones given in (1).2.3  In t r ins ic  : computat iona l  p roper -t ies  o f  a definite programLet S be a class of specializations, and let r(z)be an arbitrary unary relation on H.  We supposehere that programs are evaluated with respect toa sound and compiete interpreter, which has beenfixed once and for/all, and we say that:?
r is enumerable on S iff there exists a definiteprogram P which enumerates r on S.?
r is discoverab!e on S iff there exists a definiteprogram P which discovers r on S.llXn particular, the relation r T is, loosely speaking,"finitely representable asa union of terms T1, T2, .
.
.
Tk" andthe  program is "aware", at a certain point, that it has ex-hausted  the possible answers.?
r is finitely enumerable on Sq iff there exists adefinite program P which finitely enumerateston  S.These three notions, taken together, constitute a"computability hierarchy" where enumerability isthe weakest condition, discoverability is an inter-mediary condition, and finite enumerabil ity is thestrongest condition.
These computabil ity condi-tions can be described more intuitively in the fol-lowing way: 12?
r is enumerable on S if there exists a programP such that, for any T E S, P is able, giveninfinite time, to find terms T1, T2, ?
?
?
such that:Vz e H r(z)  ^  z E TzET lVz  ET2V- .
.?
r is discoverable on S if there exists a programP which is furthermore able to decide in finitetime, for any T E S, if there actually exists anz such that:r(x) ^  z E T?
r is finitely enumerable on S if there exists aprogram P which is furthermore able to find infinite time, for any T E S, terms T i ,T2 , ' .
.
,Tksuch that:VxE H r(z) AxETx E T~ V x E T2.
.
.
v x E TkLet {X} be the set having for only element hetrivial specialization X; {X} is called the trivialclass of specializations.
We will simply say that ris ennmerable (resp.
discoverable, finitely enumer-able) iff r is enumerable (resp.
discoverable, finitelyenumerable) on the trivial class {X}.Let ~ = H be the set of all ground terms of H.is called the class of ground specializations.
The fol-lowing properties--which we will not prove here- -establish links between the notions that we havejust defined and the classica} notions of recursivelyenumerable relations and recursive relations:r is a recursively enumerable relation on Hiff r is enumerable on the trivial class ofspecializations {X};  if thiS is the case, then (2)for any class of specializations S, r is enu-merable on S.12Note that these definitions critically depend on the rel-ative scopes of quantifiers 3P VT E S .
.
.
: it is essenti~dthat program P be the same for all specializations T in S.23r is a recursive relation on H iff r is discov-erable on the class of ground specializationsG iff r is finitely enumerable on the class ofground specializations G.(3)3 Grammars  and  the i r  com-putat iona l  usesLet X#Y denote, in infix notation, the term#(X ,Y ) .
In the context of this paper, we takea grammar to be a definite program G having asits main predicate the unary predicate r, and wewill assume that the clauses defining r are of theform:r(X#Y) .
.
.X will be called the "p-parameter", Y the "g-parameter".
Generally, the p-parameter will rep-resent a character string, and the g-parameter asemantic form.
133 .1  S ix  computat iona l  p rob lemsA grammar can be used either to enumerate well-formed structures or to check whether certain fullyinstantiated values of the parameters can be ac-cepted.
We distinguish six computational prob-lems (grouped into four types) which can be solvedwith a grammar: p-enumeration, p-acceptation,g-enumeration, g-acceptation, bi-enumeration, bi-acceptation.
These problems are defined, togetherwith comments on their computational proper-ties, using the terminology of ?2.3.
This per-mits us to characterize the different positions agiven grammar can occupy on the "computabilityhierarchy" ---enumerability/discover ability/finiteenumerability--relatively to each of these prob-lems.3.1.1 p -enumerat lon  and  p -acceptat lonThe p-enumeration problem or parsing problem isthe problem of enumerating, for any fixed groundterm x, all ground terms y such that r(x#y).
Thep-acceptation problem or decision problem for pars-ing is the problem of checking, for any fixed groundterm z, whether there exists a ground term y suchthat r ( z#y)  is true.The same specialization class is associated withboth these problems, namely the class ~C'P ={z#Y}~eH consisting in all the terms ~#Y where13We thus take r to be a unary relation which "encodes"a binary relation.
This is unessential, but permits us to usethe concepts of the previous ection, developed for unary re-lations, without having to generalize them to n-ary relations.is any ground term, and Y is a certain variable(whose name is indifferent).Let's consider in turn, with respect to G~P, thedifferent positions the grammar--or  equivalently,its denotational semantics r - -can occupy on thecomputational hierarchy, from strongest o weak-est:F in i te  enumerab i l i ty  When r is finitely enu-merable on G7 ~, it is in theory possible to finda program P such that, for any given (ground)value x of the p-parameter (the string), the pro-gram enumerates all the solutions to the parsingproblem and terminates.
These solutions are givenimplicitly as a finite list of answers TY1,.
.
.
,  TYk:the TYi's are terms whose ground instances y arethe looked-for values of the g-parameter (the se-mantics associated with string z by the grammar).We also say that, with the grammar at hand, p-enumeration is finitely enumerable, or simply, thatparsing is finitely enumerable.
This is an inher-ent property of the grammar, and, ill practice, thisproperty does not necessarily entail that finding aprogram P to exploit will be obvious.
14 For in-stance, offiine-parsable grammars \[9\] can be shownto possess a finitely enumerable parsing problem,but algorithms which are able to make use of thisproperty are by no means trivial \[9, 13, 3\].
15D iscoverab i l i ty  If r is not finitely enumerableon GP, it may still be discoverable on G79.
Bydefinition, this means that it is possible to find aprogram P such that, for any given (ground) valuez of the p-parameter, if there is no value y of theg-parameter corresponding to z, then the programwill "recognize" this fact in finite time and termi-nate with an empty list of answers; if, on the otherhand, there are solutions y corresponding to x, thenthe program will enumerate them, but maybe notterminate.
If this property holds, we also say thatwith the grammar at hand, p-enumeration is dis-coverable, or, simply, parsing is discoverable.
Onecan easily prove (although we will not do it here)that this property is equivalent to the decidability(in the classical sense) of the p-acceptation prob-lem.
In other words:14See footnote 177.15These papers do not use the concept (or, afort iori ,  theterminology) "finite enumerabillty of parsing", which, to myknowledge, appears here for the first time (see however \[6\],for the related notion of "Universal Parsing Problem" ).24!p-enumeration is discoverable if and onlyif p-acceptation is decidable.
16Enumerab i l l ty  By the definition of a gram-mar as being a recursively enumerable mechanism,and by property (2), r is enumerable on any spe-cialization class, and in particular on G'P.3.1.2 g-enumerat ion  and  g -acceptat ionThe g-enumeration 'problem or generation problemis the problem of enu~ merating, for any fixed groundterm y, all ground terms x such that r(x#y).
Theg-acceptation problem or decision problem for gen-eration is the problem of checking, for any fixedground term y, whether there exists a ground termx such that r(x#y)its true.The specialization class is associated with boththese problems is the class G~ = {X#Y}ueH con-sisting in all the terms X#y where y is any groundterm, and X is a certain variable (whose name isindifferent).The situation is e.xactly symmetrical to the caseof p-enumeration and p-acceptation, and we candefine, in the same way, the notions: "generationis finitely enumerabie" and "generation is discover-able" (which is equivalent to "g-acceptation is de-cidable').3.1.3 b i -enumerat ionThe hi-enumeration,problem is the problem of enu-merating all ground i terms x, y such that r (x#y) .The specialization class associated with thisproblem is the class' 7rRZP = {X#Y} which con-tains the single term X#Y.For non-degenerate grammars, it is not the casethat r is finitely enumerable on TRIP ,  for thiswould entail in particular that any string recog-nized by the grarnrnar is subsumed under one ofthe terms in a fixed finite set of terms T1, .
.
.
,  Tk.This is a slightly weaker property than saying thatthere are finitely many strings recognized by thegrammar, but is stil!
a very unlikely property for agrammar.On the other hand, by definition, r is enumerableon TRZP.
It can be shown easily that it is alsodiscoverable on 'TRT- 'P .
1716An immediate  cons,~luenee of this property (l inking thep-enumerat ion  problem, with the p-acceptat ion problem) isthe fact that  a grammmr which is finitely enumerable  forpars ing has a decidable p-acceptat ion problem.
The con-verse is clearly false (see ?6 for a counter-example) .lr  Th is  is because :  (i) In case the grammar  gener-ates nothing, there is a trivial p rogram which, on query3.1.4 b i -acceptat ionThe bi-aceeptation problem is the problem of check-ing, for any fixed ground terms x and y, whetherr(z#y) is true.The specialization class associated with thisproblem is the set ~ = {x#Y}~,v~n of ground spe-cializations.It can be shown that r is finitely enumerable onG iff it is discoverable on ~ iff the relation r on His recursive in the classical sense.
When this is thecase, one says that bi-acceptation is decidable.Again, by property (2), r is enumerable on anyspecialization class, and in particular on G.REMARK.
Suppose that parsing is finitely enu-merable, that is, r is finitely enumerable on ~P.This obviously implies that r is also finitely enu-merable on ~.
Therefore, one has:parsing is finitely enumerable ::~ bi-acceptation is decidable;and, by the same reasoning:generation is finitely enumerable =V bi-acceptation is decidable.On the other hand, the weaker property thatp-acceptation is decidable (or similarly, that g-acceptation is decidable) does not seem to entailthat bi-acceptation is decidable.4 Definite programs, unifor-mity of imp lementat ion ,and reversibilityIt is sometimes tated that various grammaticalformalisms, based on a variant or another of uni-fication, are "reversible".
It should more properlybe said that they are "well-adapted" to reversiblegrammar implementations.
The paradigmatic caseof a grammar given as a definite program G makesthis especially clear.We know, from the discussion of ?3.1.1 and?3.1.2, that we always have: (i) r is enumerable?r(X#Y),  produces an  empty  list of answers and  termi-nates  and (it) if this is not the case, then the grammaritself may  serve as an enumerat ing  program (perhaps anon- terminat ing  one).
Note that  this does not entai l  thatby looking at  the grammar ,  one is actual ly  ab le - -even  inprinciple---to decide which of these two s i tuat ions  actual lyholds!
Th is  is an  extreme instance of the remark  made above(in the discussion of f inite enumerabi l i ty  of pars ing)  that  theexistence in principle of a p rogram meet ing  certain criteriadoes not imply that  it is obvious, or indeed possible, to findsuch a program.25on 6P  and (ii) r is enumerable on 66;  we thereforeknow that there exist programs Pp and Pg whichenumerate r respectively on ~P and ~G.
But infact we have more: if we use a sound and completeinterpreter, we can simply take Pp = Pg = G. Thisfollows from the fact that, by definition, relativelyto such an interpreter, G enumerates rT, for anyspecialization T (see ?2.1.1):* G enumerates r on GP;?
G enumerates r on GG.To be more concrete, suppose that we use a com-plete top-down interpreter; Its behavior will bealong the following lines:1.
On query ?
r (X#Y) ,  the interpreter eturnsthe (generally infinite) list of answersT~,T2 , .
.
.
,Tk , .
.
.where each ~ is a term of the form Ai~Bi;The (generally infinite) "union" of these terms"exactly covers" the query;2.
On a query of the form ?r (z#Y) ,  where x isa ground term, the interpreter returns the listof answersTtU(x#Y),  T2U(x#Y) , .
.
.
,  Tk U(z#Y) , .
.
.where I._1 is the operator of term unification,and where, with some abuse of notation, onlythe terms TitA(x#Y) for which unification ispossible actually appear in the list;3.
On a query of the form ?r(X~y), where y isa ground term, the interpreter returns the listof answersT, u(  X #y) ,  T~u( X #y) ,  .
.
.
, TkU( X #y)  .
.
.
.
(with the same abuse of notation as above).This is a rather striking property of definiteprograms: different "input modes" can be imple-mented using one and the same interpreter andone and the same program.
(This property stronglycontrasts with other programming paradigms, forinstance functional or imperative ones.
Programsof these types typically map an input x to an out-put y, and, while it is indeed true that, for a giveny, the set of ~i which can serve as its input is recur-sively enumerable, the interpreter that could imple-ment the (nondeterministic) mapping y ~ x wouldhave to be widely different from the "normal" in-terpreter for the language at hand.
)However, "reversibility" in this sense only meansuniformity of implementation for different modesof use of a grammar.
Intrinsic finite reversibilitywhich is defined in the next section, gives a muchstronger criterion of grammar eversibility.5 Inherent ly  revers ib le  g ram-marsWe say that a grammar G is (inherently) finitelyreversible iff, in the terminology of ?3.1.1 and?3.1.2, G is such that:1. parsing is finitely enumerable;2. generation is finitely enumerable.In other words, G is finitely reversible iff thereexists a program Pp for parsing and a (not necessar-ily identical) program P9 for generation such that,relative to some sound and complete interpreter: is1.
On a query of the form ?r (x#Y) ,  where x isany ground term, Pp returns a finite list ofanswersx#T1, x#T2,..., z#Tkand stops.2.
On a query of the form ?r (X#y) ,  where y isany ground term, Pg returns a finite list ofanswersTI #y ,  T~#y,  .
.
.
, T/  #yand stops.In order to guarantee that a grammar is finitelyreversible, some strong assumptions must be madeon its form.
An example of such assumptions i  pro-vided by the class of Lezical Grammars describedin \[5\].
19Lexical grammars are presented as definite pro-grams.
They all share the same core of rules,which describe basic compositionality assumptions(string compositionality, syntactic compositional-ity, semantic ompositionality), but may have dif-ferent lexicons, which contain all the more specificlinguistic knowledge.lSIn fact, one can also take here an incomplete interpretersuch as the standard Prolog interpreter stintpr.
Obviously,if programs Pp and Pg exist for a sound and complete in-terpreter intpr, one can also find such programs P~ and P~relative to stintpr, by simulating intpr inside stintpr.19See also \[10\] for a related approach.26parsingfinitelyenumerableb i -acceptat ion J  i /~ ?
?decidable ~ ~ :generationfinitelyenumerables~ % ".9 s >./#?
%%s "alKrparsing discoverablep-acceptation decidablegeneration discoverableg-acceptation decidableFigure 1: Computational problems associated with a grammar.The hypotheses made on string compositionalityin Lexical Grammars are simply that sister con-stituents concatenate heir strings; they entail thatparsing is finitely e~numerable.
The hypotheses onsemantic ompositignality are related to functionalapplication and composition in categorial gram-mars (see e.g.
\[15\]).
They entail that generationis finitely enumerable.A lexical grammar G is therefore finitely re-versible.
This does not imply that it can be useddirectly for parsing and for generation, but only,as seen previously, that there exist two programsPp and P9 implementing G respectively for pars-ing and for generation.
These programs are eachobtained by a technique of adding to the grammarsome redundant knowledge--respectively a conser-vative guide for parsing and aconservative guide forgeneration--and by applying a left-recursion elim-ination transformation (see \[5\]).6 Some counter -examples  tofinite reversibi l i ty and a"moderat ion"  condi t ion onl inguist ic descr ipt ionFig.1 sums up graphically some of tile relationswhich have been est,ablished in ?3 between tile com-putational problems associated with a grammar.The full arrows indicate entailments which havebeen established.
The dotted arrows relate to arather obvious question: What are the connectionsbetween the computational properties of parsingand those of generation?
For instance, does thefinite enumerability of parsing entail the finite enu-merability of generation?
If not, does it at leastentail that g-acceptation is decidable?
(The samequestions can be asked in the reverse direction.
)The answer is that, if no further assumptions aremade (see below ?6.3), then there are no connec-tions.
To show this, we now sketch one examplewhich shows that finite enumerability of parsingdoes not even entail that g-acceptation is decid-able.6.1 A "grammar"  re la ted  to  Mat iya -sev ich 's  theoremMatiyasevich's theorem \[2, p. 116\] provides--among other things--a negative solution toHilbert's tenth problem: "Does there exist an al-gorithm capable of solving all diophantine qua-tions?
", a diophantine quation being a multivari-able polynomial in integer coefficients and whosevariables range over N. 2?Let K be a recursively enumerable, but non-recursive, subset of N. One corollary of Matiya-sevich's theorem is the following proPerty \[2, p.127-28\]:There exists a polynomial q(zx,.. .
,  zn) ininteger coefficients such that K is the setof values taken by q, for z l , .
.
.
,  z,~ rangingover all integers.This corollary can be exploited to give an exam-ple of a "grammar" which has a finitely enumerableparsing problem, but such that its g-acceptationproblem is not decidable.Consider the relation r(x#y) which is trueiff: (i) x is a string encoding any instance (forZl, .
.
.
,  zn ranging over the integers) of the expres-sion q(zl , .
.
.
,  zn), using the symbols 0, .
.
.
,  9, '+','*', '(', ')', etc., and (ii) y is a term encoding the in-teger resulting from the arithmetical evaluation ofq(zl , .
.
.
,  zn).
This relation can easily be described2?The actual statement of Matiyasevich's theorem isstronger: "Every partially decidable predicate is diophan-tine" \[2, p. 116\].27by a "grammar" G: This grammar checks the welbformedness of string x, and calculates its "seman-tics" y.~l G has the following properties:?
parsing is finitely enumerable: there is a pro-gram (namely G itself) finitely enumerating ron GP.
In effect, for any string x, this pro-grams checks z for well-formedness and calcu-lates the (single) "semantics" y resulting fromthe evaluation of x.?
g-acceptation is not decidable.
Indeed, theproblem of g-acceptation is the problem of de-ciding, for any given integer y, whether y is inthe image of polynomial q, that is, whether ybelongs to K. But K is a non-recursive set,hence the conclusion.6.2 A "grammar" related to the un-decidabil ity of f irst-order logicI will only very broadly sketch this example, whichI think may provide useful insights on the impor-tance of constraining "string compositionality" ina grammar.Consider ordered pairs (x,y) of (ground) termswhere x is a string encoding a certain first-orderlogic tautology, and y (the "semantics") is a deriva-tion of x using a certain fixed set of axiom schemataand rules of inference for a complete system of first-order logic.
Let's assume for simplicity that thegiven rules of inference always have two premisesand one conclusion.
22A grammar G can be defined along the follow-ing general ines.
The clauses of G correspond tothe system's axiom schemata nd rules of inference.Each clause corresponding to an axiom schema ofname as defines "terminal constituents" (x, as(x)),where string z is any instance of schema as; eachclause corresponding to an inference rule of nameir takes two "constituents" (xx,yl) and (x2,y2),and, if applicable (which is checked on the basis ofstrings Xl and x2), builds a new constituent (x, y),where x is the string obtained from xl and x2 ac-cording to it, and where y is a new derivation treeir(x,yx, y2).
We have the following properties:?
generation is finitely enumerable: The genera-tion problem is the problem, given a derivation~1 This requires defining addition and multiplication of in-tegers inside G, which presents no special problem.22See for instance \[8, p. 43---44\] which describes a systemhaving the two rules of in_ference p I pDqq and ~ (wherex is free in p).
The second rule has one premise, but caneasily be viewed as having two, if the premise True is addedto  i ts  original premise.tree y, of enumerating all formulas x that areassociated with it.
But y contains an explicitrepresentation f x, so that generation is triv-ially finitely enumerable.p-acceptation is not decidable: The p-acceptationproblem is the problem of checking if a stringx can be derived from the axioms and the in-ference rules of the system.
That is, it is theproblem of checking if x is a tautology of first-order logic.
By Church's undecidability result,this problem is undecidable.6.3 Under a "moderation" conditionon linguistic description, parsingis finitely enumerable iff genera-tion isThe two counter-examples that we have just givenhave one property in common: the p-parameter canstay "small", while the g-parameter grows indef-initely "large", or conversely the g-parameter canstay small while the p-parameter grows indefinitelylarge.
For instance, in the first counter-example,for a given value of y, there is no way to bounda priori the sizes of the integers z l , .
.
.
, zn  thatmay produce this y; in the second counter-example,there is similarly no way to bound a priori the sizesof proofs y for a given formula x.In order to characterize this phenomenon for-mally, we will define a notion of "moderation" for agrammar G, defined as a definite program over theHerbrand universe H. As previously r is the unaryrelation representing the denotational semantics ofG.If a is a ground term in H,  let us call size ofthis term, and denote by size(a), the number ofnodes in a. Grammar G will be called moderate iffthere exist total recursive functions f : N ~ N,and g : N ~ N, such that:Vx, y E H r(x, y) :.~ size(y) _< f(size(x))^ size(x) < g(size(y)).We have the following property:If G is moderate, then, relative to G, pars-ing is finitely enumerable iff generation is (4)finitely enumerable.Let us briefly sketch the proof: Suppose that pars-ing is finitely enumerable, then we know (see ?3.1.4)that bi-acceptation is decidable.
On the other hand,for any fixed ground term y, there are only finitelymany ground terms z in H such that size(x) <28g(size(y)).
Therefore, we can finitely enumerateall these z's, and for each of them, decide whetherr(x, y) holds.
This shows that generation is finitelyenumerable.
The converse is proven in ,the sameway.Moderation might be claimed to be a "natural"constraint o impose on grammars used for "legit-imate" linguistic purposes: One might want to ar-gue that, in natural language, complexity of ex-pression is a rather direct reflection of complexityof meaning.
For example, semantic rules which re-duced "you love htm or you don't" to 'true', or?
J 7 "  "how much is 6 times 7 .
to '?x.
(x = 42)' wouldseem to be ruled out as valid linguistic descriptions.But we will not ffirther pursue these tricky ques-tions here.AcknowledgmentsThanks to Pierre Isabelle, Francois Perrault, PatrickSaint-Dizier, Tomek Strzalkowski and Gertjan vanNoord for their comments on an earlier version ofthis paper.
English and content have bigly sufferedfrom my lacking time to impose, as usual, its read-ing on Elliott Macklovitch.AppendixExamples  o f  f in i te ly  revers ib le  gram-mars  that  a re  inherent ly  d i f f i cu l t  toreverseIn this appendix, we give two examples of gram-mars that, although they are finitely reversible, aresuch that one mod~ is easy, while the reverse modehas a high degree o f  complexity.
These examplesare closely parallel, in the context of complexity,to the examples of  section 6, which were concernedwith computability.Number  produc is ,  c ryptography  and revers ib i l -i tyConsider the binary relation r(x#y) which is trueiff x is a string of the form:N*Mwhere N and M are strings, interpreted as integers,of O's and l's and ' . '
is interpreted as multiplica-tion, and where y is an integer equal to tile productof M and N. 23 We impose a priori that integersM and N be strictly greater than 1.This relation can be defined by a "grammar"G: this essentially simply involves constraining the"syntax" of z and defining multiplication by a setof definite clauses.Implementing r in p-enumeration mode is easy:it involves verifying that x is well-formed, and com-puting its product according to specification G; Infact, G itself can be used for that purpose, using astandard interpreter.On the other hand, efficiently implementing r ing-enumeration mode is extremely difficult, what-ever the interpreter, program transformations, math-ematical properties of prime factorization, ..., whichare brought to the task.
The fact that it is so dif-ficult is the basis of the best known "public keycryptography" algorithm, RSA \[11\].NP-complete  prob lems and  revers ib i l i tyA NP-complete problem is, informally, a problemfor which solutions can be checked in polynomialtime (relative to the length of the problem), butwhich requires more than polynomial time for thediscovery of a solution \[1\].24For specificity, let us focus on one NP-completeproblem, namely the "3-colorability problem" whichconsists, given a certain graph x, in finding a color-ing y for x using blue, green and red, in such a waythat vertices haring a common arc have differentcolors.It is possible to state the problem as a definiteprogram G, whose main relation is of the formr(x#y), x and y being suitable term encodings forthe graph z and for the solution y.
The solutiony can be considered as implicitely containing a de-scription of graph x.It is obvious that g-acceptation is computation-ally easy (polynomial): it consists in verifying thatthe coloring y respects the coloring condition.
Onthe other hand, p-acceptation is computationallycostly: it consists in checking whether graph x hasa solution, a problem which is at the present imebelieved to require exponential time.23The string N*M and the integer y are suitably encodedas ground terms on H.24More exactly, which is believed to require more thanpolynomial time.
This belief constitutes the content of thefamous P~NP conjecture.29References\[1\] Alfred V. Aho, John E. Hopcroft, and Jef-frey D. Ullman.
The Design and Analysis ofComputer Algorithms.
Addison-Wesley, Read-ing, MA, 1974.\[2\] N.J. Cutland.
Computability.
Cambridge Uni-versity Press, Cambridge, England, 1980.\[3\] Marc Dymetman.
A Generalized GreibachNormal Form for Definite Clause Grammarsand the decidability of the offline-parsabilityproblem, May 1991.
Paper presented at theSecond Meeting on the Mathematics of Lan-guage, Yorktown Heights, NY.
(To be pub-lished).\[4\] Marc Dymetman and Pierre Isabelle.
Re-versible logic grammars for machine transla-tion.
In Proceedings of the Second Interna-tional Conference on Theoretical and Method-ological Issues in Machine Translation of Nat-urai Languages, Pittsburgh, PA, June 1988.Carnegie Mellon University.\[5\] Marc Dymetman, Pierre Isabelle, and FrancoisPerrault.
A symmetrical approach to parsingand generation.
In Proceedings of the 13th In-ternational Conference on Computational Lin-guistics, volume 3, pages 90-96, Helsinki, Au-gust 1990.\[6\] Mark Johnson.
Attribute-Value Logic and theTheory of Grammar.
CSLI lecture note No.16.
Center for the Study of Language and In-formation, Stanford, CA, 1988.\[7\] John Wylie Lloyd.
Foundations of Logic Pro-gramming.
Springer-Verlag, Berlin, secondedition, 1987.\[8\] Roger C. Lyndon.
Notes on Logic.
Van Nos-trand, New York, NY, 1966.\[9\] Fernando C. N. Pereira and David H. D. War-ren.
Parsing as deduction.
In Proceedings ofthe ~lth Annual Meeting of the Associationfor Computational Linguistics, pages 137-144,MIT, Cambridge, MA, June 1983.\[10\] Francois Perrault.
Un nouveau formalisme degrammaire logique r6versible.
Master's thesis,McGill University, Montr6al, Canada, 1991.\[11\] R. L. Rivest, A. Shamir, and L. Adleman.
Amethod for obtaining digital signatures andpublic key cryptosystems.
Communications ofthe ACM, 21:120-126, February 1978.\[12\] Stuart M. Shieber.
A uniform architecturefor parsing and generation.
In Proceedings ofthe 12th International Conference on Compu-tational Linguistics, pages 614-619, Budapest,August 1988.\[13\] Stuart M. Shieber.
Parsing and type inferencefor natural and computer languages.
Techni-cal note 460, SRI International, Menlo Park,CA, 1989.
(Ph.D. dissertation, Department ofComputer Science, Stanford University).\[14\] Stuart M. Shieber, Gertjan van Noord,Robert Moore, and Fernando Pereira.
Asemantic-head-driven g eration algorithm forunification-based formalisms.
In Proceedingsof the ~7th Annual Meeting of the Associa-tion for Computational Linguistics, pages 7-17, Vancouver, BC, Canada, June 1989.\[15\] Mark Steedman.
Dependency and coordina-tion in the grammar of dutch and english.
Lan-guage, 61(3):523-568, 1985.\[16\] Tomek Strzalkowski and Ping Peng.
Auto-mated inversion of logic grammars for genera-tion.
In Proceedings of the 28th Annual Meet-ing of the Association for Computational Lin-guistics, pages 212-19, Pittsburgh, PA, June1990.\[17\] Gertjan van Noord.
Towards convenient bi-directional grammar formalisms.
In Proceed-ings of the 18th International Conference onComputational Linguistics, volume 2, pages294-298, Helsinki, August 1990.\[18\] Gertjan van Noord.
BUG: A directed bottom-up generator for unification based formalisms.Technical report, RUU, Department of Lin-guistics, Utrecht, Holland, 1989.\[19\] Remi Zajac.
A uniform architecture for pars-ing, generation and transfer.
In Proceedingsof the Workshop on Reversible Grammars inNatural Language Processing, Berkeley, CA,1991.30
