Proceedings of EACL '99An Object-Oriented Approach to the Designof Dialogue Management FunctionalityIan M. O'Neill and Michael F. McTearFaculty of InformaticsUniversi ty o f  UlsterNewtownabbeyCo.
Antr imBT37 0QBN.
IRELANDmf.mctear@ulscac.ukAbstractDialogues may be seen as comprisingcommonplace routines on the one handand specialized, task-specific interactionson the other.
Object-orientation is anestablished means of separating thegeneric from the specialized.
The systemunder discussion combines this object-oriented approach with a self-organizing,mixed-initiative dialogue strategy, raisingthe possibility of dialogue systems thatcan be assembled from ready-madecomponents and tailored, specializedcomponents.1 Introduct ionFor the purpose of developing automated systems,dialogues may be seen as comprisingcommonplace routines on the one hand andspecialized, task-specific interactions on the other.In software engineering, object-orientation hasproved to be an effective means of separating thegeneric from the specialized, and moreparticularly, of letting the specialized inherit thegeneric (Rumbaugh et al, 1991).
Identifyinginheritable generic functionality (for confirmation,repair of misunderstanding, personalization ofutterances, etc.)
and specialized or highly domain-specific functionality, opens the way to dialoguesystems that can be assembled largely from ready-made components and extended with the additionof more specialized components.
The prototypesystem that we have been developing in Prolog++for the last year combines this familiar object-oriented approach with a self-organizing, mixed-initiative dialogue strategy.
Pseudocode is usedhere to represent the Prolog processing.2 Ident i fy ing the generic and thespecia l izedIn the course of developing the prototype system anumber of important generic elements have beenidentified that can be ported with a minimum ofalteration between domains.
These genericelements are now introduced.2.1 Dialogue ManagerIn any system that is concerned with conducting adialogue with a user, a mechanism is required forreceiving, forwarding for processing, andoutputting semantic ontents of utterances.
Thisresponsibility falls to a Dialogue Manager.2.2 Domain SpotterAny system that is intended to handle processingacross a number of real-world areas of expertiserequires a means of associating key semanticcontent of the user's utterances with one or moreof the available domains.
This responsibility fallsto the Domain Spotter.2.3 Discourse StackAny system dealing with a transaction thatinvolves multiple dialogue turns must have ameans of logging a) what it believes the user hassaid, b) the degree of 'confirmedness' of what hasbeen said, and c) how the system has decided torespond.
Maintaining a record of the evolvingdiscourse, and providing the means of creating andretrieving entries for individual utterances, are theresponsibilities of the Discourse Stack.23Proceedings of EACL '992.4 Enquiry ProcessorGiven the current difficulties of speechrecognition, and the possibility that a user willmisunderstand or change his or her mind, anysystem conducting a complex transaction musthave a strategy for confirming the semanticcontents of the user's utterances and forproceeding with the transaction only when detailshave been adequately confirmed.
The currentsystem increments or decrements levels of'confirmedness' depending on whether the userrepeats or confirms, alters or negates values.
I fnecessary, the system queries the user explicitlyabout values that are new, altered or negated.
Theresponsibility for these purely generic,mechanistic confirmation routines falls to theEnquiry Processor, whose strategies are inherited,via a generic agent or Expert, by subclasses thathave their own domain-specific processingheuristics.2.5 ExpertEach of the more specialized agents within thesystem must have access to wider systemresources and have ways of providing the widersystem with high level information about itsprocessing abilities.
Supporting these commonbehaviours and characteristics is the responsibilityof the generic Expert class.Other parts of the system must be tailored torepresent the specialized knowledge andprocessing abilities of real-world humanspecialists.
These are introduced next.2.6 Expert SubclassesFor each business area within the system theremust be functionality a) to decide whatinformation to elicit next, or what information toinfer, given that certain information may alreadyDialogue Manager!
Domain Spotter Event ExpertAhave been provided, b) to check the validity of thecombinations of information provided, c) to givethe most helpful guidance when the user is havingdifficulty completing the enquiry, and d) to decidewhen sufficient, confirmed information has beenprovided to conclude the transaction.
Suchfunctionality is specific to the Expert subclasseswithin the system, and recreates in sometimesquite extensive sets of domain-specific heuristics,the kind of behaviour (e.g. '
i f  details for anoutward journey are received, check if a return isneeded'; ' i f  a venue has been confirmed but not aday, ask for the day') that would characterize anyhuman expert in a particular business domain - atravel agent or a theatre booking clerk, forinstance.
The current subclasses are TravelExpert, Event Expert and Place Expert.2.7 Expert InstancesThe system must contain detailed serviceinformation of the kind that in the real world isassociated with individual businesses.
Businessesare represented by instances of Expert subclasses.The instances represent particular airlines,railways, theatres, cinemas and so on; they haveaccess to the data - concrete schedules andtimetables - that must be consulted if a transactionis to be meaningful.3 Some impor tant  sys temcharacter i s t i csThe current prototype (Figure 1 below) focuses ondialogue management.
It is not intended totranscribe and parse raw spoken input, norcompose complete utterances for speechgeneration.
Rather, the system accepts an input ofconcepts and attributes in the form concept(actiontype(attribute list)) and outputs concepts andattributes in similar fashion.~ Enquiry Processor ~ Discourse StackExpertI} \[ Travel Expert J I Place ExpertI Avent Expert) ~ ( (Travel Expert)~eatre 1 / \[ A!rline 1 Jvent Expert)'1 ~ (Travel Expert)~nema 1 | \[Railway 1 |Figure I.
Main System Components.24Proceedings of EACL '99If  the system is to conduct a dialogue as ahuman interlocutor might, it must use to bestadvantage whatever information it is given -whether that information was explicitly sought ornot - and then be able to ask for information it stillrequires.
Such self-organizing behaviour, asopposed to simpler state transitions (Novick andSutton, 1996), generally has one of a number ofpossible motivations.
The system may be plan-based, attempting to identify and understand theramifications of the problem the user wants tosolve (Allen et al, 1996).
Alternatively it mayattempt o prove theorems, questioning the userfor the missing facts that it needs to know in orderto help him or her complete some complex task(Smith and Hipp, 1994).
Or the system mayattempt to identify or elicit specifically those factsthat it needs to complete a 'request template' for aparticular transaction.It is essentially this last approach that thecurrent prototype has adopted, and to this extent itresembles the SpeechMania system developed byPhilips (Aust and Oerder, 1995), which hasalready been used successfully to implement aspeech-based timetable nquiry system for SwissFederal Railways (Aust et al, 1995).
However,by additionally identifying eneric and specializedfunctionality, including heuristics that wouldcharacterize a human expert, it becomes possibleto create a dialogue management system that cancope with several real-world enquiry domains, or anumber of complex subtasks, in one and the sameadaptable, extensible implementation.4 Gener ic  behav iour  - domain -spec i f i c  knowledgeThe system is coloured throughout by a designphilosophy that keeps the higher-level systemcomponents largely ignorant of the capabilities ofthe lower-level system.
This has the advantagethat higher-level, generic dialogue functionalitycan remain unchanged as the lower-level system isadapted for specialized real-world applicationareas.
However, it goes without saying that thehigher-level components must know how to accessthe lower-level functionality.Domain Spotter is one such higher-levelcomponent in the current prototype.
Its purpose isa very simple one: it consists of a collection ofrules that the Dialogue Manager uses to passenquiries of different ypes to the most appropriatedomain experts.
For it to work - in the currentimplementation - Domain Spotter relies on theassumption that recognizer-grammar functionality(outside the scope of the current implementation)will be sufficiently powerful to identify keysemantic content from the user's utterance,content hat may be characteristic of possibly oneor more real-world business domains.
DomainSpotter's heuristics then tell it broadly where thecorresponding domain-related functionalityresides in the system.
It may then have todetermine, if necessary by quizzing the userfurther, which of several Expert subclasses i  bestsuited to the current enquiry.If, for example the user's utterance indicatessimply that he or she wants to make a booking andno further details are given, Domain Spotter isprogrammed to interrogate the Expert subclassesto find out which ones can handle bookings.
(Prolog++ conveniently provides a call to allsubclasses of a given type.)
On the basis of theresponses it obtains, it may subsequently have toask the user to narrow the scope of the enquiry.For the moment, however, if a subclass doeshandle bookings, it will simply push its class areaattribute (indicating its area of competency: travel,or events, say) on to the class candidate list withinDomain Spotter.
Otherwise it performs a Prologcut and allows the call to pass to another subclass.In the next dialogue turn the Dialogue Manageruses the contents of the list to offer the user aselection of business areas to choose from.
Figure2 below (with simplified calls) illustrates theprocess.If the user's enquiry is more specific - ' I 'dlike to book a trip on Friday' or ' I 'd  like to make atheatre reservation' - such that travel- or event-related semantic content might be readilyDia Mgr.L analyse(booking~;e/ect_from(areas~Domain Spotter Exl analyse(booking)add_to.~nalyse(boo:ind:)t cl "analyso(booking~~ert Travel Expert Event Expert Place ExpertI=.list(trav_area).list(event_area)Figure 2.
Finding the Relevant Subclass25Proceedings of EACL '99identified by a recognizer-grammar - DomainSpotter, in its high-level analysis, performs like ahuman receptionist or operator and passes theenquiry to the most relevant subclass for a moredetailed analysis specific to that subclass.Any available attributes of the travel enquiry -day, time, etc.
- are also forwarded to thespecialized omain expert.
The expert hen has todecide using its own heuristics what use it canmake of the attributes.5 F ind ing  an object  to hand le  thet ransact ionAt this point the enquiry is still being processedquite generically at the level of an Expert subclasslet us assume the Travel Expert, in order toexplore further the evolution of a typicaltransaction.
However, for the enquiry to stand anychance of reaching a successful conclusion, itmust eventually be processed by an instance of aclass (in object-oriented terms a specific 'object'),representing an actual company or organisationthat has a highly detailed knowledge of therequired service.
(Cf.
Wang (1998), who uses asemantic grammar in a base class to provide highlevel understanding of an utterance, and then findsa 'best match' from among the grammars ofderived classes for a more detailed understanding.
)Thus, having been passed the enquiry byDomain Spotter, the Travel Expert subclass nowattempts to identify the most suitable TravelExpert instance to handle the enquiry, or if it isunable to do so in this dialogue turn, to elicitfurther information from the user to help itidentify a 'handling instance'.
In a moveanalogous to the one adopted by Domain Spotterpreviously, the Travel Expert interrogates itsinstances and has them push their area of expertise(their area attribute - railway, airline, etc.)
on toDomain Spotter's candidate list.
In the next turnthe Dialogue Manager will ask the user to narrowthe enquiry to one of the areas available.Although the system may request specificinformation (as in the turn above), the user maysupply rather more than this.
Using the heuristicsof the relevant Expert subclass (here the TravelExpert), the system analyses the suppliedinformation, to try to establish the context of thetransaction, and then to process the transactionwithin that context.
Again, the system is aimingto find the object (the :representation of a real-world business) that is best suited to processingthe transaction to its conclusion.
Let us explorethis further.6 A f lex ib le  responseAt the early stages of the transaction DomainSpotter polls the Expert class and subclasses (onthe basis of the semantic content of the user'sutterance) with the goal of finding a handlinginstance.
If  in response to the system's question'Is that a railway ticket or an airline ticket?'
theuser says that he or she wants a ticket with aparticular airline, processing is immediately takenup by the appropriate airline instance.Alternatively the user might respond along thelines that he or she wants 'a plane ticket forLondon on Friday at around nine a.m.' Assumingthat a phrase such as 'ticket to London' has beensuccessfully parsed as a travel-related request,Domain Spotter will pass the query to the TravelExpert class, which in turn will interrogate itsinstances to see how many have airline as anattribute and travel to the destination on the dayand at the time requested.
Figure 3 belowillustrates the process.
If the instance is unable tomeet the criteria it simply performs a cut andpasses the call to the next instance.
Any instancethat can provide the required service adds itsDia Mgr,a?alyse(travbk~lchoose_from(exp:Domain Spotteranalyse(trav_bkg)Travel Expert Travel Expert 1do_you_go_there(trav_destadd to._list(exp 1~l  - -~dd_to_list(exp2list(exps) qdo_you_go_there(trav_dest)~o_you_go_there(trav_dest)Travel Expert 2 Travel Expert 3Figure 3.
Identifying Appropriate Instances26Proceedings of EACL '99mnemonic, its unique identifying name, to DomainSpotter's candidate list.
Again, the analogy withDomain Spotter's own interrogation techniqueholds good.Now the role of the instances becomes moreimportant.
In the prototype system the instancescontain, as one of their attributes, specific detailsof the service they offer: in the case of a TravelExpert instance this will be a schedule; in the caseof an Event Expert instance a programme ofshows.
In a more realistic implementation theinstance is more likely to serve as the gateway to acorporate database.
Nonetheless, whatever theimplementation, the instance will serve as themeans by which the system at large has access tothe detailed information it needs to complete thetransaction.If  as a result of the interrogation above, thereare several candidates for 'handling instance' onDomain Spotter's candidate list, the DialogueManager, in the system's next turn, will promptthe user to choose one of them (and, of course,accept any additional information that the usermight provide).
If there is only one candidate, orindeed if at some point the user specifically namesthe instance he or she wants to provide the service( ' I 'd  like to book a flight with Aer Lingus.
'), thesystem can move the dialogue into its final stage,where the semantic content of the user'sutterances i methodically confirmed and checkedfor compatibility with the instance's data, andwhere data still required for  closure of thetransaction are elicited from the user.7 An engine for conf i rmat ionstrategiesPerhaps the most domain-independent element ofthe system is the Enquiry Processor class, whichimplements the generic confirmation strategiesthat must be performed in a system intended tocope with imperfect speech recognition, and userswho change their mind.
In reality, EnquiryProcessor adopts quite a mechanistic approach toconfirmation and this routine functionality isinherited, via the Expert class and the Expertsubclasses, by the 'handling instances' thatultimately process the enquiry.Enquiry Processor has two strategies, used incombination, to help it decide whether theattributes of a user's utterance have beenconfirmed to a sufficient degree to be used asinput in the final transaction (the actual process ofreserving a ticket for a journey or an event).
Onthe one hand, Enquiry Processor assigns anappropriate status to each of the attributes in theuser's utterance (from the set defined byHeisterkamp and McGlashan (1996)) and updatesthe statuses as the dialogue evolves.
EnquiryProcessor is designed to perform this functionregardless of how many attributes might beassociated with the concept expressed in the user'sutterance - though realistically even a complexconcept, such as a booking for a return trip, willhave no more than about fourteen attributes,covering place of departure, destination, details ofoutward and return journey, and so on.
WithinEnquiry Processor the attributes are processedsimply as members of a list of arbitrary length.Each attribute is structured as follows.attribute(type, value, status, system intention)The attribute's status is generally assigned one ofthe following values:?
new for  system?
inferred by system?
repeated by user?
modified by user?
negated by userA suite of evolve predicates represent the rules bywhich the statuses are updated as values arerepeated, modified or negated by the user, orinferred by the system, evolve takes the followingform:evolve(type, last value, last status, current value,new value, new status).The new status of any given attribute is thereforedetermined by its last value, its current value (i.e.its value in the user's current utterance), and itslast status.
The last value and last status are takenfrom the Discourse Stack, a discrete systemcomponent comprising a list and functionality topush and pop the concepts and attributes thatdocument he user's utterances and the system'sresponses.
Enquiry Processor also contains therules that determine the system's poken responseto an attribute, taking into account not only thestatus of the individual attribute but also of theother attributes in the overall enquiry concept.Following invocation of the rules, the systemintention parameter of the attribute term is set tothe system's intended next move in regard to theattribute - whether it will confirm, query, etc., theattribute.
This is especially important in the eventthat the user replies simply 'yes' or 'no' in his orher subsequent turn.
Moreover, EnquiryProcessor's rules not only determine the system'sresponses, but also help it prioritize its responses:for example, before doing anything else it willquestion the user about any value that he or shehas negated since negation represents asignificant misunderstanding or change of plan; ifit needs to confirm attributes, it will attempt o27Proceedings of EACL '99confirm no more than three in a single turn.
Its setof priorities permitting, the system will perform arepair request on a negated value, a repairconfirm on a modified value, a confirm on a valuethat is new to the system or has been inferred bythe system, and a spec on any value that requiresthe user to choose between one of several options(Heisterkamp and McGlashan, 1996).Alongside this processing of the attributes'statuses, each attribute has a 'discourse peg' thatis incremented by 1 when the user repeats a value,zeroed if the value is modified, and set to -1 if thevalue is negated.
The aim here is to ensure thatevery attribute has been adequately confirmed (inthis prototype its peg must simply be set to a valuegreater than zero) before it is used to complete atransaction.ANDthe Hand l ing  Agent ' s  scheduleinc ludes a serv ice  fordeparture point,destination,day anddeparture time)THENins t ruc t  the D ia logue  Managerto generate  a f ina l  sys temut terance  conf i rming  areservat ion  fordeparture point,destination,day anddeparture time.8 Knowing when enough is enoughAs well as implementing these mechanisms forevolving attributes' statuses and determining thesystem's next utterance, the Enquiry Processorclass has a mechanism, a template check, fordeciding whether the user has supplied enoughinformation to complete the transaction.Enquiry Processor's functions are performedin the context of a specific handling instance, sothe template check uses the data that areencapsulated in the current handling instance.Again, in an actual real-world system these datamight be contained in the database to which theinstance has, from the overall system'sperspective, exclusive access.
For each Expertsubclass there are normally a number of differentpotential combinations of confirmed ata that canbe used to successfully conclude a transaction:collectively these constitute the 'request template'for the subclass.
The request templateadditionally indicates information that the systemshould prompt for next, given a particularcombination of data that have already beenconfirmed.Thus, for example, in the current relativelysimple prototype, if the system has confirmed theplace of departure, the destination, the day ofdeparture and the departure time, and if a finalcheck with the instance's database indicates thatthe combination of data is valid, then the systemcan proceed with issuing a ticket.
In a morestructured form the processing for template checkruns as follows:IF(the d i scourse  pegs fordeparture point,destina tion,day anddeparture time are > 0Alternatively, if the system has all the requiredinformation except, say, a departure time, thetemplate check may indicate that prompting theuser for the departure time would be the nextappropriate step.Should the check on the template fail -because the details supplied by the user andconfirmed by the system prove to be an invalidcombination in terms of the handling instance'sdatabase - then Enquiry Processor will move onfrom the template check to perform a number ofremedial checks.
These checks again useheuristics that are valid at the level of the Expertsubclass, in combination with data that are specificto the handling instance.
In performing its checksEnquiry Processor aims to offer the user analternative course of action - for example, if theflight does not depart at the time the userrequested, the system might be able to use theinstance's data to suggest another time.
Again, inmore structured form, processing for a typicalcheck can be represented as follows.IF(the d i scourse  pegs fordeparture point,destination,day anddeparture time are > 0AND the Hand l ing  Agent 's  schedu leDOES NOT inc lude a serv ice  fordeparture point,destination,day anddeparture timeAND the Hand l ing  Agent 's  schedu leinc ludes a serv ice  fordeparture point,destination,day andanother depaJ~_ture time)28Proceedings of EACL '99THENinstruct the Dialogue Managerto generate an utterancesuggestinganother departure time.In the present implementation the system willcontinue to seek information until it has confirmedenough values to conclude the enquiry, or until theuser quits.9 The way aheadCurrently the system is being tested in a selectionof short travel- and event-related transactions,during which it processes concept terms whoseattributes the user may alter or negate to simulatemisrecognition and/or revised requirements.
Itsperformance has been accurate and its responsesnear-instantaneous on a 100 MHz Pentium PCwith 16 MB RAM running under Windows 95.Typically the test transactions require the user andthe system each to make between three and sevenutterances.The prototype system has recently beenamended to allow the confirmation strategy tocome into play as soon as the user has supplied aconcept with confirmable attributes - even beforea handling agent has been identified.
With theconfirmation strategy now being introducedearlier, and potentially having to deal with moreamendments, negations and additional commentsby the user, further investigation will be requiredto determine the best way to prioritize andmeaningfully group the attributes that the systemhas to query for different enquiry types.
It islikely that additional heuristics will be required atthe Expert subclass level.Peer objects will also be developed to workalongside the current Expert subclasses, providinghighly specialized but essentially domain-independent functionality - such as processingcredit card details or gathering addressinformation.
The aim is to create a suite ofcomponents which, with their encapsulated real-world expertise, can be combined 'off-the-shelf'for functionally rich dialogue management.
Theobject architecture readily supports the addition ofstill more specialized subclasses and instances asfurther functionality is required.Allen, James F., Bradford W. Miller, Eric K. Ringger,and Teresa Sikorski.
1996.
A Robust System forNatural Spoken Dialogue.
Proceedings of the 34 thAnnual Meeting of the ACL: 62-70.Aust, Harald and Martin Oerder.
1995.
DialogueControl in Automatic Enquiry Systems.
ECSAWorkshop on Spoken Dialogue Systems: 121-124.Heisterkamp, Paul and Scott McGlashan.
1996.Units of Dialogue Management: An Example.ICSLP96 - Proceedings of the Fourth InternationalConference on Spoken Language Processing: 200-203.Novick, David G. and Stephen Sutton.
1996.Building on Experience: Managing SpokenInteraction through Library Subdialogues.Proceedings of TWL T 11 - Dialogue Management inNatural Language Systems: 51-60.Rumbaugh, James, Michael Blaha, WilliamPremerlani, Frederick Eddy, and William Lorensen.1991.
Object-Oriented Modeling and Design.Englewood Cliffs, New Jersey: Prentice-Hall.Smith, Ronnie W. and D. Richard Hipp.
1994.Spoken Natural Language Dialog Systems: APractical Approach.
New York: Oxford UniversityPress.Wang, Kuansan.
1998.
An Event-Driven Model forDialogue Systems.
ICSLP98 - Proceedings of theFifth International Conference on Spoken LanguageProcessing: 393-396.ReferencesAust, Harald, Martin Oerder, Frank Seide, andVolker Steinbiss.
1995.
The Philips automatictrain timetable information system.
SpeechCommunication 17: 249-262.29
