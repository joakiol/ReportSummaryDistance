An Algorithm for Generating QuantifiersNorman CreaneyFaculty of lnformaticsUniversity of Ulster at ColeraineN IrelandBT52 1SAE-mail."
n. creaney@ulst, ac.
ukTel: +44 (0)1265 324502Fax: +44 (0)1265 324916Abstract:Quantifiers, and their associated scoping phenomena re ubiquitous in English and other naturallanguages, and a great deal of attention has been paid to their treatment in the context of naturallanguage analysis.
Rather less attention, however, has been paid to their treatment in the context oflanguage generation.
This paper describes an algorithm for generating quantifiers in Englishsentences which describe small models containing collections of individuals which are inter-relatedin various ways.
The input to the algorithm is, i) a model represented as a collection of facts and ii)an abstract description of the target sentence with gaps where the quantifiers hould be.Keywords: lexical choice, realisation, quantifiers121An Algorithm for Generating QuantifiersQuantifiers, and their associated scopingphenomena are ubiquitous in English andother natural anguages, and a great deal ofattention has been paid to their treatment inthe context of natural anguage analysis(Alshawi 1990, Creaney 1995, Grosz et al1987, Hobbs and Shieber 1987, Park 1995,Saint-Dizier 1984).
Rather less attention,however, has been paid to their treatment inthe context of language generation.
This paperdescribes an algorithm for generatingquantifiers in English sentences whichdescribe small models containing collectionsof individuals which are inter-related invarious ways.A model is represented asa collection of factslike the following:rep( rl ).
sample( sl ).rep( r2 ).
sample( s2 ).rep( r3 ).
sample( s3 ).rep( r4 ).saw( rl, sl ).saw( r2, sl ).saw( r2, s2 ).saw( r3, s2 ).saw( r3, s3 ).saw( r4, sl ).saw( r4, s2 ).saw( r4, s3 ).In model (1) there are four representatives andthree samples and some of the representativessaw some of the samples.
The algorithmgenerates suitable quantifiers to completesentences of the form:QR representative(s) saw Qs sample(s)where QR and Qs can be arbitrary quantifierslike; some, two, all, both, one of the, most, etc.The algorithm also handles models containingmore relationships than model (I) to generatesentences of the form:QR representative(s) of Q c company(s)saw Qs sample(s)QR representative(s) saw Qs sample(s) ofQp product(s)QR representative(s) of Qc company(s)saw Qs sample(s) of Qp product(s)One of the most striking things about heproblem is that there are generally a greatmany sentences which provide reasonabledescriptions of any given model.
For example,the following are all acceptable for model (1).2 Every representative saw a sample3 Every representative saw at least onesample4 Most representatives saw at least twosamples5 A representative saw every sample6 At least one representative saw everysample7 At least two representatives saw mostsamplesIt turns out that there are three distinct sourcesof this variation and they correspond to threedifferent kinds of choices which are made inthe generation algorithm.
They are:o quantifier scoping choiceso choice of focus setso choice of individual quantifiers constrainedby the above two choicesA great deal has been written about hequantifier scoping problem for naturallanguage analysis (Hobbs & Shieber 1987)and much of this is applicable to thegeneration problem in the sense that anyparticular description must assume someparticular quantifier scoping arrangement.
Forexample, sentence (2) assumes that "Everyrepresentative" has wide scope while sentence(5) assumes that "every sample" has widescope, and the sentences are only satisfied inthe model under these assumptions.
In factsentences (2), (3) and (4) all assume widescope for "representative" while sentences(5), (6) and (7) all assume wide scope for"sample".
The gencration algorithm, ofnecessity, incorporates quantifier scoping.122The concept of a focus set has no correlate inthe language analysis literature although it issimilar to what Barwise and Cooper (Barwiseand Cooper 1981) call a witness et.
It has todo with choosing some particular subset of themodel on which to base the description.Sentence (2) talks about all threerepresentatives while sentence (4) talks onlyabout he subset {r2,r3,r4}.
This subset standsin the realtion most to the entire set ofrepresentatives {rl,r2,r3,r4} and is the focusset for R in sentence (4).
The concept of afocus set will be made more precise belowwhere dependency functions are discussed.saw( QI(R, rep(R)), Q2(S, sample(S)) )saw( Q3(R, rep(R) ^  of(R, Q4(C,com(C))),Qs(S, sample(S)) )and the purpose of the algorithm is to assignvalues to the Oi's given some suitable model.It works by processing the PAS recursivelyand non-deterministically selecting quantifierscopings and focus sets at each level.Quantifiers are then generated based on thecosen focus set.Inputs to the algorithmThe inputs to the algorithm are:a model ike (1)a predicate argument structure for thetarget sentenceA predicate argument structure (PAS) isessentially an unscoped logical form of theform taken as input to Hobs and Shieber'salgorithm (Hobbs & Shieber 1987).
It makesexplicit the relationships between predicatesand there arguments but does not express anyquantifier scope relationships.
Sentence (2)has the following PAS:saw(every(R,rep(R)), a(S,sample(S)) )Quantifier scopingSince the particular scoping frameworkunderlying the generation algorithm is novel abrief explanation is appropriate.
The orthodoxapproach to quantifier scoping is embodied inHobbs and Sheiber's algorithm and it permitsall permutations of quantifiers such that thereare no unbound variables in the resultinglogical form.
For example, Hobbs andShieber's algorithm produces the scopings(8b-f) for sentence (8a)t:8 a Every representative of a company sawsome samplesb R>C>Sc C>R>Sd S>R>Ce C>S>Rf S>C>Rand sentence (8a) has the following one.saw( every(R, rep(R)Aof(R,a(C,com(C))),some(S, sample(S)) )Each variable in a PAS has a quantifier and arestriction which restricts the values which itmay take.OOS's restriction is sample(S) in both casesR's restriction is rep(R) in the first PASand rep(R)Aof(R,a(C,company(C)) in thesecondSince the algorithm generates quantifiers itsinput PASs are not exactly like these.
Insteadthey have gaps where quantifiers hould be:where R > C > S indicates that "Everyrepresentative" outscopes "a company" whichin turn outscopes "some samples".
Themissing permutation, R > S > C, is notpermitted because it violates what has becomeknown as the unbound variable constraint.The scoping framework which underlies thegeneration algorithm recognises fewerscopings than (8).
The relative scope of twoquantifiers i only considered for variablesWe adopt the convention of naming variableswith the first letter of the head noun with whichthey are associated (R=representative, C=company,S=sample) and using the symbol '>' to denoterelative scope.123which are arguments to the same predicate.For example, R must be scoped relative to Cbecause they are both arguments to thepredicate of The possibilities are R > C and t3> R. Similarly, R and S are arguments to thepredicate saw and may be scoped either R > Sor S > R. The relative scoping of C and S isnever considered irectly because they do notparticipate directly in any single predication inthe sentence.
They may however end up witha relative scoping as a result of taking thetransitive closure of other scopingrelationships.
For example, if it is decided thatC > R and R > S, then clearly, since scope istransitive, C > R. In this framework thefollowing scopings are allowed for (8a).9 a R>S,R>Cb S>R>Cc C>R>Sd S>R,C>RIt is clear from (8) and (9) that this frameworkundergenerates in comparison with Hobbs andShieber's.
However, in the context oflanguage generation, undergeneration is notnecessarily a serious problem, provided thatthere is the ability to adequately describe anymodel.
In fact there is an argument to be madein favour o fa  scoping framework whichundergenerates with respect to Hobbs andShieber's as a general approach to quantifierscoping (Park 1995).
This is the subject of afuture paper.Dependency functions, partitionsand focus setsEach variable in a PAS has a candidate setwhich is defined by its restriction and themodel under consideration.Definition 1: candidate setA variables candidate set is the set ofindividuals from the model which satisfy thevariables restriction.For the PAS:saw(every(R,rep(R)), a(S,sample(S)) )and model (1), R's candidate set is{rl,r2,r3,r4} and S's is {sl,s2,s3}.When we say that "Every representative" haswide scope we are saying that there is afunction which maps R's candidate set ontothe power set of S's candidate set.
Thisdependencyffunction is computed from model(1) and is exhaustively listed in (lO) below.10 saw: {rl,r2,r3,r4} ~ power({sl,s2,s3})rl ~ { sl  }r2 ~ {s l ,  s2}r3 --~ { s2, s3 }r4 ~ {s l , s2 ,  s3}Alternatively, i fS is given wide scope thefollowing dependency function is computed.11 saw: {sl,s2,s3} - ,  power({rl,r2,r3,r4})sl  --~ {r l ,  r2, r4}s2 --~ { r2, r3, r4 }s3 ~ {r3, r4}Focus sets were discussed briefly above andare made more precise now in the context ofdependency function partitions.Any dependency function can be partitionedby choosing a arbitrary subset of the mappingsit contains as its focus, the remainder being itscomplement.
Of course, the domains andranges of these sub-functions areappropriately adjusted.The partitions (12a-c) are among the possiblepartitions of dependency function ( I 0).12 a focus: saw: {rl} ~ power({s l})rl -+ { sl  }compt: saw: {r2,r3,r4}power({sl ,s2,s3})r2 ~ {s l ,  s2}r3 ~ {s2, s3}r4 -~ { sl ,  s2, s3 }focus: saw: {r2,r3} --~ power({sl,s2,s3})r2 --~ {s l ,  s2}r3 --~ { s2, s3 }compt: saw: {rl,r4} ~ power({sl,s2,s3})rl ~ { s l  }r4 --~ {s l ,  s2, s3}124focus:saw:{r2,r3,r4} --~ power({sl ,s2,s3})r2 --~ {s l , s2}r3 ~ {s2, s3}r4 ~ {s l ,  s2, s3}The mapping from partitioned ependencyf,mction to quantifiers i non-deterministic as(13) shows.
For instance, partition (12b)gives, at least, the three sentences (13bi,ii,iii).compt: saw: {rl} ~ power({sl})rl -~ {s l}Definition 2: focus setThe focus set for a variable, given aparticular partition is either:o the domain of  the partition's focuso the union of the range of the partition'sfocusdepending on the variable of interest.Not all sentences provide equally gooddescriptions of the model but they are all truein it.
For example, (13ai) is true in (1),assuming "a" means at least one, but is notvery informative.
Bigger focus sets tend togive more information and sound more naturalhowever the generation algorithm isconcerned only with presenting alternativesand not with selecting between them.For example, (12a-c) define the followingcandidate sets for R and S.{r l}  {s l}{r2, r3} {s l ,  s2, s3}{ r2, r3, r4 } { sl, s2, s3 }It is useful to note that a variable's candidateset is related to an unpartititioned dependencyfunction in exactly the same way that its focusset is related to the focus of the partitionedfunction.
These relationships are illustrated inappendix 1.Individual quantifiers are selected forgeneration on the basis of dependencyfunction partitions.
For example, thedescriptions (13a-c) are licensed by thepartitions (12a-c) respectively.13a i A representative saw a sampleii Exactly one representative sawexactly one sampleIIIAt least hal\[the representatives sawexactly two samplesExactly two representatives sawexactly two samplesTwo.
representatives saw mostsamplesExactly three representatives saw atleast twq samplesThree representatives saw somesamplesGenerating quantifiersThe process of generating quantifiers takesplace after a scoping has been chosen and adependency function has been constructed andpartitioned, so that all decisions are made inthe context of a particular partitioning of aparticular dependency function.Generation consists of going through the listof all possible quantifiers and checkingwhether or not each one is consistent with theappropriate variable in the current dependencyfunction partition.
Those which are consistentare then generated and those which areinconsistent are rejected.
To check theconsistency of a particular quantifier with aparticular variable it is first necessary tocompute the variable's candidate set, focusset, and focus maximum and focus minimum.Definition 3: Focus maximum and minimumFor a variable with wide scope the focusmaximum (Fmax) and focus minimum(Fmin) are the same.
They are simply thesize of the focus set or, equivalently, thenumber of mappings in the focus of thedependency function.e.g.
R in (12a): Fmax=Fmin= I{rl}l = 1R in (12c): Fmax=Fmin= I {r2,r3,r4} I = 3For a variable with narrow scope the focusmaximum (Fmax) is equal to the size of the125biggest member of the range of the focus ofthe dependency function.e.g.
S in (12a): Fmax = max(l{sl}i)  = 1S in (12c): Fmax=max( I {sl ,s2} I, I {s2,s3} \], I{sl ,s2,s3} I )=3The focus minimum is defined along thesame lines as he focus maximum except hatthe minimum set size is taken.e.g.
S in (12a): Fmin= min(\ [{s l} l )= 1S in (12c): Fmin=min(I {s1,s2}l, I {s2,s3}l, I {sl,s2,s3}l )=2q_inc( 1,_, \[a\] ).q_inc( 1,_, \[somesing\] ).q_inc( 1,_, \[at, least,one\] ).q_inc( 2, _, \[at, least,two\] ).q_inc( N, _, \[some_plur\] ):- N > 1.q_inc( N, M, \[most\] ) :- M < 2*N.q_inc( 1, 1, \[the\] ).q_inc( 2, 2, \[both\] ).q_inc( 3, 3, \[all,three\] ).q_inc( N, N, \[all\] ).q_inc( N, N, \[each\] ).q_inc( N, N, \[every\] ).For R in (12a) the appropriate call is therefore:The checking procedure varies according tothe type of quantifier under considerationwhere quantifiers are classified as one of threetypes monotone increasing, monotonedecreasing or cardinal (Barwise and Cooper1981).o Monotone increasing quantifiers are thosewith an at least N interpretation.
Theyinclude; a, some_sing, some_plur, the,both, many, at least fouro Monotone decreasing quantifiers are oneswith an at most N interpretation.
Theyinclude; no, few, at most three, less thanthree quarterso Cardinal quantifiers are of the form exactlyN?- q_inc( 1, 4, QR ).which returns the following quantifiers: a,some_sing, at least one.
Similarly, for 9 in(12a) the appropriate call is:?- q_inc( 1, 3, QS ).which returns the same set ofquantifiers.Hence sentence (13ai) is generated, as is:Some representatives saw _a sampleAt least one representative saw a sampleA representative saw some samplesand other similar sentences formed byselecting from the above quantifiers.The check for monotone increasing quantifiersis simplest.
The acceptability of eachquantifier is as defined by a call to thefollowing Prolog goal:?- q_inc( Fmin, Nc, QUANT ).For a monotone decreasing quantifier thecheck depends on whether it is in wide scopeposition or narrow scope position.
In narrowscope position the check is similar to the onefor monotone increasing quantifiers exceptthat:where; Fmin = the focus minimum, Nc =I candidate set\], and the q_inc/3 relation isdefined along the following lines.14 % q_inc( +N1, +N2, ?Q ) defines Q as% - "at least N1 out of a possible N2"% e.g.
"a man" means% - at least 1 man out of any number% "some men" means% - at least 2 men out of any number% "both men" means% - at least 2 men out of a possible 2o a different collection of quantifiers ischecked - the monotone decreasing oneso the focus maximum is input rather than thefocus minimum.
?- q_dec( Fmax, Nc, QUANT ).where; Fmax = the focus maximum, Nc =I candidate set\[, and the q_dec/3 relation isdefined along the following lines.12615 % q_dec( +N1, +N2, ?Q ) defines Q as% - "at most N1 out of a possible N2"% e.g.
"no man" means% - at most 0 men out of any number% "few men" means% - at most half of all the men% "neither man" means% - at most 0 men out of 2q_dec( 0, _, \[no\] ).q_dec( 2, _, \[at, most, two\] ).q_dec( N, M, \[few\] ) :- M < 2*N.q_dec( 0, 2, \[neither\] ).The check for monotone decreasingquantifiers in wide scope position is a little bittrickier.
For example, to check theconsistency of the quantifier at most two in"At most two representatives saw a sample",assuming R > S, the following checks need tobe made.O There must be a set of at most two of R'swho may or may not have seen a sample.This entails checking that R's focus setcontains exactly two members.All other R's outside this set must certainlynot have seen a sample.
This entailschecking the complement of thedependency function to make sure that thequantifier a fails to be consistent with thevariable S.These checks are carried by calls to q_dec/3an q_inc/3 with appropriate input values.The check for cardinal quantifiers is definedin terms of two sub checks: one for amonotone increasing quantifier and one for amonotone decreasing.
This follows from theobservation that exactly N meant he same as(at least N)A(at most N).Embedded quantifiersThe preceding discussion concentrated onsimp!e linguistic structures like (2-7) whichcontain one main verb and noun phrases withno recursive structure.
The processing of amore complex structure like:16 saw( QR(R, rep(R) ^  of(R, Qc(C,com(C))),Qs(S, sample(S)) )is done by breaking it down into sub-structures (17) which are processed almostindependently.17 a saw( QR(R .... ), Qs(S, sample(S)))b of( QR,(R, rep(R)), Qc(C, com(C)) )The variable R is assigned the quantifier OR in(1 7a) and the quantifier OR, in ( 1 7b) butclearly only one of these will ultimately begenerated and some special treatment isrequired.
Thes are called R's outer and innerquantifiers respectively.
PAS (17b) isprocessed first.
A scoping is chosen for R andC and a dependency function is constructed inthe normal way but when it comes topartitioning the function and generating aquantifier for C some care must be taken.Some choices of partition and quantifier mustbe excluded.
What is required is that theresulting focus set for R is the set of allrepresentatives who satisfy restriction (17b)under the chosen partition and quantifier.Consider the following dependency functionand associated partition.18a of: {rl,r2,r3} ~ power( {cl,c2,c3} )rl --~ { c l  }r2 --~ {c2}r3 --~ {c3}b focus: of: {rl,r2} ~ power({cl,c2})rl  ~ { c l  }r2 ~ {c2}compt: of: {r3} ~ power({c3})r3 ~ {b3}Based on the focus in (18b) the quantifierexactly one might be generated for C. Thecorresponding candidate set for R is {rl,r2} butthis is not the set of all representatives whosatisfy the restriction since r3 also satisfies it.It is to avoid this anomaly that the followingconstraint on the acceptability of dependencyfunction partitions in this context.12719 If variable R is in wide scope position in(17b) then QR' must be of the form exactlyN but is not generated in the final output.Constraint (19) restricts the range ofacceptable partitions by restricting the rangeof acceptable inner quantifiers for R. It alsospecifies R's outer quantifier as the one whichis to be finally generated.
It guarantees thatR's focus set is maximal in the sense that itcontains all possible R's which satisfy therestriction and avoids the above anomoly byfailing to allow partition (18b).
A parallel butdifferent constraint is applied whenever R isin narrow scope position.20 If variable R is in narrow scope position in(17b) then QR must be the quantifier V butis not generated in the final output.The a lgor i thmThe overall strategy is to process a PASrecursively, assigning quantifiers to the mostdeeply nested structures first.
As a variable'srestriction is processed the resulting focus setis passed back up to act as the candidate setfor the same variable in the embeddingstructure.
An inner quantifier is also returnedtogether with a flag which indicates copingchoices within the restriction.
The algorithmis as follows, where the choose constructindicates non-determinism.21 to process_PAS p(Qx(X,RX),Qy(Y,RY) )process_RES RX; process_RES RY;% returned by calls to process_RES:% Xs, Ys: the candidate sets forX&Y% Qx', Qy': the innerquants forX&Y% ScpX, Scp Y: = '>' if head variable% is given wide scope within restriction,% '<' if it has narrow scope or 'nil' if there% are no other variables within the rest'nchoose a scoping for X and Y;construct the dependency function;choose a partition;choose outer quantifiers Qx" and Qy";% must be consistent with consts.
19&20if ScpX = > or ScpX = nil then Qx := Qx"else Qx := Qx';if ScpY = > or ScpX = nil then Qy := Qy"else Qy := Qy';end process_PAS;to process_RES RX % X is head of phrase% this procedure returns: Xs, Qx & ScpXcase 1: RX = p(Qx(X,RX),Qy(Y,RY))% i.e.
RX contains an embedded NPprocess_RES RY; % returns Ys Qy' ScpYXs := { X: RX };choose a scoping for X and Y;% and so assign a value to ScpXconstruct a dependency function;choose a partition;choose quantifiers Qx and Qy";% must be consistent with constraints% 19&20 and ScpX & ScpYcase 2: RX = p(X)% i.e.
RX contains no embedded structureXs := { X: p(X) }; Qx := nil; ScpX := nil;end process_RES;An exampleConsider the following model:rep( rl ).
of( rl, cl ).
saw( rl, sl ).rep( r2 ).
of( r2, c2 ).
saw( rl, s2 ).rep( r3 ).
saw( r2, sl ).rep( r4 ).
samp( sl ).
saw( r2, s2 ).samp( s2 ).
saw( r3, sl ).corn( cl ).
saw( r4, s2 ).corn( c2 ).and the target PAS (16).
According toprocess_PAS the following restrictions mustbe processed first.22 a of(QR(R,rep(R)), Qc(C,com(C)) )b samp(S)Starting with (22a):candidate set R = { rl, r2, r3, r4 }candidate set C = { cl, c2 }choose scoping R > Cthe following dependency function isconstructed.23 of: {rl,r2,r3,r4} --~ power'( {cl,c2} )rl ~ { cl }r2 ~ {c2}r3 ~{}r4 --~ {}The following partition is chosen.12824 focus: of: {rl,r2} ~ power({cl,c2})rl ~ { cl  }r2 ~ {.c2}compt: of: {r3,r4} ~ power({})r3 ~ {}r4 --, {}The quantifier a is chosen for C and thecandidate set {rl ,r22} is returned.Processing (22b) is straightforward andconsists of returning the value {sl,s2}, the setof all samples.
Now both restrictions havebeen processed and PAS (16) is processedwith the candidate sets {rl ,r2} and {sa ,s2}.candidate set R = { rl, r2 }candidate set S = { sl, s2 }choose scoping R > SThe following dependency function isconstructed.25 saw: {rl,r2} ~ power( {sl,s2} )rl ~ {s l , s2}r2 ~ {s l , s2}and the following partition is chosen.26 focus: saw: {rl,r2} ~ power( {sl,s2} )rl ~ {s l ,  s2}r2 ~ {s l ,  s2}compt: saw: { } ~ power( { } )The quantifiers every and both are now chosenfor R and S respectively giving the followingsentence.27 Ever~ representative of_a company sawboth samplesOf course different scoping and partitioningchoices may have generated differentquantifiers.
Those in (27) are based on thescoping choices R > C and R > S with thepartition choice shown in (26).ConclusionAn algorithm has been described forgenerating quantifiers in English sentenceswhich describe small models containingcollections of individuals which are inter-related in various ways.The algorithm performs a great deal of searchwith three levels of non-determinismcorresponding to.o quantifier scoping choiceso choice of focus sets / dependency functionpartitionso choice of individual quantifiers constrainedby the above two choicesThis is not necessarily a problem in thecontext of language generation where onlyone solution is sought.An obvious improvement tothe algorithmwould be to generate a preferred sentence orto rank the outputs as to how well theydescribe the model.
We are currently lookingat how this might be done by incorporatingsomething like the preference heuristics thathave been used successfully to selectquantifier scopings in natural anguageanalysis (Grosz et al1987).
After the choosescoping step in the algorithm quantifiers canbe proposed which are preferred in the givenscoping position.
These proposed quantifiersare then checked first by q_inc/3 and q_dec/3.The details of this have not yet been workedout.The description given of the algorithm isbased on binary predicates for the sake ofbrevity and clarity but the generalisation topredicates with three or more arguments i notdifficult.
For example, sentences of thefollowing form can be generated:28 Every boy gave most girls a kisswhere there is a different kiss for each<boy,girl> pair.
The resulting dependencyfunctions are, however, much bigger, andconsequently the search space is also.It is well documented (Webber 1978, Park1995) that some plural noun phrases arecapable of collective interpretations which arenot sensitive to quantifer scoping.
For129example, the sentence "'Three men lifted twoboxes" has an interpretation in which threemen combined their efforts in a single act oflifting two boxes.
The algorithm does notdeal with collective interpretations like this.ReferencesAlshawi, H, (1990), "Resolving Quasi Logical Forms.
", Computational Linguistics, 16, 3.Barwise, J, R Cooper, (1981), Generalized Quantifiers andNatural Language, Linguistics andPhilosophy, 4, 159-219.Creaney, N, (1995), Implementing Scope and Dependency Constrains in a Typed Attribute Logic,Proceedings of5th International Workshop on Natural Language Understanding and LogicProgramming, Lisbon.Grosz, B J, DE Appelt, PA Martin, and FCN Pereira, (1987), TEAM.
An Experiment in the Design ofTransportable Natural-Language Interfaces, Artificilal Intelligence, 32, 173-243.Hobbs, JR, SM Shieber, (1987), An Algorithm for Generating Quantifier Scopings, ComputationalLinguistics, Voi.3, No.l, 47-63.Park, J, (1995), Quantifier Scope and Constituency, Proceedings ACL-95.Saint-Dizier, P, (1984).
Handling Quantifier Scoping Ambiguities in a Semantic Representation fNatural Language Sentences.
In Dahl, V. and Saint-Dizier, P.
(eds.).
Proc.
I st Int.
Workshop onNatural Language Understanding and Logic Programming, (1984).
North-Holland.Webber, BL, (1978), A Formal Approach to Discourse Anaphora, BBN report no.
3761, Cambridge,MA: Bolt Beranek and Newman Inc.Appendix 1: terminology diagramCandidate sets for R and CWhole dependencyfunctionOne possible \]partition -focus andcomplement~ power(,{ cl, c2 }r2 ~ {c2}r3 ~ {c3}cl, c2, c3 })).~-~ power((cl, c2 }{c2}of: { r3 } ~ power( { c3 } ~", xr3 ~ {b3}ocus sets for R and C?
Focus maximum (R) = 2Focus minimum (R) = 2Focus maximum (C) = 2Focus minimum (C) = 1130
