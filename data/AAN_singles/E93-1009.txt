A Strategy for Dynamic Interpretation: a Fragment and anImplementat ionOl iv ie r  Bouchez  1,2, Jan  van  E i j ck  2,3 and  O l iv ie r  I s tace  1,2EMAIL: obo@info.fundp.ac.be, jve@cwi.nl, ois@info.fundp.ac.belInstitut d' Informatique, FUNDP, 61 Rue de Bruxelles, 5000 Narnur, Belgium,2CWI, P.O.
Box 4079, 1009 AB Amsterdam, The Netherlands3OTS, Trans 10, 3512 JK Utrecht, The NetherlandsAbst rac tThe strategy for natural language interpre-tation presented in this paper implementsthe dynamics of context change by translat-ing natural anguage texts into a meaningrepresentation language consisting of (de-scriptions of) programs, in the spirit of dy-namic predicate logic (DPL) \[5\].
The dif-ference with DPL is that the usual DPLsemantics i replaced by an error state se-mantics \[2\].
This allows for the treatmentof unbound anaphors, as in DPL, but alsoof presuppositions and presupposition pro-jection.The use of this dynamic interpretationstrategy is demonstrated in an implemen-tation of a small fragment of natural an-guage which handles unbound pronoun an-tecedent links, where it is assumed that theintended links are indicated in the inputstring, and uniqueness presuppositions ofdefinite descriptions.
The implementationconsists of a syntax module which outputsparse trees, a semantic module mappingparse trees to DPL representations, a repre-sentation processor which determines truthconditions, falsity conditions and presuppo-sition failure conditions, and an evaluator ofthese conditions in a database model.The implementation uses the logic pro-gramming language GSdel \[6\], an exper-imental successor of Prolog, with similarfunctionality and expressiveness, but withan improved eclarative semantics.1 The  Idea  o f  DynamicIn terpreta t ionRecent developments in Natural Language semanticshave witnessed a shift away from static represen-tation languages towards representation languageswith a dynamic flavour.
Such representation lan-guages can be viewed as definitions of very simpleimperative programming languages.To see how the imperative style comes in, considerthe treatment of indefinite descriptions (or: existen-tial phrases).
Existential quantifiers are viewed dy-namically as random assignment s atements followedby tests.
The translation of the natural anguagephrase 'a man' becomes omething like:x := ?
; man(x)The first part of this statement can be viewed as arandom assignment toregister x, the second part as atest on the value ofx.
This sequence of instructions iperformed against the background ofa database, i.e.,a model of first order logic.
The sequence succeeds ifthe database contains (representations of) men, andit can succeed in as many ways as there are menavailable in the database.The motivating examples for the shift from staticto dynamic representation have to do with pronounbinding.
The translation of phrases like 'a man' interms of assignments of values to registers makesit possible to treat binding of pronouns across sen-tence boundaries (the next sentence can start with'He' to pick up the reference to 'a man').
The nicething about the treatment in terms of assignment isthat the scope of the existential quantification is notclosed off at the end of a sentence, as used to be thecase for NL systems that employ static representa-tion (in terms of the existential quantifiers of predi-cate logic, with their irritating closing brackets).61Recently, it has become clear that dynamic repre-sentation has some other interesting features:?
It becomes possible to give an account of pre-supposition failure phenomena in terms of thedefinition of an error state semantics for the dy-namic representation language \[3; 2\].
Presuppo-sition failure occurs for example if one tries tointerpret "John's wife is unhappy" in a situationwhere John is not married.?
A more natural treatment of tense becomes pos-sible.
A sequence of sentences in the past tenselike "A man walked in.
He sat down.
He or-dered a drink" etc, is represented using subse-quent assignments of values (time intervals) toa dedicated time register t \[10\].The dynamic representation language can be anal-ysed with tools that were originally designedfor analysing imperative programming languages,namely the tools for precondition reasoning fromItoare logic or dynamic logic \[11\].
Precondition rea-soning for dynamic predicate logic with standard se-mantics was introduced in \[4\].
Precondition reason-ing gives the truth conditions of DPL representationsin the form of formulas of first order logic (FOL).When applied to the error state semantics of DPL,precondition reasoning can also be used to find thepresupposition failure conditions of DPL representa-tions as FOL formulas.We provide an integrated treatment of syntax andsemantics of a small fragment of natural languageand test this by implementing it.
The syntax of ourtoy grammar is a version of categorial grammar withfeature unification.
The semantics uses DPL rep-resentations, with an error state semantics which isreflected in the rules for precondition reasoning im-plemented in the precondition module.
This modulegenerates predicate logical formulas expressing theweakest preconditions of success, failure or error ofthe DPL representations.In detail, our interpretation strategy consists ofthe following steps:1.
Parsing a sentence or text and building a repre-sentation tree of its structure.2.
Translating the parse tree into a DPL program.3.
Using precondition reasoning to compute pre-conditions as formulas of FOL.4.
Simplifying the preconditions using a simplifierfor FOL formulas.5.
Evaluating the resulting formulas in a databasemodel.The current implementation produces for an inputtext within the grammar fragment: a LaTeX form re-port containing the sentence, the parse tree, the DPLtranslation, the precondition of success, the precon-dition of failure and the precondition of error, all insimplified form, and the result of evaluation in thedatabase.2 Dynamic  P red icate  Log ic2.1 In fo rmal  discussionDPL meaning representations for natural languagesentences can be viewed as procedures or programswith a relational semantics.
The programs that rep-resent the meanings are interpreted as relations be-tween input states and output states.
A state is amapping from variables to values in a model (in oursimple set-up all variables are of the same type).
Therepresentation for an example sentence such as "Johnsaw a man" is a program which associates John witha variable z, a man with a variable y, and first checkswhether the value of x equals John, next puts a valuein y which satisfies the predicate of being a man, andfinally checks whether the values of z and y are suchthat the first saw the second.Thus, the representation of "John saw a man"is a program which relates input states where z ismapped to John to output states where z is mappedto John and y is mapped to some man seen by John.If the evaluation takes place in a model where Johnsaw several men, then there are several possible out-put states.
If the evaluation takes place in a modelwhere John saw no men at all, then there is no out-put.
A program that yields no output for a given in-put fails for that input.
A program yielding at leastone output for a given input succeeds for that input.A program which yields at most one output for agiven input is deterministic for that input.
A pro-gram which yields more than one output for a giveninput is indeterministic for that input.
The example"John saw a man" shows that indefinite descriptionsmay give rise to indeterministic programs.
Deter-ministic programs that do not change their input arecalled test programs.
If a test program succeeds, itsoutput equals its input.
The sentence "John sawhim" would give rise to a test program.
Assumingthat the variable z, y are used for the subject andobject of the sentence, respectively, the program willsucceed for any input with x mapped to John and ~/mapped to some male individual seen by John.
Inthis case success means that the output state equalsthe input state.
The program will fail for any otherinput.All basic programs of DPL are tests; they do notchange their input, and they succeed if the values ofterms are in a specified relation and fail otherwise.Indeterminism in DPL arises from assignment pro-grams.
The assignment program for an indefinite de-scription a man will assign a new value to a variablex and succeed for any value of z which is a man.This is called indefinite assignment.
The assignmentprogram for a definite description ~he manager givesa value to a variable if and only if there is only onepossible value in the model under consideration.Complex programs can be formed by means ofnegation, implication and sequential composition.Negation and implication always form tests, but se-62quential composition does not.
Sequential composi-tions are tests if and only if the component programsare tests.2.2 SyntaxFor ease of exposition we will assume there are nofunction symbols in the DPL representation lan-guage, so the terms of DPL are either constants orvariables.
Let C be the set of constants, V the set ofvariables, and assume c E C, v E V.DPL  te rms t ::= c I v.Assume a set of relation symbols R with arities.Then the programs of DPL are given by the followingBNF definition.DPL  programs ~r ::= t = t I Rt .
.
.
t  \[ Qr;r) \ [ ( r  ::~I I v: I,v :We will use man, see as the relation symbols thattranslate "man", "see", and so on.
Thus, (1) is aDPL program.
(1) (T/v2 : man(v2); see(v2, v4)).We will omit outermost brackets and brackets insequential compositions like ((71"1;7i'2);r3).
This isharmless, for sequential composition is associative.Also, we will abbreviate r\]v : v = t as v := t. Thisabbreviation is natural, as the sequential composi-tion of random assignment to v and test for equalitywith t boils down to assigning the value of t to v.2.3 Ind ices  for  Antecedents  and  AnaphorsIn the natural language fragment we treat, we useco-indexing to indicate intended anaphoric links.We follow Barwise \[1\] in using superscripts for an-tecedents and subscripts for anaphors.
(2) A man walked in.
He smiled.If we intend the pronoun in (2) to refer to the subjectof the first sentence, we indicate this intention asfollows.
(3) A man 1 walked in.
He1 smiled.The superscript on the indefinite noun phrase indi-cates that this NP acts as an antecedent for NPswith the same index as a subscript.
The subscripton the pronoun indicates the antecedent towhich thepronoun is linked.The use of subscripts and superscripts i necessarybecause noun phrases can act as anaphors and an-tecedents at the same time.
(4) A man I walked in.Another man~ walked ont.Hez was angry.In example (4) the noun phrase another man isanaphorically constrained by an antecedent nounphrase a man (it must have a different referent), andat the same time acts as antecedent for the secondoccurrence of a man.The superscripts and subscripts refer to the vari-ables we employ in the translation of the nounphrases.
Superscripts correspond to variables thatget assigned a value in the translation, subscripts tovariables that are simply used.
Sentence (5) will gettranslated as (6) (tense is ignored, here and hereafter,for ease of exposition).
(5) John 1 saw a man 2.
(6) vl := J; : man( 2); see( l,,2).Sentence (7) gets translated as (8).
(7) Mary 3 ignored himx.
(8) va := M; ignore(va, vl).Sentence (9) gets translated as (10).
(9) Shea saw another man~.
(10) ~/v4; v4 ?
v2; man(v4); see(va, v4).Turning now to definite descriptions, the naturaltranslation of example (11) is (12).
(11) John I saw the man 2.
(12) vl := J; ~v2 : man(v2); see(vl, v2).In the error state semantics for DPL that we have inmind for this, (12) gives error in every model wherethere is no unique man.
It is clear that in most casesthis is too strong.
Still, we do not think this is aserious problem for our general approach.
It seemsto be a linguistic fact that definite descriptions oftenare used in a context-dependent way, to designatea unique referent in a very specific context, whichhowever is not made fully explicit.One context where (11) makes perfect sense is asituation where John and some other male individ-ual are present, and where it is left implicit that Johnis excluded from the context where the reference isunique.
In such cases we propose to read the def-inite description as uniquely satisfying the descrip-tion plus the extra condition of being non-identicalwith some constraining antecedent, in this case thesubject of the sentence.
This strategy boils down toreading (11) as (13).
(13) John 1 saw the other man~.Here the determiner the otheri is treated similarly toanotheri.
This gives translation (14).
(14) Vl := J; ,v2:(v2 ?
vi; man(v2));see(vi,cases another mechanism seems to be at In manywork.
(15) A man walked in.
John saw the man.Example (15) has a natural reading where thedefinite description is anaphorically linked to anantecedent.
We propose to make such implicitanaphoric links explicit, as in (16).
(16) A man a walked in.
John 2 saw the man~.If we provide the right translation instruction forsuch anaphoric uses of the, we arrive at translation63(17).
(17) Ovl : man(vl); walk-in(v1); vg~ := J;/,'03 : (133 = 131; man(vs)); see(v2, v3).This gives the man~ the meaning: the unique manthat is equal to vl, with v3 available for later referenceto this individual.
It seems to us that this gives thecorrect result, in the present case and in lots of othercases .In the case of (18) we still run into trouble, how-ever .
(18) The man with the hat smiled.Here, the natural translation is (19).
(19) +vx : (man(v1); ,vz : hat(v2); is-of(v2, vl);smile(v1).This translation contains a definite assignment ev2 :hat(v2), so it seems to assume that there is a uniquehat in the domain of discourse, which is perhaps abit too strong.
There are at least the following twoways out.
One is by handwaving.
Just remark thatin descriptions like the man with the golden gun, thesecond definite article is not quite as definite as itlooks, and the description is in fact idiomatic for themore strictly correct he man with a golden gun.
Theother escape is to add an epicycle to the analysis, inorder to achieve that man 1 with1 the hat 2 translatesinto (20).
(20)  man(~) l ) ;  t~)2: (hat( I )2)"  ~ i8-0f( I ;2 ,1)1)  ).We provisionally opt for the first solution.2.4 SemanticsThe standard DPL semantics maps input states tosets of possible output states.
Let a model .A4 =(M, II, where M is the domain and I the interpre-tation function for a set of constants and relationsymbols be Kiven.
Then the set of states is the set offunctions M v , and the standard semantics for DPLis given by a function \ [ .
\ ]~ : M V --+ ~p(MV).In order to capture the uniqueness presuppositionsof definite descriptions, we replace the standard se-mantics by an error state semantics.
In a Russellianaccount of definite descriptions, "The king of Franceis bald" when evaluated with respect o the state ofaffairs in 1905 or 1993 is false, for there is no uniquereferent for the description.
But it is much more nat-ural to follow Frege, Strawson and the majority of thelinguistic ommunity in assuming that statements in-volving "the king of France", when interpreted withrespect o a state of affairs where there is no uniqueking of France, may be neither true nor false, becausethey suffer from presupposition failure.We propose to use an error state semantics to takein account he failure of uniqueness presuppositionsof t assignments.
The error state semantics of DPLif given by a function\[.\].~ : (M e t.J <r) -+- :P(M V 12 e).In the definition of this function, which follows, erefers to a special error state, A ranges over properstates, B ranges over states in general (including theerror state), and A\[x := d\] is used for the properstate which is like A, except for the fact that z ismapped to d.1.
\[xl.~l(e) = {c}2.
\ [Rta.
.
.
tn\] .~(A)={A} if (V~,a(tl), .
.
.
.
V.~,a(tn)) E I(R)0 otherwise.3.
\[t~ = t2\].~(A) ={A} if Vdbl,A('l) ~- V.I~,A('2)0 otherwise.4.
\[(~1; ~2) \ ]~(a)  =s.
\ [ (~,  ~ ~) |~(a)  =/ {~} if there is a state B E \[a'l\]~(A)with\[lr2\]~(B) = {c}{A} if for all B e \[~II~(A)it holds that\[a'2\]~(B)  {e)otherwise.6.
\[('~x\]~a(A) ={e} if \[a'\]~(A) = {e}{A} if \[Tr\],~(A) = $O otherwise.7.
\ [ , lx :  ,~ \ ]~(A)  =U{\[-\]~(A\[z := d\])ld e A4}.s.
\ [ , , x : .
l~CA)  ={ \[x\]~(A\[z := d\]) for the unique d with\[x\]~(A\[z := d\]) g {e}if d exists{e} otherwise.More information on this definition can be found in\[2\].
For present purposes it is sufficient o note thata DPL program can execute in three different ways,when acting on a given input state:1.
The program reports success by producing atleast one proper output state.
For example, theprogram man(vx) when acting on an input statewhere Vl refers to John will succeed and returnthe input state as its only output state.2.
The program reports failure by not producingany output at all.
For example, the programrlvl : woman(v1) will fail for any input state(except e) if there are no women in the modelunder consideration (its output state set will beempty).3.
The program reports error by producing eas itsonly output.
For example, the program ,.vl :manager(v1) will produce e for any input stateif the model under consideration does not havea unique manager.643 Precond i t ions  of DPL  programsAbove, we have referred to DPL formulas as pro-grams.
We are now going to use tools for program-ming language analysis on DPL.
We will use quan-tified dynamic logic over DPL to describe the pre-conditions for success, failure and error of DPL pro-grams.QDL terms t ::= c I v,qDLprograms lr ::= t = t \] R t .
.
.
t  I Or; It) \]QDLformulas  ~: :=t - - t IR t .
.
- t l (~A~) l - -~ lNote that the QDL programs are precisely the DPLprograms.
An atomic relation Rtl, .
.
.
,  tn can occurinside a QDL program or as an atomic QDL formula,so we need to distinguish the programs of QDL fromthe static QDL relations.
We use boldface for thetest program Rt~ .
.
.
tn and italics for the formulaRt t .
.
.t~.We omit outermost parentheses as usual, and useT for a formula which is always true, I for a formulawhich is always false.The semantics of QDL is as for first order logic,with the following clauses for the program modalitiesadded (assume A ~ e):?
A4 ~A (~')~ iff there is some B with B E\[Tr\]\]~a(A), B ?
e and .44 ~B 9.?
A4 ~A \[lr\]~ iff for all S e I r i s (A)  it holdsthat B # e and .44 ~ 9-Note that (~r) and \[~r\] are not duals.
(~')T expressesthe conditions for success of ~r, \[~-\].L the conditionsfor failure of z.
It follows that ~(~r)T A --\[~r\].l_ ex-presses the conditions for error.The following axiom schemata can be used to com-pute these conditions as formulas of FOL.1.
(Rt ,  .
.
.
t , , )~ ~ (nt t  .
.
.
t ,  A ~).2.
\[Rt, .
.
.
t , \ ] to  ~ (Rt t .
.
.
tn  -~ 9).~.
( t ,  = t , )~,  ~ (t~ = t~ ^  9) .4.
It, = t~\]~, ~ (t~ = t~ --.
9)-6.
\[~, ;~:~\]~ ~ \ [~, \ ] \ [~\ ]~.7.
( - ,~)~ ~ (~, ^  \ [~\ ]?)
.8.
\[-~-\]~, ~ ( (~) - r  v (~, ^  \[~-\]?)).10.
\[~r, =~ ~r,\]~ ~ ((\[~',\]((~r,)T V \[~r,\]J_)) A(\[~r,\](~,)T --~ 9))-11.
(n , , :  ,r)~, ~.
a~,(,,-)~,.12.
Nv :  ~r\]~# --Vv\[vr\]~.14.
\[ , , , :  ~-\]~, ~ (a!v(~-)T ^ V,,((~-)T --+ \[~-\]~)).The most interesting item of this list is the univer-sal schema for t assignment (item 14).
To see whatit means, note that \[~r\]m expresses that all outputstates of ~r are proper.
The schema states that thefollowing are equivalent:?
For proper input state A, the program tv : lrdoes only have proper output states, and all ofthese satisfy ~a.?
For proper input state A there is precisely oned E M for which 7r has a proper output on inputA\[v : -  d\], and for all d' for which ~r has properoutputs on A\[v := d'\], all outputs of lr on A\[v :=d'\] are proper and satisfy 9.It is not very difficult to see that these are indeedequivalent, so the axiom schema is sound, as are theother axiom schemata.The axiom schemata can be used to calculate thetruth, falsity and error conditions of DPL programsas formulas of FOL.
If we represent a first ordermodel as a database, then evaluation of DPL in amodel reduces to evaluation of first order formulasin the database.An example will make clear how the axioms maybe used to compute preconditions of DPL programsas FOL formulas.
Consider example (21) with trans-lation (22).
(21) I f  a woman is married,her husband looks after her.
(22) (qx : Wx; Mx)  =~ (~y: gyx;  Lyx).Here is the derivation of the truth conditions.
((rlz : Wa~; Mz)  =~ ( ty :  Hyz;  Lyx))T4-~ \ [~x:  Wx;  Mx\ ] (~y  : t tyx ;  Lyx)T~-+ \[r lx: Wx\] \ [Mz \ ] ( *y  : I ' lyz)(Ly~)T~-* Vx\[Wx\] \ [Mx\](Ly : Hyx}(Lyx)TVx(Wx ~ (Mx  -~(:JIy(I-Iy~c)-t- A By(I-Iyx)(Lyx)T))),-, Vx(W2: .-* (Mx(3 !yH~ ^ 3y(Hy~ ^ Lye)))) .To calculate the falsity conditions, we can usetheorem (23), which is derivable from the axiomschemata:Applying theorem (23), we get the following falsityconditions for (22):3x(Wx A Mx A 3!yHyx A Vy(Hyx ~ -~Lyx)).Program (22) aborts with error if it doesn't succeedand doesn't fail.
Modulo some FOL reasoning theconditions for this are given by (24):(24) 3x(Wx A Mx A - ,d!yYyx).This means that in all models where married womendo have unique husbands, program (22) will neverabort with error.
In other words, the calculus allowsus to derive that the presupposition of the definitedescription has been cancelled by the implication.654 The  Imp lementat ionThe parser The grammar for our fragment usescategorial feature unification, and the parser is basedon standard techniques for such grammars.
The syn-tax consists of a lexicon, which associates categorieswith lexical items, a category descriptor which givesdefinitions of complex categories in terms of simplercategories and some reduction rules.Basic categories are S without features, and Ewith features for number, person, case, uindez forup index (= antecedent index) and dindex for downindex (= anaphor index).
Complex categories arebuilt with / and \ and the constraints on feature uni-fication in the usual way.
The index features uindezand dindez also occur on noun phrases and determin-ers.
Here are some examples of complex categories(, marks the feature values that do not matter).?
N(number) =S/E(number,*,*,*).?
NP(number,person,case,uindex,dindex) =S/(E(number,person,case,uindex,dindex) kS).?
VP(number,person,*) =E(number,person,Nom,*,*)\S.?
TV(number,person,tense) =VP(*,*,tense)/NP(*,*,Acc,*,*).?
DET(number,uindex,dindex) =NP(number,Third,*,uindex,dindex)/N(number).?
AUX(number,person) -VP(number,person,Tensed)/VP (number ,person ,In f).?
NEG =AUX(number,person)\AUX(number,person).Basic categories get assigned in the lexicon.
For ex-ample:word CategoryJohn ~ NP(Sg,Third,*,i,*)hei NP(Sg,Third,Nom,*,i)himi NP(Sg,Third,Acc,*,i)sees TV(Sg,Third,Tensed)a i DET(Sg,i,*)the i DET(*,i,*)another~ DET(*,i~i)h i s}  DET(*,ij)man N(Sg)with (N(nr)kN(nr))/NP(*,*,*,*,*)Some examples of complex category formation:?
a man;:DET(Sg,i,*).
N(Sg) =NP(Sg,Third,*,i,*)/N(Sg).
N(Sg) =NP(Sg,Third,*,i,*).?
sees a man*:TV(Sg, Third, Tensed) ?
NP(Sg,Whird,*,*,*)= (VP(Sg,Third,Tensed)/NP(Sg,Third,Acc,*,*,*))-NP(Sg,Third,*,*,*)= VP(Sg,Third,Tensed).?
John~ sees a mani:NP(Sg,Third,*j,*)- VP(Sg,Third,Tensed) -(S/(E(Sg,Third,* j,*)kS))-(E(Sg,Third,Nom,*,*)\S)mS.The trans lator  The translator uses A-calculus totranslate parse trees into DPL programs?
We couldhave translated on the fly, building translations whileparsing, but the present set-up seemed preferable forreasons of modularity of design.The translation algorithm makes use of a lexicalfunction mapping pairs consisting of a lexical itemwith an associated category to A-expressions in thelexicon, along the lines of \[9\].Translating a sentence into DPL boils down tolambda reduction of the lambda expression whichresults from combining the lambda expressions as-sociated with the leaves of the parse tree, accordingto the rules of functional application dictated by thecategorial structure.Here are some examples of lambda expressions as-sociated with lexical items with categories.
Note thatwe assume the presence of indices in the lexicon, sowe can handle anaphoric links by co-indexing.For a proper understanding of the translation i -structions one should bear in mind the distinctionbetween DPL variables that are used for DPL assign-ment and lambda calculus variables.
We use lowercase for the first and upper case for the latter.Translation for man, N(Sg):AVl.m..(VI).Translation for John i,NP(Sg,Third,*,i,*):AVl.vi := J; Vi(v,).Translation for sees, TV(Sg,Third,Tensed):A VI.
( A V2.
(Vl A V3.see(V2, V3))).Translation for is, TV(Sg,Third,Tensed):A VI .
( A V2.
(Vl A Vs. V2 = v3)).Translation for a(n) i, Det(Sg,i,*):AV~.(AV2.
(,lv, : VlO,,); V2(,,))).Translation for the i, Det(*,i,*):AVI.(AV~.
(~,,,: V,(v,); V~(v,))).Translation for the~, Det(*,ij) (the anaphoric use ofthe):AVI.
(AV2.~v, : (v, = vi; VlV,); v2(,,)).Translation for if, (S/S)/S:A VI ,( A V2.
V, =~ v~ ).Translation for does, AUX(Sg,Third):AVI.V1.66Translation for not, NEG:~ v~ .
( ~ v~ .-, ( v~ v~ )) .Translation for another, DET(Sg,i,j):~Vl.(~v~.
(,~v~ : ,  # v~; v\](~); V~(vd)).Translation for the other, DET(*,i~):~Vl.(~V~.
(~,~ : (.~ # ~; V~(v~)); V~(~d)).Translation for he/, NP(Sg,Third,Nom,*,i):~v~.v,(~,).Translation for hisS, DET(*,ij):~v~.
(~v~.,v~ : Vl(,d; iso/(,~, ~); V2(vd).Translation for with, (N(nr)\N(nr))/NP(*,*,*,*,*):~ v~.
( ~ v2.
( ~ v~.
( v~(v~); Vl ( ~ ?
~of ( V~, v3)))).All these translations are typed, but we have leftmost of the typing discipline implicit.
For example,the translations of noun phrases all are of the typeof (dynamic) generalized quantifiers, which take aproperty to give a DPL program.
The translationof proper names is a dynamic variation of the Mon-tague treatment for proper names \[8\].
In extensionalMontague grammar, proper names translate into ex-pressions denoting the set of properties which aretrue of the named individual.
Here, proper namestranslate into expressions that for every propertygive the DPL program which first assigns the nameof the individual to the index variable of the propername, and then tests for the property.
This is likein Montague grammar, but with a dynamic touchadded.
Anaphoric links to the name remain possibleby means of the index variable as long as its valueremains unchanged.Other noun phrases with a dynamic flavour areindefinite and definite descriptions.
Indefinite de-scriptions translate into expressions that for everyproperty give the DPL program which does an in-definite assignment to an index variable and testsfor the property.
Definite descriptions are handledlikewise, but with definite assignment instead of in-definite assignment.
(25) John x uses his pc~.As an example, we treat the translation of (25),which is obtained starting from the following parsetree:(S ,(NP  1, John) ,(yP,(TV, u~e~),(NP?,(DET~,his),(N, pc))The translation step by step:his pc~ ~ AVI.
()W~.tv2 :y~ (v2); i8-o/(v2, 1); y2(,2))(~v~ .pc(V1))*-.-b;w2.,v2 : pc(v2); is-of(v2, v0; v2(~2).uses his pc~)~ V~ .
( )W2 .
V, ( ), Vs .
use ( V2 ,113 ) ) )(~v2.~v2 : pc(v2); i~-of(~2, v0; v2(v2)).--'4"~v2.(~v2.
(~ : pc(~2); i~-of(v2, ~); V2(v2))(aV3.use(V~, V,))(AV~.tv2 :pc(v2); is-of(v~., vl); (AVa.use(V2, Vs))(v2))~v2.,v2 : p~(v2); is-of(,2,,1); use(V2, ~2).John 1 uses his pc~(~Vl.v~ := J; (vdvl))~V2.,v2 : ~c(v~); i~.of(v~, v~); use(V2, v~), .
-+v~ := J;(AVz .tv2: pc(v2); is-of(vg., Vl); use(V~, vg.))(vl).
.
.4Vl := J; ~ : ~c(v~); is-of(~, ~1); use(~x, v~).In the same way, (26) gets translated into (27).
(26) John 1 is a man ~.
(27) vl := J; ~/v2 : man(v2); Vl = v2.Note that 'is' is treated as in Montague grammar \[8\].5 Experiences with the GSdelImplementat ion LanguageThe declarative semantics of GSdel improves on thesemantics of Prolog: extra-logical Predicates (such asvat, nonvar, assert, retract, !
.
.
.
.  )
are avoided andsometimes replaced by declarative counterparts.Like Lambda Prolog \[7\], GSdel is a typed language:it is necessary to declare the type and domain of allfunctions and predicates (polymorphism is allowed,however).
This convention makes program writing abit more cumbersome, For example, we have to de-clare the type Program for representing a DPL pro-gram.
For each DPL statement, it is necessary todefine a function to build a Program (example: Pi-ota : Variable * Program ~ Program).
We also haveto declare a type Expression for A-expressions.
Somecomplications arise from the fact that an expressionmay contain a DPL program and vice versa.
On theplus side, more errors are detected uring compila-tion, the compiler generates more efficient code, andthe typing discipline makes for more legible, com-prehensible programs.
Last but not least, the typingdiscipline has obliged us to think a bit more aboutthe clauses we were writing than we perhaps wouldhave done otherwise.67GSdel has facilities that permit elegant meta-programming.
In Prolog the program and the meta-program are not independent: the predicates as-sert and retract modify the program itself in whichthese predicates occur.
In GSdel, program and meta-program are completely independent.
It is possiblefor a program to load another program, to modifythis other program by inserting or retracting predi-cates, functions or types, and to demonstrate a goal.In our implementation we use these facilities to rep-resent a model as a logic database and a preconditionas a complex goal.6 The  Program I t se l fThe main module takes a sentence or text as inputand produces a report containing the sentence, theparse tree, the DPL program it gets translated into,and the preconditions.
This module uses the follow-ing submodules:?
the parser module which from a sentence, findsits category and builds its parse tree,?
the translation module which from the parsetree, computes a representation f a DPL pro-gram,?
the precondition module which from a DPL pro-gram, derives the preconditions (this modulecalls another module to simplify the resultingFOL formulas),?
the evaluation module which performs adatabase valuation.A lexicon module is called by the first two of thesemodules.
It contains the words, with their categoriesand the associated A-expressions.6.1 Ma in  modu leThis module receives a sentence represented by a listof words and parses it, translates it, produces a re-port, computes preconditions and evaluates these ina given model.6.2 OutputThis module defines how to output programs, ex-pressions, categories, trees, words, .
.
.
It uses thefacilities of GSdel for manipulating text files.6.3 Lex iconThe lexicon is defined by a predicate Diet with threearguments: the word itself, a category and an appro-priate lambda expression.6.4 ParserThe parser employs backtracking and unification inthe usual way.
GSdel (as all logic programming lan-guages) has these features built in, which makes itvery easy to implement a parser for a simple frag-ment like ours.
The parsing of a sentence consists ofthree steps:* generate a list of categories corresponding to thesequence of words,?
reduce the list of categories,?
test if you have a sentence lse retrace your stepsand try again.We use the type categor to represent categories.
Itis defined by the constant S and the functionsE(nnmber, person, case, nindex, dindez),NP (number, person, case, uindex, dindex),N(number),and so on.
The two infix functions / and \ serve tobuild new and more complex categories.Sentences axe parsed by building a binary parse treein bottom-up fashion.
The binary parse trees arerepresented by a constant Empty and a function A.Empty represents the empty tree and the functionA gives the information at the current node, the leftsubtree, and the right subtree.
The information con-tent of the nodes is of two kinds: internal nodes carrythe result of combining the categories of the subtreesand leaf nodes carry a pair consisting of a word andits category.The parse trees are built during the reduction of thelist of categories, starting with a list of trees corre-sponding to the words of the sentence.
When wereduce two adjacent categories, we replace the twocorresponding trees T1, 7"2 by a single tree with T1and Tz as immediate subtrees.6.5 Trans la torThe translator uses two types: Program and Ezpres-sion.
The first represents a DPL-program, the sec-ond a complex A-expression.
We have left the rest ofthe typing of the lambda expressions implicit.The definition of programs and lambda expressionsis a bit cumbersome, for a A-expression may containa program and vice versa.
This complication is re-flected in the rules for substitution and reduction.For example, it is necessary to define the substitu-tion of an expression for a variable in a program, thefree occurrence of a variable in a program, etc.
Therules of reduction are a straightforward endering ofthe rules of ~-reduction and 7-reduction in A calcu-lus.
We do not handle a reduction, as we see no needfor variable renaming.The translation process employs the following pred-icates:Trad  This predicate translates a parse tree into areduced A-expression.
Depending on the informationat the current node of the parse tree, a lexical look-up of the translation takes place, or the translation isfound by reducing the application of the translationsof the left and right subtrees.T rans  This predicate translates a list of parse treesfor the sentences of a text into the corresponding68DPL program.
It uses the predicate Trad to trans-late each sentence, and then links these translationsby applications.Canted This predicates takes a h-expression andreduces it using the declarative functional semanticsof h-calculus.6.6 From DPL  to QDLWe have seen that DPL programs are representedas G6del functions.
The reduction of DPL to FOLby means of QDL gets implemented by defining re-duction predicates corresponding to the QDL axiomschemata.
These predicates call each other recur-sively.?
Fa(Re i (s ,v ) )  is a relational atomic test.(at1...t.)?
Fequal(t l ,  t2) is an atomic test of equality ofthe terms tl  and t2.
(tl = t2)?
Fand(phi l ,  phi2) is the conjunction of two for-mulls.
(~1 A ta2)?
For(phi l ,  phi2) is the disjunction of two for-mulls.
(~1 V ta2)?
F impl ie (ph l ,ph i2) is  the implication of twoformulas.
(ill --* ta2)?
Fall(V(i), phi) is the expression (Vvi~)?
Fexist(V(i), phi) is the expression (3vita)?
Fonlyone(V(1), phi) is the expression (q!vi~)?
Fnot(phi)  is the negation of the formula ta.?
Fpreeexist(pi,  phi)is the expression ((~r)ta)?
Fprecuniv(pi ,  phi) is the expression (\[~r\]ia)?
Fpar(pi,  phi) is the expression (-~(Tr)taA-~\[Tr\]~).In the course of applying these predicates, formulasmay get generated with obvious redundancies.
Wehave defined a formula simplifier to remove some ofthese.
This improves the readability of the output(the formulas are output in LaTeX format) and theperformance of the database lookup on the basis ofthe conditions.There is the list of simplifications handled by themodule Simple.?
~# A T +-~ ~#?
~# A .L  +-+ J-?
~ V T ~ T?
~ V-L  ~-~ ~?
( ~ T ) ~ T?
(T* -?
(_I_ *- ~) ~-~ T?
-~T ~ _L?
(3!v~ A =Ivy,) ~ :l!v~.6.7 EvaluationThe intermediate language QDL allows us to trans-late DPL programs into formulas of FOL.
These arethen evaluated in a database model, i.e., a first ordermodel which is implemented as a G6del database (aG6del program).
There we have a so-cMled meta-module Evaluation and an object program LogicDatabase, and the meta-program anipulates theobject program.
We translate first order conditionsinto G6del goals, and then apply the goal to the ob-ject G6del program, using the possibilities of meta-programming offered by G6del.
In ordinary Prolog,these things could also be done, but they would lookmuch less elegant.Here is an example of a Gfdel model (the lines pre-ceded by % are comment lines):MODULE Model1.IMPORT Strings, Sets.BASE Symbol.% We use this base for every kind of term.CONSTANTJohn, Bill, Freddy, Borsalino, Myclone: Symbol.PROPOSITION Top.PREDICATEAdmire, Cheer, Isof, See, Use : Symbol * Symbol;tilt, Man, Adult, King, Pc, Manager : Symbol.% The relations defined in the modelAdmire(John,Bill).King(Bill).Isof(Borsalino,Bill).ttat(Borsalino).See(John,Bill).See(Bill,John).Manager(Bill).Man(John).Man(Bill).Man(Freddy).Adult(John).Adult(Bill).Pc(Myelone).Use(John,Myclone).Top.% Top must be defined in every model.697 Conc lus ionThe QDL translation discussed above only handlesuniqueness presuppositions of definite descriptions.The method employed is general enough, however,to handle lots of other kinds of presupposition.
Lex-teal presuppositions, for example, are handled in theerror state semantics by a slight revision of the se-mantic clause for atomic tests.
Being a bachelor pre-supposes being male and adult, so the test for bach-elorhood should give error if it is performed on anentity that does not satisfy the test for being a maleadult.Formally, the revision boils down to this.
Let At bethe set of atomic formulae of DPL.
Assume a lexi-cat presupposition function lp : At ~ DPL mappingeach atomic test predicate of the representation lan-guage to its associated lexical presupposition, con-ceived as a program of the representation language.For example, here are the lexical presuppositions forbachelorhood.lp(bachelor x) = (male x; adult x).The semantic clause for atomic relations is mod-ified to take the function lp into account:2'.
\ [R ( tx .
- .~ . )
\ ]~(A)  ={A} if ~lp(Rtl...t,)\]~(A) q~{e}and A4 ~A Rta ...tn,0 if \[lp(Rtl-.. t,)\]~(A) 9~ {'}and .~4 ~A Rta ...t,~,{,} if ~lp(Rtl-..t,)\]~(A) C_ {,}.This modified definition gives the success and failureof the relational test modulo the fact that the lexi-cal presupposition of the relational test holds; if thepresupposition does not hold then the test results inerror.There is no need for any other changes in the rules,for the projection of lexical presupposition is takencare of by the general principles of error percola-tion that are already implicit in the semantic lauses.Thus, the DPL error semantics gives us that (28) pre-supposes that Jan is male and adult, but that (29)only presupposes that Jan is adult.
(28) Jan is a bachelor.
(29) If Jan 1 is male, then hel is a bachelor.The change in the semantic lause for atomic re-lations is reflected in the calculus by replacing theschemata for Rtl .
.
.
tn by the following versions:1.
(Rt l .
.
.
tn)~a ~-+(Rt l .
.
.
t,, A (p A (lp(Rt~ ?
?
?
tn))r) .2.
\ [R t l .
.
.
tn \ ]~ *-+( R t l  .
.
.
t .
--+ ~)  ^  ( lp (m~ .
.
?
tn ) ) r ) .In the implementation, lexical presupposition is han-dled by a predicate Lp and a modification of thereduction predicates for the relational test axiomschemata.Right now, we are extending the fragment o dealwith other kinds of presupposition failure, in partic-ular failure of presupposition ofaspectual verbs suchas start and stop.References\[1\] J. Barwise.
Noun phrases, generalized quanti-tiers and anaphora.
In P. G~rdenfors, editor,Generalized Quantifiers: linguistic and logicalapproaches, pages 1-30.
D. Reidel PublishingCompany, Dordrecht, 1987.\[2\] J. van Eijck.
The dynamics of description.
Jour-nal of Semantics, 10, 1993. to appear.\[3\] J. van Eijck.
Presupposition failure - -  a comedyof errors.
Manuscript, CWI, Amsterdam, 1993.\[4\] J. van Eijck and F.J. de Vries.
Dynamic in-terpretation and Hoare deduction.
Journal ofLogic, Language, and Information, 1:1-44, 1992.\[5\] J. Groenendijk and M. Stokhof.
Dynamic pred-icate logic.
Linguistics and Philosophy, 14:39-100, 1991.\[6\] P.M. Hill and J.W.
Lloyd.
The GSdel report.Technical report, Department of Computer Sci-ence, University of Bristol, Bristol, 1991 (re-vised 1992).\[7\] D.A.
Miller.
A logic programming language withlambda bstraction, function variables and sim-ple unification.
In P. Schroeder-Heister, edi-tor, Eztensions of Logic Programming.
Springer,1990.\[8\] R. Montague.
The proper treatment of quantifi-cation in ordinary english.
In J. Hintikka e.a.,editor, Approaches to Natural Language, pages221-242.
Reidel, 1973.\[9\] R. Muskens.
Anaphora nd the logic of change.In J. van Eijck, editor, Logics in AI  / Eu-ropean Workshop JELIA '90 / Amsterdam,The Netherlands, September 1990 / Proceed-ings, Lecture Notes in Artificial Intelligence 478,pages 412-427.
Springer Verlag, 1991.\[10\] R. Muskens.
Tense and the logic of change.Manuscript, University of Tilburg, 1992.\[11\] V. Pratt.
Semantical considerations on Floyd-Honre logic.
Proceedings 17th IEEE Symposiumon Foundations of Computer Science, pages109-121, 1976.70
