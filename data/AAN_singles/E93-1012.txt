Morphonology in the LexiconLynne J Cahi l l *School of Cognit ive and Comput ing  SciencesUnivers i ty of Sussex, Br ighton BN1 9QH, EnglandEmaih lynneca@cogs.susx.ac.ukAbst rac tIn this paper we present a means of defin-ing morphonological phenomena in an in-heritance based lexicon.
We make useof the theory behind the formal languageMOLUSC, in which morphological lterna-tions were defined as mappings between se-quences of tree-structured syllables.
Wediscuss how the alternations can be definedin the inheritance-based l xical representa-tion language DATR, and how the phono-logical aspects can be built upon to bringit closer to an integrated lexicon with rep-resentations which can be used by both themorphology and phonology of a language.1 In t roduct ionThe use of inheritance mechanisms in computationallinguistics has become wide-ranging, with applica-tions in semantics, yntax, morphology and phonol-ogy.
In this paper, we shall examine the applicabilityof such mechanisms to phonological spects of mor-phology.The inheritance-based lexical representation lan-guage, DATR, has become widely used for vari-ous aspects of linguistic description, and previoustreatments of both morphological and phonologi-cal phenomena in DATR have shown its applica-bility to this area, both for its handling of inher-itance by default, and for its ability to define hi-erarchical structures.
For example, \[Gibbon, 1990\]describes how Kikuyu tone displacement and Ara-bic non-concatenative morphology can be defined in*Thanks are due to Roger Evans and Dafydd Gibbonfor comments  on previous drafts of this paper.DATR and \[Reinhard, 1990\] describes a hierarchicalapproach to German umlaut.
In this paper we as-sume a knowledge of DATR and refer the reader tothe introductions in \[Cahill and Evans, 1990\] and\[Evans and Gazdar, 1990\].MOI_USC (\[Cahill, 1990a\],\[Cahill, 1990b\],\[Cahilland Gazdar, 1990\]), is a formal language for defin-ing morphological ternations as mappings betweensequences of tree-structured syllables.
It is based onthe theory that (many) morphological lternationsare phonologically based, and can best be describedas operating on hierarchical structures, such as thesyllable.
However, there are fundamentally linear as-pects of morphological alternations, which requirereference to concepts uch as "initial", "final" and"penultimate".An account of English verbal morphology was dis-cussed in \[Cahill, 1990b\] which was expressed in acombined DATR/MOI_USC lexicon fragment.
Themorphological distribution was defined by the DATRwhile the morphological realisation was defined by aset of MOIUSC functions.
In this paper, we discussan account derived from this (see appendix), whichexpresses the distribution of alternations involved inthe same underlying way, but which does not requirea separate language to define them.
In doing this, wecan reduce the two-tiered DATR/MOLUSC approachoriginally used, to a single-tiered account.
This hasthe obvious advantage of reducing the "mechanisms"needed.
More importantly, however, we shall demon-strate, with discussion of how the morphonologicalinformation may be generalised to be more useful tothe phonology proper, it also has the advantage ofmoving the account owards a fully-integrated lex-icon, in which ultimately all levels of description -morphology, phonology, orthography, syntax, seman-tics - are combined.87In the following sections we shall consider thestructures involved and how they may be defined inDATR, considering how to model both the precisestructures used by MOLUSC and more generally use-ful phonological structures.
We shall then considerhow we might define the alternations.
Finally, weshall discuss the advantages of this approach overprevious descriptions of such phenomena s well asover the original MOLUSC language.2 Phono log ica l  S t ructuresIn many previous approaches to morphology, partic-ularly in the English-dominated NLP community, itwas assumed that morphology consisted fundamen-tally of "sticking together" morphemes, and makingthe necessary adjustments to allow for spelling pe-culiarities.
\[Cahill, 1990b\] suggested that this wastoo narrow a view, even for the rather impover-ished inflection displayed by English.
That there areseveral subclasses of English verbs which inflect bymeans other than affixation (e.g.
"bring"- "brought" ,"sit"- "sat" ) would seem to be a strong argument initself, but looking at other languages uch as theSemitic languages hows that there is an enormousbody of interesting morphological phenomena whichneeds to be addressed.
\[Cahill, 1990b\] showed that aview of morphological lternations as mappings be-tween tree-structured syllables permitted a naturaland succinct way of defining such Mternations.
Italso showed that levels of structure above the level ofthe syllable, while clearly vital for phonological de-scription, were not necessary for morphological de-scription.
Thus the approach used structures whichconsisted only of linear sequences of tree-structuredsyllables.The question of structure above the level of thesyllable is an interesting one.
The use of metrical ortonal structure is clearly relevant o the phonologyof a language, but it is debatable whether it has anyplace at all in the lexicon.
While certain metrical no-tions such as stress are relevant o the lexicon (con-sider the noun-verb alternation "re'ject"-"'reject"),the actual metrical structure of even a polysyllabicword is dependent on the context in which it appears.Thus, it would seem reasonable to assume that thelexicon specifies the actual evel of stress on each syl-lable of a word 1 but that the structure derived fromthis is extra-lexical.In the two-tiered DATR/MOLUSC lexicon, thephonological structures were assumed to be definedfully at each lexical entry.
This meant that wecould not make use of the inheritance mechanismsin DATR, even though the structures lent themselvesto such definition.
In the present work we shall definethe structures hierarchically in DATR, thus avoiding1There is an issue of how many levels we may wantto differentiate in the lexicon, but it is not one which wepropose to address in the current work.redundancy and enabling generalisations about thestructures which were previously impossible.The formal semantics of MOLUSC (\[Cahill andGazdar, 1990\]) defined the structures as having setsof feature definitions at each node.
Although thisfacility was not used in the examples provided norin the implementation, it is an aspect of the theorywhich we shall build upon in the current work.2.1 TreesIn the first instance, let us consider the simple situ-ation, where there are onset, peak, coda and rhymenodes which consist of (sequences of) phonemes.
Asimple mono-syllabic root may be defined in DATRby the following:Word: <root> == ( "<onset>"  "<rhyme>")<rhyme> == ("<peak> .
.
.
.
<coda>")<onset> == 0<peak> == 0<coda> == 0 .Here the root is said to consist of an onset anda rhyme (which are provided at the original querynode), and a rhyme (if not explicitly defined at thequery node) consists of a peak and a coda.
The on-set, peak and coda are by default 0.
Now we candefine the root "spell" as follows:Spell: <> == Word<onset> == (s  p )<peak> == e<coda> == 1 .The structure is inherited from the Word node, withjust the values of the onset, peak and coda definedat the node Spe l l  2.In our example theory defining a fragment of theEnglish verb system, we only have mono- and di-syllabic roots to contend with, but we need to con-sider how to handle a root consisting of an arbitrarynumber of syllables.
We need to allow for a poten-tially infinite number of syllables in a root, but wealso need each syllable in a root to maintain its ownidentity so as to permit both the definition of thevalues of the onset, peak and coda of the individuallexemes, and to allow for the definition of alterna-tions in particular syllables.
In MOLUSC this wasachieved by means of a simple numbering conventionwhere +N referred to the Nth syllable from the leftand -N referred to the Nth syllable from the right.In our DATR-only account, we achieve the linearstructures by means of a path prefix "struct", and bydefining the number of syllables in a root at its ownlexical entry by means of a sequence of symbols -one for each syllable more than one.
In the examplebelow, we use the term "ext" (for "extension") todenote each syllable above one.
Thus, a disyllabicroot could be defined by the line:2The brackets around the s p are just for the benefitof DATR.
They are removed in the final result.88<sylls> == extand a tri-syllabic root:<sylls> == (ext ext)and so on.
At a higher node (in our case, "VERB")we can then define the structure of a root with thefollowing:<root> == <struct "<sylls>"><struct ext> == (<struct> "<syll ext>")<struct> == <syll><sy11> == ("<onset> .... <rhyme>")Let us run through how this works by looking atthe example of a tri-syllabic root which does nothave values for any <sy11> paths defined at itsnode, so we can ignore the quotes on the <syl l>paths.
A tri-syllabic root will have the value (extext) for the path <sylls> at its own entry, sothe first line defines the root in this case to be<st ruct  ext  ext>.
The second line defines thevalue for the path <st ruct  ext>, and this is theclosest match for the path we want to evaluate.
It isdefined to be the list (<st ruct  ext> "<sy l l  extext>") ,  as the extra "ext"from the path we areevaluating ets added to any paths to be evaluatedon the right hand side.
Taking the second partof this first, <sy l l  ext ext>, assuming it isn't ex-plicitly defined at the word's entry, is defined as("<onset ext ext>" "<rhyme ext ext>").
Thisagain is because we carry over the extra elementsfrom a left-hand side path to the right-hand side.The path <st ruct  ext> is defined explicitly as(<st ruct> "<sy l l  ext>") ,  and <st ruct> is de-fined as being the same as <sy11>.
The derivationcan be viewed as follows~ with the numbers of thelines from which values are derived in brackets:<root> == <st ruct  ext  ext> (1)<struct ext ext> == (<struct ext>"<syll ext ext>") (2)<struct ext> == (<struct> "<syll ext>") (2)<struct> == <sy11> (3)<sy11> == ("<onset> .... <rhyme>") (4)-> <struct ext> == (("<onset>" "<rhyme>")"<syll ext>")<syll ext> == ("<onset ext>""<rhyme ext>") (4)-> <struct ext> == (("<onset>" "<rhyme>")("<onset ext>""<rhyme ext>") )-> <struct ext ext> == (("<onset>""<rhyme>")("<onset ext>""<rhyme ext>")"<syll ext ext>")<syll ext ext> == ("<onset ext ext>""<rhyme ext ext>") (4)-> <struct ext ext> == (("<onset>""<rhyme>" )("<onset ext>""<rhyme ext>")("<onset ext ext>""<rhyme ext ext>"))-> <root> == (("<onset>" "<rhyme>")("<onset ext>" "<rhyme ext>")("<onset ext ext>""<rhyme ext ex~>"))The root which results is therefore,("<onset>" "<rhyme>""<onset exl;>" "<rhyme ext>""<onset ext ext>" "<rhyme ext ext>")so that we can refer to the initial syllable and itsconstituents with paths without any "ext"s, the sec-ond syllable and its constituents with paths with one"ext" suffixed and so on.The idea of having to define the number of sylla-bles in a root at each lexical entry may seem a littleundesirable, but we will need to define each syllableseparately at the entry anyway, so the explicit in-formation of how many syllables there are is a verysmall cost.
In addition, since in our example frag-ment below most roots are monosyllabic anyway, thiswill not have to be defined for each entry.
We canhave a default value for <sylls> at the VERB node of"( )" .
Although this is a language specific advantage,it is expected that it would not often be necessary todefine polysyllabic roots for any language, since verylong words will usually be made up of either com-pounded roots (as happens frequently in German)or a single root plus several affixes (as happens inagglutinative languages uch as Turkish).The structures as defined above allow us to referto an individual syllable provided we know its po-sition from the left.
But if we want to refer to thelast syllable in a root, for example, we need to knowhow many syllables are in each root, thus preventingus from making generalisations over classes of verbswhich do not all have the same number of syllables.This is clearly undesirable, but it can be avoided.
Inthe example of English verbs, it is a feature of theverb roots that while most roots are monosyllabic:.those which are not only require reference to theirfinal syllable, never their initial syllable.
We there-fore want to reverse the structure definition above,which can be very simply achieved by reversing theorder of the paths <st ruct> and "<sy l l  ext>" inthe list on the right-hand side of the second line 3.What this means is that we must define for each lan-guage or language fragment (it may be different fornouns and verbs, for example) whether any alterna-tions take place at the right- or left-hand end of theroot.
It is possible to refer to a syllable any num-ber in from either side, not just the initial or finalSin our example fragment, we have replaced the term"ext" with "pref" to reflect he fact that it is prefixingwhich extends the structure.
The actual term used is, ofcourse, irrelevant.89and any form or set of forms which show a devia-tion from the norm can be accommodated in DATRsimply by means of overriding structure definitionsat a lower node in the hierarchy.
However, the def-inition of structure at the higher node(s) make fora generalisation about the set of forms covered bythat node.
This is in marked contrast o MOLUSC,which permitted equally easy reference to either end,and even permitted mixing within a single alterna-tion definition.
MOLUSC was much too powerful inthis respect, and permitted the definition of alterna-tions which do not occur in any language, so this isclearly a desirable restriction.2.2 Segments within onset, peak and codaAs well as accessing syllables within a sequence, MO-LOSC permitted the accessing of segments within theonset, peak and coda in a similar way.
Although wedo not want to go into detail here, as we do not pro-pose to ultimately use discrete segments, we can dothe same in the DATR framework outlined above, bymeans of a similar mechanism to that used for sylla-bles.
Again, we need to decide whether we want toextend leftwards or rightwards, and this again givesus a highly desirable restriction, which in this casewe can use to restrict onsets to extend rightwardsand codas to extend leftwards.
Thus, we may referto initial, second etc.
segments within the onset andfinal, penultimate etc.
segments within the coda butnot vice versa.
Of course, DATR itself does not forcesuch restrictions, but the framework we have definedforces the lexicon writer to decide on how to applythe restrictions.2.3 Phonological featuresAs mentioned above, we have used segments in theexamples given so far for clarity of explanation.
InMOLOSC and in the current work we intend the realunit of description to be the phonological feature orevent rather than the segment.
Much recent work,both computational and theoretical, has shown thatthe use of such units permits a more accurate, andabove all, a declarative description of phonologicalphenomena such as ellision, epenthesis and assimila-tion (e.g.
\[Coleman, 1992\], \[Bird and Klein, 1990\]).As mentioned above, \[Cahill and Gazdar, 1990\] de-fined a formal semantics for the MOLOSC languagewhich permitted the definition of phonological fea-tures at any level in the structure, although the im-plementation a d examples did not make use of fea-ture definitions except at terminal nodes.
Thus, thesegment labels below the onset, peak and coda nodeswere deemed to be abbreviations for a set of fea-tures, any one or more of which could be alteredby a morphological lternation.
It is possible totalk about inheritance of phonological features upor down the tree.
For example, a \[+ voice\] fea-ture at a rhyme node may be considered to be in-herited by the peak and coda nodes below it, so thatany segments within either of those two will containthe feature \[+ voice\].
Alternatively, the value of acoda node (null or non-null) may be inherited by therhyme and syllable nodes above it in order to spec-ify stress vMues which may be affected by whether asyllable is "open" or "closed".In the account we are proposing here, we only re-quire the latter type of inheritance, where the highernodes inherit features from the lower nodes.
This isbecause we are advocating an approach to phonologylike that proposed by \[Bird and Klein, 1990\], \[Cole-man, 1992\].
In both of these approaches, phonologi-cal features consist of a feature (or "event") name, avalue for that feature and an argument which defineshow it relates temporally to the other features in theword 4.
Thus, for example, in the word "bat" theremay be features uch as \[+ vo ice \ ] ,  \[+ l ab ia l \ ] ,  \[+alveolar\ ] ,  \[+ consonant\] and \[+ vowel\] amongstothers 5.
The voice feature would have a temporal ar-gument which expressed the fact that it lasts for theentire word, the labial feature would be defined aslasting for some time from the beginning of the worduntil the onset of the vowel feature and the alveolarfeature would be defined as commencing at the endof the vowel feature and ending at the end of theword.
Of course, this is very approximate, but it isintended only to give the flavour of the treatment.In an account of this nature, it is not necessary forthe features at higher nodes to be "trickled" downto lower nodes, since the temporal arguments definehow they relate.
However, that is not to say thatthe structure is unimportant.
Both of the theoriesfrom which we are borrowing here make use of thenotion of a tree-structured syllable, and phonologicalrestrictions are defined as holding within such struc-tures.
In particular, from the point of view of thecurrent account, reference to parts of the structureis necessary for the definition of morphological lter-nations (see below).
In our definition of the structuregiven above, the result is a simple list (of segmentsin the example we gave).
If we use features insteadof segments, the same result is achieved, but insteaxiof a list of segments, considered to be temporally or-dered, we end up with a list of features, not tempo-rally ordered, but with explicit temporal argumentsdefining their relationship to each other.2.3.1 The features and the i r  a rgumentsAlthough we will not be using segments, we main-tain the notion of segmental units in the temporal4\[Bird and Klein, 1990\] does not use features in thisform exactly, but the notion of temporal relations be-tween the events is vital to their account5It is important to note here that in this and all subse-quent examples of actual phonological features, no claimis being made as to the accuracy of the actual featuresused.
They axe meant purely to demonstrate the applica-bility of the framework to (morpho)phonological descrip-tion and not to demonstrate a full phonological theory.90arguments in our examples below.
We argue thatsegments, although possibly unnecessary in strictphonological terms, do seem to have a role at somelevel.
The very fact that our writing system makesuse of segment-type units appears to be an argumentin favour of maintaining their existence at some level,and in morphological terms it is clear that many al-ternations eem to require reference to such units.For example, the English alternation "bend"-"bent"can be defined as an alternation i  the voicing featureof only the final segment of the coda.
We are there-fore assuming timing boundaries at what would havebeen segment boundaries.
Thus the word "spell" isassumed to have four "timing sections", one for eachof the conventional segments.
The stem "spell" canthus be redefined as follows:Spell: <> == VERB<rhyme_feats> == (\[ + voice 2-4 \])<onset> == (\[ - voice 0-2 \]\[ + s ibi lant 0-I \]\[ + a lveolar  0-I \]\[ + stop I-2 \]\[ + labial  I-2 \])<peak> == (\[ - round 2-3 \]\[ - h igh 2-3 \]\[ - low 2-3 \]\[ + front 2-3 \])<coda> == (\[ + lateral  3-4 \]).The third element in each list is a (very simple)temporal argument.
The sibilant feature, for exam-ple, lasts from 0 to 1, i.e.
the first "segmentsworth";the approximant feature of the onset goes from 1 to2, i.e.
the second "segmentsworth"; the voice featureof the onset covers the whole two segmentsworth ofthe onset.
These are of course extremely simplified,both in the definition of the temporal arguments,and in the descriptions of the features themselves.But the theories from which we are borrowing haveplenty to say about these aspects of phonology whichis not relevant o how it might be expressed in aDATR lexicon combining phonological and morpho-logical description.
Note that in the example above,since we have temporal arguments, it is possibly notnecessary to differentiate he rhyme features (just thevoicing feature in the above example) from syllablefeatures.
We can have the feature \[ + voice 2-4 \]defined at either the rhyme or syllable node.
Sinceall rhyme features are inherited by the syllable, itwill only be relevant o make the distinction if analternation requires reference to the rhyme featuresspecifically.
However, it is more accurate to maintainthe distinction, and so we shall do so.2.3.2 Inher i t ing  feature  argumentsThe description above requires that every featurefor which we want to define a value in a stem must beexplicitly defined.
In addition, every value for everyfeature must be explicitly defined.
There is no roomfor a marked/unmarked distinction, for example.
Indoing this, we are not making use of DATR's defaultinheritance mechanisms to define default values forfeatures.
What we can do to improve on this situ-ation is to define a set of features for which a valueand a timing must be given (although the value maybe "undef" or some such), and provide default valuesfor each feature at a very high node.The set of features we have chosen are not intendedto be comprehensive or even necessarily consistent,but are simply those sufficient o describe the stemsand alternations involved in our example fragment.The feature set is as follows:alv = a lveolarapprox = approximantfr ic = f r icat ivehigh = highlab = labia llat = latera llow = lownasal  = nasalround = roundsib = s ib i lantstop = stopvel = velarvoice = voiceThe default value for all features is "-" and the de-fault timing is r l ,  for "root length" - i.e.
the wholelength of the root.The definition of the structure of a stem (i.e.
thenumber of syllables) is as before, but the definition ofa syllable needs to take into account he fact that weare now dealing with lists of features and their val-ues and timings, rather than linear sequences of seg-ments.
Since we are going to permit the permeationof features up the tree, we want the syllable node tocontain all of the features for the onset and rhymenodes, and the rhyme node to contain all of the fea-tures for the peak and coda nodes.
One consequenceof this is that we cannot simply allow the definitionof features hared by say the peak and coda nodes atthe rhyme node, since they will not then be inheriteddownwards, and any alternation which is dependenton the value of a feature at the coda node will needto look at the rhyme and syllable nodes' features,taking the timings into account as well.
It would un-doubtedly be possible to get around this problem butfor our present purposes the extra cost of defining ashared feature at both nodes which share it is not aproblem.The feature sets can be defined as follows:<syl l> == (\[ <feats syl l> \]\[ <feats onset> \]\[ <rhyme> \])<rhyme> == (\[ <feats rhyme> \]\[ <feats peak> \]\[ <feats coda> 3)The paths are not quoted in this because we want theactual feature set to be defined at the top node, with91just the values and timings defined at the terminalnodes.
Thus, the feature set can be defined:<feats> == (\[ alv "<val alv>" "<time alv>"approx "<val approx>" "<time approx>"f r ic  "<val  f r i c>"  "<t ime f r ic>"high "<val high> .
.
.
.
<time high>"lab "<val lab>" "<time lab>"lat "<val lat>" "<time fat>"low "<val low>" "<time low>"nasal "<val nasal>" "<time nasal>"round "<val round>" "<time round>"sib "<val sib>" "<time sib>"stop "<val stop>" "<time stop>"vel "<val vel>" "<time vel>"voice "<val voice> .... <t ime vo ice>" \])Then to find the set of features at the peak node,for example, the word peak is appended to all of the(quoted) paths in the feature list, thus evaluatingthe val and time for each feature at that node.
Thepaths:<val> == -<time> == rlthen define default values for the val and time paths.With these definitions, we can define a stem by sim-ply providing values for all those features which havethe value ,,+,,6 and times for these.
The examplestem "spell' can therefore be defined as:Spell: <> == VERB_A<val  s ib onset> == +<val lab onset> == +<val stop onset> == +<val  f ront  peak> == +<val  vo ice  peak> == +<val  lat coda> == +<val  voice coda> == +<time sib onset> == 0-1<time lab onset> == 1-2<time stop onset> == 1-2<time front peak> == 2-3<t ime vo ice peak> == 2-3<t ime voice coda> == 3-4<time lat coda> =- 3-4.Although the timings we are using here are extremelyapproximate, they can provide a starting point forphonological/phonetic systems, such as YorkTalk(\[Coleman, 1992\]).
The YorkWalk system definesphenomena such as epenthesis as adjustments in thetimings of such features, so as to blur the bound-aries between "segment" sections.
For example, theepenthesis which occurs in words such as "mince"(/mints/) is a result of the fact that the closure as-pect of the nasa l /n / i s  carried over to the non-nasaleWe are using simple boolean valued features here,but this is not a restriction.
Multi-valued features, suchas stress (see section 2 above), can be just as easilyaccommodated./s/, resulting in a / t / sound.
This type of phonolog-ical phenomenon is not something we would expectto be represented in the lexical entry for the word"mince", but having approximate, relative timings ofthe features gives a system like YorkTalk somethingwith which it can work more easily than simple seg-mental structures.
They also eliminate the need torefer to individual segments within onset, peak andcoda.
The stem "bend" for example has a coda whichconsists of an "n" and a "d" (in conventional terms).This can be expressed in our account by the featuresvoice, alveolar, nasal and stop having the value "+"in the coda, but with the following timings:<t ime vo ice  coda> == 2-4<time nasal coda> == 2-3<time alv coda> == 2-4<time stop coda> == 3-4The voice and alveolar features carry across thewhole coda, but the nasal feature is only on the firstsection and the stop feature is only on the second.There would appear to be a problem here, result-ing from the decision to only allow inheritance offea-tures up the tree, in that it is possible for a featureat a particular node to be given a value at that nodebut a timing which only covers part of the node.
Forexample, the stem "swell" has an onset whose voicefeature has the value "-" for the first section and"+" for the second section.
However, as we noted inthe example of "spell" above, it is possible for thesyllable node to contain features whose temporal ar-guments do not cover the whole syllable.
Thus, theonset of "swell" would have a feature "f-  voice\]"which has the timing "0-1" and the syllable nodewould have the feature "\[+ voice\]",  with the tem-poral argument "1-4".3 Morpho log ica l  A l te rnat ionsLet us momentarily return to the use of segments forclarity, and consider how to define alternations be-tween forms.
In our example case of English verbs,most of the inflections take the form of suffLxation,which can be defined trivially.
For example, thepresent participle form might be defined:<pres par t> == ("<root  pres>"  ing)(with the suffix itself having its structure defined- we are not concerned with that here).
What ismore interesting, however, is the definition of alter-nations uch as that in the forms "bereave"-"bereft","cleave'-"cleft".
Such verbs, although only in smallgroups, do exhibit consistent, phonologically deter-mined, but not strictly phonological, alternations.
InMOLUSC, these could be defined by means of func-tions such as the following:\[(peak,-1)/ii/:=~/e/\]\[(coda,-1,-1)/v/=~ If/\]\[(coda,-1,-l)\[+ voice\] :=~ \[- voice\]\]92There are two aspects to these alternations.
Onthe one hand, defining the alternation between, say, apeak o f / i i /w i th  a peak o f /e / i s  extremely straight-forward, simply requiring path extensions to the"<peak> ''7 definitions for past and present.
Thus,the following would define the alternation:<peak pres> == ii<peak  past> == ?However, in the account of English verbs in \[Cahill,1990b\], such verbs were grouped together with alarge number of other verbs which did not exhibitthis precise alternation, with the peak alternationbeing dependent on the original peak.
Thus, the pasttense peak i s /e / i f  the present ense peak i s / i i /andthe same as the present ense peak otherwise.3.1 Def in ing context -dependenta l te rnat ionsWe can define this type of context-dependent alter-nation in our framework by evaluating the presenttense value for the peak and using that as an argu-ment in a path for defining the past tense peak.
Thecode for this is:<peak past> == <peak_change "<peak pres>"><peak_change ii> == ?<peak_change> == "<peak pres>"This says that the peak of the past tense root(<peak past>) is found by evaluating the path whichhas the word peak_change followed by whatever thevalue of the present ense peak is ("<peak pres>").If this results in the path <peak_change i i> (i.e.
ifthe present tense peak is "ii") then the past tensepeak is "e".
In any other case (the path with thepresent peak value unspecified) the past tense peak isthe same as the present ense peak ("<peak pres>").3.2 Def in ing feature  value a l te rnat ionsThe coda change function is given in MOLUSC in twodifferent forms - one with segments and the otherwith features.
The version with segments can, unsur-prisingly, be defined in exactly the same way as thepeak change above.
Let us consider the alternationdefined as an alternation in the value of the voicingfeature.
The voicing feature of the set of verbs weare talking about is altered if the final segment ofthe coda is either a labial fricative ("v") or an alve-olar stop ("d").
There are therefore four features inwhose values we are interested: lab, f r ic ,  a lv  andstop.
We can define the value of the voicing featureof the coda in the past tense form to be dependenton the values of all four of these features:<val voice coda past> ==<coda_change "<val fr ic coda pres>"~This is the peak of the final syllable in all cases.
Wehave already discussed above how to define roots as ex-tending from either the right or the left, and we assumehere that the roots all extend from the right.
"<val lab coda pres>""<val stop coda pres>""<val alv coda pres>">and we can define the actual value simply by meansof the following two DATR sentences:<coda_change + +> = =  -<coda_change - - + +> == -The first says that, if the values of both the f r i cand lab features are "+" then the vo ice feature hasthe value "-", regardless of what the values of thestop and a lv  features are.
The second says that ifthe f r i c  and lab features both have the value "-"and the stop and s ly  features both have the value"+" then the value of the vo ice feature is "-".
Notethat the asymmetry is necessary but insignificant.
Itis not possible to define the alternation so that it isunimportant what the values of either the f r i c  andl ab  features or the stop and a lv  features are, butit should be clear that in a consistent phonology, itwould not be possible to have both the f r i c  andstop features having the value "+" and even if itwere possible to have the a lv  and lab features withthe value "+", it is highly unlikely that it would af-fect such an alternation.
That is to say, in the exam-ples of alternations we have looked at, such conflictshave never arisen.Two more alternations which can interestingly behandled very neatly in this framework are the sibi-lant/voice and alveolar/voice dependent "s" and "d"suffixes in English.
The plural noun and presenttense third person singular verb suffixes in Englishboth have three realisations: / i z /a f ter  sibi lants,/s/after unvoiced non-sibilants and/z /a f te r  voiced non-sibilants.
Traditionally this is defined with rules suchas,S ~/ i z / / \ [+  sib\] _s - .
I s / / \ [ -  voice\] _ _S - -+/z / / \ [+  voice\] __where the first rule must apply before the other two.Alternatively, the feature \[- sib\] must be specified inthe second and third rules in order to eliminate theneed for ordering.
In our account, we can define th isalternation declaratively and succinctly.
As with thecoda voicing alternation described above, we need toevaluate a path which contains values of features -in this case the s ib  and vo ice features.
The presenttense third person singular form is defined as:<pres th i rd sing> ==("<root pres>" <ssuff  "<val sib coda>""<val voice coda>">)and the value of the suffix ("ssuff") is defined verysimply with the following linesS:<ssuff +> == iz<ssuff - +> == Z<SSUff -> == s8We have left the suffix forms as segments rather thanexpanding them out to features for simplicity.93This says that if the value of the sib feature is "+"then the ssuff is "iz", regardless of what the valueof the voice feature is, and if the sib feature hasthe value "-" then the ssuff is "z" if the voice fea-ture has the value "+" and "s" otherwise.
We cando a similar thing for the past tense / id/ - /d/ - / t /suffix with the s ly  and voice features.
This analy-sis permits us to define the alternation declaratively,and hence without anyneed for rule ordering, but wecan specify one feature value less than is necessaryto avoid ordering in the traditional description.4 Conc lus ionsWe have presented an approach to describing mor-phological alternations in the lexicon which combineslinear and hierarchical notions, making use of thetheory behind MOLUSC.
Let us now consider theadvantages of this approach, both over the MOLUSClanguage and over previous DATR approaches tosuchphenomena.MOLUSC defined all morphological lternationsas mappings between linear sequences of tree-structured syllables, including affixation.
This re-quired extending the numerical labelling to include+0 and -0 to represent the prefix and suffix slots.While this was a reasonable extension to permit hedefinition of all morphological alternations within thesame framework, it ignored the obvious difference be-tween affixation and phonologically related alterna-tions.
It also implied (although it did not require)that all affixes were monosyllabic.
While this is veryoften the case, it is by no means always o (e.g.
En-glish "ation", Latin "amus" etc.)
and MOkUSC didnot have anything to say about these.
Equally, it didnot permit compounding, since every morphologicalprocess had to involve a stem and an affix.In the account we have proposed here, we can havethe best of both worlds.
We can use the type of defi-nitions of alternations that MOIUSC used to handlethe phonologically related phenomena, but we canleave the affixation and compounding to be treatedas simple concatenation in DATR lists.The account proposed here also has the advantage,mentioned above, that certain types of alternationand structural definition are much harder to definethan in MQLUSC.
MOLUSC was noticably overpow-ered, permitting the definition of alternations whichaffected both the first syllable and penultimate coda,dependent on the value of the third onset, for exam-ple, a combination unlikely in the extreme.
\[Cahill,1990b\] discussed some possible ways to restrict helanguage to have context dependencies adjacent othe alternation being defined and to only permit ref-erence to the initial, second, final and penultimatesyllables, for example.
Such restrictions are not en-forced by the account discussed above, but the kindof alternations which we would want to avoid are no-tably more difficult o define, which is in contrast toMOLUSC.The present account has much in common withthat in \[Gibbon, 1990\], which provided accounts ofKikuyu tone displacement and Arabic binyan mor-phology.
The account Gibbon gave of Arabic can bedirectly contrasted with the general approach pro-posed here.
Gibbon, like most others, makes use ofa C V template level, with the C and V slots be-ing filled by inheritance through a DATR lexicon.
Inour account, we can deal with the Arabic "template"morphology without he need for this extra layer, byusing the syllabic structure.
The vowels are definedsimply to be the peaks of the first, second etc.
syl-lables and the consonants are defined as the onsetsand codas.
An analysis along these lines using MO-LOSE was given in \[Cahill, 1990b\], and it could betranslated into the framework described above in thesame way as the English fragment has been.
Thiswould amount o a description very similar to thatin \[Gibbon, 1990\], but the resultant form, insteadof being simply a sequence of segments, would bea fully specified phonological structure of the typedescribed above.
Thus, the node for each triliteralroot would define the three basic consonant featuresets, with the form for each binyan being defined asa syllable sequence, for which the onset and coda foreach syllable would inherit from the root definition.The vowel alternations would be defined exactly asthe peak alternations in the English example above.A small example DATR theory by Dafydd Gib-bon in \[Evans and Gazdar, 1990\] (pp.
99-100) alsogives a small example of phonological underspeeifi-cation could be expressed in DATR.
An interestingextension of the current work would be to attemptto integrate it with the definition of underspecifiedphonology given by Gibbon.The framework outlined here, then, permits thesame intuitive description of morphonological alter-nations as did MOLUSC, but with the following ad-vantages:?
it forces the lexicon writer to restrict, or at leastguide, the types of alternations occurring in anylanguage fragment;?
it permits amore simple and intuitive treatmentof concatenation;?
it moves the theory closer to an integrated lex-icon - the output of the morphology is phono-logical representations which could be used byexisting phonological theories and implementa-tions.Append ix :  The  DATR codeVERB:<> == ()<root> == <struct  "<syl ls>"><syl ls> == ()<struct  pref> == ("<syl l  pref>"<struct>)<struct> == <syl l>94<sy11> == (\[ <feats sy11> J\[ <feats onset> \]\[ <rhyme> J)<rhyme> == (\[ <feats rhyme> \]\[ <feats peak> J\[ <feats coda> \])<feats> ==(\[alv "<val alv> .
.
.
.
<time alv>"approx "<val approx> .... <t ime approx>"fr ic  "<val f r ic>" "<time fr ic>"h igh "<val h igh> .
.
.
.
<time high>"lab "<val lab>" "<time lab>"lat "<val lat>" "<time lat>"low "<val low>" "<time low>"nasal  "<val nasal>" "<time nasal>"round "<val round>" "<time round>"sib "<val sib>" "<time sib>"stop "<val stop>" "<time stop>"vel "<val vel>" "<time vel>"voice "<val voice>" "<time voice>"\])<val> == -<t ime> == rl<pres> == "<root pres>"<pres part> == ("<root pres>" ing)<pres th i rd  sing> == ("<root pres>"<ssuff  "<val sib coda>""<val voice coda>">)<ssuff  +> == iz<ssuff  - +> == z<ssuff  - -> == s<past> == ("<root past>""<dsuff  "<val alv coda>""<val voice coda>">")<dsuff  +> == id<dsuff  - +> == d<dsuff  - -> == t.VERB_A:<> == VERB<~eats peak  past> == <peak_change"<feats peak pres>"><peak_change ii> == e<peak_change> == "<feats peak pres>"<val  voice coda past> ==<coda_change "<val fr ic coda pres>""<val lab coda pres>""<val stop coda pres>""<val alv coda pres>"><coda_change + +> == -<coda_change - - + +> == -<coda_change> == "<val voice coda pres>"<dsuf f> == t.Spell: <> == VERB_A<val sib onset> == +<val lab onset> == +<val stop onset> == +<val front peak> == +<val voice peak> == +Live:<val lat coda> == +<val voice coda> == +<time sib onset> == 0-I<t ime lab onset> == i-2<time stop onset> == 1-2<time front peak> == 2-3<time voice peak> == 2-3<time voice coda> == 3-4<time lat coda> == 3-4.<> == VERB<val fat onset> == +<val voice onset> == +<val h igh peak> == +<val front peak> == +<val voice peak> == +<val voice coda> == +<val fr ic  coda> == +<val lab coda> == +<time lat onset> == 0-I<t ime voice onset> == 0-I<t ime<time<time<time<time<timeh igh peak> == 1-2front peak> == 1-2voice peak> == I-2voice coda> == 2-3fr ic  coda> == 2-3lab coda> == 2-3.Bereave:<> == VERB_A<syl ls> == pref<val voice onset pref> == +<val lab onset pref> == +<val stop onset pref> == +<val front peak pref> == +<val voice peak pref> == +<feats coda pref> == 0<val voice onset> == +Bend:<val approx onset> == +<val h igh  peak> == +<val front peak> == +<val voice peak> == +<val voice coda> == +<val fr ic  coda> == +<val lab coda> == +<time voice onset pref> == 0-I<t ime lab onset pref> == 0-I<t ime stop onset pref> == 0-I<t ime front peak pref> == I-2<time voice peak pref> == I-2<time voice onset> == 2-3<time approx onset> == 2-3<time h igh peak> == 3-5<time front  peak> == 3-5<time voice peak> == 3-5<time voice coda> == 5-6<time fr ic  coda> == 5-6<t ime lab coda> == 5-6.<> == VERB_A95<val  vo ice  onset> == +<val  lab onset> == +<val  stop onset> == +<val  f ront  peak> == +<val  vo ice  peak> == +<val  vo ice  coda> == +<val  nasa l  coda> == +<val  alv coda> == +<val  stop coda> == +<t ime vo ice onset> == O-i<t ime lab onset> == 0-I<time stop  onset> == 0-I<time f ront  peak> == 1-2<t ime vo ice peak> == 1-2<t ime vo ice  coda> == 2-4<t ime nasa l  coda> == 2-3<time a lv  coda> == 2-4<t ime stop coda> == 3-4.editors, Lexicon und Lexicographie.
Olms Verlag,Hildesheim, 1990.Re ferences\[Bird and Klein, 1990\] S. Bird and E. Klein.
Phono-logical events.
Journal of Linguistics, 26, 1990.\[Cahill and Evans, 1990\] Lynne J. Cahill and RogerEvans.
An application of DATR: The TIC lexicon.In Proc.
ECAI-90, pages 120-125, 1990.\[Cahill and Gazdar, 1990\] L. J. Cahill and G. J. M.Gazdar.
The semantics of MOI.USC.
In ECAI-90,pages 126-131, Stockholm, 1990.\[Cahill, 1990a\] L. J. Cahill.
Syllable-based morphol-ogy.
In COLING 90, volume 3, pages 48-53,Helsinki, 1990.\[Cahill, 1990b\] L. J. Cahill.
Syllable-based morphol-ogy for natural language processing (DPhil Disser-tation).
Technical Report Cognitive Science Re-search Report 181, Cognitive and Computing Sci-ences, University of Sussex, 1990.\[Coleman, 1992\] J. S. Coleman.
Synthesis by rulewithout segments or rewrite rules.
In C.Benoitand G.Bailly, editors, Talking Machines.
Elsevier,1992.\[Evans and Gazdar, 1990\] R. Evans and G. Gazdar.The DATR papers.
Cognitive science research re-port 139, Cognitive and Computing Sciences, Uni-versity of Sussex, 1990.\[Gibbon, 1990\] Dafydd Gibbon.
Prosodic associa-tion by template inheritance.
In Walter Daele-mans and Gerald Gazdar, editors, Proceedings ofthe Workshop on Inheritance in Natural LanguageProcessing, pages 65-81.
Institute for LanguageTechnology, Tilburg, 1990.\[Reinhard, 1990\] S. Rein-hard.
Verarbeitungsprobleme nichtlinearer Mor-phologien: Umlaut-beschreibung in einem hierar-chischen Lexicon.
In B. Rieger and B. Schaeder,96
