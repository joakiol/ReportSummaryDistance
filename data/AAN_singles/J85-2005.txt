EURO TRA: A MULTILINGUAL SYSTEM UNDER DEVELOPMENTRod JohnsonCentre for Computational LinguisticsUniversity of Manchester Institute of Science and TechnologyPO Box 88Manchester M60 1QD, EnglandMaghi KingInstitut Dalle Molle pour les etudes cognitives et semantiquesUniversit$ de Geneve54 route des AcaciasCH-1227 Geneve, SwitzerlandLouis des TombeInstituut voor Algemene TaalwetenschapRijksuniversiteit UtrechtTrans 143512 JK Utrecht, HollandACKNOWLEDGMENTNone of the authors could claim ownership of the workand ideas presented here.
They are the result of a colla-borative effort over several years.
Our thanks should go,therefore, to all our EUROTRA colleagues, and especiallyto Sergei Perschke for his help in preparing this paper.The authors are of course, solely responsible for misre-porting, inaccuracies or errors.1 INTRODUCTIONThis paper tries to give an overview of the state ofEUROTRA development at the beginning of 1985.
Thesystem is under development in the sense that the projectis now an official project of the European community,much basic preliminary work has been done, and work inthe Member States has started.
However, as will be seen,linguistic work is in a very early stage, and no veryconcrete results are as yet available.The paper is composed as follows.
In the first twosections, we describe the project's purpose, some of theexternal factors influencing its organisation, its infra-structure and some of the design principles deriving fromthese general considerations.Section 3 discusses in more detail the model of trans-lation on which the project is based and some of thelinguistic and metalinguistic ssues involved.In section 4 we turn to the issue of communicationbetween the linguists developing the linguistic modulesand the computer.
It presents our choice of a softwareenvironment that allows rapid development and modifi-cation of problem-oriented notations for linguists.Section 5 describes the architecture of the currentsoftware prototype, which has been implemented follow-ing the principles outlined in section 4.Since EUROTRA, as already noted, is barely out of itspreparatory phase, the final sections do little more thansketch some factors that will determine the project'sfuture development.2 PROJECT HISTORY, BACKGROUND,AND ORGANISAT1ONEUROTRA is a research and development programme ofthe European Communities.
It is intended to produce acomparatively small operational prototype translatingoperational prototype translating from each of the sevenofficial languages of the Community into any one of theother seven languages.
The programme period of fiveCopyright1985 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is granted provided thatthe copies are not made for direct commercial dvantage and the CL reference and this copyright notice are included on the first page.
To copyotherwise, or to republish, requires a fee and/or specific permission,0362-613X/85/020155-169503.00Computational Linguistics, Volume 1 !, Numbers 2-3, April-September 1985 155Rod Johnson, Maghi King, and Louis des Tombe EUROTRAand a half years started in November 1982.
The totalbudget is roughly equivalent to 25 million dollars.The system is to be developed cooperatively, by inde-pendent teams working in each of the Member States.Seven teams, some of them involving more than oneMember State, take primary responsibility for work ontheir own language.
Two smaller teams carry out supportwork used by all the other groups, such as acting as asoftware clearing house or as expert terminologists.
Afurther group, independent of the organisation in theMember States, ensures coordination, is responsible forthe linguistic framework within which the languagegroups agree to work, and provides documentation bothfor the software and for the linguistics.
Software specifi-cations also are being developed by an independent team.At the time o f  writing (May 1985), seven of theMember States of the Community have already signedthe contracts of association under which the linguisticwork in the Member States is to be done.
Signature ofthe remaining three is expected in the near future.The first peculiarity of EUROTRA can already be seenfrom this: it is very much a linguists' project.
The aver-age size of a group working on a language will be on theorder of 10-12 people.
This gives a total of around ahundred linguists - a term that should be taken verybroadly as including linguisticians, translators, lexicogra-phers and so on - as against perhaps ten people workingon software.
This fact has had a profound influence onthe system design.Development is broken down into three phases, ofwhich the first is drawing to its end:1.
1983-1984:The main tasks to be achieved during this periodwere the definition of a basic software to be used byall the groups and a preliminary definition of thelinguistic framework to serve as the basis for workduring the second phase.The manpower available during this phase reflectsthe concentration on setting up the basic framework.Some twelve people have been involved in producingsoftware and linguistic specifications, whilst thelanguage groups remained comparatively small,mostly equivalent to two or three people.2.
1985-1986:During this period a first working system is to beproduced, taking all the seven languages as potentialsource and target languages.
This system will becorpus based, and cover approximately 2,500 lexicalentries for each of the languages.
The corpus will bea Community text in the domain of information tech-nology.
The choice of a corpus is constrained bytwo factors: equivalent versions of the corpus mustbe available in all of the languages, and, although thesubject area should be technical, it should be an areawith which the people in the language groups arereasonably familiar in order to minimize dependenceon outside help for technical terminology.
CertainCommunity texts fulfil both these conditions, and at.the same time provide an interesting range of sub-text-types, which is important in demonstrating thegeneralisability of the first system.
It is perhapssuperfluous to remark that testing and evaluation ofthe first system will not be based on the corpusalone.
The system's ability to translate similar textsin the same subject area and with the same vocabu-lary will also be taken into account.The construction of the first system serves twomain purposes.
First it demonstrates the feasibilityof the approach taken.
A number of aspects arerelevant here: it is laid down in the requirements hesystem must meet that it must, as well as being multi-lingual, be easily extensible in order to incorporatenew subject areas, new text types, new linguistictechniques, and even new languages.
To this end thesystem is designed to be as modular as possible andalso puts a great deal of emphasis on the declarativerepresentation of linguistic knowledge.
Extrememodularity, besides ensuring easy extensibility, alsomakes it easy to repair the system, even, if necessary,re-writing sub-parts completely.Secondly, the construction of the first systemprovides the feed-back needed to refine and stabilizethe linguistic framework.
Of our seven languages -Danish, Dutch, English, French, German, Greek andItalian - most have received comparatively littlestudy within computational linguistics, and for nearlyall of the language pairs contrastive work is almostentirely lacking.
For this reason, many of the deci-sions taken about linguistic representation during thefirst phase cannot be known to be correct until theyhave been thoroughly tested during the secondphase: indeed it is a fair assumption that they willhave to be modified.
Hence the emphasis in sectionthree on the tentativeness of current proposals.
Firmdecisions will be made only towards the end of thesecond phase.1987-1988:In this phase, the real prototype system will beconstructed.
Once again, it will cover all the sevenlanguages and will be corpus based, but the vocabu-lary will be approximately 20,000 lexical entries perlanguage.
The time allowed for this phase is only ayear and a half (the programme period stops in mid-1988), so the importance of establishing reliablelinguistic models by the end of the second phase isclear.
Note that the prototype is still only a proto-type rather than an industrial system.
During thislast phase the question of industrial development willbe considered for the first time.The twin constraints of multilinguality and decen-tralized development essentially determine somefundamental choices in system design.
The systemwill be transfer based, but in the interests of keepingthe transfer components as small as possible anattempt has been made in the definition of the156 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRAlinguistic representation that is input to transfer, todetermine what linguistic information can be consid-ered interlingual across the European languages andto treat it as such.
For example, differences insyntactic structure between the languages are effec-tively neutralized before transfer, emphasis has beenput on an attempt to define an adequate set ofsemantic relations common to all the languages, todefine language independent representations of time,modality, and so on.
In short, the linguistic represen-tation is semantically based, and as close to an inter-lingua as seems possible, whilst still recognising thata pure interlingua based system is out of the ques-tion.
The primary aim of defining a representationrich in semantic information is always to reduce thesize and complexity of the transfer components.
Infact, in the ideal (but unrealistic) case, transferwould consist of simple lexical substitution.
Thedesirability of keeping transfer small is obvious onpurely economic grounds (42 transfer modules versus7 analysis and 7 generation modules).
But at thesame time, the extraction and use of interlingualinformation should do much to improve the qualityof the translation.The system is designed to be integrated into an overalltext-handling system suitable for use in a heavily pressedtranslation service.
Thus, it is not intended that thereshould be any significant human intervention during thetranslation process, although, of course, the possibility ofhuman revision of the output text is allowed for.
Theamount of post editing to be foreseen depends on the useto which the text is to be put.
For simple text, or text tobe used for information gathering, there should be littleor none.
For more sensitive text, careful post-editing willbe required.
Special input modules are being designed toeliminate any need for pre-editing.Although the primary purpose of EUROTRA is to builda working prototype for the seven languages, it is alsointended to serve some important secondary purposes.
Itaims at stimulating research in Europe on machine trans-lation and related areas, including computational linguis-tics and natural language work in artificial intelligence,whilst at the same time building expertise in these areas.This is reflected in the software design, where an attempthas been made to design a general purpose tool forcomputational linguistics applications which is thenspecialized down into a machine translation software.The basic design is best seen as a system generator ratherthan as one particular software system.
As will be seenlater, the flexibility of a system generator is very usefuleven within the specific application of machine trans-lation.
It makes it possible to offer the linguist a range oftools with which to express himself, leaving him tochoose the tool most appropriate to the linguistic task inhand.3 SOME FUNDAMENTAL CHOICESIt is clear from the preceding section that EUROTRA is avery ambitious project with a very special set of initialrequirements, which, at the time of writing, distinguish itfrom all other machine translation projects of which weare aware.
In particular, there are three a priori decisionsabout the general organisation of the project that havestrongly influenced our whole methodological pproach:decentralisation, diversification, and size.3.1 DECENTRALIZATIONEUROTRA is intended from the start as a collaborativeventure between groups working in all the countries ofthe European Community.
Since the European Commu-nity institutions are set up to perform a political andadministrative function, there is simply no place in theorganisation for establishing large research institutions,particularly to serve R & D projects.
In any case, the vastmajority of the contributors to EUROTRA are facultymembers in Universities and it would just be impracticalto attempt o move them to one place for a period of fiveyears.The consequence of this is that most of the EUROTRAwork will be carried out by teams working semi-autono-mously on their own language, or in pairs on transfer.
Ifa project of this magnitude is to succeed with such a highlevel of decentralisation, there needs to be a great deal ofadvance planning to ensure that all the componentsdeveloped separately will fit together smoothly andcorrectly.
This is why, in EUROTRA, almost all thelinguistic work done to date has been preoccupied withthe question of defining interfaces at the points wherethe different components meet.
There are implications,too, for the software design, in that the softwareprovided should facilitate modular construction ofsystems, even, if necessary, at the cost of other desidera-ta like efficiency.3.2 DIVERSIFICATIONEUROTRA is also unusual in that it sets out giving equalpriorities to seven languages and 42 distinct languagepairs.
Some of these languages (especially English) havebeen the subject of very detailed study by theoretical andcomputational linguists.
Others, like Greek and Danish,have received comparatively little attention.
InEUROTRA it would be quite foolhardy to base the entiredesign of the system on our experience of working with,say, English or French, assuming that the same linguisticand computational strategies will be appropriate very-where else.
In any case, many of the countries of Europehave their own strong linguistic traditions, and we shouldexpect hese traditions to be reflected in the way scholarsin these countries go about handling their own languageon a computer.These considerations add to the problems we alreadyface as a result of decentralization.
On the one hand,such a level of inherent diversity increases the impor-Computational Linguistics, Volume I I, Numbers 2-3, April-September 1985 157Rod Johnson, Maghi King, and Louis des Tombe EUROTRAtance of initial /planning and particularly of a welldefined; well understood, and adequate interface repre-sentation.
On the other, we have to try to ensure thatthe representation chosen is sufficiently general to meetthe requirements of all languages (and linguists) in thesystem, and sufficiently constrained to be practicallyeffective.
Here again, there are implications for the soft-ware design, of quite similar nature: we want to constrainthe software so that it helps users to express what theywant to express about their language; and we want to beflexible enough to cope with the idiosyncrasies of all thelanguages.This tension between generality, on one side, and aneed for constraints on the other is pervasive inEUROTRA, and constitutes one of the most interestingand challenging aspects of the project.3.3 SIZEThe last of the partice ar features of EUROTRA is thequestion of sheer size.
Even in the development of thefirst initial prototype with a lexicon of a mere 2500words per language, we can expect the number of activecontributors to the system to be over 100.
Not only donumbers of this magnitude clearly compound the seriousproblem of diversification, but the mass of linguisticknowledge which has to be encoded in a relatively shorttime to meet the requirements of the full project term of5.5 years is quite staggering.
In our view it will just notbe feasible to try to encode such vast quantities of know-ledge using specialised programmers as intermediaries.We must expect hat the people who have the knowledge(linguists, lexicographers, translators) will themselveshave to interact directly with the system.
Therefore wehave concentrated on designing a software systemintended to perform .computations on the basis of (mainlydeclarative) user knowledge as input.3.4 SUMMARYAlthough the idea of EUROTRA has been with us since1978, we are only now, at the time of writing, nearingthe end of the design stage, and just beginning to exper-iment with the first prototype software system.
Becauseof the peculiar circumstances of EUROTRA, the gestationperiod has been extraordinarily long, and we have beenforced to reason at length and in some depth about thetheory and methodology of machine translation.
Webelieve, in retrospect, that this long preparatory phasehas led to better and more secure design, and will lead inits turn to a more manageable and robust machine trans-lation system.
By the time this paper is published, thefirst intensive efforts at linguistic development will havetaken place, and we shall know whether or not we arejustified in that belief.In the remainder of this paper, we discuss first thecurrent state of the EUROTRA linguistic specifications;then we outline our approach to the development of asuitable software environment for a project such asEUROTRA, and finally we finish with some speculationson the future of EUROTRA and on the question of evalu-ating our results.4 THE THEORY OF LINGUISTIC REPRESENTATION4.1 BASIC NOTIONSThe following diagra m forms a good basis for the studyof representations in a transfer-based translation system:(1)ANTRFRs RtI I1 I gEN| 1| ITs TtTRAIn (1), Ts and Tt are texts, where a language is regardedas a set Of texts.
TRA is a binary relation, consisting ofpairs of texts \[Ts, Tt\] where Tt is a translation of Ts.
So,given two languages, SL and TL, TRA <SLxTL .
Weintroduce, furthermore, p, which is a set of represen-tations of some kind.
Rs and Rt are both members ofthis set.
We will write R when it is unimportant whetherwe are dealing with Rs or Rt, or when the context makesit clear which is intended.AN, TRF, and GEN are all binary relations:AN _< SLxp, GEN < pxTL ,  and TRF _< pxpWe define the composition AN o TRF o GEN as the set ofpairs \[Ts,Tt\] such that there exist Rs and Rt such that TsAN Rs and Rs TRF Rt and Rt GEN Tt.
We will restrictour attention to those cases where AN oTRFoGEN =TRAAnalysis, transfer, and generation are systems thatcompute the relations AN, TRF, and GEN. For thereasons given in the previous section, EUROTRA tries toproduce a detailed specification of the contents of therelations as input to the research teams that write thecomputational systems.
For this, we have a theory ofrepresentation.
This should not be confused with theschemes for representation of knowledge proposed by,amongst others, Hayes (1978).
Together with the know-ledge linguists and bilinguals have of their languages, thistheory will specify the contents of AN, TRF and GEN.The contents of the theory itself depend in part on theaims of the EUROTRA linguistics (cf.
section 2 above),and in part on experience gathered by the writers of thevarious subsystems.158 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRA4.2 THREE PRINCIPLES4.2.1 DIVISION OF LABOURAn important consequence of decentralized developmentin EUROTRA is that a serious amount of attention mustbe given to the nature of Rt, because a research groupwriting generation for language L should have concreteideas about the class of inputs to expect.
Moreover, thisclass should make sense to people who only know aboutL.
In EUROTRA, we relate Rs to Rt, where these areboth representations of texts in L, one would expectthere to be some similarity between the Rs of some textT and the Rt that represents the same text.At first sight, one may be inclined to think that ANand GEN must be each other's "mirror image", that is:(2) \[T,R\] E AN(L) i f f  \[R,T\] e GEN(L)Given (2), there is a lot of structure in the framework.
Ifa given representation theory determines the Rs for sometext, it also determines the Rt.
This has two advantages:?
First, since the class of Rs for language L is clearlyunderstandable to linguists of L, the class of Rt is alsounderstandable.?
Second, given (2), it becomes possible to relate simplici-ty of transfer directly to the "depth" of the represen-tations (for discussion, see section 4.2.2).However, (2) is too strong, and may be in conflict withthe idea of simple transfer.
For example, if surfaceconstituent structure is taken as (the basis for) a theoryof representation, then (2) implies that TRF relatessource language surface word order to target languageword order, which clearly involves a lot more than substi-tution of lexical elements.Therefore, we define an equivalence relation betweenrepresentations.
We will not say anything about thecontents of this relation here, since its definition clearlydepends on the contents of the representation theorydiscussed in section 4.
However, it should be clear thatwe can use this relation (called isoduidy, which is aninvented name) to relate GEN(L) to AN(L) as follows:(3) Relation between AN(L) and GEN(L):\[RP,T\] GEN(L)  iff \[T,R\] AN(L) and R r isoduid to RIn practical terms, this means that generation will relateeach R r that is isoduid to R to the T that R belongs to.If we think again of surface constituent structure as apossible basis for a theory of representation, one couldimagine that R p isoduid to R if they have the same verti-cal geometry but not necessarily the same left-to-rightorder of constituents.
In that case, whatever structuretransfer is presented with, it would only have to producea representation with the target language vertical struc-ture.
Generation then produces the text from that.As a consequence of this, the representation theorywill, amongst other things, contain a substantive defi-nition of isoduidy.4.2.2 SIMPLE TRANSFERThe reasons for the desirability of simple transfer havebeen stated in section 2.
In order to give this notionsome content, we have to be rather specific about thenature of the representations.In EUROTRA, the structure input to transfer (theinterface structure) is always a hierarchical structure, thatis, a tree.
For our present purposes the linguistic inter-pretation of the nodes of the tree is irrelevant; it could besurface constituents, units of meaning, or whatever.We then introduce another elation, called translates-as.
This relation must not be confused with TRA or TRF.Translates-as is a binary relation, probably many-to-many.
If we call 0* the set of all subtrees of all elementsof 0, then translates-as 0* x 0".
Its left-hand term is asubtree of the source language interface structure.
Itsright-hand term is a tree.
The relation TRA is entirelydifferent: it is a relation between texts.
TRF is a subsetof translates-as: it is the set of those elements of trans-lates-as for which the left-hand term is the topmost nodeof a representation f a complete text.The following example may clarify the idea of trans-lates-as.
Dotted lines indicate instantiations of therelation.Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985 159Rod Johnson, Maghi King, and Louis des Tombe EUROTRA(4)/ \ o P ?
Tom/ \B .
.
.
.
.
F C .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
I (Tom) om/D .
.
.
.
.
g E .
.
.
.
.
0tzwem) (swim) (g~aag)Q RA (likeAO K S 1 ( l i k~ (emptg)(swim)L M(emptg) (swim)Translates-as i a straightforward generalization fromtwo notions that have already existed for a long time invarious machine translation projects:?
TRF, which is the same relation but only between rootnodes of representations of whole texts;?
the bilingual dictionary, which is the same relation butonly between terminal nodes.We now turn to the notion of simple transfer.The basic EUROTRA view (see section 2, above) isthat the relation translates-as i trivially simple in allcases except terminal nodes, which then correspond tothe lexical units of the two languages.
Actually, if thisview were guaranteed to be correct, then the generalizedrelation introduced here would be just a useless compli-cation of the description of transfer: instead, we thenwould just say that transfer equals substitution of thelexical unit in a given representation.However, there are three reasons for modifying thebasic view.First, and most important, there are well known prob-lem cases such as the translation of the Dutch adverbgraag to the English verb like:(5) Tom zwemt graag translates as 'Tom likes to swim'Many examples like this are caused by lexical holes in thelanguages; in the example, English does not have theadverb corresponding to graag.
If we stick to the basicview, examples like these force us to have a ratherabstract, "deep" theory of the interface structure.
Such adeep theory may cause difficulties to analysis and gener-ation in many cases; it would be motivated on thegrounds of exceptions.Second, we assume that whatever theory we choose atthe end of the second phase of the project has to stabiliseand undergo no further modification during the thirdphase.
Thus, even if it were feasible to construct hisdeep theory, it would be hard, if not impossible, to guar-antee that problems like the one described will never turnup during the third phase.Third, one importar ~.
way in which EUROTRA is saidto be extensible is the possibility of adding otherlanguages.
But it is really impossible to have a version ofthe representation theory, based on the current sevenlanguages, guaranteed to be compatible with the basicview on simple transfer when languages like Spanish orPortuguese are added.For these reasons, we believe that the possibility ofsome "complex transfer" will have to be accepted, where"complex" means that the relation translates-as i notalways trivial.
However, the intention of the basic viewremains valid.
That is, the number of complex transferrelations must be minimized.A more precise formulation is the following.If A translates-as A t, then we will call A t a TN of A.We now call an element \[s,t\] of the set defined bytranslates-as  simple element iffeithers and t are both terminal nodes,or( i )and(ii)and(iii)and(iv)s is a subtree, whose root node is the nontermi-nal node A.t is a tree, whose root node is A p,A p is a copy of A,the immediate daughters of A' are copies of theTNs of the immediate daughters of A.160 Computational Linguistics, Volume 1 !, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRAThe principle of simple transfer then says that theproportion of simple elements in translates-as must bemaximal.The generalised relation translates-as makes it possibleto put some order into complex transfer.
It localises it ina natural way, based on a tree structure.
In (4), only thepair \[C,I\] is complex; all the others are simple.
This viewon transfer is easy to implement by means of an built-instrategy that simulates recursion.
(See also section 4.4below).4.2.3 SPECIFICITYThe problem of this section is the relation between therepresentation theory on the one hand and AN and GENon the other.Clearly, the representation theory must be "specific",in the following sense: given the representation theory, alanguage group must be able to produce a device thatcharacterizes the right set of pairs \[T,R\].
That is, alanguage group must be able to infer from the represen-tation theory(i) what the Ts are,(ii) what the Rs are,(iii) what the pairings between Ts and Rs are.It is likely (but not entirely obvious) that (i) will beunproblematic (it might be problematic if some specialrestriction on text type were imposed).
But the samecannot be said for (ii) and (iii).
A language group needsclear guidelines in order to be able to analyse its languagein a way that is compatible with the principle of simpletransfer.So, the representation theory must be rather specific.The obvious way to specify the pairings of texts andrepresentations i  to provide some full grammar thatenumerates all the pairs \[T,R\].
However, it is certainlynot the task of the representation theory to define eachof the languages in full.
Its task is only to enable thelanguage groups to do just that.
So, the representationtheory must be not only specific but also global.In the ideal case, the representation theory shouldstrongly suggest a "discovery procedure"; that is, giventhe representation theory and some set of relevant dataof some language L, it should be possible to construct he"right" grammar of L:(6) the representation theory + knowledge of L yieldcorrect grammar of LHowever, the state of the art of discovering usefuldiscovery procedures or even evaluation metrics inlinguistics is not such that we may hope to achieve this inEUROTRA.
So, in practice, there will be a representationtheory that is not specific enough, and the grammars ofthe languages will not necessarily be "right".In EUROTRA, we try to partly overcome this problemby relating the representation to the text via some inter-mediate representations.
That is, some "level" of repre-sentation is defined with respect o some other "level",for which it is easier to relate it to the text.
Note thatthis only applies to the definition of the relations AN andGEN, and not necessarily to the working of analysis andgeneration.
Furthermore, we try to stick as much aspossible to traditional linguistic analyses and provide a 10tof exemplification.
Finally, there is a central linguisticteam that can bring into agreement he work in thelanguage-specific centres and the general representationtheory.4.3 THE GENERAL THEORY OF REPRESENTATION4.3.1 LEVELS OF REPRESENTATIONTexts are represented in different ways in EUROTRA;these are called levels.First, there is the level of normalized text, roughly asequence of words and special symbols.
A word is anystring of characters.
In what follows, by "text" we willalways mean "normalized text".Second, there are the intermediate levels.
InEUROTRA, there are three of them:?
the EUROTRA Morphological level (EM)?
the EUROTRA Surface Syntactic level (ESS), the EUROTRA Deep Syntactic level (EDS)Third, there is the Interface structure, intended to bethe level at which transfer (i.e., simple transfer) takesplace normally.One may wonder what all these levels are for.While the purpose of the level of normalized text isclear, as well as the purpose of the interface structure,this is less obvious for the intermediate levels.
Theirpurpose is threefold:?
They serve specificity, in that they make it possible totalk about the interface structure and its relation totexts in a well-defined way;?
They may be the basis for some stratificational nalysisor generation strategy; while such a strategy may ulti-mately turn out not to be the most desirable one, espe-cially in the case of analysis, it could serve as a "safetynet" if a more "intelligent" strategy fails to yield aresult;?
Representations at the intermediate l vels may serve assafety nets for transfer; this holds certainly for the"morphological level", as at least the lexical units havebeen identified there.4.3.2 THE NOTION OF CONSTRUCTIONThe fundamental notion in EUROTRA representations atall levels is the construction.
A construction is a struc-ture, made out of primitive elements and otherconstructions; a text is considered a construction itself.4.3.2.1 DEPENDENCY CONSTRUCTIONSThe primary principle of the EUROTRA representationtheories is dependency.
In this section, we describe theintuitive basis for this notion.A dependency relation is said to hold between twoelements in certain circumstances.
One member of thisComputational Linguistics, Volume I 1, Numbers 2-3, April-September 1985 161Rod Johnson, Maghi King, and Louis des Tombe EUROTRArelation is called the gov(ernor), the other element hedependent.Two intuitive ideas determine the existence of adependency relation between a gov and some dependent.?
The gov expects to find certain types of dependents inits neighbourhood.
This expectation is inherent o theelement hat constitutes the gov, and may be a piece ofdictionary knowledge.?
The goy is felt to be modified by the dependent.Thus, to say that there is a dependency between twoitems is to say that the dependent element is either a slotfiller or a modifier of some other element, called the gov.One further principle determines the nature ofEUROTRA dependency grammar: the gov must always bea primitive element (with respect o the level involved).The nature of what are called primitive elements mayvary amongst levels of representation.A dependency construction is the collection ofelements consisting of one gov and all its dependents.The description given here is rather abstract; eachdistinct level of representation i stantiates dependency inits own fashion.4.3.3 CATEGORIESConstructions as well as primitive elements can be cate-gorized in various ways.
For example, if we take wordsas primitive elements, then we can classify them withrespect o lexical class.
Constructions can be categorizedaccording to syntactic category, like sentence, or noungroup, which cross-classifies with the distinction betweendependency and coordinate constructions.Dependency relations can also be categorized.
Forexample, notions like "subject" or "object", and also"agent" or "patient" can be taken to be types of depend-ency relations.
One classification of dependencyrelations must of course be fundamental; since depend-ency is said to be based on the notions slot filler andmodifier, there will always be two categories associatedto them.
We call them complement (for the slot filler)and modifier (obviously, for the modifier); abbreviationsare compl and mod.There is an intimate relation between the category ofthe gov and the category of the construction of which itis a gov.
As the nature of this relation varies acrosslevels, we will not discuss it here.4.3.4 THE BASIC REPRESENTATION THEORYThe representational device used in EUROTRA is thelabelled tree.The representational principles are straightforward:?
There is a one-to-one correspondence between leavesof the tree and primitive elements of the constructionrepresented by the tree;?
There is a one-to-one correspondence between nonter-minal nodes of the tree and constructions of the text;?
Labellings on the nodes express the categories of primi-tive elements, constructions, and dependency relations.This embodies a very strong theory about language: itsays that each text is a construction, and that eachconstruction is a straightforward hierarchy of primitiveelements and constructions.
Elegant though this idea is,we will shortly see that it is empirically wrong.
Conse-quently, the representation theory will have to beaugmented.But first, we give one example of a representation:Given the text:(7) John and Mary went to ParisWe may have the following tree:(8).
.
t  g j  \( to)  \]yov gov 9ov(Oohn) (Ma~y) (Par is )Note that we have omitted all the labellings, except two:we have indicated the govs, and the coordinateconstruction has got the label con.4.3.5 THE AUGMENTED REPRESENTATION THEORYThere are two classes of problems to the basic represen-tation theory.
First, the theory implies that no unit162 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRA(primitive or construction) can be a member of morethan one construction.
Second, it implies that every unitmust be a member of at least one construction (with theexception of the text itself).
Both implications turn outto be wrong.4.3.5.1 UNITS THAT ARE PART OF MORE THAN ONECONSTRUCTIONThe following is a possible type of counter-example tothe basic representation theories.
Suppose that in asentence like John tried to swim the element John is feltto be a dependent of tried.
It is then a member of twoconstructions, as described informally:nr l  I I IConstruction John tried to swimnr2" I \]The element John is a member of two constructions; thisis impossible to represent in the form of a tree.The second example shows that one unit can also bethe gov of two dependency constructions.nrl .
I I IConstruction Tom went to Paris and Hanna to Londonnr2.
\[ I IThe unit went is the gov of two dependencyconstructions.The representation theory is now changed in thefollowing way.
We introduce the notion of emptyelements.
These are meant to be "shadow elements" oftheir antecedents, i.e.
the elements that participate inmore than one construction.
Obviously, the relationbetween an empty element and its antecedent must beexpressed in some way other than tree geometry; inpictures of trees, we will use coindices, but that shouldnot prejudice in any way the representation methodchosen in the actual computational systems analysis,transfer, and generation.As a consequence of this, the idea of a one-to-onerelation between leaves of trees and primitive elements oftexts is now no longer valid: the empty elements in treesare leaves that do not correspond to anything at all in thetext.Given empty elements, we can now represent the twoproblem cases as follows:(9)( i )  ( t~ ied)g ov em~ tU g ov( , John)  ( i )  (swim)(10)I emptu( i )dohn to Par is  Hanna to London4.3.5.2 UNITS THAT ARE NOT PART OF ANY CONSTRUCTIONThe typical example is:(1 1) Frankly, I do not care a bitHere, the element frankly cannot be said to be a depend-ent of any gov.
The problematic elements are calledtranseonstruetionals.
They are counter-examples to thebasic representation theory.
This theory is augmented asfollows.
Transconstructionals re represented as if theyComputational Linguistics, Volume 11, Numbers 2-3, April-September 1985 163Rod Johnson, Maghi King, and Louis des Tombe EUROTRAwere dependents in the construction they are related tointuitively.
However, in order to indicate that they arenot real dependents, a special label is attached to them,indicating pseudodependency.
The actual pseudodepen-dency label depends on the representation level.The following is an example tree:(12)pseudo \[ gov I (real lg) (am)gov gov(I) (serious)4.4 THE INTERFACE STRUCTUREAt this moment, EUROTRA has only preliminaryproposals about the contents of the interface structure;this is natural, since decisive arguments about it mustcome from experience with the writing of transfersystems for all the language pairs.
On the currentproposals, the interface structure will be a tree,where leftto right order of the sub-trees is irrelevant, with a geom-etry that is 'deep syntactic' in that its leaves are lexicalunits and surface word order is not necessarily mirroredby the geometry.The trees will be labelled extensively.As well as the more conventional labels indicatingmorphological and syntactic features of constructions,there will be labels indicating what in the introductionwas called interlingual information.
There is no spacehere to do more than indicate what kinds of informationare included in this category.For example, there will be labels expressing time andmodality.Modality labels are necessary for disambiguation of atleast modal auxiliaries.
One well-known example:(13) E : cantranslates asF : pouvoir or savoirThe choice is made on the basis of a modal label differ-entiating between ability and possibility.Time meaning is certainly one of the more difficultmatters in linguistics.
Without some semantically-basedtime label, EUROTRA would have to translate frommorphological tense to morphological tense.
That wouldalready mean a deviation from simple transfer as definedin the framework, as tenses are normally not consideredlexical units.
However, even if the project accepts uch adeviation, then there is a severe problem of choice intransfer.
One example is the translation of 'present' fromDutch to English:(14) NL : presenttranslates asE : present or present progressive or futureThe list indicates the kind of problem transfer writerswould meet if there was no time label.
Example trans-lations are:(15) NLE(16) NLE(17) NLEThese examples are relatively simple, but as soon aswe take complex sentences and sequences of sentencesinto account, the problem for the transfer writer getsreally difficult.
Therefore, there is good reason for alabel that captures the "time meaning" of a text; this mayeven be interlingual.
In any ease, we expect that such alabel will considerably simplify the task of the transferwriter.With similar justification, i.e.
the need to simplifytransfer and to produce good translation, semanticrelation labels (such as agent, patient), Katz-Fodor typemarkers, morpho-syntaetie class markers, and represen-tations of anaphoric relations are included in the inter-face structure.
: Ik lees een boek: I am reading a book: Ik lees vaak boeken: I often read books: Morgen lees ik zes boeken: Tomorrow I will read six books5 COMPUTATIONAL TECHNIQUESIn the present state of the art, the problem of machinetranslation is not fully understood.
In some sub-domains(e.g., English syntax, English-French lexical equiv-alences) we have a good deal of experience, a richtheoretical literature, and, hence, the confidence topredict in some detail the behaviour of the program to dothe job.
In other areas, (the synthesis of Greek texts,mapping Italian representations to equivalent Danish textrepresentations), we have virtually no experience and canonly make informed guesses about the "right" way to dothe job by computer.
In the worst case we are still (atthe time of writing at least) hopelessly at a loss when itcomes to characterizing precisely what is preserved intranslation if more than two languages are involved.
In164 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRAother words, we do not have, as yet, anything like acomplete theory of multilingual machine translation.
Wehave argued elsewhere, and at some length (Johnson,Krauwer, Rosner, and Varile 1984, Johnson and Rosner1984) that it is in the nature of problem-oriented soft-ware to embody some theory of the problem domain, andwe shall not repeat he detailed arguments here.We simply restate our view that no existing solution tothe question of finding an appropriate problem-orientedprogramming language for machine translation seems tous to be acceptable for EUROTRA.
These solutions fallroughly into three categories:(a) Assume some theory and implement i directly; thisapproach is fairly rare, but seems inherent, forinstance, in Jan Landsbergen's Rosetta project(1984).
(b) Use an existing programming language, perhapsextended by a library of purposely-built macros,sub-routines or functions (depending on persuasion):examples of this approach are the IBM macro assem-bler in SYSTRAN (Bruderer 1978) and FORTRAN inSUSY (Maas 1984).
(c) Invent a new programming language, embodying avery weak, low-level theory of machine translation -usually based on explicit tree-to-tree mappings as inROBRA (Boitet and Nedobekjine 1982), Q-systems(TAUM 1973), and GRADE (Tsujii 1983).
Theunderlying thesis is normally sufficiently weak, insuch cases, to allow the claim that the language hasuniversal or near-universal pplication for all or mostof machine translation tasks.We have not adopted (a) because there is not suffi-cient practical evidence of a single theory that encom-passes translations between all pairs of the Communitylanguages.
We reject (b) on the grounds discussed atsome length in section 2. above: ordinary programminglanguages are just too unconstrained to be reliablyhandled by a large, loosely-linked community of users,many of whom are unskilled in their use; and theyobscure some of the true issues of linguistic knowledgerepresentation a d use in the detail of managing avonNeuman machine (or lambda calculus or Horn clauses orwhat have you).
The last option, (c) is more interesting.In principle, we reject (c) also, although in the short termwe have adopted a form of it for reasons of expediency,as we explain below in section 6.
We are sceptical aboutany kind of universal programming language for machinetranslation, because we believe that the tasks involved inmachine translation are essentially heterogeneous innature.
If we are constrained to use the same languageto describe syntactic parsing, "semantic" interpretation,lexical and structural transfer, resolution of structural andlexical ambiguities, in and between seven differentlanguages, it follows that either all of these are compara-ble or that the language of description gives us very littlehelp in saying what we want to say.To give a very simple example, suppose we have astrategy for parsing English that uses phrase structurerecognition to construct a network of syntactic relations(SUBJECT, OBJECT, etc.)
and then maps these relationsto case relations like AGENT, PATIENT etc.
In thehomogeneous view of the world, we might have to writesomething like:given A+B where cat(A)=NP and cat(B)=VPbuild C(A+B) setting cat(C)=Sandgiven A+B where cat(A)=V and cat(B)=NPbuild C(A+B) where cat(C)=VPfollowed in a later process by.
"given A(B+C(X*+D+Y*+E+Z*)where cat(A)=S and cat(B)=NPand cat(C)=VP and cat(D)=Vand cat (E)=NPbuild P (Q+R+X*+Y*+Z*)where srel(P)=pred and srel(Q)=subjand srel(Q)=obj and lex(P)=lex(D)and lex(Q) =lex(B) and lex(R)=lex(E)and semf(P)=semf(D) and semf(Q)=semf(B)and semf(R)=semf(E)/* semf stands for "semantic feature", X*,Y*, Z*are intended to stand for variables over sequencesof trees */followed again later bygiven A(B+C) where srel(A)=pred and srel(B)=subjand srel(C)=obj and action-process in semf(A)and animate in semf(B)build A(B+C) adding case(A)=pred and case(B)=agentand case(C) =patientWhile the above notation is very informal, it is worthnoting the very arbitrary semantics that underly it.
Forexample, there are clearly conventions about the use ofidentical variable names on the left and right hand side ofrules; in some cases, right hand nodes may be understoodas copies of corresponding nodes on the left (indicatedby the use of where), in others they may be interpreted asidentified with their left hand counterparts (indicated byadding).
The arbitrariness i  not accidental - indeed,since the linguistic theory underlying the notation is soweak, the meaning of the notation cannot but be arbi-trary to the user.
Their arbitrariness, however, is not thebiggest defect of notations of this kind.
Where they real-ly fail is in being intolerably cluttered, since the user isforced to be explicit about every detail of the operations,precisely because in the absence of any strong linguistictheory, none of the responsibility for details can be left tothe machine.Consider now the same statements in a more perspicu-ous notation:S ~ Np\ [ i suB J=.
\ ]  vp \ [ i= , \ ]VP ~- V\[ i=, \ ]  Np\ [ ioB J=.
\ ]and elsewhere (in the lexicon perhaps),Computational Linguistics, Volume I 1, Numbers 2-3, April-September 1985 165Rod Johnson, Maghi King, and Louis des Tombe EUROTRAif action-process in semf(PRED)and animate in semf(SUBJ)then \[SUBJ-- AGENT,OBJ-~ PATIENT\].Again the notation is informal, but not totally arbitrary(the debt to Lexical Functional Grammar (Kaplan &Bresnan 1982) is obvious).
What is significant, though,is not so much the syntax of the notation as its semantics.Because we have a theory of parsing, we can include inthe user's machine a large chunk of the meaning of whatit is to parse within that theory.
As a result, the user isleft with a much clearer view of the task in hand: toprovide the details of specific cases within the theory.The ideal goal of the EUROTRA software designshould be to provide just such a theory sensitive systemfor machine translation.
Unfortunately, and we havemade the point many times here, we just do not havesufficient knowledge of the domain to provide the neces-sary theoretical input, and the problem is magnified inthe special circumstances of EUROTRA.What we have therefore built is an environment inwhich new theories and/or  sub-theories of machinetranslation can be implemented very rapidly on an exper-imental basis.
The environment consists essentially offour parts, not including the usual editing and debuggingfacilities.
Two of the parts are quite standard: a compilercompiler, which we use to write compilers for thelanguages of a new theory; and a kernel interpreter thatruns the outputs from the compiler.
What is interesting isthat we contrive to make the process of compilation asmuch as possible a purely syntactic one, mapping state-ments in the user language into a simple tuple language.Statements in the tuple language are not, however,executable directly by the kernel interpreter, since theycontain as yet uninterpreted symbols.
The interpretationof the symbols is given by external definitions, which areof two types: control definitions and data definitions.As the names suggest, data definitions are essentiallyinstructions to a pattern matcher which acts as a slave tothe main interpreter; control definitions define how andwhen calls to the pattern matcher are made.
By judiciouschoice of the definition languages we are able to usethese external definitions in two ways - to make rapidimplementation of new theories, and to serve directly asspecifications for a more efficient implementation, shouldthe user agree after experimentation to include a newtheory in the system.
A more detailed description can befou0d in Johnson, Krauwer, Rosner, and Varile (1984).This device is already proving very effective in allow-ing users to try out new ideas.
More important, it freesus from the dangers of committing the user communitytoo early to a small number of particular strategies, whichmay turn out to be unsuitable in the medium term, with-out making ultimate commitment impossible by imposingmonolithic homogeneity from the start.Nonetheless, we clearly need to make some decisionsnow, however provisional, so that we can get started.The remainder of this section describes the first user-lan-guage prototype implementation which is being handedover to users for preliminary experimentation.All our software prototyping has been done underUnix, 1 both for reasons of easy portability and because ofthe rich set of available software tools.
The originalprototype was developed on a VAX-11/780 under bsdversion 4.2, and successful ports have been made to absd version 4.1 on a VAX 750 and to a Dual Systems83/20 running Unisoft Version 7.
We are about toattempt a port to a Sun Workstation and anticipate noserious difficulty.It should be noted that our decision to adopt Unix as asoftware prototyping environment (and therefore neces-sarily as a linguistic prototyping environment in the shortterm) does not necessarily of itself commit the antic-ipated industrial implementation to any particularhardware/software combination.
The main purpose ofour own software prototypes is to help us derive morereliable specifications for the industrial implementation,and to provide temporary short term support for linguis-tic experimentation.6 THE FIRST USER-LANGUAGE PROTOTYPE6.1 PROCESSESThe overriding design criterion we have followed is thatof modular construction.
Not only is this generally desir-able, it is virtually essential given the organisationalframework of EUROTRA.
The basic unit of a user"program" is called a process.
Since we want it to bepossible for users to test parts of a system independentlyof others, and indeed to combine parts together in a reli-able way, we have been particularly careful to provideways of limiting or even excluding the propagation ofunexpected side effects between processes.
We achievethis by defining a process as a quintupleprocess=\[name, expectation, focus, body, goal\]The name is just a symbol used to identify the process.The expectation and the goal are pattern descriptionsthat serve a number of desirable functions.
The mostimportant of these is to guarantee that the domain andrange of the process can be known when the process isdefined.
They achieve this by acting as filters over thecurrently active data configuration.
A process may onlyoperate on data that satisfy the expectation; correspond-ingly, only data that satisfy the goal are allowed to beoutput from the process.
Operationally what happens is:the system attempts to apply the process by matching theexpectation against the currently active data set; theprocess is invoked only if a match is found, in which casethe process is applied in parallel to all data subsets thatmatch; on termination (we assume that the processterminates) all results are matched against he goal; in all,and only, the cases where the match succeeds, the new1 Trademark of AT&T Bell Laboratories.166 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTRAresults are added to the active data set, and the systemproceeds to the next task.The focus gives a way of narrowing down application,to a subset of the data set yielded by the expectation; thisis necessary, for example, when a process invokes itselfrecursively.The process body may be either primitive or non-primitive.
Processes with primitive bodies are also calledgrammars, and we shall return to them later.
Non-primi-tive bodies consist of expressions over the names of proc-esses, where the meaning of the expression can be variedby external definitions.
In the current version, we allowregular expressions over processes, interpreting theconcatenation operator as sequential application, theunion operator as parallel application and the closure orstar operator as all paths combinatorial application.
Theprinciple underlying this general scheme of controllingpattern directed invocation via a formal control languageowes much to the work of Georgeff (1982).
Thus, in thebody of a process, a user might writebodypl,p2,(p3 I p4)with the meaning "apply p l ,  then p2, then p3 and p4 inparallel".
Our current compiler is defined to translatethis into the tuple\[sequence, pl,p2,\[parallel, p3,p4\]\]And, in our control definition language (we currently useFP, Backus 1978), the definition of apply includes:apply= atom--,- execute;eq o \[1,'sequence\] --,- /apply o tail;eq o \[1,'parallel\]~apply o tailwhere, with some simplificationexecute =integrate o filter-goal o apply o filter-expectation.It should be emphasised that the user is only concernedwith writing (and understanding!)
statements likebody pl,p2,(p3 I p4)6.2 GRAMMARSThe process interpreter continues to try to apply proc-esses until it bottoms out at grammars (processes whosebody is a primitive).
The structure of a primitive dependson the theory it implements: thus a general rewrite primi-tive will be organised - and defined - differently from adictionary primitive, which in its turn will differ from atransfer primitive, and so on.
We currently have veryfew primitives, since the system is still in an experimentalstage.
The most important is a non-deterministic treetransducer, implementing a general re-write system,which does not differ in any interesting way fromColmerauer's Q-system (1971) or Kay's powerful parser(1967).
Its main purpose is to provide users with a very(excessively) powerful tool for experimentation, and toprovide fall-back for those cases where there is noadequate computational linguistic theory.
We also havean analysis dictionary (a device that maps strings tonodes with complex collections of attributes andfeatures) and a phrase structure parser.
We are about tostart on a transfer device to implement he proposaloutlined in section 3, and, as a more searching test of thecapabilities of the basic tools, an implementation of amultilevel parser inspired by LFG.
Once the basic toolswere built, we found it very easy to build prototypeimplementations quickly.
For example, the generalre-write system took about two man-months.
The firstdictionary implementation took less than a man-week.We expect that the transfer device will take around twoto three weeks; the multilevel parser will almost certainlytake longer - perhaps a month to six weeks.6.3 DATA STRUCTUREIn our system, there is no data "structure" as such.
Thesame effect is achieved through interaction between apattern matcher and a data base of primitive objectscalled nodes.
The behaviour of the pattern matcher isdefined externally through statements in a data definitionlanguage, much in the same way as the meaning ofsystem control constructs is defined in FP.
At the pres-ent time, we are using Prolog to supply both the database manager and the definition language.
This is nottotally satisfactory, and we expect o have a more appro-priate "in-house" data definition language shortly.
'Togive a flavour of our data definitions, we give a singleexample of the definition and use of a tree, in pseudo-Prolog.First we define some basic relations, using built-inhigher-order relations:antisymetric (dom)intransitive(dom)irre flexive (dom)$dom(x,x)$dom(x,y):-dom(x,z),$dom(z,y)/* reflexive transitive closure */tree (R,x) : -Sdom(R,x) /* tree x with root R */If the notation #x in the user program means "bind x to atree", then we define our compiler to translate #x to \[treex\].
The control interpreter simply performs elementarysyntactic manipulation on data requests and passes themdirectly to the data manager, \[tree x\] is transformed totree (-,- x).
Repeated calls to the data manager will yieldall possible trees x in the currently active data set.Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985 167Rod Johnson, Maghi King, and Louis des Tombe EUROTRA6.4 DISAMBIGUATIONThe system potentially has a number of ways of dealingwith ambiguity.
Which ones are used depends on theextent o which disambiguation strategy is embedded intoan implemented theory.The simplest device is an extension of the use of goalsto allow the user to supply an ordered list of goaldescriptions.
The system simply continues to try tomatch goals, in order, until it finds one which succeeds.The output from that goal is the result of the process.This rather cumbersome device is actually quite useful,for example in constructing elementary preference strate-gies painlessly.
It is, however, not particularly subtle.More interesting are strategies that exploit the inher-ent parallelism of the system - defined, for examplethrough the (apply to all) functional of FP.
Normally,the results of a parallel process application are all addedto the current data set "in the same place".
We could,however implement a primitive that allows the user tostate criteria for selection between competing represen-tations, and to exclude less favoured ones on the basis oflinguistically motivated judgements.
This would only besensible, however, if the user were able to formulate suchjudgements in a general way.Finally, we also have the option of implementing arelation a l t  (for alternative) directly in the data defi-nitions (we have, in fact, done a simulation of a chartparser in this way).
The problem here is that an altrelation between odes is easy to handle, but an inducedalternative relation between sets of nodes is not, unlessthe process that constructs it is very well behaved (forexample, only building alternatives between simpleconstructs like trees).
We do not know of any practicalmethod of guaranteeing that such a relation can be main-tained in a system which can perform transformations ofarbitrary complexity.6.5 EFFICIENCYThe system we have described here is not particularlyefficient - indeed it can be dramatically inefficient whenpresented with only moderately large and complexcomputations to perform.
We are not (yet) undulyconcerned by this inefficiency, for two reasons.
First, weare still at the experimental stage where correctness istill more important than speed; there are no plans for anindustrial implementation before 1988.
Second, theexperimental device we have described here has twoequally important functions: the first is indeed to permitus to generate implementations of new theories rapidlyfor experimentation in the field; the second is to providethe basis for a formal specification of the semantics ofthat theory.
If we can construct prototypes using precisedefinition languages, with the benign side effect that thesame prototypes perform tolerably well for experimentalpurposes, we can be confident hat an optimized imple-mentation derived from the same specifications has agood chance of being both correct and operationally effi-cient.7 CRITERIA FOR SUCCESSIt is obvious from what has been said already thatEUROTRA is to be regarded as a research and develop-ment programme, rather than as either a pure researchproject or a pure development project.
This affects thecriteria that will be used in evaluating its success or fail-ure.
Main emphasis, even at the end of the five and ahalf year programme period, will be put on quality oftranslation, with speed and efficiency playing a relativelyminor role.
(Of course, certain minimum limits of speedmust be reached if only to allow the large amount oflinguistic development work necessary to be accom-plished).
Quality will be judged in terms of ability tocover the corpus texts and other texts in the same generalclass.
The testing procedure will probably bear a strongresemblance to that used for evaluating METAL (Slocumet al 1984).Apart from the quality of translation, one of the maincriteria in evaluating the  system design will be ease ofextensibility.
Exact procedures for evaluation will bedecided by the programme's management committeetowards the end of each phase, when a checkpoint mustbe passed before permission is given to pass to the nextphase.8 FUTURE DIRECTIONSEUROTRA's future falls into two distinct parts: the futurecovered by the programme period itself, up to mid-1988,and the future after that.
During the programme perioditself, two further languages (Spanish and Portuguese)will be added, increasing the number of language pairs to72.
(It goes without saying that not all 72 language pairswould be fully treated by mid-1988.)
Apart from thisextension, it is planned to increase the variety of text-types dealt with, although remaining within the generalarea of Community texts.
There will also be some exper-imentation with subject areas other than the one initiallychosen.
Throughout the programme period, the flexibili-ty and modularity of the system design will encourageexperimentation with different linguistic techniques, aswell as making it possible to expand and repair thesystem with ease, since the extremely modular approachtaken makes it possible for any single module, forinstance a primitive process treating noun groups orcarrying out dictionary look-up, to be modified independ-ently of other processes, even, in the limit, being replacedby a completely different process.
When a process ismodified, the goal attached to each process becomesimportant in that by specifying the results to be deliveredby the process, unforeseen interactions with other proc-esses in the system are prevented.During the third phase, planning of the future after theprogramme period will begin.
The feasibility and desir-168 Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985Rod Johnson, Maghi King, and Louis des Tombe EUROTILAability of an economic development of the workingprototype system will be investigated, and specificationsdrawn up if it is decided to go ahead.
At the' same time,by Community conventions for researcfi and develop-ment projects, both the prototype system and the kernelsoftware will be distributed at cost to Government insti-tutions, and to Universities and research institutes in theMember States.
Indeed, the software can be distributedto these parties before the end of the programme periodto be used as a research tool.
This is one of the ways inwhich EUROTRA hopes to stimulate research outside theimmediate nvironment of the project itself.It could, with some justice, be said that all ofEUROTRA lies in the future: given the time and resourcesinvested in defining a sound linguistic basis and a flexi-ble, heavily problem oriented software, it is our hope thatthe future can be faced with confidence.REFERENCESBackus, J.
1978 Can Programming be Liberated from the vonNeumann Style?
Communications of the .4 CM 21 (8).Boitet, C. and Nedobekjine, N. 1982 Russian-French Machine Trans-lation at Grenoble: A General Software Used for Implementing aParticular Linguistic Strategy.
Linguistics.Bruderer, H.E.
1978 Handbuch des maschinenunterstutzten Sprachuber-setzung.
Munchen, New York: 100.Colmerauer, A.
1971 Les Systemes-Q: un Formalisme pour Analyseret Synthetiser des Phrases sur Ordinateur.
Groupe TAUM,,Universit6 de Montr6al.Georgeff, M. 1982 Procedural Control in Production Systems.
Artifi-cial Intelligence 18: 175-201.Hayes, P.J.
1978 The Naive Physics Manifesto.
ISSCO Working paperNo.
34.Johnson, R.L.
; Krauwer, S.; Rosner, M.; and Varile, G.B.
1984 TheDesign of the Kernel Architecure of the EUROTRA System.Proceedings of COLING-84.Johnson, R. and Rosner, M. 1984 Machine Translation and SoftwareTools.
In: King, M., Ed.Kaplan, R.M.
and Bresnan, J.
1982 Lexical Functional Grammar: AFormal System for Grammatical Representation.
In Bresnan, J.,Ed., The Mental Representation f Grammatical Relations.
MIT Press,Cambridge, Massachusetts.Kay, M. 1967 Experiments with a Powerful Parser.
In Proceedings ofthe 2eme Conference International sur le Traitement Automatique desLangues Grenoble.King, M., Ed.
to appear Machine Translation: the State of the Art.Edinburgh University Press.Landsbergen, J.
1984 Isomorphic Grammars and their Use in theRosetta Translation System.
In: King, M., Ed.Maas, H.D.
1984 The MT System SUSY.
In: King, M., Ed.Slocum, J. et al 1984 METAL: The J Machine Translation System.In: King, M., Ed.TAUM, Le Systeme de Traduction Automatique de l'Universit6 deMontr6al (TAUM).
Meta 18: 227-289.Tsujii, Jun-ichi 1983 Technical Outlines of Japanese National MTProject.
Paper given at the Joint EUROTRA-Japanese Workshop,Brussels.Computational Linguistics, Volume 11, Numbers 2-3, April-September 1985 169
