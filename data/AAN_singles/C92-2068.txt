Quasi-Destructive Graph Unificationwith Structure-Sharing*Hideto TomabechiCarnegie Mellon University109 EDSH, Pittsburgh, PA 15213-3890t0mabech@cs.cmu.eduAbst ractGraph unifi(:ation remains the nlost expensive partof unificatiou-b~Lsed grammar  l)arsing.
We fl)cuson (Hie 81}ee(l-u 1) elelltellt ill the design of llllifiea-tion algorithms: avoidance of copying of umao(li-fled sul)graph.s.
We propose a method of attainingsnch a design through a nlethod of structnre-sharingwhich avoids log(d) overheads often associated withstructure-shari l lg of graphs without any use of costlydependency pointers.
The proposed scheme elimi-nates redundant copying whih~ maintain ing the qua.si-dc,qtructive scheme's abil ity to avoid over copyingand early copying eomlfined with its ability to handlecyclk: structures without algorithnfie additions.1 Mot ivat ionDespite recent efforts in improving graph unificationalgorithms, graph unification renlains the most ex-pensive part  of parsing, both in t ime and space.ATR 's  latest data  fi'om the SL -TRANS large-scalespeech-to-speech translation project (\[Morimoto, etal, 1990\]) show 80 to 90 percent of to t~ parsing t imeis still consumed by graph unification where 75 to 95percent of t ime is consumed by graph copying fune-ti(ms. 1 Qu~si-Destruetive (Q-D) Graph Unification(\[Tontabeehi, 1991\]) was deveh)ped as a fiLst variationof non-destructive graph unification based upon thenotion of t ime-sensit ive 'qu~mi-destruction' of nodestructures.
The Q-D algorithm was proposed I)~Lsedupon the following m:cepted obserwttion about graphunification:Uni f i ca t ion  does  not  a lways  succeed.Copy ing  is an expens ive  operat ion .The design of tit(', Q-D scheme was motiwttcd bythe following two princil)les h~r frost gral)h unificationba,sed upon the above observations:?
Copy ing  shou ld  be  per fo rmed on ly  for suc-cess fu l  un i f i cat ions .?
Un i f i ca t ion  fa i lures shou ld  be  found assoon  as poss ib le .
*This research wa.8 (lone while the author was ~ VisitingResearch Scientist at ATR Interpreting Telephony \[O~searchLaboratories.lBased on unpublished reports from Knowledge itnd DataProcessing Dept.
ATR.
The observed tendency was that sen-tellCCS with very long parsing tillle requiting a large Ii|lltll~t~r ofunification calls (over 200l} top-level calls) coll811lllcd extremelyhtrge proportion (over 93 percent) of total paraing time ft~rgraph unification.
Similar data tep0rted in \[Kogure.
19901.and el iminated Over  Copying and Early Copying (asdefined in \[Tomabechi, 1991\] 2) and ralt about twicethe speed of \[Wroblewski.
1987\]'s algorithm, a In thispal)er we proi)ose another design principle f(n' graphunification bmsed upon yet another accepted observa-tion that:Unmodi f ied  subgraphs  can  be  shared .At lemst two schelnes have been proposed recently\])a.~ed Ul)OU this observation (namely \[Kogure.
1990\]and \[Emele, 1991\]); however, both schemes are I)asedupon the increlllent'al Col)yiug sehellle all( l  ~-LS (\[e-scribed in \[Tomal)eehi, 1991\] incremental copyingschemes inherently suffcr fi'om Early Copying as de-fined in that article.
This  is I)eeause, when a unifica-tion falls, the copies that were (:reated up to the pointof failure are w~Lste(l if copies are created incremen-t;ally, By way of definition we would like to catego-rize the sharing of struetul'eS in gral)hs into Feature-Structure Sharing (FS-Sharing) ~nd Data-StructureSharing (DS-Sharing).
Below arc our definitions:?
Feature -St ruc ture  Shar ing :  Two or more dis-tinct i)~,ths within a graph share the same sub-graph by (:onwwging (111 the same node equiv-alent to the notion of structure sharing or reen-lrancy in linguistic theories (such ~ in \[Pollardand Sag, 1987\]).?
Data-St ruc ture  Shar ing :  Two or more dis-tinct graphs share the same subgral)h by con-verging nil the same node the noti(m nf2 Namely.?
Over Copying: Two dags ate created in order to createone new dag, This typically happens when Col)its of twoinput d~tgs are created prior to a destructive unific~Ltionoperation to build one new dag.?
Early Copying: Copies ar~ created prior to the failureof unification so that copies (:reltted since the beginningof the unitication up to the point of failure are wasted.Wroblewski defined Early Col)ying as follows: "The argutnentdags are copied be/t~te unification started.
If the unilicationfails then some of the Ct)l)ying is wasted effort" attd restrictsearly copying to cases that only apply to copies that are createdprior to a unification.
Our definition ()f Early Copying includescopies that ~rc created during a unification and created upt() the point of fltilur(~ width were iltt(!ow~red by Wroblewski'sdefinition.3 Recent (~xp(~rilnents COlllhlctt~d ill the Knowledge all(\] DataPro(:esniug Dept.
of ATR shows the original Q-D algorithmCOllsiatelltly rllllS lit ~tt~out 40 \])q~rctrl|t ~ff the elal)sed tillleuf Wroblewski'8 algorithm with its SL-TRANS large-scaleupoken-languag,~ ttansl~ttlon system (with over l(t00{I gram-matical gral)h nodes).ACRES DE COLING-92, NANTES, 23-28 AOt~T 1992 4 4 0 PROC, OF COLING-92, NANTES, AUG. 23-28, 1992straeture-sharing at tim data structure level.\[Kogurc, 1990\] cldls Coltying of sui:h strltcturesRedundant Copyin 9.Virtually all gral~ll-lutitication alg(n'itlinl,,; suptmrtFS-Sh~triug and some SUliport DS-Sharing with vary-ing levels (if overhead.
In this lisper we proltOSl~~t sclienle of graph unification I)tmed UllOn a qu;~si-destrtt(:tive gratth uniti(:ati(m inetlloll that attainsDS-Sharing with virtually no overh(',ad for structure-sharing.
Henceforth, in tills palter, structltre-sharingrefers tit DS-sllariug unless otllerwise n(ited.
Wcwill see that tfic iutroducti(m of strlu:ture-sliarilag toqua~si-destructive mification art;tins another two-foldincrease ill rim tiluc spired.
The graphs llamdled inthe scheme (:;tit lie auy dirc(:ted grai)ll and cycli(:ity isllaudled without any algorithmic ;tdditions.Our design princiitles for achieving structlu'C-sharing in tit(', qlta.si-destructive scllellU~ are:?
A tomic  and  Bot tom nodes  can  be  shared  4Atomic nodes can lie sltarcd sahdy since theyt lever  cli~l, l l ge  the i r  wdues .
B ( I t to l l l  l l od l !s  Cal l  It(!share(l 5s i t tce  bottom nodes are always fl)rwal'dedto somc other uo(Jes wllcn they unify.?
Complex  nodes  can  be  shared  un less  theyare  mod i f ied -  conq)lex nodes (:all bc COllSld-ercd modified if they ~tre a target of the fitrward-ing operation m' if riley received the curreut ad-ditiml of comltlcment arcs (into COml)-ari:-list in(pia,si-destructive sclmme).By designing an algorithm ba.sed Ult,m these pril>(:il)les for strlu:ture-sliarillg while retaining the quasi-destructive nature of \[Totnat)echi, 1991\]'s algoritllnl,our scllmnc eliniinates l{,cdlnt(tant Cllpying whih~elinlinating botll Early Copying auld Over Copying.2 Q-D Graph Unif icat ionWe Woldd first like to describe tlle qu;Lsi-destructiwe(Q-D) graph unilication schenle which is the lnLsis ofour s(:henl(,'.
As a data structltrl~, at nolle is rcpresentcd with live fiehls: type, arc-llst, comp ark-list.fm'w~u'd, (:oily, and geueration.
6 The data-structurefor an at'(: has two liclds, qabel' and 'value'.
"Lot)el"is an atmnic symt)ol wllicli labels tile ;u'e.
and 'wdue"is a llointer to a l lo ( le  structure.The central notion of tile Q-D algm'itlun is tiledel)eudency of the retiresentational (:ontcnt on theglob~d timing clol:k (or thc global counter for tliccurrcnt generation of lUlific;~tions).
Any luodilic;~tiol~made to coml)-arc-list, forward, or i:Olly rid(Is duringone top-lcw:l uniticati(m (:au bc inwdidated by (me in-(:renlent otmration inl tile global t imiug counter.
COIltents of the (xmlp-arc-list, forward and (:opy fields arc' IAtomic lto(\[l~8 ;ire IlodeH (halt reprea(~llt atoluic vcdue8, l i e (lo in nodes are llo{|e8 that  repreuellt var iabh* .~As long as the unific~ttion Ol)er,~tion is the only operationto nmdify graphs.6 Note that \[Tonlabechi, 1991\] used sellarttte lltark fields finCOml)-;trc-liat, forward, fill(| copy: (:urrently however, (}lily f}llttgeneral(kin mark is used for adl three fiehls.
Thanks are dueto Hidehiko M~U,uo of T,)yo Informattion Sy,tcms (TIS) forsuggesting thin.NODEtype+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+are - l i s t+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+comp-nrc - l in t+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+~orward  IRC+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+ + .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+copy I l abe l  I+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+ + .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
+generat ion  I va lue  I. .
.
.
.
.
.
.
.
.
.
.
.
.
.
+ .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
?Figure 1: Node  and  Arc  S t ructuresresl)cctc(l ,rely wlten tile ge.neration mark of the lml'-ticlll~u' node nuttches tile current glob;d comat.er wdue.Q-I) graph unificatiola ham two kinds of arc lists: 1)ar,:-list and 2) colnt~;u'c-list.
Arc-list (:Ollt~tins thearcs that are p(!rln;tu(!nl (i.e.. ordimLry gral)li arcs)and Cillnp-arc list contains arcs that are rally wdidduring one top-hwel graph unitication oper;d, ion.
Timalgorittun also uses two kintls of fi)rwardlng links, i.e,,l ) (!rtt la lal!nt ;IAl(l t;(!llll)Ol'&l'y, i l l(!rl l l~l, l lel lt fo rwar ( f i l l glink is the usual fm'warding link ftnmd in ottler' ;d-goritfilns (\[Pereir~t, 19851, \[Wroblewski.
1987\], ctc).Telnl)orary forwarding links arc links tlud.
arc onlywdid during onc top-level unilic~tti(m, Tlic currencyIIf the temporary links is (letermiued by matchingthe emlteut of tim generati(nl field for the links witllthe gl(ibal (:ounter; if they nutt(:ll, the content of thistiehl is respect\[~d 7.
As in \[Pereira, 1985\].
tile Q D~dgorithln lla.S tltree types of uodes: 1) :atonfic.
2):lie(torn 8, and 3) :conqth!x.
:atOllli(: tyllc nodes rep-res(mt at(nni( synll)ol values (such ;~s 'Noun') ,  :bettom type n(Jdes are variables and :(:()lttl)lcx tylac nodes~l.re Ilo(les that have art:s i:ol\[litlg (lilt of thenl.
Arcsare stored in the m'cqist tiehl.
Tile atomic vahl(!
isalso storc.d in the m'c-list if the node tyttc is :at,imil:.
:l lottom nodes succeed in unifyiug with nny uodesand the result of lint(it:alien t~kes tim type ~md thevalue of the node tlutt the :bottona nI)de w;m unifiedwith.
:atonli(: nodes succeed in unifying with :btIttonanodes or :at(lllliC llO(li~s with the mune vallle (Stiltedin the arc-list).
UnificatioD of an :atomic uode witha :co \ ] t l l ) lex  l lOde  i l l l l l te ( \ [ ia tc ly  f i l J ls.
: co t t l l ) l ex  taodessite(reed in unifying with :bottolit nodes or witll :(:OUl-l)lex trades whose subgrlqdls all unity.
?
Figure 2 is thecentral qllmsi-,lestructlw~ graph unifi(:ation algorithmand Figur('.
3 is the dcrcfel'encing 1?
flulction.
Fig-lit'(?
4 shows  the  a lgor i t l i l l ;  fo r  (:ollying tti lf l(!s all(1 ~Lrcs(called from lmify0) wllih~ respecting the (:Ollt(mts of~a~4 "~x~is t~7~1~ do II(It \]l~tVe ~t separate field for temporary  forwtLrdinglinks; instead, we desigllat(t tile integer wdue 9 to repreuent apermanent f,~rwatding llnk.
We Ht~trt incrementing the globalCOUltter f\[Olll 10 ,() whel lever the gener;tti(ut lu~trk i8 lIO| 9, theinteger  vahle 11111~4t e(ltla\] the globad COllltter v;tllle to reulmCtthe forwaxding link.8 lqottom i8 called leaf in Pereira'u algorithm.9Arc wtlues are ,'always It(Idea Lnd never synlbolie V~dlle8 be-cause :atomic *uLd :bottom nodes lilly lie (or \]l(}cO\]ll(}) poilltedto by luultiph: arl:x (i.e, FS-Sh~ring) depemlil~g on gt0annlarCOllHtr.
'killtg, and we do not want  arcu to (:oltt~tln terlnin~d atomicV~lleO.l?Derefi~rel|Cillg i8 till opera((loll to recl lrsively traw~rae f .
r -w;trding links to return the target mille of forwarding.AcrEs  DE COL ING-92 ,  NANTgS, 23 -28  AO~" 1992 4 4 1 I'ROC.
OF COL ING-92 .
NAmES,  AUG.  23-28 ,  1992QUASI-DI~qTnuCTIVE ~RAPI\[ UNIFICATION \]FUNCTION unify-dg(dgl,dg2};result ~ catch with tag 'unify-failcalling unify0(dgl,dg2):increment *unify-global-counter*: ;; starts front 1(} 11ret urn (result);END;FUNCTION unify0(dgl,dg2);if '*T* = unifyl(dgl,dg2); THENcopy ~ copy-dg-with-coml)-arcs(dgl);return(copy);END;FUNCTION unify1 (dgl-underef,dg2-undercf):dgl ~ derefercnce-dgldgl-underef);dg2 ~ dereference-dgl 2-undercf }:IF (dgl.copy is son-empty)THENdgl.copy ~ nil; :; cutoff ullt:ltrrent copyIF (dg2.copy is non-empty) THENdg2.copy ~ nil;IF (dgl = dg2)I~THENreturn('*T*);ELSE IF (dgl.type = :bottom) THENforward-dg( dgl,dg2 j t  empor asy);return('*T*);ELSE IF (dg2.type = :bottom) THENforward-dg( dg2,dgl,:tem porary );rcturn('*T*);ELSE IF (dgl.type = :atomic ANDdg2.type = :atomic) THENIF (dgl.arc-list = dg2.arc-list)13THENforward-dg( dg2,dgl,:tempor ary}:return('*T*);ELSE throwt4with keyword 'unify-fail;ELSE IF (dgl.type = :atomic OHdg2.type = :atomic) THENthrow with keyword 'unify-fail;ELSE shared ~ intersectaxcs(dgl,dg2);forward-dg( dg2,dgl,:t empor ary ); 15FOR EACH arc IN shared DOunifyl(destination fthe shared arc for dgl,destination ofthe shared arc for dE2);new ~ complementarca(dg2,dgl); 16IFlT(dgl.comp-arc-list is non-empty) THENIF (dgl.generation = *unify-gloh;d-counter*) THENFOR EACH arc IN new DOpush as\['.
to dgl,comp-arc-list,,ELSE dgl.colnp-arc-list ~ nil:ELSE dgl.genera.tion ~ *unify-glohal-couttter*:dgl.comp-arc-list ~- new;return ('*T*);END:FigLure 2: The  Q-D Un i f i ca t ion  Funct ionsTit(' functions Contl)lenlelttarcs((lgl,dg2) and In-119 indicates a l)ermanent forwarding link.12 EquM in the 'eq' 8ellse.
Bec~tuae of forwarding altd cycles,it is possible that dgl and dg2 are "eq'.13 Arc-list contains atomic value if the node is of type :atomi(.14Catch/throw coastxuct; i.e., immediately return to unify-dE.lSThis was performed ~dter FOR EACH letup in \[Tonrahechi,19911 which couht haw~ c~.uacd it prtddem writ a sttccessfulcyclic call.
Thanks are due to Marie Boyle of University ofTuebingen fur suggesting the change.16Colnplementarcs(dg2jlgl) was called before unifyl recur-siena in \[Tomabechi, 1991\], Currently it is moved to after allunifyl recuraions successfully return.
Thanks are ;dso due toMarie Boyle for suggestiug this.17This check was added after \[Tomabechi, 1991\] to avoidover-writiltg the conlp-arc-list wll(~ll it is wrltt(,it more thanonce within one Ulfify0 call.
Thanks are duc to Peter Neuhausof Oniversitiid Karlsruhe for reporting this l)roblem.C;RAPll NODF" DF',F'F'FERF'NF'ING \]FUNCTION dereference-dg(dg):f(>rward-dest ~ dg.forward;IF (forward-dent is non-empty) THENIF (dg.generation : *unify-global-counter* ORrig.generation = 9) THENdereferetu:e-dg( for ward-dent );ELSE dE.forward ~ nil: :; make it GCableretura(dg)',ELSE return(rig);END;Figure 3: The  Q-D Dere ference  Funct iont('rsc('tarcs(dgl,dg2) return the sct-diff(,renF`(" (thearcs with labels that exist in dg l  but not in dg2)and intersection (the arcs with labels that exist bothin dg l  and dg2).
During th(" sct-difl'erence and sct-iutersection otlera.tiultS, the (,ulttent of colnp-arc-listsart" respected ms parts of arc lists if the genera.tionmark matchs the current va.lu(, of the globa.l tintingcounter.
Forward(rig1, dE2, :forward-type) puts (tg2in tile forwa.rd field of dgl .
If the keyword in thefun('tion call is :temporary.
the eurrev.t valu(, of the*unify-glob;d-counter* is writtea in the generationfiehl of dgl .
If the kcyword is :perman(,nt, 9 is writ-ten in the generation fiehl of (lgl.
18 The temporaryforwarding links are necessary to handle rcentrancyand cycles.
As soon as unification (at any level ofr(,cursion through sha.rcd art,s) is performed, a. tem-l)orary forwarding link is made from dg2 to dgl  (dE1to dE2 if dgl  is of type :bottom).
Thus, during unifi-cation, a. node already unified by othcr recursive callsto unify1 within the same unify0 c',dl has a temporaryforwarding link from dg2 to dE1 (ur dg l  to dE2).
As aresult, if this node becomes an int)ut argument node,derefcrencing the node causes dg l  a.ud dg2 to llecontetile Salll(, llo(lc attd unification immediately succeeds.Thus, a subgraph below an Mrea(ly unified nude willnot be checked inore than once even if an a.rgumentgraph has a. cycle.
19\[ QUASI- DF` STI1UCTIVF, COPYING \]FUNCTION copy-dg-wit h-conq*-arcs(dg-underef):dg ~ dereferencc~dg(dg-underef};IF (dg.copy is iron-empty ANDdg.copy.generation 2n ~ *unify-gloh',d-countcr*) THENret urn(dg.copy); 21ELSE IF (dg.type = :atomic) THENncwcopy ~ create-node(); 2~newcopy.type ~ :atolltic;newcopy.arc-list ~ dg,arc-list:Itewcopy.gel|eratiolt ~ *tinily-global-counter*;dg.copy ~ newcopy;ret urn(newcopy);ELSE IF {dg,type = :bottom) THENltewcopy ~ creatc-nodel );newcopy, type 4~ :hottoltl;I~ewcopy.gem!rlttioll ~ *unify-global-counter*;dg.copy ~ newcopy;ret urtt( newcopy )iELSE18permanent forwardings may be needled by gr~tlltlltar COlll-pliers that merge graphs.l?Also, during copying suhaequent to a mlccessful unitica-tioll, two 0d?
:8 COllvergillg into the 8&lltl~ llode will Ilot c~*,lSeovcrcopying simply because if a node already has a copy thenthe copy is returned.AcrF, s DE COLING-92, NANTES, 23-28 AOt3T 1992 4 4 2 PRec.
OF COLING-92, NANTES, AUO.
23-28, 1992lieW(;Opy ~ (:reilt.
:-node();lleWCOpy.type ~ :COlllp|i~x;newcopy.g(~neratioll ~ *ltnify-glolnd-countel*:dg.col)y ~- lieWco|)y: 23FOR ALL arc IN dg,arc-llst DOn(~warc ~ ctlpy-arc-alid-ct)lnp-llrc(arc)lpllsh ll()w,%rc into newct)py.ttrc-li,t;I F  (dg.coiup-arc-li,t is non-mnpty ANDdg.generation - *unify-glohal-counter*) THENFOR ALL c(nnp-ar(: IN  dg.conll~-itrc-li~t DOli(~wlirc ~-- Col)y-arc-and-colllli-ltrc(colllp-arc};plish liewltrc into n?~wcopy.arc-liut;dg,cotnp-arc-list ~ nihreturn (newcopy):END;FUNCTION Colly-arc-aud- conq)-arc(inpu t - arc };label ~- input-,xrc.labchV~dllO t'~ copy-dg-witil-coulp-arl:s(input-arc.valul~);return a liCW ~trc with hd,el itltd vahle;END;Figure 4: Node and  Arc  Copy ing  Funct ions3 Q-D Copying + DS-SharingIn order  to a t ta in  s t rnc ture -shar ing  dur ing  QmLsi-Dest ruct ive  gral)h un i t i ca t ion ,  no n iod i f ieat ion is nec-essary for the un i f icat ion funct ions  descr i t )ed in theprev ious  sect ion.
Th is  sect ion descr ibes  the qua.st-des t ruct ive  copy ing wi th  s t rueturc -shar ing  wh ich  re-p laces the  or ig ina l  copy ing  a lgor i thm.
S ince uni-f icat ion funct ions  are unnt0d i t ied ,  the Q-D uni t ies-l ion w i thout  s t ru ( : tu re -shar ing  eau be mixed  t r iv ia l l yw i th  the Q-D uni f icat i tm wi th  s t rueturc -shar lng  ifsuch a mix ture  is des i red (by s imply  choos ing differ-eat  copy ing f imet ions) .
Inf i )r lnal ly,  the  Q-D copy ingw i th  s t ruc ture -shar ing  is l )er formed in the fo l lowingway.
Atonf ie  and \ ] )ot tom l lodes are shared,  A COlll-p lex node is shared  if  l lo nodes be low that  node arechanged (a node is cons idered ehange(I  by be ing  ata rget  of fo rward ing  or  hav ing  a val id COlnp-arc- l ist) .I f  a uode is ehaaged then that  in fo rmat ion  is 1)~sedUl) the graph  path  us ing mult i l ) le-valut~ b ind ing  facil-i ty when a copy of the nodes are recurs ive ly  re turned .Two wdues  are re turned ,  the first va lue  being the  Col)y(or or ig ina l )  nol le  and the  second va lue being the f lagrepresent ing  whethe, r any of the  node below that  node( inc lud ing  t, hat  node)  h;us been ehanged.
A tomic  audbot ton l  nodes are  a lways sharet l :  however ,  they  arecons idered  changed if  they  were a ta rget  of forward-ing st) that  the ' changed '  in fo rn la t ion  is passed up.
I fthe eomI) lex node is a ta rget  of fo rward ing ,  i f  no nodebehiw that  node is changed then the ()rigin;d eon lp lexnode is shared;  however ,  the  ' ( :hanged'  inforniat i t )n20I.e.. the *gtill(Sratioli" fiehl of the iiodt, stored in tile q:olly'field of the "dg' llode.
The Mgoritlnn (lescrihed in \[Tomabechi,1991\] imt,d ~COlly-ln~rk' fiehl of'dg'.
Currently 'generlttion' fieldreplaces tile three lnltrk fiehl described ill the article.21 I.e.. the cxisthig copy of the ilodc.22 Creltto8 fin empty node 8tlliCiUr(L~a'l'lli~ ofl~ratil)li to set it newly i:tl!iited copy node into tim'copy' field of Mg' w~ dolill Mter reclirSiOll into tubgtaph~ intile Mgorithnl description in \[Toinabechl.
19911 which wa~ itcause of iufinite D2CllrSiOll with it parl icuhtr type of cycle~ lit thegraph.
By l l loving ill> to ti l ls p(mltion f lol l l  after the recilrtdon,811ch a pr(~l)hmi Call be effectively avoided.
Thil l lk8 itr(2 due toPeter Neuhaus for reporting tile pro|lima.is l>~Lsse(l ut> when the recurs ion re tunts .
Be low isthe a<:tual a lgor i t lnn  descr ip t ion  for the  Q-D copy ingw i th  s t ruc ture -shar ing .\[ Q-I) C .
.
.
.
.
.
.
.
.
.
.
.
.
s .
.
.
.
.
.
.
........ S .
.
.
.
.
.
.
IFUNCTION copy-dg-wit h-conq~-arce-share( dg-u nderef I:dg ~ dereference-dg(dg-underef);IF  (dg,col)y i8 ito,-enlpty ANDdg.ctqiy.generation = *unify-global-counter*) THENIF  (dg = rig.copy) THEN ~anewcopy ~- create-itode( ):newcopy.typc ~- :bottom;tmwcopy.gtmt~r ation ~ *unify-gh)b~d-ctm nt er *;dg.copy ~-- newt:spy;wdues(dg.copy.
:changed): 25ELSE vMue~(dg,col)y,:changed);ELSE I F  (dg ~ dg-underef) THENcopy- imde-comp-not - for war ded(dg);ELSE copy-node-cmnp-fi)rwardedidg);END;FUNCTION copy~node-comp-not-fi)rwarded(dg):IF  (dg,type : :atolnic) THEN values(dg,uil);;: rt~turn original dg with "liO ch;lllg(~' flag.ELSE I F  (dg.type = :bottolll} THEN wdueu(dg.nil):ELSEI F  (dg.cmnp-arc-liat is no.-empty ANDrig,generation = *unify-globaLcounter*) THENlmWCopy ~ creatt:-node();newcopy.tylm ~ :eonwlex;n(~wcopy.genet&tiolt ~ *ullify-globAl-collnter*:dg.copy ~ newct)py:FOR ALL arc IN dg.arc-list DOnewarcfirst Wdilt~ of copy-arc-and-contp-arc-Mlltre(arc);i)llsh liewitrc into lmwcopy,arc-\]ist;FOR ALL conq)-arc IN  rig,cutup-arc-list DOilawltrc?~ firl4 t vahlc ofcopy-~trc-alld-ct )ill p-arc-share( corn \[)-arc ):\])uflh ileWltr(: iltto ilew(:opy.arc-|iat;dg.conlp-arc-list ~ nihwdtieu{ llew(:t~py,:chltlt ged ):ELSEstate ~ IdL arcs ~ ldhdg.copy ~ rig 26 , dg.gtmerittiolt ~ *uliify-giol~al-i;o.nt(!r*;FOR ALL art: IN  rig.arc-list DOitewar?,challge~tl ~ (:opy-arC-~lld-t:Olllp-ar(-sh;tr~(arc};pus|t newart: illt~ arcs:IF  (changed has wdue) THENstate , -  I:hllligl~d;I F  (state has vldue) THENIF  (rig.copy # dg) THENdg.copy.arc-liat , Arcs:dg.copy.type ~ :complex;vldues{ tlg.ct~py,:changed );ELSEliewcopy ~ create-node();newcopy.type ~- :comtdex;llewcopy.getleratioll ~ *tniify-gl()lnd-ctnlntl~r*;newcopy.arc-liat ~ ~trc~;dg.copy ~-- m~wl:opy;vidues( liewct)py.
:t:hallged ) ;ELSE dg.copy ~ nil; ;;reset copy fieklvalues{dg,uil):END;FUNCTION copy-node-conq)-forwarded{ dg);IF  (dg.type : :g, tomic) THEN values(dg.
:changed);;; return origiaM dg with 'changed' flag.ELSE I F  (rig.type ~- :lmttom) THEN values(dg,:changed);ELSEIF  (dg,comp-arc-li~t is uon-enipty ANDdg,generMion : *unify-globM-counter*) THENnewcopy , -  create-node():newcopy.tylm *- :coilifdex;ACRES DE COLING-92, NAMES, 23-28 AO~I 1992 4 4 3 PROC.
OF COLING-92, NANTES, AUG. 23-28, 1992newcopy.gencratio~l ~ *utdfy-global-counter*; slle(:essful t lliticatiOllS to the total ltUlllbcr of Itllifica-dg.copy ~ newcopy: tions.
Wc parsed cach selltcncc three times on a Sym-FOR ALL arc IN  dg.arc-list DO I)oli(:s 3620 using three tin}float}on tethods, namely,Ilew&rc(- first value of capy-arc-and-coml)-arc-sharc(arc); Wroblewski's algorithln, a qua,si-dcstrttctive lllethodpllslt new&re }taro newcopy.arcdist:FOR ALL c<>ml)-arc IN dg.comp-arc-list DOilewar(:first value ofcopy-arc-and-(:Olllp-ar(:-sh are( colll \])-arc/;pudt newarc into l|eWcg)y.arc-list;dg.comp-arc-list ~ nil:vMm~s(newcopy,:dlanged );ELSEstale + nil, arcs ~ tail;without structure-sharing, and a qu,%i-destructivemethod with structure-shariug.
Wc took tile short-est elapsed time for ea(:h metho<l ( 'W' representsWroblewski's algorithnl with a modification to han-dle cycles and wtrialllcs 29, 'QD' represents the <luimi-destructive nletlmd without structure-sharing, slid'QS' represents the prol)osed lnethod with structure-sharing).
Data stru(:tures arc the same for all threedg.col)y ~ (Ig, dg.gcneration + *Ulfify-glol>al-counter*; unification methods ex(:el)t for additional fields forFOR ALL  art: IN  dg.arc-list DOimwarc,changed +: COl)y-arc-an( -comp-arc:s lare(arc); )l II -ar -list ill tile Q-D lnethod8.
8anle fltllctil)ltSpush newarc into arcs; are llsed to interface with Eal'ley~s parser and tileIF (dmnged has value) THENstat~ ~ cbal|ged;IF (state }tits value) THENIF (rig.copy =fi dg) T I tENrig.copy.arc-list ~ arcs:dg.copy.type ~ :comt)lex;value,(dg.col~y.
:changed);ELSEnewcopy ~ create-node();newcopy.type ~-- :complex;SalIIC sul)fllllCtiOllS are used wherever possible (snch;as creation sl id access of arcs) l, ll lnilthllize th(!
dif-fcrem:eu that are not purely algorlthltfi<:.
'Nmnber ofCopies' represents the numl)er of nodes created dur-illg each parse.
'Nlll l lber of Arcs' rcprcsents the nlllll-ber of arcs created durillg each parse.We used Earley's parsing 'algorithnl for the exper-intent.
The Japanese gralmnm' is based on t lPSGnewcopy.gencration ~ *unify-gbJb~d-(:ounter*;newcopy.arc-list ~ a~cs;dg.copy ~ neweopy;v~dueA( newcopy.
:cllangcd);ELSE dg,copy ~ nil;vahte~(dg,clmnged); ;; considered changedEND;FUNCTION copy-arc-and-comp-arc-dkare(input -arc );destination,cb~tngedCol)y-rig-wit h-coml)-~rcs-dtare(in put -,xr(:.value );IF (changed has value I TItENlal)d + inpubarc.label;value ~ destination;values(a new arc witb lalml and value,:cluulged);ELSE rabies(input-arc jail): ;; return original arcEND;F igure 5: Structure-Sharing Copy ing  Funct ions4 ExperimentsTable 1 shows the resltlts of our experiments us-ing all HPSG-11,~sed sample Japanese granmtar dc-vdoped at ATR br  a conference registration tele-phone dialogue domain.
'Unifs' represents the to-tal ltulnl/er of top-level unifications during a parse(i.c, the munl)er of calls to the top-loyal "unify-dg',and not 'tinily1') 28.
'USratc'  represents the ratio of24 Currently, all lIOdetl arc Col)ted ill a cych~ il~ order to preventthe split of the copy ~uld the original when node above alluladl~.ngcd original i8 modified.
Tbanks are due to Makoto'I'ak~d,a~i of TIS for suggesting the fix.
Of c,urue, a bettermethod, if possihle, would be 1o copy tim whole cycle onlywheat at least one node in the cycle i~ modified,25'Values' retltrn nlllltil)le values ~rOlll ~t fllnCtioII.
In ouralgoritlmt, two values are retunlcd.
The first value is the resultof copying, and the second value is ~t flag iMicatiag if tlmre wa~any modificatiolt to the node or to ally of its desc(!n(lallt8.26Temporarily set copy of the dg 1o be itself,27Multil)te-value-hind call.
The first value is homld to'newarc'.
arid the second vahte is bt)und to 'dumged'.28Unifyl in called several times the number (>f uttify-dg inthe gtalnl|l&r ilSC(I ill the eXl)erilllCltt.
For exanlpb!
nnifyl wi~analysis (\[Ponard and Sag, 1987\]) eovering llhe-nomena such as coordination, case adjmlction, ad-junets, control, shLsh categories, zero-pronouns, interrogativcs, WH constructs, and sonic pragmatics(speaker, hearer relations, politeness, etc.)
(\[Yoshi-moto and Kogm'e, 1989\]}.
The grammar covers manyof the imllortant linguistic phenomena in conversa-tional Japaucse.
The grammar graphs which are con-vertcd front the l)atll equations contaiu 2324 no(tcs, a?Wc used 16 Sclttenecs from a sanlplc telet/hone con-vcrs~tion dialog whi(:h range from very short sen-tenets (one word, i.e., tie 'no') to rdat ivdy  hntg ones(such as soredehakochirakarasochiranitourokuyoush, i-woookuriitashimasu 'In that case, wc \[speaker\] willsend you \[hearer\] the registration form.').
Thus, tltcnumber of (toll-level) unifications per senteltce wu'icdwiddy (from 6 to over 500).5 Discussion:Pereira (\[Percira, 1985\]) attail ls structure-sharing I)yhaving the rcsult graph share information with theorigiw, d gr~tphs by storing charges to tile 'envirolt-merit'.
There will be tlle log(d) overhead (where dis the nuM)er of nodes ill a graph) associated withPercira's ntetho<l that is rcqttircd during node accessto ,~ssenfl>le the whole graph from the 'skeleton' andthe updates ill thc 'environment'.
Ill the proposedsdtcmc, since tim arcs dircetly lloint to the originalgraph structures there will be no overhead till" nodeaccesses.
Also, during unificatioli, siltce citaltges art!called 3299 times for sentence 9when Itnify-dg was called 480tillies.29 Kogure (\[Kogur< 1989\]) des(:ribe~ It trivial time modifica-tion to WrohlewRki's algorithm lo handle cycles which is usedill oltr experillleltts,3tlDisjunctive quation~ are l)reproceH~ed hy the grammarreader module to expand into cross-multiples, whereas il~ATR% SL-TraNs syRtem.
Kasl)er's method (\[Kauper.
1987\])to handle disjunctive f ature-strltctures ia adopted.ACRES DE COLING-92, NANTES, 2348 AOt~T 1992 4 4 4 PROe.
OF COLING-92, NANTES, AUG. 23-28, 1992sent# Unifs USrate1 6 0 .502 101 0 .343 18 0 .224 71 0 .555 305 0 ,376 59 0.277 6 0,508 81 0.519 480 0 .3710 555 0.41i i  109  0.4512 428 0 .3313 559 0.3914 52 0.3815 77 0 .5516 77 0.55to ta l  2984(Z for total)Elapsod timo(nec) Num of CopiesW QD QS w QD q3o ,2o  o .15  0 .13  107 79 182,53  1 .16  1 .10  2285 1317 4070 .40  0 .20  0 ,20  220 111 262 .20  1.24 0.91 2151 1564 51413.78  6 ,51  3 .65  9092 5224 12203,20  0 .64  0 .50  997 549 970.21  0 .13  0 .11  107 79 183 .17  1 .59  1 .21  2406 1699 40124 .62  8 .11  5 .74  15756 8986 169640 .15  16 .39  8 .80  18822 11234 27374.60  1 .71 1 .41 2913 1938 55519.57  8 .24  4 .45  13363 7491 158637 .76  11 .74  6 .23  17741 9417 24833 .61  0.90 0.50  947 693 1072 .50  1.57  0.93  2137 1513 4282 .53  1 .57  0 .90  2137 1513 428161.23  61.85  36 .77  91181 53407 12721ioo~ 38.4~ 22 .8~ 100~ 58 ,6~ 14~~Sd)le 1: Compar i son  of three methodsstored directly in the nodes (in the tluasi-destructivcmaturer) thcrc will be no ovcrhead for rctlccting thechanges to gral)hs during unitic;ttion.
We share thel)rittciph~ of storing changes in a rcsU)rablc way with\[Karttuncn, 1986\]'s rcvtwsilfle unification and copygraphs only after a socccsshtl unification.
However,Kal'ttllllCll~S nlcthod (lots llOt list!
strllctllrc-sharilig.Also, }11 Kal'ttullcn's llltttll()t\[ 31, whenever it destruc-tive chaage is about to bc made, tile attribute vahlepairs a2 stored in the body of the tlodc arc saved illtoall array.
The dag node structure itself is idso savedin another arrlty.
These wtlucs arc restored after thetop lcvcI unification is c(mq)leted.
{A t:opy is madcprior to the rcstoratiou Ol)cration if the unificationwlus +t successful one.)
'\['has, ill Karttuncn's lncthod,clmh node ixI the entire argulllcnt gral)h that hius beendestructively modified must t)c restored SCl>aratclyby l'eXricviltg the attributc-values savcd ill an arrayand rcsctting th,!
values into the (lag structure skele-tons sltvcd in another array.
Ill the Q-D method.Olt(!
illCl'ell/ellt to the global COlllltcr c.q.ll iav+didatcall tht'.
changes made to tilt!
no<tern \[Karttunen slidKay, 1985\] suggests the use of lazy evaluation to de-lay dcstructive chalLges during unificatiou.
\[Goddcn,1990} presents one method to delay copying until a de-structive change is al)out to take phtcc.
Godden usesdelayed closures to directly imphm|cnt lazy evalua-titm during unification.
While it may be concel)tuallystraightforward to takc iulvantagc of delayc(I cVahla-tion functionalities ill progranuning laagtlages, actllalefficiency gain fl'on!
such a schelnc may not bc signif-icant.
This is l)et:aase such a schenle siml)ly shiftst4e time and space  consmned for Col)ying to creatingand evaluating closures (which couhl be very costlycompared to 'dcfstruct" operations to create COl)ics31The discussion of Karltunen's lnethod is ba.e,l on the DPATR imphnuent;ttion on Xerox 1109 machines (\[Karttunmt,1986\]).32I+e., arc stru(:turen: 'label" and 'vld\[l(~' \])ilii'~ ill oUrw~cabulary.Num of  ArcsW qD OS113 123 362441 1917 760182 183 622408 2191 8799373 7142 2272874 797 204113 123 362572 2334 71017358 12427 339420323 15375 51163089 2712 99214321 10218 305919014 13055 4471893 983 1992436 2185 7932436 2185 79397946 73950 23776100~ 76% 24~which arc often effectively ()l)timized lit many tom...... ?cial ....... lfilcrs).
\[Kog,|l'C, 1990\] anti \[Eulelc.
19611also use the lazy evaluation i(h',a to delay destruc-tive changes.
Both Kogurc all(l Eme, h~ avoid directusage of delayed evMuation by using pointer Oln:ra-tions.
As b3mchr suggests, KogurCs method also re-quires a special dcl)endcncy inf(,rmation to bc mifin-tained which adds all overhead ahmg with the costfin' traversing tile dCl)cudency arcs.
Also, a secon(Itravcrsa\] of the set of dellelldellt liodes i8 required foractually pcrfl)rming the copying.
Emele proposes amethod of dcrcfercncing by adding enviromnent in-forlltatioli tllld, carries it scqtl(Hl(:t!
of gCllCl'atioll COllll*tcrs so that a specific generation ode (:all I)(~ fOlllldby traversing tim forwarding links until a node withthat generation is found.
While this allows undoingdestructive changes cheaply by backtracking the en-virolllOCllt, every tinlc a spccilic graph is to bc at:-(:cssed the whoh!
gt'aph ilcctls tO bc rccollstrll(:tedby following the fol'wardillg pointers ,~cqucntildly asspeciticd in the environment list (cxt:et)~ for the rootnode) to find the node that shal'CS the smne genera-tion number as the root llOde.
Therefore, similar toPcrcira's mcthotl, there will be Nlog(d) ovcrhcad iLs-sociated with constructing t!ach graph every tinle &gral)h is accessed, where (1 is the llUillbCr of nodes illthe graph and N is the average depth of the tmviron-lllClttal dcfcrcncc hain, This would cause a probh!nlif the algtlrithm is adolltcd fin' a large-sclde systcm illwhich result graphs arc unified agidnst other graphsmany times.
Like Wroblewski's method, "all three lazymethods (i.c, Godden's, Kogure's and Emele's) suf-fer fi'mn the t)roblenl of Early Copying ms defined in\[Tonlabcchi, 1991\].
This is because the copies that arcincrcnmntally created u1, to tile point of failure duringthe same topAcvel unification arc wasted.
The prob-lent is inherent ill increlnental copying scheme andthis probhml is elinfil|ated completely in \[Karttuncn,ACRES DE COL1NG-92, NANTES, 23-28 Aotrr 1992 4 4 5 PROC.
oF COLING-92,  NANTES, AUO.
23-28, 199219861 and ill tile Q-D nmtltod.
3aThere is one l/otential problent with the structure,-sharing idea whMt is shared by each of the schemesinchlding tile proposed tnethod.
This  ltallpens whenoperations other tllan ttnification modify the graphs.
(This is typical whco a parser cuts off" a part of agraph for sltbsequellt analysisa4.)
When such ol)-erations are perfornmd, structure-sharing of t)ottolll(vlu'iablc) nodes stay cause probhmts when a sub-graph cotttaitdog a 1)ottmn is shared by two differentgraphs and these graphs are used as argtl l l le l l tS of autfification function (either ~Ls the part of the sameinput graph or as ehmumts of dg l  and dg2).
When agt'aplL that shares st bottl)lO ( lode iN llOt Ilsed ill its en-tirety, then the, represented i: lmstraint postulated bythe path leading to the bottotn no(h; is no longer thesame, Therefl>re, when such a graph appears in thesame unification aloog with soIoe other graph withwhich it DS shares the same bottotn node.
there will1)e a false FS-Sharing.
(If the graph is used in itsentirety this is not a problem since the two graphpaths would unify anyway.)
Th is  problenl happensmdy when neither of the two graphs that DS-Sltaresthe same I)ottol l l  node wan ultified against SOille othergraph before al)pearing in the santo unification, as{If either was once unified, h)rwardiug wouht haveavoided this prol)lent).
The methods to avoid sucha problent can be 1) As long as these convergence ofbottoln nodes are used h)r features that are not pressedup during i)arsing, the ln'oblems does not affect theresult of parse in any way whMt scents the ca,se withthe gr~mtmars at ATII azl(l CMU.
2) A parser calltie modified so that when it modifies a graph otherthan through graph unification a6, it et'eatcs copiesof the arc stru(:tures containing the bottotn nodes.In the prolmsed tnethod this can be done by call-ing the copy function without structure-sharing lle-fl)re a parser ntodifics a grallh.
3) A parser can lierood(tied so that it does not (:lit off parts of graphsand use the graphs in their entirety (this should notadd emnplexity (mcc strttctttre-sharing is introducedto unification).
Thus,  althtmgh the space and t imereductioo attained by structure-sharing (Jail t)e sig-nificant.
DS-Shariag can cause l)roblems unless it isttsed with a eautiott (by making sure variM)le sharingaaLazy methods delay eopyiug until a destructive chaalgeis to be perforlne.d Do that unnecessary copies are not cre-ated within a lmrticular ecurs(on into a unification function;howover, 8il|ce each shared arc recllrsion is indellendent (llOll-deterlllillistic).
(!villi if there are 11o unltecesa&ry copies createdat ,dl iu otte particular relalrsioll, if there is a failure in 8Ollllrother shared art: recurs(on (at some depth), then the copiedthat are created hy successful shared arc recurs(ass up to thepoint of detection of failure will beconm wasted, As long asthe haste contr<fl structure retnltins incremental, this is inher-(!lit ia the increlllental |uethod.
In otheI wolds, the problem isinhereut in these ilmremental methods by definition.34 For example, lnltny parse\[.~ cut off a subgraph of the path0 hJr applying further rules whmz it rule is accepted.35Such cases lltay happen whell the 8allle rule (such as VV} augluented with a heavy use of convergence ill the bottonlnodes is applied malty times during a parse.36Stlch as when a rule is accepted and suhgraph of O path isCltt off.does not cause crroncous sharing by using these orsome othm" methods).6 ConclusionThe structure-sharing scltemc introduced ill this pa-per made the Q-D Mg(~ritlnn run significantly f~mter.The original gain of the Q-D algorit, hnt was due tothe fact that it does not create ally Over Copiesor Early Col>ies whereas iIIcrelllelltal (:opyillg sfllI~Illeinherently produces Early Copies (iLs defined in\[Totnal)echi, 19911) when a unification fails.
Tilt: pro-l)osed schenm lllakes the Q-D algotfflmi fully i~vl)i(1lh~dundaltt Collies as well by only copying the low-est nodes that need to be eoI)ied due to destrtt(:tivechatlges caused by successful unifications only.
Sincethere will bc virtually uo overhead associated withstructure=sharlng (except far returning two vahl(!s ill-stead (If oDc' to pa.ss tip :chattge(l i lforltlatioll wht!ll rt!-curs(oil for copying rcturos), the perfornlatlee of theprol)osed strnl:ture-sharing schel l le should llOt dropeveii when the granmlar  size is significantly scaledUl).
With the denttmstratcd speed of the algorithm.as well as the ability to handle cyclicity in the graphs.mid ease of switching betwemt strueture-sharittg attdnon-structure sharing, the algorithm couhl lie a viablealternative to exist ing tttfifit:ation algorithnts used incurrent nature|  language systems.References\[Emele, 1991\] Erode.
M, "Unificatimt with Lazy Non-Redundant Copying'.
In Proc.
of A CL-91, 1991.\[Godden.
1990\] Godden, K. "Lazy Uuification" In Proc.
ofACL-90.
1990.\[Katitunen.
1986\] Karttuuen.
L. "D-PATR: A Deveh)pmentEnyirOltlllellt for IJnifi(:a.til)it-13mued Gr0.llllllalrs".
In Proc.
ofCOLING-86, 1986.
(Also, Report CSLI-86-61 Stanford Uni-versity).\[Karttunen and Kay, 1985\] Katttum)n. L. ~nd M. Kay.
"8tnu-tnre Sharing with Binary Tr(~s".
In Proc.
of ACL-85.
1985.\[Kasper, 1987\] Kasper.
R. "A Unifice.tion Method for Disjunc-tive Feature Descriptim~s".
In Prec.
of ACL-87, 1987.IKogute, 1989\] Kogure, K. A Study oil Feature St1*l~cture.~ andUnificatim~.
ATR TechuicM Report.
TR-l-O032.
1988.\[Kogure.
1990\] Kogurc, K. "Strategic Lazy Incremental CopyGraph Unification".
In Prom of COLING-go, 1990.\[Marimoto.
et el, 199(1I Morimoto, T.. H. Ilda, A. Kurem~tsu,K.
8hikano, and T. Aizawa.
"Spoken Language Translation:Toward Realizing an Automatic Telepholu!
InterprelationSystem".
In P'roc.
of l'nfoJapan 1990, 1990.\[Pereira, 1985\] Pereira, P. "A Slructure-Sharing Representa-tion for Unification-Based Grammar Formallsms".
In Proc.of ACL-8& 1985.\[Pollard ~nd Sag.
1987\] Pollard, C. and L Sag.
Infovmatio.--based Syntax and Semantics.
Vol 1.
CSLI, 1987.\[Yoshimoto and Kogure, 1989\] Yoshilnoto, K. and K. Kogure.Japanese Senfence Analy.~is by means of Phrase Strltctu.reGrammar: ATR Technical Report.
TR-1-0949, 1989.\[Tolnabechi, 1991\] Tomahechi, H. "Quasi-Destructive GraphUnification".
lit Proc.
of ACL-91, 1991.\[Wroblewski, 1987\] Wrohlewski.
D."Noudestructlve GraphUnification", In Proc.
of AAAI87.
1987.AcrEs DE COLING-92,  NANTES, 23-28 AOr3T 1992 4 4 6 PROC.
OF COLING-92,  NANTEs, AUG. 23-28, 1992
