Approximating Context-Free Grammarswith a Finite-State CalculusEdmund GRIMLEY EVANSComputer  LaboratoryUnivers i ty  of Cambr idgeCambr idge,  CB2 3QG,  GBEdmund.
Gr imley -EvansOc l .
cam.
ac .
ukAbst ractAlthough adequate models of human lan-guage for syntactic analysis and seman-tic interpretation are of at least context-free complexity, for applications uch asspeech processing in which speed is impor-tant finite-state models are often preferred.These requirements may be reconciled byusing the more complex grammar to auto-matically derive a finite-state approxima-tion which can then be used as a filter toguide speech recognition or to reject manyhypotheses at an early stage of processing.A method is presented here for calculat-ing such finite-state approximations fromcontext-free grammars.
It is essentially dif-ferent from the algorithm introduced byPereira and Wright (1991; 1996), is fasterin some cases, and has the advantage of be-ing open-ended and adaptable.1 F in i te -s ta te  approx imat ionsAdequate models of human language for syntac-tic analysis and semantic interpretation are typi-cally of context-free complexity or beyond.
Indeed,Prolog-style definite clause grammars (DCGs) andformalisms uch as PATR with feature-structuresand unification have the power of Turing machinesto recognise arbitrary recursively enumerable sets.Since recognition and analysis using such modelsmay be computationally expensive, for applicationssuch as speech processing in which speed is impor-tant finite-state models are often preferred.When natural language processing and speechrecognition are integrated into a single system onemay have the situation of a finite-state languagemodel being used to guide speech recognition whilea unification-based formalism is used for subsequentprocessing of the same sentences.
Rather thanwrite these two grammars eparately, which is likelyto lead to problems in maintaining consistency, itwould be preferable to derive the finite-state gram-mar automatically from the (unification-based) anal-ysis grammar.The finite-state grammar derived in this way cannot in general recognise the same language as themore powerful grammar used for analysis, but, sinceit is being used as a front-end or filter, one wouldlike it not to reject any string that is accepted bythe analysis grammar, so we are primarily interestedin 'sound approximations' or 'approximations fromabove'.Attention is restricted here to approximationsof context-free grammars because context-free lan-guages are the smallest class of formal anguage thatcan realistically be applied to the analysis of naturallanguage.
Techniques uch as restriction (Shieber,1985) can be used to construct context-free approx-imations of many unification-based formalisms, sotechniques for constructing finite-state approxima-tions of context-free grammars can then be appliedto these formalisms too.2 F in i te -s ta te  ca lcu lusA 'finite-state calculus' or 'finite automata toolkit'is a set of programs for manipulating finite-stateautomata nd the regular languages and transduc-ers that they describe.
Standard operations in-clude intersection, union, difference, determinisationand minimisation.
Recently a number of automatatoolkits have been made publicly available, such asFIRE Lite (Watson, 1996), Grail (Raymond andWood, 1996), and FSA Utilities (van Noord, 1996).Finite-state calculus has been successfully appliedboth to morphology (Kaplan and Kay, 1994; Kempeand Karttunen, 1996) and to syntax (constraintgrammar, finite-state syntax).The work described here used a finite-state calcu-lus implemented by the author in SICStus Prolog.452The use of Prolog rather than C or C++ causes largeoverheads in the memory and time required.
How-ever, careful account has been taken of the way Pro-log operates, its indexing in particular, in order toensure that the asymptotic complexity is as good asthat of the best published algorithms, with the resultthat for large problems the Prolog implementationoutperforms ome of the publicly available imple-mentations in C++.
Some versions of the calculusallow transitions to be labelled with arbitrary Prologterms, including variables, a feature that proved tobe very convenient for prototyping although it doesnot essentially alter the power of the machinery.
(Itis assumed that the string being tested consists ofground terms so no unification is performed, justmatching.
)3 An approximation algorithmThere are two main ideas behind this algorithm.
Thefirst is to describe the finite-state approximation us-ing formulae with regular languages and finite-stateoperations and to evaluate the formulae directly us-ing the finite-state calculus.
The second is to use,in intermediate stages of the calculation, additional,auxiliary symbols which do not appear in the finalresult.
A similar approach as been used for compil-ing a two-level formalism for morphology (GrimleyEvans et al, 1996).In this case the auxiliary symbols are dotted rulesfrom the given context-free grammar.
A dotted ruleis a grammar rule with a dot inserted somewhere onthe right-hand side, e.g.S -+ - NP VPS -+ NP ?
VPS --~ NP VP ?However, since these dotted rules are to be usedas terminal symbols of a regular language, it is con-venient o use a more compact notation: they canbe replaced by a triple made out of the nonterminalsymbol on the left-hand side, an integer to determineone of the productions for that nonterminal, and aninteger to denote the position of the dot on the right-hand side by counting the number of symbols to theleft of the dot.
So, if 'S ~ NP VP' is the fourthproduction for S, the dotted rules given above maybe denoted by (S, 4, 0}, (S, 4, 1) and (S, 4, 2}, respec-tively.It will turn out to be convenient to use a slightlymore complicated notation: when the dot is locatedafter the last symbol on the right-hand side we use zas the third element of the triple instead of the corre-sponding integer, so the last triple is (S, 4, z) insteadof (S, 4,2).
(Note that z is an additional symbol,not a variable.)
Moreover, for epsilon-rules, wherethere are no symbols on the right-hand side, we treatthe e as it were a real symbol and consider there tobe two corresponding dotted rules, e.g.
(MOD, 1, O)and (MOD, 1, z) corresponding to 'MOD --~ ?
e' and'MOD --~ e -' for the rule 'MOD -+ e'.Using these dotted rules as auxiliary symbols wecan work with regular languages over the alphabetE= TU{ (X,m,n)  \ ]X  E V Am= I , .
.
.
,mxAn = O,.. .
,max{nx,m - 1,O},z}where T is the set of terminal symbols, V is the set ofnonterminals, mx is the number of productions fornonterminal X, and nx,m is the number of symbolson the right-hand side of the ruth production for X.It will be convenient to use the symbol * as a'wildcard', so (s,*, O) means { (X,m,n} E E IX  =s ,n=O} and (*,*,z) means {(X ,m,n)  E E ln=z }.
(This last example xplains why we use z ratherthan nx,rn; it would otherwise not be possible to usethe 'wildcard' notation to denote concisely the set{ (X, m, n) I n = nx,m }.
)We can now attempt o derive an expression forthe set of strings over E that represent a valid parsetree for the given grammar: the tree is traversed in atop-down left-to-right fashion and the daughters of anode X expanded with the ruth production for X areseparated by the symbols (X, m, .).
(Equivalently,one can imagine the auxiliary symbols inserted inthe appropriate places in the right-hand side of eachproduction so that the grammar is then unambigu-ous.)
Consider, for example, the following grammar:S--+ aSbS--+eThen the following is one of the strings over E thatwe would like to accept, corresponding to the stringaabb accepted by the grammar:(s, 1, O)a(s, 1, 1}(s, 1, O}a(s, 1, 1)(s, 2, 0)(s, 2, z)(s, 1, 2)b(s, 1, z)(s, 1, 2)b(s, 1, z)Our first approximation to the set of acceptablestrings is (S, *, 0)N*(S,*, z), i.e.
strings that startwith beginning to parse an S and end with havingparsed an S. From this initial approximation we sub-tract (that is, we intersect with the complement of)a series of expressions representing restrictions onthe set of acceptable strings: 11In these xpressions over regular languages set unionand set difference are denoted by + and - ,  respectively,while juxtaposition denotes concatenation a d the bardenotes complementation (5 - E* - x).453(z*((,, ,, ,) - ( , , , ,  z))) + (1)Formula 1 expresses the restriction that a dottedrule of the form (%., 0), which represents starting toparse the right-hand side of a rule, may be precededonly by nothing (the start of the string) or by adotted rule that is not of the form (*, *, z) (whichwould represent the end of parsing the right-handside of a rule).+ ( ( , , , , , )  - ( , , , ,0 ) )z*  (2)Formula 2 similarly expresses the restriction thata dotted rule of the form (*, *, z) may be followedonly by nothing or by a dotted rule that is not ofthe form (*, *, 0).For each non-epsilon-rule with dotted rules(X ,m,n) ,  n = O, .
.
.
,nx ,m - 1,z, for each n =0 , .
.
.
,nx ,m-  1:E*(X ,m,n)next (X ,m,n  + 1)E* (3)wherenext(X, m, n) =a(X ,m,n)  (rhs(X, m, n) = a, aCT ,  n<nx,m)a(X ,m,z )  (rhs(X, m, n) = a, aeT ,  n=nx,m)(A, *, 0) (rhs(X, m, n) = A, A e V)where rhs(X, m, n) is the nth symbol on the right-hand side of the ruth production for X.Formula 3 states that the dotted rule (X, m, n)must be followed by a(X, m, n + 1) (or a(X, m, z)when n+ 1 = nx,m) when the next item to be parsedis the terminal a, or by C A, *, 0) (starting to parsean A) when the next item is the nonterminal A.For each non-epsilon-rule with dotted rules(X ,m,n) ,  n = O,.
.
.
,nx, ,~ - 1,z, for each n =1, .
.
.
,  n x , m  - 1, z:E*prev(X, m, n)(X, m, n)E* (4)whereprev(X, m, n) =iX, re, n -  1)a (rhs(X, m, n) = a, a C T, n ~ z)(X, m, nx,m - 1)a (rhs(X, m, n) = a, a ?
T, n = z)(A, *, z) (rhs(X, m, n) = A, A ?
V)Formula 4 similarly states that the dotted rule(X, m, n) must be preceded by i X, m, n - 1)a (or(X ,m,  nx,m - 1) when n = z) when the previousitem was the terminal a, or by (A,*,z)  when theprevious item was the nonterminal A.For each epsilon-rule corresponding to dottedrules (X,m,O) and (X ,m,z ) :E* (X ,m,O)(X ,m,z)E* ,  and (5)(x,  m, 0)(x,  m, (6)Formulae 5 and 6 state that the dotted rule(X, ra,0) must be followed by (X,m,z) ,  and(X, m, z) must be preceded by iX, m, 0).For each non-epsilon rule with dotted rulesiX, re, n), n : O, .
.
.
,nx ,m - 1,z, for each n :O, .
.
.
,nx ,m-  1:m,*))*(iX, m,0)+(X,m,n ' ) )Z*(r)andm, z)+ (x,  m, - (X, m, *))* iX, m,(S)wheren' = ~ n + 1, if n < nx,ra - -  1;\[ z, if n = nx,m - 1.Formula 7 states that the next instance of(X ,m,* )  that follows (X ,m,n)  must be either(X, m, 0) (a recursive application of the same rule)or (X ,m,n ' )  (the next stage in parsing the samerule), and there must be such an instance.
Formula 8states imilarly that the closest instance of (X, m, *)that precedes (X, m, n') must be either (X, m, z) (arecursive application of the same rule) or (X, m, n)(the previous stage in parsing the same rule), andthere must be such an instance.When each of these sets has been subtracted fromthe initial approximation we can remove the auxil-iary symbols (by applying the regular operator thatreplaces them with e) to give the final finite-stateapproximation to the context-free grammar.4 A smal l  exampleIt may be admitted that the notation used for thedotted rules was partly motivated by the possibil-ity of immediately testing the algorithm using thefinite-state calculus in Prolog: the regular expres-sions listed above can be evaluated irectly using the'wildcard' capabilities of the finite-state calculus.Figure 2 shows the sequence of calculations thatcorresponds to applying the algorithm to the follow-ing grammar:S -~aSbS -~eWith the following notational explanations it shouldbe possible to understand the code and compare itwith the description of the algorithm.?
The procedure r(RE,X) evaluates the regu-lar expression RE and puts the resulting (min-imised) automaton i to a register with the nameX.454?
l i s t _ f sa (X)pr in ts  out the transition table forthe automaton i  register X.?
Terminal symbols may be any Prolog terms, sothe terminal alphabet is implicit.
Here atomsare used for the terminal symbols of the gram-mar (a and b) and terms of the form _/_/_ areused for the triples representing dotted rules.The terms need not be ground, so the Prologvariable symbol _ is used instead of the 'wild-card' symbol ?
in the description of the algo-rithm.?
In a regular expression:- #X refers to the contents of register X;- $ represents E, any single terminal symbol;- s represents a string of terminals withlength equal to the number of arguments;so s with no arguments represents theempty string e, s(a) represents the singleterminal a, and s (s / _ /0 )  represents thedotted rules (s, *, 0);- Kleene star is * (redefined as a postfix op-erator), and concatenation a d union are ^and +, respectively;- other operators provided include ~ (inter-section) and - (difference); there is no oper-ator for complementation; i stead subtrac-tion from E* may be used, e.g.
($ *)-(#1)instead of L;- rein(RE,L) denotes the result of removingfrom the language RE all terminals thatmatch one of the expressions in the list L.The context-free language recognised by the origi-nal context-free grammar is { anb n \[ n > 0 }.
The re-sult of applying the approximation algorithm is a 3-state automaton recognising the language + a+b +.5 Computat iona l  complex i tyApplying the restrictions expressed by formulae 1-6gives an automaton whose size is at most a smallconstant multiple of the size of the input grammar.This is because these restrictions apply locally: thestate that the automaton is in after reading a dottedrule is a function of that dotted rule?When restrictions 7-8 are applied the final au-tomaton may have size exponential in the size of theinput grammar.
For example, exponential behaviouris exhibited by the following class of grammars:S --+ al S alS -+ an S anS -+eHere the final automaton has 3 n states.
(It records,in effect, one of three possibilities for each terminalsymbol: whether it has not yet appeared, has ap-peared and must appear again, or has appeared andneed not appear again.
)There is an important computational improve-ment that can be made to the algorithm as describedabove: instead of removing all the auxiliary symbolsright at the end they can be removed progressivelyas soon as they are no longer equired; after formulae7-8 have been applied for each non-epsilon rule withdotted rules (X,m,*) ,  those dotted rules may beremoved from the finite-state language (which typi-cally makes the automaton smaller); and the dottedrules corresponding to an epsilon production maybe removed before formulae 7-8 are applied.
(To'remove' a symbol means to substitute it by e: aregular operation.
)With this important improvement the algorithmgives exact approximations for the left-linear gram-marsS-~ SalS~SanS--+eand the right-linear grammarsS --+ al SS --+ an SS--+ein space bounded by n and time bounded by n 2.
(Itis easiest o test this empirically with an implemen-tation, though it is also possible to check the cal-culations by hand.)
Pereira and Wright's algorithmgives an intermediate unfolded recogniser of size ex-ponential in n for these right-linear grammars.There are, however, both left-linear and right-linear grammars for which the number of states inthe final automaton is not bounded by any polyno-mial function of the size of the grammar.
An exam-ples is:S --~ al S S~a l  A1S-+anS S -+anAnA~ -+ a~ XA2 ---+ al A2An -~ al AnX -+eA1 -+ a2 Az ... A1 ~ an A1A2 -+ a2 X ... A2 --~ an A2An -+ a2 A,~ ... An --~ an XHere the grammar has size O(n 2) and the final ap-proximation has 2 n+l  - -  1 states.455MOD --+MOD --+ p NPNOM --+ a NOMNOM --+ nNOM --+ NOM MODNOM --+ NOM SNP --+NP ~ d NOMVP --+ v NPVP-~ vSVP -~ v VPVP --+vVP --+ VP c VPVP ~ VP MODS ~ MOD SS -+NP SS~ScSS ~ v NP VPFigure 1: An 18-rule CFG derived from a unificationgrammar.Pereira and Wright (1996) point out in the contextof their algorithm that a grammar may be decom-posed into 'strongly connected' subgrammars, eachof which may be approximated separately and theresults composed.
The same method can be usedwith the finite-state calculus approach: Define therelation 7~ over nonterminals of the grammar s.t.ATC.B iff B appears on the right-hand side of a pro-duction for A.
Then the relation $ = 7~* A (7~*) -1,the reflexive transitive closure of 7~ intersected withits inverse, is an equivalence relation.
A subgram-mar consists of all the productions for nonterminalsin one of the equivalence classes of S. Calculatethe approximations for each nonterminal by treatingthe nonterminals that belong to other equivalenceclasses as if they were terminals.
Finally, combinethe results from each subgrammar by starting withthe approximation for the start symbol S and substi-tuting the approximations from the other subgram-mars in an order consistent with the partial orderingthat is induced by 7~ on the subgrammars.6 Resu l t s  w i th  a la rger  g rammarWhen the algorithm was applied to the 18-rule gram-mar shown in figure 1 it was not possible to com-plete the calculations for any ordering of the rules,even with the improvement mentioned in the previ-ous section, as the automata became too large forthe finite-state calculus on the computer that wasbeing used.
(Note that the grammar forms a singlestrongly connected component.
)However, it was found possible to simplify the cal-culation by omitting the application of formulae 7-8for some of the rules.
(The auxiliary symbols notinvolved in those rules could then be removed be-fore the application of 7-8.)
In particular, when re-strictions 7-8 were applied only for the S and VPrules the calculations could be completed relativelyquickly, as the largest intermediate automaton hadonly 406 states.
Yet the final result was still a usefulapproximation with 16 states.Pereira and Wright's algorithm applied to thesame problem gave an intermediate automaton (the'unfolded recogniser') with 56272 states, and the fi-nal result (after flattening and minimisation) was afinite-state approximation with 13 states.The two approximations are shown for comparisonin figure 3.
Each has the property that the symbolsd, a and n occur only in the combination d a* n. Thisfact has been used to simplify the state diagrams bytreating this combination as a single terminal symboldan; hence the approximations are drawn with 10and 9 states, respectively.Neither of the approximations is better than theother; their intersection (with 31 states) is a bet-ter approximation than either.
The two approxima-tions have therefore captured ifferent aspects of thecontext-free language.In general it appears that the approximations pro-duced by the present algorithm tend to respect henecessity for certain constituents to be present, atwhatever point in the string the symbols that 'trig-ger' them appear, without necessarily insisting ontheir order, while Pereira and Wright's approxima-tion tends to take greater account of the constituentswhose appearance is triggered early on in the string:most of the complexity in Pereira and Wright's ap-proximation of the 18-rule grammar is concernedwith what is possible before the first accepting stateis encountered.7 Compar i son  w i th  prev ious  workRimon and Herz (1991; 1991) approximate therecognition capacity of a context-free grammar byextracting 'local syntactic onstraints' in the form ofthe Left or Right Short Context of length n of a ter-minal.
When n = 1 this reduces to next(t), the set ofterminals that may follow the terminal t. The effectof filtering with Rimon and Herz's next(t) is similarto applying conditions 1-6 from section 3, but theuse of auxiliary symbols causes two differences whichcan both be illustrated with the following grammar:S~aXa\ [bXbX--+eOn the one hand, Rimon and Herz's 'next' does notdistinguish between different instances of the sameterminal symbol, so any a, and not just the first one,may be followed by another a.
On the other hand,Rimon and Herz's 'next' looks beyond the emptyconstituent in a way that conditions 1-6 do not, so456initial approximation:r( s(s/_/O)^($ * ) ' s ( s / _ /Z )  , a ) .fo rmulae  (1 ) - (2 ) :r ( (#a)  - ( ($ * ) - ( ($  *)'(s(_/_/_)-s(_/_/z))+s))'s(_/_/O)'($ *) , a ) .r ( (#a)  - ($ * )^s(_ / _ / z )^( ($  * ) - ( s+(s (_ / _ / _ ) - s ( _ / _ /O) )^($  * ) ) )  , a ) .fo rmula  (3) fo r  "S -> a S b" :r ( (#a)  - ($ *)^s(s/i/O)'(($ *)-s(a)'s(s/I/l)^($ *)) , a).r ( (#a)  - ($ * )^s(s /1 /1 ) ' ( ($  * ) - s (s / _ /0 )^($  *))  , a ) .r ( (#a)  - ($ * ) ' s ( s /1 /2 )^( ($  * ) - s (b )^s(s /1 /z )^($  *))  , a ) .formula (4) for "S -> a S b":r ( (#a)  - (($ * ) - ($  * ) ' s ( s /1 /0 )^s(a) )^s(s /1 /1 )^($  , )  , a ) .r ( (#a)  - ( ($ * ) - ($  * )^s(s / _ / z ) ) ' s (vp /2 /1 ) ' ($  *) , a ) .r ( (#a)  - (($ *)-($ *)^s(s/i/2)^s(b))^s(s/i/z)^($ *) , a).formulae (5)-(6) for "S -> ""r ( (#a)  - ($ *)'s(s/2/O)^(($ *)-s(s/2/z)^($ *)) , a ) .r ( (#a)  - ( ($ * ) - ($  *)^s(s/2/O))^s(s/2/z)'($ *) , a ) .fo rmula  (7) fo r  "S -> a S b" :r ( (#a) - ($  * )^s(s /1 /0 )^( ($  * ) - ( ($  -s(s/1/_))*)^(s(s/1/O)+s(s/1/1))^($ * ) ) ,a ) .r ( (#a) - ($  * ) ' s ( s /1 /1 )^( ($  * ) - ( ($  -s(s/1/_))*)^(s(s/1/O)+s(s/1/2))^($ * ) ) ,a ) .r ( (#a) - ($  *)'sCs/1/2)^(($ * ) - ( ($  -sCs/1/_))*)^(s(s/1/O)+s(s/1/z))^($ * ) ) ,a ) .fo rmula  (8) fo r  "S -> a S b" :r ( (#a) - ( ($  * ) - ($  * )^(s (s /1 /z )+s(s /1 /O) )^( ($  - s (s /1 / _ ) ) . )
)^s(s /1 /1 ) ' ($  * ) ,a ) .r((#a)-(($ *)-($ *)'(s(s/i/z)+s(s/i/l))^(($ -s(s/i/_))*))'s(s/i/2)^($ *),a).r((#a)-(($ *)-($ *)^(s(s/i/z)+s(s/I/2))^(($ -s(s/i/_)).
))^s(s/i/z)^($ *),a).define the terminal alphabet:r(s(s/i/O)+s(s/i/l)+s(s/i/2)+s(s/i/z)+s(s/2/O)+s(s/2/z)+s(a)+s(b), sigma).remove the auxiliary symbols to give final result:r(rem((#a)a((#sigma) *),\[_/_/_\]) , f).list_fsa(f).Figure 2: The sequence of calculations for approximating S -+ a S b I e, coded for the finite-state calculus.vC p v dan p I c v / / .
I'v , d a n ~ ~Figure 3: Finite-state approximations for the grammar in figure 1 calculated with the finite-state calculus(left) and by Pereira and Wright's algorithm (right).457ab is disallowed.
Thus an approximation based onRimon and Herz's 'next' would be aa* + bb*, andan approximation based on conditions 1-6 would be(a + b) (a + b).
(However, the approximation becomesexact when conditions 7-8 are added.
)Both Pereira and Wright (1991; 1996) and Rood(1996) start with the LR(0) characteristic machine,which they first 'unfold' (with respect o 'stacks' or'paths', respectively) and then 'flatten'.
The char-acteristic machine is defined in terms of dotted ruleswith transitions between them that are analagousto the conditions implied by formula 3 of section3.
When the machine is flattened, e-transitions areadded in a way that is in effect simulated by condi-tions 2 and 4.
(Condition 1 turns out to be impliedby conditions 2-4.)
It can be shown that the approx-imation L0 obtained by flattening the characteristicmachine (without unfolding it) is as good as the ap-proximation L1-6 obtained by applying conditions1-6 (L0 c L1-6).
Moreover, if no nonterminal forwhich there is an e-production is used more thanonce in the grammar, then L0 = L1-6.
(The gram-mar in figure 1 is an example for which Lo # L1-6;the approximation found in section 6 includes tringssuch as vvccvv which are not accepted by L0 forthis grammar.)
It can also be shown that LI-~ isthe same as the result of flattening the character-istic machine for the same grammar modifed so asto fulfil the afore-mentioned condition by replacingthe right-hand side of every e-production with a newnonterminal for which there is a single e-production.However, there does not seem to be a simple corre-spondence between conditions 7-8 and the 'unfold-ing' used by Pereira and Wright or Rood: even somesimple grammars uch as 'S ~ a S a \[ b S b I e' areapproximated differently by 1-8 than by Pereira andWright's and Rood's methods.8 D iscuss ion  and  conc lus ionsIn the case of some simple examples (such as thegrammar 'S --~ a S b I e' used earlier) the approxi-mation algorithm presented in this paper gives thesame result as Pereira and Wright's algorithm.
How-ever, in many other cases (such as the grammar 'Sa S a I b S b I e' or the 18-rule grammar in theprevious ection) the results are essentially differentand neither of the approximations is better than theother.The new algorithm does not share the problem ofPereira and Wright's algorithm that certain right-linear grammars give an intermediate automaton ofexponential size, and it was possible to calculate auseful approximation fairly rapidly in the case of the18-rule grammar in the previous ection.
However, itis not yet possible to draw general conclusions aboutthe relative efficiency of the two procedures.
Never-theless, the new algorithm seems to have the advan-tage of being open-ended and adaptable: in the pre-vious section it was possible to complete a difficultcalculation by relaxing the conditions of formulae 7-8, and it is easy to see how those conditions mightalso be strengthened.
For example, a more compli-cated version of formulae 7-8 might check two levelsof recursive application of the same rule rather thanjust one level and it might be useful to generalisethis to n levels of recursion in a manner analagous toRood's (1996) generalisation ofPereira and Wright'salgorithm.The algorithm also demonstrates how the generalmachinery of a finite-state calculus can be usefullyapplied as a framework for expressing and solvingproblems in natural anguage processing.ReferencesGrimley Evans, Edmund, George Kiraz, andStephen Pulman.
1996.
Compiling a Partition-Based Two-Level Formalism~ COLING-96, 454-459.Herz, Jacky, and Mori Rimon.
1991.
Local Syntac-tic Constraints.
Second International Workshopon Parsing Technology (IWPT-2).Kaplan, Ronald, and Martin Kay.
1994.
Regularmodels of phonological rule systems.
Computa-tional Linguistics, 20(3): 331-78.Kempe, AndS, and Lauri Karttunen.
1996.
ParallelReplacement in Finite State Calculus.
COLING-96, 622.Pereira, Fernando, and Rebecca Wright.
1991.Finite-state approximation of phrase structuregrammars.
Proceedings of the 29th Annual Meet-ing of the Association for Computational Linguis-tics, 246-255.Pereira, Fernando, and Rebecca Wright.
1996.Finite-State Approximation of Phrase-StructureGrammars.
cmp-lg/9603002.Raymond, Darrell, and Derick Wood.
March 1996.The Grail Papers.
University of Western Ontario,Department of Computer Science, Technical Re-port TR-491.Rimon, Mori, and Jacky Herz.
1991.
The recogni-tion capacity of local syntactic onstraints.
ACLProceedings, 5th European Meeting.Rood, Cathy.
1996.
Efficient Finite-State Approxi-mation of Context Pree Grammars.
Proceedingsof ECAI 96.458Shieber, Stuart.
1985.
Using restriction to extendparsing algorithms for complex-feature-based for-malisms.
Proceedings ofthe 23nd Annual Meetingof the Association for Computational Linguistics,145-152.Van Noord, Gertjan.
1996.
FSA Utilities: Manipu-lation of Finite-State Automata implemented inProlog.
First International Workshop on Imple-menting Automata, University of Western On-tario, London Ontario, 29-31 August 1996.Watson, Bruce.
1996.
Implementing and using finiteautomata tcolkits.
Procccdings of ECAI 96.459
