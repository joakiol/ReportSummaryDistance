EXTENDED GRAPH UNIFICATIONAllan RamsaySchool of Cognitive SciencesUniversity of Sussex, Falmer BN1 9QNAbstractWe propose an apparently minor extension toKay's (1985} notation for describing directedacyclic graphs (DAGs}.
The proposed notationpermits concise descriptions of phenomena whichwould otherwise be difficult to describe, with-out incurring significant extra computational over-heads in the process of unification.
We illustratethe notation with examples from a categorial de-scription of a fragment of English, and discuss thecomputational properties of unification of DAGsspecified in this way.argue that our extension makes it possible to de-scribe any phenomena which could not have beendescribed at all using the existing notations, justthat the descriptions using the extension are moreconcise.2 GRAPH SPECIF ICAT IONWe start by defining a language GSL (graph spec-ification language} for describing raphs, and byspecifying the conditions under which two graphsunify.1 INTRODUCTIONMuch recent work on specifying grammars forfragments of natural languages, and on producingcomputational systems which make use of thesegrammars, has used partial descriptions of com-plex feature structures {Gazdar 1988}.
Gram-mars are specified in terms of partial descriptionsof syntactic structures; programs that depend onthese grammars perform some variant of unifica-tion in order to investigate the relationship be-tween specific strings of words and the syntac-tic structures permitted by the grammarmis somesentence grammatical, what actually is its syn-tactic structure, how can some partially specifiedstructure be realised as a string of words, andso on.
Nearly all existing unification grammarsof this kind use either term unification (the kindof unification used in resolution theorem provers,and hence provided as a primitive in PROLOG) orsome version of the graph unification proposed byKay {1985) and Shieber (1984).
We propose an ex-tension to the languages used by Kay and Shieberfor describing raphs, and to the specification ofthe conditions under which graphs unify.
This ex-tension enables us to write concise descriptions ofsyntactic phenomena which would be awkward tospecify using the originM notations.
We do not2.1 GSL: syntaxThe syntax of GSL has been kept as close as possi-ble to that of FUG (Kay 1985) in order to facilitatecomparisons.
It is not, unfortunately, possible tokeep it close to both FUG and PATR (Shieber1984), but it should be possible for readers famil-iar with PATR to see roughly what the relationbetween the two is.A node descriptor consists of either an atomicsymbol, e.g.
agr, cat, bar, or of two atomicsymbols separated by a slash, e.g.
cat/C,head/OBJECT.
In the first case the symbol is thevalue of the described node, in the second the sym-bol before the slash is the node's value and thesymbol after it is its name.
We will generally uselower case words for values and upper case onesfor names, but the distinction between upper andlower case has no significance in GSL.A path descriptor consists of a sequence ofnode descriptors separated by equals signs, e.g.head---major=cat=prep.
The path described bysuch a descriptor consists of the sequence of de-scribed nodes.
The first node in a path is calledits initial node and the final node is called its ter-minal node.
The descriptor of the terminal node ina path may be followed by an exclamation mark,- 212 -as in head=major=cat=prep/, in which case thenode is said to be mandatory.A graph descriptor consists of a set of path de-scriptors separated by commas.
The graph con-sists of the set of described paths.
If two nodedescriptors in a graph descriptor specify the samename, they refer to the same node.A set of paths with identical initial segmentsmay be specified by writing the initial segmentjust once and including the divergent tails withinnested brackets, so thatA=B--C=(X--Y, W=(V=U, Q=R))is a shorthand form for:A=B=C=X=Y,A--B=C=W=V=U,A=B=C=W=Q=RThe sub-graph governed by a path is the set ofall terminal sequences of paths whose initial se-quence matches the given path.
The last node inthe given path is called the root of the sub-graphgoverned by the path.
Thus in the above examplethe set of paths X=Y, W=V=U, W=Q=R is thesub-graph governed by the path A=B=C, and Cis the root of this sub-graph.A macro is simply a symbol which has beenspecified as a shorthand for some other sequenceof symbols.
Macros are expanded by simple tex-tual substitution, so that if NP were a macrofor the sequence of symbols cat=n, bar=two thenhead=(NP) expands to head=(cat=n/, bar=two~).The parentheses are important--head=NP ex-pands to head--cat=a~, bar=two~, which is verydifferent from head=(cat=n!, bar=two/).The major differences between GSL and thelanguages used by Kay and Shieber axe thatGSL distinguishes between optional and manda-tory nodes, and that names (which function asthe constraints for turning trees into graphs) canbe attached to non-terminal nodes.
GSL also dif-fers from FUG in that it does not provide a facil-ity for disjunctive graphs--disjunction is cateredfor by requiring the grammar and lexicon to con-tain explicit alternatives, rather than by permit-ting graphs themselves to contain options.
Mostof the other differences are cosmetic--the GSLpath agr=num=sinq/ is equivalent to the PATRpath \[aqr: Inure: siag\]\] and the FUG descriptoragr=num=sing.
The GSL path aqr=num=singis roughly equivalent o the PATR path \[agr:\[hum: \[sittg: <Alpha>\]\]\] and the FUG descrip-tor agr=num=sing=ANY.
The fact that the sec-ond set of paths axe only =roughly ~ equivalent isa consequence of the new definition of unificationgiven in the next section.2.2 CSL:  un i f i ca t ionThe major operation that we are going to performon graphs specified in GSL  is unification.
We de-fine this, as usual, in terms of the common ex-tension of sets of graphs.
We start by defining thecommon extension of a pair of graphs.
Two graphsG1 and G2 unify to produce a common eztettsionE under the following conditions:(i) Suppose V is the value of initial nodes ineach of G1 and G2.
Then the sub-graphs of G1and G2 which axe governed by the path consistingof just the node V must have a common extension,say Ev.
If they do have such a common exten-sion, then the common extension E of G1 and G2themselves must include all the paths obtained byadding V to the front of members of Ev.
If theydo not then G1 and G2 do not unify, and hencehave no common extension.Furthermore, if any initial node in either graphwith V as its value has a name, that name must beassociated with a sub-graph which has a commonextension with each of G1 and G2.
All the pathswhich appear in any of these extensions must alsobe included in E. Again if the sub-graph associ-ated with any such name fails to have a commonextension with either G1 or G2  then G1 and G2themselves do not unify.
(ii) Suppose V appears as the value of one ormore initial nodes in G1 but of none in G2.
Thenif V is a mandatory terminal node of any pathin G1 of which it is the initial node then G1 andG2 do not have a common extension (since V ismandatory in G1, but does not appear as an initialnode of any path in G2).
Otherwise the commonextension of G1 and G2, if it exists, must includeall the paths in G1 for which V is an initial node.The same condition applies if V is the value of oneor more initial nodes in G2 but of none in G1.
(iii) The common extension of G1 and G2 con-tains no paths not explicitly required by conditions(i} and (ii}.The common extension of a set of graphs {G1,G2, ..., Gn} where n > 2 is simply the commonextension of G 1 with the common extension of theset {G2, ..., Gn}.This definition of the common extension of- 213  -a set of graphs is rather non-constructive, andis neutral with respect to compatational mecha-nisms.
We need to show that we can in fact com-pute common extensions, and to consider the com-plexity of the algorithm for doing so, but beforethat we ought to try to show that we can use GSLto give concise descriptions of syntactic rules.
Ifwe can't do that, there is no point in worryingabout the efficiency of algorithms for comparinggraphs described in GSL  at all.3 SYNTACTIC  DESCRIP -T IONS US ING GSLWe will illustrate the use of GSL with elementsof a categorial grammar for a fragment of En-glish.
GSL is not specifically designed for catego-rim grammar, but the complexity of the categorystructures of any non-trivial categorial grammarmeans that such grammars provide a good testbedfor notations for describing categories.
Althoughcategorial grammars have recently received con-siderable attention (Pareschi & Steedman (1987),Klein & van Benthem (1987), Oehrle, Bach &Wheeler (1987)), computational treatments havebeen hindered by the need to develop and ma-nipulate large category descriptions.
The expres-sive power of GSL is therefore well illustrated bythe ease with which we can develop the categorydescriptions required for a non-trivial categorialgrammar.We start with the basic categorial rules:{major/X, minor/Y, subcat/SUB, slash/SLASH)(HEAD=(major/X, minor/Y, subcat/SUB,slash/SLASH),RSLASH=(major/X1, minor/Y1, subcat/SUB1,slash/SLASH),slash=null!
),{major/X1, minor/Y1, subcat/SUB1,slash/SLASH}(major/X, minor/Y, subcat/SUB, slash/SLASH)(major/X1, minor/Y1, subcat/SVB1,slash=nullI)(HEAD=(major/X, minor/Y, subcat/SUB,slash/SLASH),LSLASH--(major/X1, minor/Y1, subcat/SUB1,slash/SLASH),slash/SLASH)The first of these is an extended version of thenormal categorial rule for combining somethingwhich requires an argument to its right with anargument of the appropriate type, namely:A ~ A/B BWe have been forced to complicate this rule,as have others trying to produce categorial gram-mars for non-trivial fragments, in order to takeinto account intrinsic syntactic functions uch ascase and number agreement, and to deal with thefine details of sub-categorisation rules.
In our ex-tended version of the basic rule, the A of the basicversion is replaced by (major/X, minor/Y, sub-cat/SUB, slash/SLASH) and the B of the basicversion by (major/X1, minor/Y1, subcat/SUB1,slash/SLASH).
The major features of a categoryare simply its main category (noun, verb, preposi-tion, conj) and its bar level (zero, one, two).
Theminor features are the intrinsic syntactic featuressuch as agr and auz.
subcat specifies what argu-ments (lslash and rslash) are required and whatthe head (head) of the local tree described by therule is like.
slash, as usual in unification gram-mars, carries information about unbounded e-pendencies.
The category A/B of the basic ruleis replaced by:(HEAD=(major/X, minor/Y,subcat/SUB,slash/SLASH),RSLASH=(major/X1, minor/Y1, subcat/SUBl,slash/SLASH),slash=null!
)This describes a structure which will join witha (major/X, minor/Y, subcat/SUB, dash/SLASH)to its right to make a (major/Xl, minor/Yl, sub-cat/SUBl, slash/SLASH).We have made very little use of the extra facil-ities provided by GSL in specifying this rule, be-yond the convenience of the abbreviations HEADfor subcat=head nd RSLASH for subcat=rslaah.Apart from that, we have used names for speci-fying constraints, but that could easily have beendone in any of the standard formalisms; and wehave used the exclamation mark to constrain thevalue of slash on the first element of the right handside to be null.
The second of the basic rules issufficiently similar that it requires no further dis-cussion.To show how the extra power of GSL can helpus construct concise descriptions, we will considertwo specific examples.
The first is the definition- 214 -of the lexical entry for an auxiliary.
This requiresthe, fr,ll,,wing three macro definitions:VP ~* (V, I, minor/X=vform=agr/AGR,RSLASH=nulI1,HEAD=(S, minor/X),LSLASH=minor=agr/AGR)VERB ~* (V, O, minor/X, LSLASH=null!,HEAD=(VP, minor/X))AUX ~ (VERB, minor=anx=yes!,RSLASH=(VP, LSLASH/SUBJ),HEAD=LSLASH/SUBJ)The definition of A UX says that it is a specialtype of VERB, namely one that will combine witha VP to its right.
The head of the A UX inheritsany constraints on the subject of its own rslash.The definition of VERB says that it is somethingwhich does not require anything to its left, andthat it will participate in local trees dominated byobjects of type VP, with the constraint that theVERB has the same minor features as the VP.The definition of VP is fairly similar, but it doesmake use of the facility for placing names in non-terminal positions to enforce two constraints--onebetween the entire set of minor features of the VPand the minor features of its head, and anotherbetween the agr features of the VP and the agrfeatures of its subject.Although this set of abbreviations appears onlyto call upon the facility for including names fornon-terminal nodes once, we can see that if wewere to expand the macros inside the definitionof A UX there would be two other places wherethis was done (the definition below still has somemacros unexpanded to help keep it readable):AUX "~ (V, O,minor/X=aux=yesT,LSLASH=null!,H=(V, I,minor/X=vform=agr/AGR,RSLASH=nuU~,H=(S,minor/X),LSLASH/SUB J=minor=agr/AGR),RSLASH=(VP, LSLASH/SUBJ))It is worth noting that nowhere in either theexpanded definition or in the three abbreviationsis the major category of the subject specified.
Thisinformation may be inherited from the main verbof the VP argument of the auxiliary, but otherwiseits major category is unconstrained, in order topermit sentences like Eating people i8 going out offa.qhion and For me to eat you u, oulJ be the h*ichtof impropriety.
It is assumed that the \[exical en-tries for verbs will sub-categorise for NP, VP orS subjects as required, just as they sub-categorisefor complements.The second example of the use of GSL  featurescomes from a group of rules which describe alter-native sub-categorisation frames--rules which say,for instance, that a typical ditransitive verb hasa case frame requiring two NP's rather than anNP  and a PP.
The rule below generates the %ux-inverted" case frame for A UX's:(V, O, minor=vform/VFORM=agr/AGR,RSLASH=(NP, minor= (SUB J, agr/AGR),slash=null!
),HEAD= (major=cat=partial!, RSLASH/A2,HEAD=(S,  minor=(vform/VFORM,mood =interrogative!
))))(AUX,minor= (vform/VFORM=finite=tensed!
),RSLASH/A2)This rule again specifies names for non-terminalnodes, with VFORM twice being used as a namefor a non-terminal node.
The effect of thisis to constrain the relevant item to be tensedand to share the same value for agr as its"inverted" subject.
The rule also contains anumber of mandatory features.
The path mi-nor=~form=finite=tensed!, for instance, restrictsthe rule to cases of tensed auxiliaries.We cannot use examples to "prove" that GSLmakes it possible to write more concise specifica-tions than we could write in FUG or PATR.
Thisis particularly clear when the examples are culledfrom a grammar whose overall structure imposesconstraints which can only be motivated by con-sidering the grammar as a whole (which we do nothave space for), rather than by looking at the ex-amples in isolation.
The best we can hope for isthat the examples do seem to describe the con-structions they are aimed at fairly concisely; andperhaps that it is not all that obvious how youwould describe them in PATR or FUG.~_~ - 215  -4 COMPUTATIONAL COM-PLEX ITYWe end by briefly considering the complexity ofthe task of seeing whether two graphs with namednon-terminal nodes have a common extension.
Itis well-known that disjunctive unification is NP-complete (Kasper 1987).
What is the status ofunification of structures with constraints on sub-graphs?The definition of unification given in Section 2looks very non-deterministic--full of phrases like~Suppose V is the value of initial nodes in each ofG1 and G2 ~ and ~Suppose V appears as the valueof one or more initial nodes in G1 but of nonein G2".
We can make it much more constrainedby imposing a normal form on graphs.
The firstthing we need for this is an arbitrary ordering onfeatures, which we can easily find since featuresare just alphanumeric strings, and these can beordered lexicographically.
If we were working withtrees rather than DAGS, and we had such an or-dering, we could impose a normal form by orderingthe sub-trees of a node by the lexicographic order-ing of their own root nodes, so that the normalform of the tree(A (X (Z Y)) (P (S R)))would be:(A (P (R S)) (X (Y Z)))Unification of trees in this kind of normal formis of complexity o(M ?
N), where M is the maxi-mum branching factor for the tree and N is themaximum depth.
It is clear that we can im-pose a very similar normal form on DAGs with-out constraints on non-terminal nodes.
For DAGswhich do have constraints on non-terminal nodes,we have to split the representation of the graphinto two pieces.
We represent the basic structureof the graph in terms of sets of nodes and theirsuccessors; but where a node has a name, we in-clude the name rather than the node itself.
Foreach such named node, we store the sub-graphrooted at the node separately as the value of thename (this sub-graph itself, of course, may containnamed nodes, in which case we just do the sameagain).
We now effectively have a set of DAGseach of which has no constraints on internal nodes.We can therefore put each of these into normalform as before.
The theoretical time for unifica-tion is again o(M ?
N), though N is now the lengthof the longest path through the graph you wouldget if you replaced names by the sub-graphs theyname.
The practical time is such as to make itperfectly sensible to use it as the basis of a com-putational system.
Quoting times for analysingspecific texts is a fairly meaningless way of com-paring parsers, let alne unification algorithms,since there are so many unspecified parameters--size of the grammar, degree of ambiguity in thelexicon, speed of the basic machine, ... All I cansay is that left-corner chart parsing with categorialrules specified via GSL descriptions of categoriesis markedly quicker than naive top-down left-rightparsing of grammars of comparable coverage writ-ten as DCGs.ReferencesGasdar G. (1987) The new grammar formalisms--a tutorial survey \]JGAI-87Kasper R. (1987) A unification method for dis-junctive feature descriptions ACL Proceed-lags, PSth Annual Meetin9 235-242Kay M. (1985) Parsing in functional unifica-tion grammar in Natural Language Parsingeds.
D.R.
Dowty, L. Karttunen & A.M.Zwicky, Cambridge University Press, Cam-bridge, 251-278Klein E. & van Benthem J.
(eds) Categories,Polymorphism, and Unification (1987) Cen-tre for Cognitive Science, University of Ed-inburgh and Institute for Language, Logic,and Information, University of AmsterdamEdinburgh and AmsterdamOehrle D., Bach E. & Wheeler D. (1987) Cate-gorial grammars and natural anguage struc-tures Reidel, DordrechtPareschi R. & Steedman M.J. (1987) A lazyway to chart-parse with categorial grammarsACL Proceedings, 25th Annual Meetin9 81-88Shieber S.M.
(1984) The design of a com-puter language for linguistic informationCOLING-84 362-366- 216-
