IMPLEMENTING SYSTEMIC  CLASS IF ICAT ION BY UNIF ICAT IONC.
S. Mel l ishSchool of Cognitive Sciences, University of Sussex 1The "system networks" of Systemic Grammar providea notation for declaring how combinations ofpropertiesmay imply or be inconsistent with other combinations.Partial information about a linguistic entity can berecorded as a set of known properties, and a systemnetwork then enables one to infer which other proper-ties follow from this and which other properties areincompatible with this.
The possible descriptions al-lowed by a system network are partially ordered by therelationship of subsumption, where a description sub-sumes any description that is more specific than it,given the background constraints declared by the net-work.
Given this partial ordering, the set of descriptionscan be seen as forming a lattice with least upper boundand greatest lower bound operations.
In a class ofapplications (such as parsing and generation) that re-quire incremental description refinement, we are onlyreally interested in forming new conjunctions (greatestlower bounds) and testing subsumption relationships.If one factors out the complexity of variable renam-ing and introduces special top and bottom elements, theset of logical terms also forms a lattice (the lattice ofGeneralised Atomic Formulae - "GAF lattice") underthe partial ordering relation "is equally or more instan-tiated than" (Reynolds (1970)).
In this lattice, the great-est lower bound operation is unification (Robinson(1965)).
Unification is a primitive operation in mostlogic programming systems and is also the basis ofvarious grammatical formalisms.
It is therefore a rela-tively well understood operation and can be efficientlyimplemented.In this paper, we investigate to what extent it ispossible to find structure-preserving mappings from thedescription spaces defined by system networks to su-blattices of the GAF lattice.
Where this is possible, wecan use a fixed mapping from property names to logicalterms to create terms that represent conjunctive de-scriptions (by unification) and to test subsumption (bytesting "less instantiated than").
Incompatibility ofdescriptions is also indicated by unification failure.There are a number of reasons why it is interesting toinvestigate these possibilities:(I) They may result in more efficient or flexible ways ofusing system networks for inferencing.
(2) They may enable language analysers or generatorswhich involve unification for other reasons (e.g.,analysers for GPSG (Gazdar et al (1985)) or Func-tional Unification Grammar (Kay (1984)) to build infeature co-occurrence t sts using the same mecha-nism.
(3) They may enable us to make formal sense of variousad-hoc mechanisms used by logic programmers innatural language processing.
(4) By exposing the nature of the relevant descriptionspaces, they may open various possibilities for theimplementation f other classification tasks, e.g.,concept learning (Mellish forthcoming).
(5) They may give us more insight into the semantics ofsystem networks and the potential of unification.1 HALLIDAY'S SYSTEM NETWORKSSystem networks, as used in Halliday's Systemic Gram-mar (Hudson (1971), Kress (1976), Winograd (1983)) area way of encoding the choices that must be made in thegeneration of a complex linguistic object and the inter-dependencies between them.
There is actually nothingthat makes such networks pecific to linguistic applica-tions, and so there is no reason why they cannot beapplied to describing the choices involved in othercomplex situations.A system network can be viewed as a graph, some ofwhose nodes are annotated with symbols representingproperties.
The nodes are tied together by the use offour different "connectives", which we shall designateby "1", "{", "}" and "\]" .
In order to be precise aboutCopyright 1988 by the Association for Computational Linguistics.
Permission tocopy without fee all or part of this material is granted providedthat he copies are not made for direct commercial advantage and the CL reference and this copyright notice are included on the first page.
Tocopy otherwise, orto republish, requires a fee and/or specific permission.0362-613X/88/010040-51503.0040 Computational Linguistics Volume 14, Number 1, Winter 1988C.S.
Mellish Implementing Systemic Classification by UnificationgendermA~ulinefeminineneuterexactly what system networks mean, we will present alogical interpretation, where each appearance of a"connective" in a network gives rise to a set of logicalaxioms relating the property symbols (interpreted asunary predicates) appearing with it.A fundamental concept in system networks is that ofthe choice system.
A choice system indicates that, if acertain "entry condition" holds, then the object de-scribed must have exactly one of the properties men-tioned in the system.
Choice systems are denoted byuse of the "1 .
.
.
.
connective".
Thus, Figure 1 indicatesthat masculine, feminine and neuter are mutually exclu-sive and whenever an object has a gender it has one ofthese.
In logic,V x: AMO {feminine(x) masculine(x) neuter(x)}V x: gender(x) =- feminine(x) v masculine(x) vneuter(x)where AMO ("at most one of") is defined by:AM0 S = =/~ 7(s I & $2)sl,s 2 E SSI ~ $2Incidentally, an alternative reading that might suggestitself, namely:V x: gender(x) =- (AMO {feminine(x) masculine(x)neuter(x)} &feminine(x) v masculine(x) vneuter(x))is not adequate, because it allows spurious models, forinstance where there is an object "a"  which satisfies"feminine(a)" and "masculine(a)" but not "gender(a)".Sometimes more than one choice will be relevant,given the same entry conditions.
This is indicated by the"{ .
.
.
.
connective".
For instance, as indicated in Figure2, in some languages a noun may be either singular orplural, and also either masculine or feminine.
Instancesof the "{" connective can be translated into logic bynou l lfma~ul inefemininesingularpluralsimply treating the entry condition of the "{" as that ofall the networks introduced on the right hand side.Thus:V x: AMO {feminine(x) masculine(x)}V x: noun(x) -= feminine(x) v masculine(x)V x: AMO {singular(x) plural(x)}Vx: noun(x) -= singular(x) v plural(x)The final two connectives concern complex entry con-ditions into networks.
A conjunctive ntry condition isdenoted by "}", as shown in Figure 3.
This meanssinggeadexsimply:V x: third(x) & sing(x) -- gender(x)Finally, " \ ] "  introduces a disjunctive ntry condition, sothat the example provided in Figure 4persomddemonstrnumbermeans:V x: personal(x) v demonstr(x) ~ number(x)By convention, uses of the four "connectives" can beconnected together in any way, as long as " loops" arenot created.
That is, if one regards each connective as aset of arcs going from properties on its " left"  toproperties on its "r ight",  the resulting directed graphmust be acyclic.As a larger example, Figure 5 depicts the systemnetwork for English pronouns presented in Winograd(1983)).
Here is a logical translation of selected parts.V x: AMO {first(x) second(x) third(x)}V x: person(x) --- first(x) v second(x) v third(x)V x: AMO {singular(x) plural(x)}V x: numb(x) = singular(x) v plural(x)V x: third(x) & singular(x) -= gender(x)It is important o note that in this paper we considersystem networks as a self-contained notation for de-scribing certain types of choices ("systemic hoices")that are available in the construction of a complex(linguistic) object.
We will be completely ignoring thephilosophical differences between Systemic Grammarand other forms of generative grammar, and we will alsocompletely ignore the other components that are re-quired in a full Systemic Grammar, such as realisationrules.Computational Linguistics Volume 14, Number 1, Winter 1988t41C.S.
Mellish Implementing Systemic Classification by Unificationquestionpersonalfffpersorleaseanimateinanimatesubjectiveobjectivereflexivepossessivepossdetnumbfirstsecondthirdsingularplural~ gender feminine masculineneuterdemonsWativ,nes.Tfax2 SUBSUMPTION AND THE LATTICE OF DESCRIPTIONSThe property symbols in a system network provide abasic vocabulary out of which descriptions can be built.The most obvious way to produce more complex de-scriptions is by conjunction and disjunction.
The logicalinterpretation of such complex descriptions i straight-forward, and we will often blur the distinction betweena description and its interpretation.
Thus:masculine & singular corresponds toAx.
masculine(x) & singular(x)masculine v feminine corresponds toAx.
masculine(x) v feminine(x)A fundamental relationship between descriptions issubsumption:d I subsumes d2 iff ~ ~ V x: d2(x) D dl(x)where E is the set of axioms derived from the network.Note that our notion of subsumption depends vitally on~.
This is a special case of what Buntine (1986) calls"generalised subsumption".
Intuitively d~ subsumes d2if, given the axioms E, d~ is a more general descriptionthan d2.
That is, if dl describes all the objects accuratelydescribed by d2 and maybe more.
Subsumption is apartial ordering on descriptions, and the set of possibledescriptions (properties and all possible finite conjunc-42tions and disjunctions of descriptions made from them j,ordered by subsumption, forms a lattice.
In this lattice,the least upper bound of two descriptions is theirdisjunction and the greatest lower bound is their con-junction.
Figure 6 is a picture of a portion of the latticeconsisting of the descriptions derived from the pronounnetwork.
In the picture, if there is a line going upwardsfrom description d2 to description dl then dl subsumesd 2.
Two descriptions that are logically equivalent (e.g.,"personal&singular" is the same as "singular&case")give rise to a single node in the diagram (technically, weare interested in the quotient lattice of the free latticegenerated by the property symbols, with respect o thecongruence relation defined by E).
To find the node forthe conjunction of two descriptions, one finds thehighest node that is "below" both, i.e., the greatestlower bound.
Similarly, to find the node for the disjunc-tion of two descriptions, one finds the lowest nodewhich is "above" both.3 INCREMENTAL DESCRIPTION REFINEMENTThe previous two sections introduced a simple languageof descriptions and the use of system networks toexpress extra background information about (con-straints on) the terms appearing in those descriptions.
Anotion of subsumption was defined which allowed thisComputational Linguistics Volume 14, Number 1, Winter 1988, (C.S.
Mellish Implementing Systemic Classification by Unificationpersonal singularthird perso 1 &genderJneuterbackground information to be taken into account.
Butwhat are the operations that we need to carry out ondescriptions in practical natural language processingsystems, and does the structure we have describedsupport hese?In this paper, we will concentrate especially on aprocess that seems to arise in a number of contexts innatural language processing--incremental descriptionrefinement.
Incremental description refinement (IDR)takes place when.
a target description is gradually beingbuilt of some individual, and information about thisindividual appears as a sequence of self-contained,independent data descriptions.
For instance, the targetcould be the description of an English sentence and thedata descriptions partial descriptions of this sentencelike:the sentence is passivethe sentence is declarativethe agent of the sentence is the speakerAt any point in an IDR process, the information that hasaccumulated sofar may allow certain properties of theindividual to be inferred, and so one would like to beable to interrogate the partial description that has beenbuilt.
In particular, one would like to be able to answerquestions about which descriptions are compatible andincompatible with the target description.
To build aneffective IDR system, one must have a way to representthe conjunction of an arbitrary set of pieces of informa-tion so that inconsistency and subsumption relation-ships with other descriptions can be easily detected.The term "incremental description refinement" was,we believe, originally coined by Bobrow and Webber(1980), but the notion of incrementally building descrip-tions has been influential in a number of AI projects.In natural anguage processing, IDR is relevant oboth natural language parsing and generation.
In pars-ing, it is natural to accumulate information about thestructure of a phrase gradually as words are read.
Forinstance, in the sentenceThe hairy sheep was .
.
.Computational'Linguistics Volume 14, Number 1, Winter 1988we know after reading the first three words that thegender of the subject noun phrase is "neuter" and afterthe next word we know that the number of that phraseis "singular".
It is important in parsing that we be ableto accumulate pieces of information of this kind anddetect inconsistencies if they arise.
In generation, it isnatural to want to allow different semantic and prag-matic factors to provide separate constraints on asentence to be generated.
For instance, one pragmaticgoal may force a sentence to be passive; another forcesit to have a given surface subject.
This conjunction ofconstraints may be inconsistent with certain choices ofthe main verb (e.g., "buy" vs. "sell").
Again there is aneed to reason about partial descriptions that are builtincrementally.In formal terms, the operations involved in IDR aresimple.
At any point, the information known about thetarget description can be represented without loss by asingle "partial description--the least upper bound of allthe descriptions the target could be.
Initially this issimply the most general description of all ("true").When a new data description appears, the partial de-scription is replaced by the greatest lower bound of itand the data description.
This "algorithm" for IDR is infact a special case of a more general classificationalgorithm given in Mellish (forthcoming).
At any point,a contradiction is signaled by the partial descriptionbecoming the most specific description of all ("false").Moreover, one can validly infer that the target issubsumed by a given description if the partial descrip-tion is.
The only operations that we need for IDR aresubsumption checking and the computation of greatestlower bounds.
This means that, in fact, we do not needthe full lattice structure developed abovenall we needis the meet semi-lattice (Birkhoff (1963)) that containsthe possible data descriptions and all possible conjunc-tions of them.The above description of IDR is not dependent ondescriptions being related to system networks, andindeed IDR has been used in quite different contexts.
Inthis paper, however, we will confine ourselves to thiscase, and consider IDR where the data descriptions areprecisely the properties mentioned ina system network.We are thus concerned with ways of computing andtesting subsumption between conjunctions of proper-ties, given the background information provided by thenetwork axioms.4 USING LOGICAL TERMS TO ENCODE SUBSUMPTIONRELATIONSHIPSThe set of terms used in logic is partially ordered by therelation ("at least as instantiated as") where:t 1 --< t 2 ifft 1 = t20  for some substitution 0Thus for instance, the following statements are true:43C.S.
MeHish Implementing Systemic Classification by Unificationfly,z) -< xf(a,x) --  ,z )f(f(x)) -< fly)Just as we formed a lattice from descriptions, collapsingtogether two descriptions that were logically equivalent,so we can form a lattice from logical terms, collapsingtogether terms which are "variants" (i.e., terms tl andt 2 such that t 1 -< t 2 and t 2 -< t 0.
This lattice, with anecessarily slightly altered version of -< defined on itand with special "top" and "bottom" terms added, isthe lattice of Generalised Atomic Formulae ("GAFlattice") discussed by Reynolds (1970).
In this lattice,the greatest lower bound operation is unification Rob-inson (1965), although for various sublattices the actualoperation may be simpler.The main point of this paper is to investigate when astructure-preserving mapping (l-l, 0-preserving meethomomorphism) can be found from the descriptionlattice arising from a system network to the GAF lattice.Where this is possible, we can use the mapping fromproperty names to logical terms to make terms thatcorrespond to conjunctive descriptions (by unification)and to test subsumption (by testing "less instantiatedthan").
Incompatibility ofdescriptions i also indicatedby unification failure.We will initially illustrate the idea of encoding prop-erties as logical terms by an example.
Let us assumethat we are given the above system network for Englishpronouns.
We might come up with a mapping z fromproperties mentioned in the network to logical termswhich includes the following assignments (variableswhose names are of no importance in the logical termsare denoted here by the symbol "_"):~(animate) = pr(q(an),c(_),no)?
(case) = pr(_,c(_),_)?
(far) = pr(d(far),no,n(_, _))"r(gender) = pr(p(3),c(_),n(s,_))r(neuter) = pr(p(3),c(_),n(s,n))~(numb) = pr( .
.
.
.
n(_,_))r(personal) = pr(p(_),c(_),n(_,_))"r(reflexive) = pr(_,c(refl),_)r(singular) = pr(_,_))?
(third) = pr(p(3),c(_),n(_,_))This mapping is not purely random, but has been chosenso that the logical relationship of subsumption is"echoed" in the "degree of instantiation" ofthe terms.So the idea of the mapping r is to have:Pl subsumes P2 iff rfp 1) --- "r(p 2)Thus, for instance, "gender" subsumes "neuter" and istranslated into a term which is almost identical, butwhich is slightly less instantiated.
The situation issimilar with "case" and "reflexive".
On the otherhand, the terms from "reflexive" and "third" do notdisagree on any non-variable component but neither ismore instantiated than the other.
This reflects the factthat the two properties are compatible but neither is44more general than the other.
In the case of the termsfrom "singular", "third" and "gender", the "gender"term is the least instantiated term that is more instanti-ated than each of the other two (it is the result ofunifying the other two).
This reflects the fact that"gender" is equivalent to the logical conjunction of"third" and "singular".Figure 7 shows a portion of the GAF lattice whosestructure mirrors the part of the pronoun descriptionspace shown in section 2.
In the GAF lattice, one objectis below another if it is more instantiated (less free), andthe greatest lower bound is computed by unification.
Ifpr(pO,c(.
.
. )
,n( .
.
, ,_))  pr(...,_.n(s,_.
))pr(p(3),c(._),n(_,_)) pr(p~,c(_ . )
,n(s ,_ . )
)pr(p(3).
?O.n(s._))pr(p(3 ),c(...),n(sza))we can find a mapping such as r, we can use operationsin the GAF lattice to solve problems in the originaldescription lattice.
For instance, if we have an objectwhich is "neuter" we might be interested to seewhether it can also be "far".
This is not possible, and isindicated by the fact that the two termspr(p(3),c(_),n(s,n))pr(d(far),no,n(_,_))(from "neuter")(from "far")do not unify (the conjunction is the "bottom", or"false" property).
Similarly, we can establish that if anobject is "singular" and "far" then it cannot be "an-imate".
For, unifying the terms for "singular" and"far" we get:pr(d(far),no,n(s,_))which does not unify with the term for "animate".Using r, we can also verify that "reflexive&gender"definitely implies "personal", that "singular" is com-patible with "reflexive", and so on.
It is worth notingthat these inferences involving compatibility and prop-erties that are not "maximally delicate" go beyondthose allowed by previous ystems uch as Patten (1986).This seems to work well, but is there a principledway to produce such mappings into the GAF lattice thatis guaranteed to yield correct results?
For correctness,Computational Linguistics Volume 14, Number 1, Winter 1988C.S.
Mellish Implementing Systemic Classification by Unificationwe need the following to be true for all possible prop-erties p~, P2 .
.
.
.
Pn+l named in the system network:~VX:  P l (X)  & P2(X)  & .
.
.&  pn(X)  ~ Pn+l (X)iff 74pl) II r(p2) II .
.
7(p n) -< ~'(Pn+l)E D Vx: p~(x) &p2(x) & .
.
.&  p~(x) = Fiff {'r(pl)rfp2 ) .
.
~(p~)} is not unifiablewhere ~ is the set of logical axioms derived from thenetwork and II is unification (greatest lower bound inthe GAF lattice).
A sufficient condition for this wouldbe for ~- to be a 1-1, 0-preserving meet-homomorphism(Birkhoff (1963)).In fact, the above mapping does not echo in the GAFlattice the result:D V x: case(x) & numb(x) ~ personal(x)and cannot be straightforwardly extended to do so.
Wethus need to investigate under what conditions uchmappings exist and what algorithms might enable us todiscover them.5 A "BRUTE FORCE ~ TRANSLAT IONThat such mappings always exist, and that inefficientalgorithms exist for discovering them, is demonstratedby a more general result.
If we have a finite set ofpropositional symbols and an arbitrary set of axiomsmentioning these symbols then there is a method ofencoding those symbols as logical terms so that con-junctions are computed by unification and subsumptionbetween conjunctive descriptions (relative to the axi-oms) is reflected in "degree of instantiation".
We canapply this result to the system networks domain be-cause the logical axioms, although not strictly proposi-tional, are equivalent to propositional xioms if we onlyconsider one object being described at a time.The way to construct this encoding is to consider allpossible models of the axioms and the truth assignmentsmade to the symbols in them.
In the case of thepronouns network, there are 54 models of the corre-sponding logical axioms.
The following example showsthe truth assignments made by one of them (this corre-sponds to the pronoun "he").animate = F, case = T, demonstrative = F, far = F,feminine = F, first = F, gender = T, inanimate = F,masculine = T, near = F, neuter = F, numb = T,objective = F, person = T, personal = T, plural = F,possessive = F, possdet = F, pronoun = T, question = F,reflexive = F, second = F, singular = T, subjective = T,third = TIf there are n possible models, each property is repre-sented by a logical term of arity n + 1.
Each such termalso has the same function symbol, the constant "0" asits first argument and the constant "1" as its lastargument.
The other arguments, for a given property,are to be derived as follows.
Each argument starts off asa distinct variable, and then, for each model i whichassigns "F"  to the property, the ith argument is unifiedwith the i + 1 st argument.
In a situation where there arefive possible models, the following example includessome of the terms that might result (again we use "_"for variables with uninteresting names).1 2 3 4 5I I I I If(0 .
.
.
.
.
X ,  X,fro, 0, _, x, x,f(0, X ,  X,  X,  1,1) (p roper ty  exc ludes  on ly  mode l  4)1) (p roper ty  exc ludes  mode ls  1 and  4)1) (p roper ty  exc ludes  mode ls  2, 3, 5)Each such term represents he models that the propertyexcludes by the instantiation of its arguments.
Whentwo such terms are unified, the result is a term thatencodes exclusion of the union of the models excludedby the terms individually.
If the two terms togetherexclude all possible models, the unification fails (thisoccurs if we attempt to unify the last two of the aboveterms).
This is as desired, since excluding all modelsamounts to incompatibility of descriptions.
The tech-nique used here, which amounts to encoding sets asterms, was, we believe, first developed by Alain Col-merauer in another context.
In fact, we can make dowith only n arguments.In general, given a set of n property symbols, therecan be as many as 2 n different models, and so this"brute force" approach is unattractive.
In a situationwhere there are very few models of the logical axioms,however, the encoding scheme might be quite practical.For instance, for the pronoun network the number ofmodels (54) is much smaller than the worst case for thesame number of properties (22s).
The theoretical maxi-mum number of models is reduced by a factor ofroughly 2r/r for every "1" connective with r symbols onits right appearing in the system network.
Moreover,the theoretical maximum is reduced by a factor ofroughly 2 for each property appearing on the right handside of a "{".
The encoding technique is analogous tousing bit strings to encode sets, the only advantagebeing that a contradictory conjunction is flagged imme-diately by a unification failure.
On the other hand, theterms make use of repeated variables, and so thepotential for exploiting parallelism in the unifications irestricted.System networks do not, however, correspond toarbitrary sets of logical axioms.
Only certain kinds ofaxioms can come out of a system network (although auseful characterisation eludes us).
We might thereforehope that, given the extra restrictions, there are betterencoding techniques available, in particular encodingtechniques that do not require the use of repeatedvariables.
We will therefore investigate whether struc-ture-preserving mappings can be found from systemicdescriptions to elements of the lattice of generalisedatomic formulae without repeated variables, which wecall GAF o.Computational Linguistics Volume 14, Number I, Winter 1988 45C.S.
MeUish Implementing Systemic Classification by Unification6 ENCODING FOR THE CONNECTIVES "1~ AND "{~If the only connective used in a system network is "1",a particularly simple encoding scheme is feasible.
Thistechnique has been used in an ad hoc way in a numberof language processing systems written in Prolog, andprobably originates from Dahl (1977).
Consider theexample network depicted in Figure 8, expressing thetop levels of classification ormally used for the plantkingdom.
For such a simple network, we can usefunction symbols more than one argument.
Such asystem has been used by McCord (1986).
Figure 9depicts a version of the "verb" network used byWinograd (1972), simplified to use only "1" and "{".One possible translation from the above property sym-bols into terms includes the following:,(vb) = vb(_,_),(vprt) = vb(vprt,_),(aux) = vb(aux( .
.
.
.
_),_.
)plantv~u~no~v~u~psilopsidansphenopsidanlycopsidanpteropsidanbacterialfungalalgalbryophytefilicinalgymnos~rmA1angiospermalnesting as a means of capturing the subsumption rela-tionships in logical terms.
Thus each property, apartfrom properties at the "leaves" of the tree, is associatedwith a unary function symbol, and the argument of afunction symbol is used for a more "fine grained"description if that is available:,(plant) = plant(_),(vascular) = plant(vascular(_)),(pteropsidan) = plant(vascular(pteropsidan(_))),(angiospermal) = plant(vascular(pteropsidan(angio-spermal)))Where there are alternatives at a given level in theclassification, these are indicated simply by differentfunction symbols appearing in the relevant argumentpositions.
Thus, for instance:*(non_vascular) = plant(non_vascular(_))*(sphenopsidan) = plant(vascular(sphenopsidan))*(filicinal) = plant(vascular(pteropsidan(fdicinal)))*(fungal) = plant(non_vascular(fungal))If the "{" connective is also allowed in system net-works, this means that a given property may haverefinements along several independent dimensions.
Inthe logical terms, this can be allowed for by giving the46*(neg) = vb(aux(neg,_,_),_)*(be) = vb(aux( .
.
.
.
be),_)*(pres) = vb(_,pres)Notice how the "aux" function symbol has arity 3; thiscorresponds to the three independent sub-classifica-tions introduced by the "{" connective.
Similarly, "vb"has arity 2.
The translation from symbols to terms isagain fairly straightforward.Instead of going into detail about the relatively sim-ple problems of dealing with system networks contain-ing only "L" and "{" connectives, we shall concentrateon an algorithm which also allows "}" connectives.This algorithm was used in essence by Bundy et al(1982), although it has not been described before.7 INTRODUCING "}~In this section we describe a generalised translationalgorithm which associates elements of GAF o withproperties displayed in a system network.
The algo-rithm works for networks using the connectives " l" ,"{" and "}", but does not handle networks that useit\],,,For this algorithm, we require in advance a functionA which associates with each node n of the systemComputational Linguistics Volume 14, Number 1, Winter 1988C.S.
Mellish Implementing Systemic Classification by UnificationvbJauxvprtno__vprtprespasteninffnegposqauxno.._qauxbedohavewillmodalnetwork (a possibly labeled location corresponding toone or more "ends"  of connectives) a function symbolA (n).
A is required to be I-1, except hat it should mapall the nodes appearing around a "{" connective to thesame function symbol.
Such a function is easy to definefor a given network; for instance, most nodes can besimply mapped to the names associated with them in thenetwork.
The translation algorithm associates with eachnode of the network a pair iC, P).
The values for C andP are:C = a set of "constraints" describing the termP = a "path"  indicating a (possibly embedded) com-ponent of the term which can become further instan-tiated for terms representing properties ubsumedby the current propertyA path is simply a sequence of alternating functionsymbols and numbers, either empty or starting with afunction symbol, indicating a specific position in a termand the function symbols that appear on the route fromthe outside of the term to this position.
A symbol in thesequence indicates a function symbol that is present,whereas a number selects one of the argument positionsof the last function symbol.
For instance, inf(a, g(X,h(b),i(d,e j(c))))the symbol "c"  appears at the place indicated by thepath (f,2,g,3,i,3,j,1) and the symbol "b"  at the placeindicated by (f,2,g,2,h, 1).
We will make use of two basictypes of extensions of a path P:an extension of P to f, for some function symbol f:If P is 0 then {f)Otherwise if P is (p~, P2 .
.
.
.
i) for somenumber ithen (Pl, P2 .
.
.
.
i,f)Otherwise if P is (Pl, P2 .
.
.
.
s) for somesymbol sthen iP~, P2 .
.
.
.
s,i,f) for some number ian extension of P beyond f, for some functionsymbol f:If P is i) then if, i) for some number iOtherwise if P is iPl, P2 .
.
.
.
i) for somenumber ithen iPl, P2 .
.
.
.
i,f,j) for some number jOtherwise if P is (Pl, P2 .
.
.
.
s) for somesymbol sthen (Pl, P2 .
.
.
.
s,i) for some number iFor instance, for the path if,2,g), two possible exten-sions to h are if,2,g,33,h) and if,2,g, 1,h).
For the pathif, l,g,2) two possible extensions beyond h areif, 1,g,2,h,4) and if, 1 ,g,2,h,6).
Finally, we will have twoways of describing paths that differ, according to thetype of the first component where they disagree:PI and P2 are independent iff their firstdisagreement is on a numberP1 and P2 are inconsistent iff their firstdisagreement is on a function symbolThus (f,2,g,3,h) is independent of if,2,g,4,d,3), andif,2,g,5,a) is inconsistent with if,2,h,4).A constraint is a path used to specify that particularfunction symbols must appear at particular places in aterm.
A term is correctly described by a constraint if thepath makes sense (i.e., all the relevant componentsexist) and the given function symbols do indeed appearat the relevant places.
A term is correctly described bya set of constraints if it is correctly described by all ofthem.
Thus, for instance, the set of constraints:{ ig, 1 ,f,2,a), (g, 1,f,3,b), (g, 1 ,i'), ig) }correctly describes any of the terms:g(f(z,a,b(c)),h(1))g(f(w(x),a(d,f,g),b,x))g(f(w(x),a(g),b),x)The term that is the translation of a node in a systemnetwork is obtained from the set of constraints asfollows.
First of all, each function symbol (element ofthe range of A) is taken to have the same arity (numberof arguments) in all the terms derived from the network.This is the minimal arity such that all the constraintsattached to all the nodes are satisfiable.
Secondly, withComputational Linguistics Volume 14, Number 1, Winter 1988 47C.S.
Mellish Implementing Systemic Classification by Unificationarities fixed in this way, the translation of a property isthe most general (least instantiated) term that is cor-rectly described by the constraints at the property'snode.
Thus, for example, if the arities of a, b, f and gwere 1, 0, 3 and 2 respectively (note that the arity of fmust be at least 3), the following term would be the"solution" of the above set of constraints:g(f(_,a(_),b),_)The following defines a space of possible translationalgorithms.
For each place where alternatives are al-lowed, it does not matter which the algorithm specifies.
(1) Record ({(f)},(f)) as the value for the leftmostnode, where f is the value of A for that node(2) Until there is no connective all of whose left nodeshave translations but none of whose right nodesdo, do the following:(2.1) Select one such connective(2.2) If the connective is " l "  and the left hand node hastranslation (C,P), assign to the ith node ni on theright hand side the translation:(C U to,}, p,~where, for each i, Pi is an extension of P to A (ni),and where Pi is inconsistent with pj if i ~k j.If the connective is "{" and the left hand node Lhas translation (C, P), assign to the ith node on theright hand side the translation:(c, pi)where, for each i, Pi is an extension of P beyond A(L) and where Pi and pj are independent if i ~ j.If the connective is "}" and the two left handnodes have translations (C 1, P1) and (C 2, P2),assign to the node on the right hand side thetranslation:(C 1 U Cz, Pt )with either i = 1 or i =.2.The basic idea is that as one goes to the right in thenetwork, the constraints on a node are the constraintson the nodes to its immediate l ft, together with possi-bly extra constraints to differentiate it from them (ifthey properly subsume it).
At each point, the pathcomponent of a node's translation indicates wherenodes further to the right can be further instantiated.
Ifthe connective is " l " ,  the extra constraints added foreach node on the right amount o forcing the placeindicated by the path to have the function symbolassociated with that node.
Since the paths used for theright hand nodes are inconsistent ,  the terms generatedfor the nodes will be incompatible.
If the connective is"{", the nodes on the right hand side must have thesame constraints as the node on the left.
On the otherhand, each is given a different, slightly longer, path sothat the term can be further instantiated in severalindependent ways.The above algorithm, although not optimal in the48sense of generating the smallest possible terms, is thebasis of one that has generated correct results in prac-tice.
In addition, we have a proof of correctness for it.The proof hinges on the reduction of the correctnesscriterion given in section 4 to the following simpler one.The translation z is correct if for all properties P l, P2 andP3 named in the network:~ V x: pl(x) D P2(X)iff ~Pl) -< "r(P2)~ V X: pl(x) D P2(X)iff "Z ~ P2 = P4&P5 for some P4,P5 in the networkwith P2, P4 and P5 all logically distinctor A(p2) appears in -r(p 0~ V X: pl(x) t~ P2(X) = Fiff {'r(pl)~P2) } is not Unifiable~ V x: pl(x) & pE(x) = p3(x)iff ~(Pl) II r(p2) = ~'(P3)for some function A is introduced above.
The reductioncan be made because of various special properties thathold of system networks that only use " l " ,  "{" and"}":If ~ ~ V x: p1(x) = p2(x)&P3(X), for properties Pl,P2 and P3 mentioned in the network and logicallydistinct, then p~ is equivalent to a property on theright hand side of a "}" connective, and Pz and P3are equivalent to the properties appearing on theleft hand side.If ~ ~ V x: pl(x)&p2(x)&...pn(X) D p(x), forproperties pl .
.
.
.
Pn, P mentioned in the network,then either Z ~ V x: p/(x) D p(x) for some i, or pis equivalent to a property appearing on the right ofa ~'}".If P is a set of properties mentioned in the networkand for every " t"  connective ither no elements ofP lie to the right of that connective or all elementslie to the right of the same right hand branch, thenthe set P is compatible.None of the schemes in this section or the previoussection require repeated variables in the logical terms,and so there is nothing to prevent unification tacklingdifferent components in parallel.
Of course, if one had agreat deal of parallelism available, one could use it toimplement a naive network searcher for testing compat-ibility of two properties (e.g., by searching for therightmost node that appears to the left of both andseeing whether the connective at that point is "\[".
Theimplementation via unification would then be unneces-sary (at least for simple cases).
Thus to a certain extentthe "compilation" of tasks like compatibility- and sub-sumption-checking to unification tasks can be viewedas a special case of compiling OR-parallel programs intoAND-parallel programs (Codish and Shapiro (1986),Ueda (1986)).
The checking can be even faster if theunifications are further compiled (Warren (1977)).
Forinstance, in the verb network, checking that a descrip-Computational Linguistics Volume 14, Number 1, Winter 1988C.S.
Mellish Implementing Systemic Classification by Unificationtion of a verb is compatible with "pres"  simply amountsto seeing whether the third component of the term is nota function symbol different from "pres" .8 INTRODUCING " \ ] "We have intentionally left consideration of the " \ ] "connective to its own section.
This is because we haveno general algorithm (apart from the above "bruteforce" algorithm) for translating system networks with" \ ] "  connectives into logical terms in a way that willcorrectly mirror the subsumption relationships.
Indeed,there is no reason to believe that there are straightfor-ward algorithms for this.First of all, we can easily demonstrate through anexample that networks containing " \ ] "s  cannot be im-plemented using only GAF o.
Thus, something like thefull power of unification is necessary, rather than thesimple subcases we have considered up to now.
Con-sider the system network depicted in Figure 10.
Theentityfa la2bxb2subsumption relationships between properties and con-junctions of properties are shown in Figure I1.
Thisentityal b2 ?al&b2 at&c bl&a2 b~a~Fdiagram must be read with some care, as we have onlyshown the elements of the meet-semilattice onsistingof the data elements and their conjunctions.
This is allthat we need for an IDR application, but it means that,although we can read off from the diagram informationabout greatest lower bounds, we cannot obtain from itinformation about least upper bounds.
Now a~&c andb~&a 2are incompatible, i.e., their greatest lower boundis "F" .
Therefore the terms representing these twodescriptions cannot unify.
If we are not allowing termswith repeated variables, the only way that two termscan fail to unify is by there being some componentwhere the two.
terms take on different non-variablevalues.
Let at&c take the value "y"  in this componentand bl&a 2 take the value "n"  (we do not have toassume that "y"  and "n"  are atomic, merely that their"top level" function symbols are different).
We canthen make various inferences about what other termsshould have in this component:al&c - y (hypothesis)b1&a 2 - n (hypothesis)b~ - -  since it is above al c  and bltYga 2c -_ since it is above bla 2 - n so as to make bl~:r.a 2 when unified with b 1b2tY?a 2 - n since it is below a 2a~ - y so to make a~&c when unified with ca~&b2 - y since it is below a~b E - _  since it is above bEtY?a 2 and altY?b 2Now bE a2 ,  as  well as being the greatest lower boundof b E and a2, is also the greatest lower bound of b 2 andc.
However, unifying the terms for b z and c, the abovespecifies that the particular component will have thevalue "_" .
This conflicts with the value already inferredfor b2&a 2 - "n" .
Therefore, under the constraint ofavoiding repeated variables, it is not possible to producea valid mapping from descriptions to terms.Figure 12 shows the subsumption relationships again,with the descriptions ubstituted by logical terms ob-tained by the "brute force" method.
Of course, re-peated variables have to be used several times.f(O .
.
.
.
.
.
.
1)f (0 .0 .0 ._ .
l )  f(0.0.X.X.1) f (0  .
.
.
.
.
1.1)f(o,o.o.o.1) f(o.o.o.1,1) f(o.1.1.1.1) f(o.o.l.l.x)It is natural to ask what it is about descriptionsarising from networks with " \ ] "  that cannot be modelledComputational Linguistics Volume 14, Number 1, Winter 1988 49C.S.
Mellish Implementing Systemic Classification by Unificationin GAFo.
There is at least one property of GAFo (andany sub-semilattice of it that contains the bottom ele-ment) which is not echoed in description spaces like ourexamples.
Since descriptions from "\ ]"  networks canviolate this property, it follows that GAFo cannot beused accurately to model the description spaces.
Theparticular property is that compatibility is pairwisedetermined:For all sets of elements {tl, t2 .
.
.
.
tn}{tl, t 2 .
.
.
.
tn} compatibleiff t i is compatible with tj for each i, j.
(we say that a set of objects is compatible if theirgreatest lower bound is not the "bottom" element).
Inour example description space, the set {a~, b2, c} is notcompatible, and yet each pair of elements taken from itis compatible.
Thus compatibility is not determinedpairwise in the description space.It seems unlikely in this example that one could comeup with an encoding in the full GAF that would improveon the "brute force" approach.
Indeed, this may oftenbe the case, as networks containing "\]"s are verycomplex to process.
Consider, for instance, Figure 13which is an extension to the above network.entityfa la2ambxbzb,.In choosing logical terms for al, a2, ?
.am, b~, b 2,?
.bn, one has to reflect he fact thatc & a i implies bl (i = 1..m-l)c & b; implies am (i = 2..n)a i&b j&c  is contradictory ( i= 1 .
.m- l , j=  2..n)This certainly prevents the sub-classifications repre-sented by the "a"s  and the "b"s  fi'om being translatedindependently, in the way that could be done in ourportion of Winograd's verb network.9 RELATED WORKA piece of work that is closely related in many ways isKasper's work (Kasper (1986)) on translating SystemicGrammars into functional unification grammars.
Kasperdescribes a way of mapping a system network andfeature choices into a functional description of FUG(Kay (1984)).
Such a mapping induces a mapping fromsystemic descriptions to functional descriptions in sucha way that conjunction of descriptions i computed by(functional) unification of the functional descriptions.Kasper's work represents an extension of ours in that ittreats more than the systemic hoices of a SystemicGrammar, and we are currently investigating how ourframework can best be extended to deal with theseother aspects.
Unfortunately, the functional descriptionthat Kasper builds for anything but a complete (maxi-mally specific) systemic description will contain dis-junctions, and the complexity of functional unificationis seriously affected by the presence of disjunctions.Moreover, Kasper actually needs to extend the notionof functional description in order to produce transla-tions for networks with complex entry conditions.
Sincelogical unification corresponds closely to functionalunification when there are no disjunctive descriptions orordering patterns, our methods can be viewed as tech-niques for mapping systemic descriptions into disjunc-tion-free, conventional functional descriptions.Whereas Kasper's primary aim is for a mapping be-tween a systemic Grammar and a Functional Unifica-tion Grammar (with a mapping between individualdescriptions induced by this), in our case there is only adescription mapping.
It is hard to believe that a unifi-cation grammar allowing exactly those functional de-scriptions corresponding to the terms generated by our"brute force" method would be of much interest.Another elated piece of work is that of Gazdar et al,(forthcoming), which seeks to produce a uniform for-malism for describing legal categories in grammaticalformalisms.
In the case of Systemic Grammar, a "cat-egory" is a set of feature specifications.
The work ofGazdar and his colleagues envisages an implementationof category conjunction by a kind of unification which issimilar to logical unification, except hat there are norepeated variables.
As with Kasper's work, the ap-proach is to provide a translation for the grammar oflegal descriptions.
In this case, however, one product ofthe translation is a set of global constraints on legaldescriptions.
Unfortunately, unification does not pre-serve the validity of these constraints and is not there-fore a correct implementation f greatest lower bound inthe subsumption lattice.
Our approach can be roughlycharacterised asan attempt to find alternative transla-tions where unification is correct because the globalconstraints have been "built in".
To do this, unfortu-nately, we need to allow repeated variables.ACKNOWLEDGEMENTSThis work was carried out as part of a project on naturallanguage generation financed by SERC grant GR/D/50 ComputationaR Linguistics Volume 14, Number 1, Winter 1988C.S.
Meilish Implementing Systemic Classification by Unification08876.
I am current ly supported by an SERC AdvancedFel lowship.REFERENCESBirkhoff, Garrett.
1963 Lattice Theory.
American Mathematical So-ciety.Bundy, Alan; Byrd, Lawrence and Mellish, Chris.
1982 SpecialPurpose, but Domain Independent, Inference Mechanisms.
InSteels, Luc and Campbell, John, Eds., Progress in ArtificialIntelligence.
John Wiley, Chichester, UK: 93-111.Buntine, Wray.
1986 Generalised Subsumption and its Applications toInduction and Redundancy.
In Steels, Luc and DuBoulay, Ben,Eds., Procs of the Seventh European Conference on ArtificialIntelligence.
Brighton, 1986.Codish, Michael and Shapiro, Ehud.
1986 Compiling OR-Parallelisminto AND-Parallelism.
In Shapiro, Ehud, Ed., Procs of the ThirdInternational Conference on Logic Programming.
Springer Ver-lag.Dahl, Veronica.
1977 Un Systeme Deductif d'Interrogation de Ban-ques de Donnes en Espagnol.
PhD dissertation, Groupe d'Intelli-gence Artificielle, University of Marseille-Luminy.Gazdar, Gerald; Klein, Ewan;Pullum, Geoffrey and Sag, Ivan.
1985Generalised Phrase Structure Grammar.
Blackwell.Gazdar, Gerald; Pullum, Geoffrey; Carpenter, Robert; Klein, Ewan;Hukari, Thomas and Levine, Robert.
(to appear) Category Struc-tures.
Computational Linguistics.Hudson, Richard A.
1971 English Complex Sentences: An Introduc-tion to Systemic Grammar.
North Holland.Kasper, Robert.
1986 Systemic Grammar and Functional UnificationGrammar.
In Benson, J. and Greaves, W., Eds., Selected papersfrom the Twelfth International Systemics Workshop.
Ablex, Nor-wood, NJ, USA.Kay, Martin.
1984 Functional Unification Grammar: A Formalism forMachine Translation.
In Procs of COLING-84.
Stanford, July1984.Kress, Gunther, Ed.
1976 Halliday: System and Function in Lan-guage.
Oxford University Press.McCord, Michael C. 1986 Design of a Prolog-based Machine Trans-lation System.
In Shapiro, Ehud, Ed., Procs of the Third Interna-tional Conference on Logic Programming.
Springer Verlag.Mellish, Chris S. (forthcoming) Version Spaces, Description Spacesand Unification.
Research paper, Dept of Artificial Intelligence,University of Edinburgh.Patten, Terry A.
1986 Interpreting Systemic Grammar as a Computa-tional Representation: A Problem Solving Approach to TextGeneration.
PhD thesis, University of Edinburgh.Reynolds, John C. 1970 Transformational Systems and the AlgebraicStructure of Atomic Formulas.
In Meltzer, Bernard and Michie,Donald, Eds., Machine Intelligence 5.
Edinburgh UniversityPress.Robinson, J. Alan.
1965 A Machine-Oriented Logic Based on theResolution Principle.
JACM 12, 23-41.Ueda, Kazunori.
1986 Making Exhaustive Search Programs Deter-ministic.
In Shapiro, Ehud, Ed., Procs of the Third InternationalConference on Logic Programming.
Springer Verlag.Warren, David H. D. 1977 Implementing Prolog: Compiling PredicateLogic Programs: Research Reports 39 and 40, Department ofArtificial Intelligence, University of Edinburgh.Winograd, Terry.
1972 Understanding Natural Language.
AcademicPress.Winograd, Terry.
1983 Language as a Cognitive Process.
Volume 1:Syntax.
Addison Wesley.NOTESAuthor's current address: Department of Artificial Intelligence,University of Edinburgh, 80 South Bridge, EDINBURGH EH11HN, Scotland.Computational Linguistics Volume 14, Number 1, Winter 1988 51
