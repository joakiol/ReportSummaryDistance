Towards Modular Developmentof Typed Unification GrammarsYael Sygal?University of HaifaShuly Wintner?
?University of HaifaDevelopment of large-scale grammars for natural languages is a complicated endeavor: Gram-mars are developed collaboratively by teams of linguists, computational linguists, and computerscientists, in a process very similar to the development of large-scale software.
Grammars arewritten in grammatical formalisms that resemble very-high-level programming languages, andare thus very similar to computer programs.
Yet grammar engineering is still in its infancy: Fewgrammar development environments support sophisticated modularized grammar development,in the form of distribution of the grammar development effort, combination of sub-grammars,separate compilation and automatic linkage, information encapsulation, and so forth.This work provides preliminary foundations for modular construction of (typed) unificationgrammars for natural languages.
Much of the information in such formalisms is encoded bythe type signature, and we subsequently address the problem through the distribution of thesignature among the different modules.
We define signature modules and provide operatorsof module combination.
Modules may specify only partial information about the componentsof the signature and may communicate through parameters, similarly to function calls in pro-gramming languages.
Our definitions are inspired by methods and techniques of programminglanguage theory and software engineering and are motivated by the actual needs of grammardevelopers, obtained through a careful examination of existing grammars.
We show that our def-initions meet these needs by conforming to a detailed set of desiderata.
We demonstrate the utilityof our definitions by providing a modular design of the HPSG grammar of Pollard and Sag.1.
IntroductionDevelopment of large-scale grammars for natural languages is an active area of researchin human language technology.
Such grammars are developed not only for purposesof theoretical linguistic research, but also for natural language applications such asmachine translation, speech generation, and so on.
Wide-coverage grammars are beingdeveloped for various languages (Abeille?, Candito, and Kinyon 2000; XTAG Research?
Department of Computer Science, University of Haifa, 31905 Haifa, Israel.E-mail: yael.sygal@gmail.com.??
Department of Computer Science, University of Haifa, 31905 Haifa, Israel.E-mail: shuly@cs.haifa.ac.il.Submission received: 3 June 2009; revised submission received: 21 June 2010; accepted for publication:14 September 2010.?
2011 Association for Computational LinguisticsComputational Linguistics Volume 37, Number 1Group 2001; Oepen et al 2002; Hinrichs, Meurers, and Wintner 2004; Bender et al 2005;King et al 2005; Mu?ller 2007) in several theoretical frameworks, including TAG (Joshi,Levy, and Takahashi 1975), LFG (Dalrymple 2001), HPSG (Pollard and Sag 1994), andXDG (Debusmann, Duchier, and Rossberg 2005).Grammar development is a complex enterprise: It is not unusual for a single gram-mar to be developed by a team including several linguists, computational linguists, andcomputer scientists.
The scale of grammars is overwhelming?large-scale grammarscan be made up by tens of thousands of line of code (Oepen et al 2000) and mayinclude thousands of types (Copestake and Flickinger 2000).
Modern grammars arewritten in grammatical formalisms that are often reminiscent of very-high-level, declar-ative (mostly logical) programming languages, and are thus very similar to computerprograms.
This raises problems similar to those encountered in large-scale softwaredevelopment (Erbach and Uszkoreit 1990).
Although whereas software engineeringprovides adequate solutions for the programmer, grammar engineering is still in itsinfancy.In this work we focus on typed unification grammars (TUG), and their implementa-tion in grammar-development platforms such as LKB (Copestake 2002), ALE (Carpenterand Penn 2001), TRALE (Meurers, Penn, and Richter 2002), or Grammix (Mu?ller 2007).Such platforms conceptually view the grammar as a single entity (even when it isdistributed over several files), and provide few provisions for modular grammar de-velopment, such as mechanisms for defining modules that can interact with each otherthrough well-defined interfaces, combination of sub-grammars, separate compilationand automatic linkage of grammars, information encapsulation, and so forth.
This isthe main issue that we address in this work.1We provide a preliminary yet thorough and well-founded solution to the problemof grammar modularization.
We first specify a set of desiderata for a beneficial solu-tion in Section 1.1, and then survey related work, emphasizing the shortcomings ofexisting approaches with respect to these desiderata.
Much of the information in typedunification grammars is encoded in the signature, and hence the key is facilitating amodularized development of type signatures.
In Section 2 we introduce a definitionof signature modules, and show how two signature modules combine and how theresulting signature module can be extended to a stand-alone type signature.
We lift ourdefinitions from signatures to full grammar modules in Section 3.
In Section 4 we usesignature modules and their combination operators to work out a modular design ofthe HPSG grammar of Pollard and Sag (1994), demonstrating the utility of signaturemodules for the development of linguistically motivated grammars.
We then outlineMODALE, an implementation of our solutions which supports modular developmentof type signatures in the context of both ALE and TRALE (Section 5).
We show inSection 6 how our solution complies with the desiderata of Section 1.1, and concludewith directions for future research.1.1 MotivationThe motivation for modular grammar development is straightforward.
Like softwaredevelopment, large-scale grammar development is much simpler when the task can becleanly distributed among different developers, provided that well-defined interfacesgovern the interaction among modules.
From a theoretical point of view, modularity1 This article extends and revises Cohen-Sygal and Wintner (2006) and Sygal and Wintner (2008).30Sygal and Wintner Modular Typed Unification Grammarsfacilitates the definition of cleaner semantics for the underlying formalism and theconstruction of correctness proofs.
The engineering benefits of modularity in program-ming languages are summarized by Mitchell (2003, page 235), and are equally valid forgrammar construction:In an effective design, each module can be designed and tested independently.
Twoimportant goals in modularity are to allow one module to be written with littleknowledge of the code in another module and to allow a module to be redesignedand re-implemented without modifying other parts of the system.A suitable notion of modularity should support ?reuse of software, abstraction mech-anisms for information hiding, and import/export relationships?
(Brogi et al 1994,page 1363).
Similarly, Bugliesi, Lamma, and Mello (1994, page 444) state that[a] modular language should allow rich forms of abstraction, parametrization, andinformation hiding; it should ease the development and maintenance of large programsas well as provide adequate support or reusability and separate and efficientcompilation; it should finally encompass a non-trivial notion of program equivalenceto make it possible to justify the replacement of equivalent components.In the linguistic literature, however, modularity has a different flavor which has todo with the way linguistic knowledge is organized, either cognitively (Fodor 1983) ortheoretically (Jackendoff 2002, pages 218?230).
Although we do not directly subscribe tothis notion of modularity in this work, it may be the case that an engineering-inspireddefinition of modules will facilitate a better understanding of the linguistic notion.Furthermore, although there is no general agreement among linguists on the exact formof grammar modularity, a good solution for grammar development must not reflect thecorrectness of linguistic theories but rather provide the computational framework fortheir implementation.To consolidate the two notions of modularity, and to devise a solution that is on onehand inspired by developments in programming languages and on the other useful forlinguists, a clear understanding of the actual needs of grammar developers is crucial.
Afirst step in this direction was done by Erbach and Uszkoreit (1990).
In a similar vein,we carefully explored two existing grammars: the LINGO grammar matrix (Bender,Flickinger, and Oepen 2002),2 which is a framework for rapid development of cross-linguistically consistent grammars; and a grammar of a fragment of modern Hebrew,focusing on inverted constructions (Melnik 2006).
These grammars were chosen sincethey are comprehensive enough to reflect the kind of data large-scale grammars encode,but are not too large to encumber this process.Inspired by established criteria for modularity in programming languages, andmotivated by our observation of actual grammars, we define the following desideratafor a beneficial solution for (typed unification) grammar modularization:Signature focus: Much of the information in typed formalisms is encoded by the signa-ture.
This includes the type hierarchy, the appropriateness specification, and the2 The LINGO grammar matrix is not a grammar per se, but rather a framework for grammar developmentfor several languages.
We focused on its core grammar and several of the resulting, language-specificgrammars.31Computational Linguistics Volume 37, Number 1type constraints.
Hence, modularization must be carried out mainly through thedistribution of the signature between the different modules.3Partiality: Modules should provide means for specifying partial information about thecomponents of a grammar: both the grammar itself and the signature over whichit is defined.Extensibility: Although modules can specify partial information, it must be possible todeterministically extend a module (which can be the result of the combination ofseveral modules) into a full grammar.Consistency: Contradicting information in different modules must be detected whenmodules are combined.Flexibility: The grammar designer should be provided with as much flexibility aspossible.
Modules should not be unnecessarily constrained.
(Remote) Reference: A good solution should enable one module to refer to entitiesdefined in another.
Specifically, it should enable the designer of module Mi to usean entity (e.g., a type or a feature structure) defined in Mj without specifying theentity explicitly.Parsimony: When two modules are combined, the resulting module must include allthe information encoded in each of the modules and the information resultingfrom the combination operation.
Additional information must only be added if itis essential to render the module well-defined.Associativity: Module combination must be associative and commutative: The orderin which modules are combined must not affect the result.
However, this desider-atum is not absolute?it is restricted to cases where the combination formulatesa simple union of data.
In other cases, associativity and commutativity should beconsidered with respect to the benefit the system may enjoy if they are abandoned.Privacy: Modules should be able to hide (encapsulate) information and render it un-available to other modules.The solution we advocate here satisfies all these requirements.
It facilitates col-laborative development of grammars, where several applications of modularity areconceivable: A single large-scale grammar developed by a team. Development of parallel grammars for multiple languages under a singletheory, as in Bender et al (2005), King et al (2005), or Mu?ller (2007).
Here,a core module is common to all grammars, and language-specificfragments are developed as separate modules. A sequence of grammars modeling language development, for examplelanguage acquisition or (historical) language change (Wintner, Lavie, andMacWhinney 2009).
Here, a ?new?
grammar is obtained from a ?previous?grammar; formal modeling of such operations through modulecomposition can shed new light on the linguistic processes that take placeas language develops.3 We restrict ourselves to standard type signatures (as defined by Carpenter [1992] and Penn [2000]),ignoring type constraints which are becoming common in practical systems.
We defer an extension of ourresults to type constraints to future work.32Sygal and Wintner Modular Typed Unification Grammars1.2 Related Work1.2.1 Modularity in Programming Languages.
Vast literature addresses modularity in pro-gramming languages, and a comprehensive survey is beyond the scope of this work.
Asunification grammars are in many ways very similar to logic programming languages,our desiderata and solutions are inspired by works in this paradigm.Modular interfaces of logic programs were first suggested by O?keefe (1985) andGaifman and Shapiro (1989).
Combination operators that were proved suitable forProlog include the algebraic operators ?
and ?
of Mancarella and Pedreschi (1988);the union and intersection operators of Brogi et al (1990); the closure operator of Brogi,Lamma, and Mello (1993); and the set of four operators (encapsulation, union, inter-section, and import) defined by Brogi and Turini (1995).
For a comprehensive survey,see Bugliesi, Lamma, and Mello (1994).The ?merge?
operator that we present in Section 2.4.2 is closely related to unionoperations proposed for logic programming languages.
We define no counterpart ofintersection-type operations, although such operations are indeed conceivable.
Our?attachment?
operation is more in line with Gaifman and Shapiro (1989).1.2.2 Initial Approaches: Modularized Parsing.
Early attempts to address modularity inlinguistic formalisms share a significant disadvantage: The modularization is of theparsing process rather than the grammar.Kasper and Krieger (1996) describe a technique for dividing a unification-basedgrammar into two components, roughly along the syntax/semantics axis.
Their mo-tivation is efficiency; observing that syntax usually imposes constraints on permissiblestructures, and semantics usually mostly adds structure, they propose to parse with thesyntactic constraints first, and apply the semantics later.
This is achieved by recursivelydeleting the syntactic and semantic information (under their corresponding attributesin the rules and the lexicon) for the semantic and syntactic parsers, respectively.
Thisproposal requires that a single grammar be given, from which the two components canbe derived.
A more significant disadvantage of this method is that coreferences betweensyntax and semantics are lost during this division (because reentrancies that representthe connection between the syntax and the semantics are removed).
Kasper and Kriegerobserve that the intersection of the languages generated by the two grammars does notyield the language of the original grammar.Zajac and Amtrup (2000) present an implementation of a pipeline-like compositionoperator that enables the grammar designer to break a grammar into sub-grammars thatare applied in a sequential manner at run-time.
Such an organization is especially usefulfor dividing the development process into stages that correspond to morphologicalprocessing, syntax, semantics, and so on.
The notion of composition here is such thatsub-grammar Gi+1 operates on the output of sub-grammar Gi; such an organizationmight not be suitable for all grammar development frameworks.
A similar idea is pro-posed by Basili, Pazienza, and Zanzotto (2000); it is an approach to parsing that dividesthe task into sub-tasks, whereby a module component Pi takes an input sentence at agiven state of analysis Si and augments this information in Si+1 using a knowledge baseKi.
Here, too, it is the processing system, rather than the grammar, which is modularizedin a pipeline fashion.1.2.3 Modularity in Typed Unification Grammars.
Keselj (2001) presents a modular Head-driven Phrase Structure Grammar (HPSG), where each module is an ordinary HPSGgrammar, including an ordinary type signature, but each of the sets FEAT, TYPE, andRULES is divided into two disjoint sets of private and public elements.
The public33Computational Linguistics Volume 37, Number 1sets consist of those elements that can communicate with elements from correspondingsets in other modules, and private elements are those that are internal to the module.Merging two modules is then defined by set union; in particular, the type hierarchiesare merged by unioning the two sets of types and taking the transitive closure of theunion of the two BCPOs (see Definition 2).
The success of the merge of two modulesrequires that the union of the two BCPOs be a BCPO.While this work is the first to concretely define signature modules, it providesa highly insufficient mechanism for supporting modular grammar development: Therequirement that each module include a complete type hierarchy imposes strong lim-itations on the kind of information that modules can specify.
It is virtually impossibleto specify partial information that is consistent with the complete type hierarchy re-quirement.
Furthermore, module composition becomes order-dependent as we show inExample 8 (Section 2.4.2).
Finally, the only channel of interaction between modules isthe names of the types.
Our work is similar in spirit to Keselj (2001), but it overcomesthese shortcomings and complies with the desiderata of Section 1.1.Kaplan, King, and Maxwell (2002) introduce a system designed for building a gram-mar by both extending and restricting another grammar.
An LFG grammar is presentedto the system in a priority-ordered sequence of files containing phrase-structure rules,lexical entries, abbreviatory macros and templates, feature declarations, and finite-statetransducers for tokenization and morphological analysis.
The grammar can includeonly one definition of an item of a given type with a particular name (e.g., there can beonly one NP rule, potentially with many alternative expansions), and items in a file withhigher priority override lower priority items of the same type with the same name.
Theoverride convention makes it possible to add, delete, or modify rules.
However, when arule is modified, the entire rule has to be rewritten, even if the modifications are minor.Moreover, there is no real concept of modularization in this approach because the onlyinteraction among files is overriding of information.King et al (2005) augment LFG with a makeshift signature to allow modulardevelopment of untyped unification grammars.
In addition, they suggest that any de-velopment team should agree in advance on the feature space.
This work emphasizesthe observation that the modularization of the signature is the key for modular devel-opment of grammars.
However, the proposed solution is ad hoc and cannot be takenseriously as a concept of modularization.
In particular, the suggestion for an agreementon the feature space undermines the essence of modular design.To support rapid prototyping of deep grammars, Bender and Flickinger (2005)propose a framework in which the grammar developer can select pre-written grammarfragments, accounting for common linguistic phenomena that vary across languages(e.g., word order, yes?no questions, and sentential negation).
The developer can spec-ify how these phenomena are realized in a given language, and a grammar for thatlanguage is automatically generated, implementing that particular realization of thephenomenon, integrated with a language-independent grammar core.
This frameworkaddresses modularity in the sense that the entire grammar is distributed between sev-eral fragments that can be combined in different ways, according to the user?s choice.However, the notion of modularity is rather different here, as modules are pre-writtenpieces of code which the grammar designer does not develop and whose interaction heor she has little control over.1.2.4 Modularity in Related Formalisms.
The previously mentioned works emphasize thefact that existing approaches to modular grammar development in the area of unifica-tion grammars are still insufficient.
The same problem has also been addressed in some34Sygal and Wintner Modular Typed Unification Grammarsother, related, formalisms; we now survey such works and discuss the applicability ofthe proposed solutions to the problem of modularity in typed unification grammars.Wintner (2002) defines the concept of modules for CFGs: The set of nonterminalsis partitioned into three disjoint classes of internal, exported, and imported elements.The imported elements are those that are supplied to the module by other modules, theexported elements are those it provides to the outside world, and the internal ones arelocal to it.
Two modules can be combined only if the set of internal elements of eachmodule is disjoint from the exported and imported sets of the other module as well as ifthe exported sets are disjoint.
Then the combination of two modules is done by simplemeasures of set union.
This is the infrastructure underlying the definition of modularHPSG discussed earlier (Keselj 2001).Provisions for modularity have also been discussed in the context of tree-adjoininggrammars (TAG) (Joshi, Levy, and Takahashi 1975).
A wide-coverage TAG may containhundreds or even thousands of elementary trees, and syntactic structure can be redun-dantly repeated in many of them (XTAG Research Group 2001; Abeille?, Candito, andKinyon 2000).
Consequently, maintenance and extension of such grammars is a complextask.
To address these issues, several high-level formalisms were developed (Vijay-Shanker 1992; Candito 1996; Duchier and Gardent 1999; Kallmeyer 2001).
These for-malisms take the metagrammar approach, where the basic units are tree descriptions (i.e.,formulas denoting sets of trees) rather than trees.
Tree descriptions are constructed by atree logic and combined through conjunction or inheritance; a module in this approachis merely a tree description, and modules are combined by means of the control logic.When trees are semantic objects, (i.e., the denotation of tree descriptions), there can bevarious ways to refer to nodes in the trees in order to control the possible combinationof grammar modules.
Several mechanisms have been suggested to facilitate referenceacross modules (Candito 1996; Perrier 2000; Crabbe?
and Duchier 2004; Kahane 2006).The solution that we propose here embraces the idea of moving from concreteobjects (e.g., a concrete type signature) to descriptions thereof; but we take special careto do so in a way that maintains the associativity of the main grammar combinationoperator, in contrast to some earlier approaches (Sygal and Wintner 2009).Debusmann, Duchier, and Rossberg (2005) introduce Extensible Dependency Gram-mar (XDG), which is a general framework for dependency grammars that supportsmodular grammar design.
An XDG grammar consists of dimensions, principles, and alexicon; it characterizes a set of well-formed analyses.
Each dimension is an attributedlabeled graph, and when a grammar consists of multiple dimensions (e.g., multigraphs),they share the same set of nodes.
A lexicon for a dimension is a set of total assignmentsof nodes and labels.
The main mechanism XDG uses to control analyses are principles,that can be either local (imposing a constraint on the possible analysis of a specificdimension) or multi-dimensional (constraining the analysis of several dimensionswith respect to each other).
In XDG, principles are formulated using a type-systemthat includes several kinds of elementary types (e.g., nodes, edges, graphs, and evenmultigraphs) and complex types that are constructed incrementally over the elementarytypes.
Then, parameters range over types to formulate parametric principles.
A feasibleXDG analysis amounts to a labeled graph in which each dimension is a subgraph,such that all (parametric) principles are maintained (this may require nodes in differ-ent subgraphs to be identified).
XDG supports modular grammar design where eachdimension graph is a grammar module, and module interaction is governed throughmulti-dimensional parametric principles.This work emphasizes the importance of types as a mechanism for modularity.Our work shares with XDG the use of graphs as the basic components and the use35Computational Linguistics Volume 37, Number 1of parameters to enforce interaction among modules.
In both works, each moduleintroduces constraints on the type system and interaction among modules throughparameters is used to construct a multigraph in which some of the nodes are identified.In our approach, however, the type system is part of the grammar specification, andmodules are combined via explicit combination operations.
In contrast, in XDG thetype mechanism is used externally, to describe objects, and a general description logic isused to impose constraints.
Another major difference has to do with expressive power:Whereas unification grammars are Turing-equivalent, XDG is probably mildly context-sensitive (Debusmann 2006).The grammar formalism (GF) (Ranta 2007) is a typed functional programminglanguage designed for multilingual grammars.
Ranta introduces a module system forGF where a module can be either one of three kinds: abstract, concrete, or a resourcemodule.
Each of them reflects the kind of data this module may include.
A module oftype abstract includes abstract syntax trees which represent grammatical information,such as semantic or syntactic data.
A module of type concrete includes relations betweentrees in the abstract module and relations between strings in the target language.Communication between modules of these two types is carried out through inheri-tance hierarchies similarly to object-oriented programs.
Resource modules are a meansfor code-sharing, independently of the hierarchies.
The system of modules supportsdevelopment of multilingual grammars through replacement of certain modules withothers.
A given grammar can also be extended by adding new modules.
Additionally, toavoid repetition of code with minor variations, GF allows the grammar writer to defineoperations which produce new elements.GF is purposely designed for multilingual grammars which share a core represen-tation, and individual extensions to different languages are developed independently.As such, the theoretical framework it provides is tailored for such needs, but is lackingwhere general purpose modular applications are considered (see section 1.1 for exam-ples of such conceivable applications).
Mainly, GF forces the developer to pre-decide onthe relations between all modules (through the concrete module and inheritance hierar-chies), whereas in an ideal solution the interaction between all modules should be left tothe development process.
Each module should be able to independently declare its owninterface with other modules; then, when modules combine they may do so in any waythat is consistent with the interfaces of other modules.
Furthermore, reference to mutualelements in GF is carried out only through naming, again resulting in a weak interfacefor module interaction.
Finally, the operations that the grammar writer can define in GFare macros, rather than functions, as they are expanded by textual replacement.2.
Modularization of the Signature2.1 Typed SignaturesWe assume familiarity with theories of (typed) unification grammar, as formulated by,for example, Carpenter (1992) and Penn (2000).
The definitions in this section set thenotation and recall basic notions.
For a partial function F, ?F(x)??
(?F(x)??)
means that Fis defined (undefined) for the value x; ?F(x) = F(y)?
means that either F is defined bothfor x and for y and assigns them equal values or it is undefined for both.Definition 1Given a partially ordered set ?P,?
?, the set of upper bounds of a subset S ?
P is the setSu = {y ?
P | ?x ?
S x ?
y}.36Sygal and Wintner Modular Typed Unification GrammarsFor a given partially ordered set ?P,?
?, if S ?
P has a least element then it is unique,and is denoted min(S).Definition 2A partially ordered set ?P,??
is a bounded complete partial order (BCPO) iff for everyS ?
P such that Su= ?, Su has a least element, called a least upper bound (lub) anddenoted?S.Definition 3A type hierarchy is a non-empty, finite, bounded complete partial order ?TYPE,?.Every type hierarchy ?TYPE,?
always has a least type (written ?
), because thesubset S = ?
of TYPE has the non-empty set of upper bounds, Su = TYPE, which musthave a least element due to bounded completeness.Definition 4Let ?TYPE,?
be a type hierarchy and let x, y ?
TYPE.
If x  y, then x is a supertype of yand y is a subtype of x.
If x  y, x= y and there is no z such that x  z  y and z= x, ythen x is an immediate supertype of y and y is an immediate subtype of x.We follow the definitions of Carpenter (1992) and Penn (2000) in viewing subtypesas greater than their supertypes (hence the least element ?
and the notion of lub), ratherthan the other way round (inducing a glb interpretation), which is sometimes commonin the literature (Copestake 2002).Definition 5Given a type hierarchy ?TYPE,?
and a finite set of features FEAT, an appropriatenessspecification is a partial function, Approp : TYPE ?
FEAT ?
TYPE such that for everyF ?
FEAT:1.
(Feature Introduction) there is a type Intro(F) ?
TYPE such that: Approp(Intro(F),F)?, and for every t ?
TYPE, if Approp(t,F)?, then Intro(F)  t, and2.
(Upward Closure / Right Monotonocy) if Approp(s,F)?
and s  t, thenApprop(t,F)?
and Approp(s,F)  Approp(t,F).Definition 6A type signature is a structure ?TYPE,, FEAT,Approp?, where ?TYPE,?
is a typehierarchy, FEAT is a finite set of features, FEAT and TYPE are disjoint, and Approp is anappropriateness specification.Again, note that type constraints are not addressed in this work.37Computational Linguistics Volume 37, Number 12.2 OverviewWe define signature modules (also referred to as modules herein), which are structuresthat provide a framework for modular development of type signatures.
These structuresfollow two guidelines.1.
Signature modules contain partial information about a signature: part ofthe subtyping relation (sometimes referred to in the literature as typesubsumption) and part of the appropriateness specification.
The key here isa move from concrete type signatures to descriptions thereof; rather thanspecify types, a description is a graph whose nodes denote types andwhose arcs denote elements of the subtyping and appropriatenessrelations of signatures.2.
Modules may choose which information to expose to other modules andhow other modules may use the information they encode.
The denotationof nodes is extended by viewing them as parameters: Similarly toparameters in programming languages, these are entities through whichinformation can be imported to or exported from other modules.
This isdone similarly to the way parametric principles are used by Debusmann,Duchier, and Rossberg (2005).We begin by defining the basic structure of signature modules in Section 2.3.
Wethen introduce (Section 2.4) two combination operators for signature modules whichfacilitate interaction and (remote) reference among modules.
We end this section byshowing how to extend a signature module into a bona fide type signature (Section 2.5).2.3 Signature ModulesThe definition of a signature module is conceptually divided into two levels of in-formation.
The first includes all the genuine information that may be encoded by asignature, such as subtyping and appropriateness relations, types, and so forth.
Thesecond level includes the parametric casting of nodes.
This casting is not part of the coreof a signature, but rather a device that enables advanced module communication.
Con-sequently, we define signature modules in two steps.
First, we define partially specifiedsignatures (PSSs), which are finite directed graphs that encode partial informationabout the signature.
Then, we extend PSSs to signature modules which are structures,based on PSSs, that provide also a complete mechanism for module interaction and(remote) reference.We assume enumerable, disjoint sets TYPE of types, FEAT of features, and NODESof nodes, over which signatures are defined.Definition 7A partially labeled graph (PLG) over TYPE and FEAT is a finite, directed labeled graphP = ?Q,T,,Ap?, where:1.
Q ?
NODES is a finite, nonempty set of nodes.2.
T : Q ?
TYPE is a partial function, marking some of the nodes with types.38Sygal and Wintner Modular Typed Unification Grammars3.
?
Q ?
Q is a relation specifying (immediate) subtyping.4.
Ap ?
Q ?
FEAT ?
Q is a relation specifying appropriateness.A partially specified signature (PSS) over TYPE and FEAT is a partially labeled graphP = ?Q,T,,Ap?, where:5.
T is one to one.6.
??
is antireflexive; its reflexive-transitive closure, denoted ??
?, isantisymmetric.7.
(Relaxed Upward Closure) for all q1, q?1, q2 ?
Q and F ?
FEAT, if(q1,F, q2) ?
Ap and q1 ?q?1, then there exists q?2 ?
Q such that q2 ?q?2 and(q?1,F, q?2) ?
ApA PSS is a finite, directed graph whose nodes denote types and whose edges denotethe subtyping and appropriateness relations.
Nodes can be marked by types throughthe function T, but can also be anonymous (unmarked).
Anonymous nodes facilitatereference, in one module, to types that are defined in another module.
T is one-to-one(item 5), because we require that two marked nodes denote different types.The ??
relation (item 3) specifies an immediate subtyping order over the nodes,with the intention that this order hold later for the types denoted by nodes.
This is why???
is required to be a partial order (item 6).
The type hierarchy of an ordinary typesignature is required to be a BCPO, but current approaches (Copestake 2002) relax thisrequirement to allow more flexibility in grammar design.
Similarly, the type hierarchyof PSSs is partially ordered but this order is not necessarily a bounded complete one.Only after all modules are combined is the resulting subtyping relation extended toa BCPO (see Section 2.5); any intermediate result can be a general partial order.
Relax-ing the BCPO requirement also helps guarantee the associativity of module combination(see Example 8).4Consider now the appropriateness relation.
In contrast to type signatures, Ap is notrequired to be a function.
Rather, it is a relation which may specify several appropriatenodes for the values of a feature F at a node q (item 4).
The intention is that the eventualvalue of Approp(T(q),F) be the lub of the types of all those nodes q?
such that Ap(q,F, q?
).This relaxation reflects our initial motivation of supporting partiality in modular gram-mar development, since different modules may specify different appropriate values ac-cording to their needs and available information.
After all modules are combined, all thespecified values are replaced by a single appropriate value, their lub (see Section 2.5).
Inthis way, each module may specify its own appropriate values without needing to knowthe value specification of other modules.
We do restrict the Ap relation, however, by arelaxed version of upward closure (item 7).
Finally, the feature introduction condition oftype signatures (Definition 5, item 1) is not enforced by signature modules.
This, again,4 The fact that the subtyping relation is only extended to a BCPO after all modules are combined impliesa lack of incrementality in the system that may be problematic for grammar developers, as modulescannot be tested and evaluated independently.
This situation, however, is not unlike the scenario ofprogramming languages, where modules can typically be developed and compiled, but not tested,independently of a complete system.39Computational Linguistics Volume 37, Number 1results in more flexibility for the grammar designer; the condition can be restored, if itis desirable, after all modules combine (see Section 2.5).Example 1A simple PSS P1 is depicted in Figure 1, where solid arrows represent the ??
(subtyp-ing) relation and dashed arrows, labeled by features, the Ap relation.
P1 stipulates twosubtypes of cat, n and v, with a common subtype, gerund.
The feature AGR is appropriatefor all three categories, with distinct (but anonymous) values for Approp(n, AGR) andApprop(v, AGR).
Approp(gerund, AGR) will eventually be the lub of Approp(n, AGR) andApprop(v, AGR), hence the multiple outgoing AGR arcs from gerund.Observe that in P1, ??
is not a BCPO, Ap is not a function, and the feature introduc-tion condition does not hold.Definition 8A pre-signature module over TYPE and FEAT is a structure S = ?P, Int, Imp,Exp?
whereP = ?Q,T,,Ap?
is a PLG and:1.
Int ?
Q is a set of internal types2.
Imp ?
Q is an ordered set of imported parameters3.
Exp ?
Q is an ordered set of exported parameters4.
Int ?
Imp = Int ?
Exp = ?5.
for all q ?
Q such that q ?
Int, T(q)?We refer to elements of (the sequences) Imp and Exp using indices, with the notationImp[i],Exp[j], respectively.A signature module over TYPE and FEAT is a pre-signature module S = ?P, Int,Imp,Exp?
in which P is a PSS.Signature modules extend the denotation of nodes by viewing them as parameters:Similarly to parameters in programming languages, parameters are entities throughwhich information can be imported from or exported to other modules.
The nodesof a signature module are distributed among three sets of internal, imported, andexported nodes.
If a node is internal it cannot be imported or exported; but a nodeFigure 1A partially specified signature, P1.40Sygal and Wintner Modular Typed Unification GrammarsFigure 2A signature module, S1.can be simultaneously imported and exported.
A node which does not belong to anyof the sets is called external.
All nodes denote types, but they differ in the way theycommunicate with nodes in other modules.
As their name implies, internal nodes areinternal to one module and cannot interact with nodes in other modules.
Such nodesprovide a mechanism similar to local variables in programming languages.Non-internal nodes may interact with the nodes in other modules: Imported nodesexpect to receive information from other modules, while exported nodes provide informa-tion to other modules.
External nodes differ from imported and exported nodes in theway they may interact with other modules, and provide a mechanism similar to globalvariables in programming languages.
Because anonymous nodes facilitate reference, inone module, to information encoded in another module, such nodes cannot be internal.The imported and exported nodes are ordered in order to control the assignment ofparameters when two modules are combined, as will be shown subsequently.5 In theexamples, the classification of nodes is encoded graphically as follows:Internal Imported Exported ExternalExample 2Figure 2 depicts a module S1, based on the PSS of Figure 1.
S1 = ?P1, Int1, Imp1,Exp1?,where P1 is the PSS of Figure 1, Int1 = ?, Imp1 = {q4, q5}, and Exp1 = ?.Herein, the meta-variable q (with or without subscripts) ranges over nodes, S (withor without subscripts) ?
over (pre-)signature modules, P (with or without subscripts)over PLGs and PSSs, and Q,T,,Ap (with the same subscripts) over their constituents.2.4 Combination Operators for Signature ModulesWe introduce two operators for combining signature modules.
The first operator, merge,is a symmetric operation which simply combines the information encoded in the two5 In fact, Imp and Exp can be general sets, rather than lists, as long as the combination operations candeterministically map nodes from Exp to nodes of Imp.
For simplicity, we limit the discussion to thefamiliar case of lists, where matching elements from Exp to Imp is done by the location of the elementon the list, see Definitions 13 and 14.41Computational Linguistics Volume 37, Number 1modules.
The second operator, attachment, is a non-symmetric operation which usesthe concept of parameters and is inspired by function composition.
A signature moduleis viewed as a function whose input is a graph with a list of designated importednodes and whose output is a graph with a list of designated exported nodes.
Whentwo signature modules are attached, similarly to function composition, the exportednodes of the second module instantiate the imported parameters of the first module.Additionally, the information encoded by the second graph is added to the informationencoded by the first one.The parametric view of modules facilitates interaction between modules in twochannels: by naming or by reference.
Through interaction by naming, nodes markedby the same type are coalesced.
Interaction by reference is achieved when the importedparameters of the calling module are coalesced with the exported nodes of the calledmodule, respectively.
The merge operation allows modules to interact only throughnaming, whereas attachment facilitates both ways of interaction.For both of the operators, we assume that the two signature modules are consistent:One module does not include types which are internal to the other module and thetwo signature modules have no common nodes.
If this is not the case, nodes, and inparticular internal nodes, can be renamed without affecting the operation.Definition 9Let S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?, S2 = ?
?Q2,T2,2,Ap2?, Int2, Imp2,Exp2?
betwo pre-signature modules.
S1 and S2 are consistent iff all the following conditionshold:1.
{T1(q) | q ?
Int1} ?
{T2(q) | q ?
Q2 and T2(q)?}
= ?2.
{T2(q) | q ?
Int2} ?
{T1(q) | q ?
Q1 and T1(q)?}
= ?3.
Q1 ?
Q2 = ?We begin by introducing the compactness algorithm which is used when twomodules are combined as a mechanism to coalesce corresponding nodes in the twomodules.2.4.1 Compactness.
When two modules are combined, a crucial step in the combination isthe identification of corresponding nodes in the two modules that should be coalesced.Such pairs of nodes can be either of two kinds:1.
Two typed nodes which are labeled by the same type should be coalesced(along with their attributes).2.
Two anonymous nodes which are indistinguishable, that is, haveisomorphic environments, should be coalesced.
The environment of anode q is the subgraph that includes all the reachable nodes via any kindof arc (from q or to q) up to and including a typed node.
The intuition isthat if two anonymous nodes have isomorphic environments, then theycannot be distinguished and therefore should coincide.
Two nodes, onlyone of which is anonymous, can still be otherwise indistinguishable.
Suchnodes will, eventually, be coalesced, but only after all modules arecombined (to ensure the associativity of module combination).42Sygal and Wintner Modular Typed Unification GrammarsAdditionally, during the combination of modules, some arcs may become redun-dant (such arcs are not prohibited by the definition of a module).
Redundant arcs canbe of two kinds:1.
A subtyping arc (q1, q2) is redundant if it is a member of the transitiveclosure of , where  excludes (q1, q2).2.
An appropriateness arc (q1,F, q2) is redundant if there exists q3 ?
Q suchthat q2 ?q3 and (q1,F, q3) ?
Ap.
(q1,F, q2) is redundant due to the lubintention of appropriateness arcs: The eventual value of Approp(T(q1),F)will be an upper bound of (at least) both q2 and q3.
Because q2 ?q3,(q1,F, q2) is redundant.Redundant arcs encode information that can be inferred from other arcs and thereforemay be removed without affecting the data encoded by the signature module.While our main interest is in signature modules, the compactness algorithm isdefined over the more general case of pre-signature modules.
This more generalnotion will be helpful in the definition of module combination.
Informally, when apre-signature module is compacted, redundant arcs are removed, nodes marked bythe same type are coalesced, and anonymous indistinguishable nodes are identified.Additionally, the parameters and arities are induced from those of the input pre-signature module.
All parameters may be coalesced with each other, as long as they areotherwise indistinguishable.
If (at least) one of the coalesced nodes is an internal node,then the result is an internal node.
Otherwise, if one of the nodes is imported thenthe resulting parameter is imported as well.
Similarly, if one of the nodes is exportedthen the resulting parameter is exported.
Notice that in the case of signature modules,because T is one to one, an internal node may be coalesced only with other internalnodes.The actual definitions of indistinguishability and the compactness algorithm aremostly technical and are therefore deferred to the Appendix.
We do provide two simpleexamples to illustrate the general idea.Example 3Consider the signature module of Figure 3.
(q1, q4) is a redundant subtyping arc be-cause even without this arc, there is a subtyping path from q1 to q4.
(q1,F, q3) is aredundant appropriateness arc: Eventually the appropriate value of q1 and F should bethe lub of q3 and q5, but since q5 is a subtype of q3, it is sufficient to require that it be atleast q5.Example 4Consider S2, the pre-signature module depicted in Figure 4.
Note that S2 is not asignature module (because it includes two nodes labeled by a) and that compactnessis defined over pre-signature modules rather than signature modules as this is the casefor which it will be used during combination.
In compact(S2), q1 and q2 are coalescedbecause they are both marked by the type a. Additionally, q3 and q6 are coalesced with q4and q7, respectively, because these are two pairs of anonymous nodes with isomorphicenvironments.
q5 is not coalesced with q3 and q4 because q5 is typed and q3 and q4 arenot, even though they are otherwise indistinguishable.
q8 is not coalesced with q6 andq7 because they are distinguishable: q8 has a supertype marked by a whereas q6 and q7have anonymous supertypes.43Computational Linguistics Volume 37, Number 1Figure 3A signature module with redundant arcs.Figure 4Compactness.2.4.2 Merge.
The merge operation combines the information encoded by two signaturemodules: Nodes that are marked by the same type are coalesced along with theirattributes.
Nodes that are marked by different types cannot be coalesced and mustdenote different types.
The main complication arises when two anonymous nodes areconsidered?such nodes are coalesced only if they are indistinguishable.The merge of two modules is defined in several stages: First, the two graphs areunioned (this is a simple pointwise union of the coordinates of the graph, see Defi-nition 10).
Then, the resulting graph is compacted, coalescing nodes marked by thesame type as well as indistinguishable anonymous nodes.
However, the resulting graphdoes not necessarily maintain the relaxed upward closure condition, and therefore somemodifications are needed.
This is done by Ap-Closure (see Definition 11).
Finally, theaddition of appropriateness arcs may turn two anonymous distinguishable nodes intoindistinguishable ones and may also add redundant arcs, therefore another compact-ness step is needed (Definition 12).Definition 10Let S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?, S2 = ?
?Q2,T2,2,Ap2?, Int2, Imp2,Exp2?
betwo consistent pre-signature modules.
The union of S1 and S2, denoted S1 ?
S2, is thepre-signature moduleS = ?
?Q1 ?
Q2,T1 ?
T2,1 ?
2,Ap1 ?
Ap2?, Int1 ?
Int2, Imp1 ?
Imp2,Exp1 ?
Exp2?
(where ???
is the concatenation operator).44Sygal and Wintner Modular Typed Unification GrammarsDefinition 11Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
The Ap-Closure of S,denoted ApCl(S), is the pre-signature module ??Q,T,,Ap?
?, Int, Imp,Exp?
whereAp?
= {(q1,F, q2) | q1, q2 ?
Qand there exists q?1 ?
Q such thatq?1? q1 and (q?1,F, q2) ?
Ap}Ap-Closure adds to a pre-signature module the required arcs for it to maintainthe relaxed upward closure condition: Arcs are added to create the relations betweenelements separated between the two modules and related by mutual elements.
Noticethat Ap ?
Ap?
by choosing q?1 = q1.Two signature modules can be merged only if the resulting subtyping relation isindeed a partial order, where the only obstacle can be the antisymmetry of the resultingrelation.
The combination of the appropriateness relations, in contrast, cannot causethe merge operation to fail because any violation of the appropriateness conditionsin signature modules can be deterministically resolved.
Note that our specificationlanguage does not support inequations; there is no way to specify that two nodes mustnot be identified with each other.
Such extensions are indeed possible, but are beyondthe scope of this work.Definition 12Let S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?, S2 = ?
?Q2,T2,2,Ap2?, Int2, Imp2,Exp2?
betwo consistent signature modules.
S1,S2 are mergeable if there are no q1, q2 ?
Q1 andq3, q4 ?
Q2 such that the following hold:1. q1= q2 and q3= q42.
T1(q1)?, T1(q2)?, T2(q3)?
and T2(q4)?3.
T1(q1) = T2(q4) and T1(q2) = T2(q3)4. q1 ?1 q2 and q3 ?2 q4If S1 and S2 are mergeable, then their merge, denoted S1 uniondbl S2, is:compact(ApCl(compact(S1 ?
S2)))In the merged module, pairs of nodes marked by the same type and pairs ofindistinguishable anonymous nodes are coalesced.
An anonymous node cannot becoalesced with a typed node, even if they are otherwise indistinguishable, becausethat would result in a non-associative combination operation.
Anonymous nodes areassigned types only after all modules combine (see Section 2.5.1).If a node has multiple outgoing Ap-arcs labeled with the same feature, these arcs arenot replaced by a single arc, even if the lub of the target nodes exists in the resulting sig-nature module.
Again, this is done to guarantee the associativity of the merge operation(see Example 9).45Computational Linguistics Volume 37, Number 1Figure 5Merge: intermediate steps.Example 5Let S3 and S4 be the signature modules depicted in Figure 5.
S3 uniondbl S4 and the intermediatepre-signature modules are also shown in this figure.
First, S3 and S4 are unioned.
Then,in compact(S3 ?
S4) the two nodes typed by a are coalesced, as are the nodes typed byc.
Notice that this pre-signature module is not a signature module because it does notmaintain the relaxed upward closure condition.
To enforce this condition appropriate-ness arcs are added to yield ApCl(compact(S3 ?
S4)), but this signature module includesindistinguishable anonymous nodes and therefore another compactness operation isrequired to yield the final result.Example 6Figure 6 depicts a naive agreement module, S5.
Combined with S1 of Figure 1, S1 uniondbl S5 =S5 uniondbl S1 = S6.
All dashed arrows are labeled AGR, but these labels are suppressed forreadability.In what follows, by standard convention, Ap arcs that can be inferred by upwardclosure are not depicted.Figure 6Merge.46Sygal and Wintner Modular Typed Unification GrammarsExample 7Let S7 and S8 be the signature modules depicted in Figure 7.
S7 includes generalagreement information and S8 specifies detailed values for several specific properties.Then, S7 uniondbl S8 = S8 uniondbl S7 = S9.
In this way, the high level organization of the agreementmodule is encoded by S7, and S8 provides low level details pertaining to each agreementfeature individually.The following example motivates our decision to relax the BCPO condition anddefer the conversion of signature modules to BCPOs to a separate resolution stage(Section 2.5).Example 8Let S10,S11,S12 be the signature modules depicted in Figure 8.
The merge of S10 with S11results in a non-BCPO.
However, the additional information supplied by S12 resolvesthe problem, and S10 uniondbl S11 uniondbl S12 is bounded complete.Example 9Let S13,S14,S15 be the signature modules depicted in Figure 9.
In S13 the appropriatevalue for a and F is b and in S14 it is c. Hence S13 uniondbl S14 states that the appropriate valuefor a and F should be lub(b, c).
Although in this module there is no such element, in S15lub(b, c) is determined to be d. In S13 uniondbl S14 uniondbl S15 the two outgoing arcs from the nodemarked by a are not replaced by a single arc whose target is the node marked by d, sinceFigure 7Merge.47Computational Linguistics Volume 37, Number 1Figure 8BCPO relaxation.Figure 9Merge of signature modules.other signature modules may specify that the lub of b and c is some type other than d.These multiple outgoing arcs are preserved to maintain the associativity of the mergeoperation.Proposition 1Merge is commutative: For any two signature modules, S1,S2, Let S = S1 uniondbl S2 and S?
=S2 uniondbl S1 where P,P?
are their underlying PSSs, respectively.
Then P = P?.
In particular,either both are defined or both are undefined.The proof follows immediately from the fact that the merge operation is defined byset union and equivalence relations which are commutative operations.Proposition 2Merge is associative up to isomorphism:6 for all S1,S2,S3, Let S = (S1 uniondbl S2) uniondbl S3 andS?
= S1 uniondbl (S2 uniondbl S3) where P,P?
are their underlying PSSs, respectively.
Then P ?
P?.6 The definition of signature module isomorphism is a simple extension of graph isomorphism; see theAppendix for more details.48Sygal and Wintner Modular Typed Unification GrammarsThe proof of associativity is similar in spirit to the proof of the associativity of (polar-ized) forest combination (Sygal and Wintner 2009) and is therefore suppressed.2.4.3 Attachment.
Consider again S1 and S9, the signature modules of Figures 1 and7, respectively.
S1 stipulates two distinct (but anonymous) values for Approp(n, AGR)and Approp(v, AGR).
S9 stipulates two nodes, typed nagr and vagr, with the intentionthat these nodes be coalesced with the two anonymous nodes of S1.
However, the?merge?
operation defined in the previous section cannot achieve this goal, since the twoanonymous nodes in S1 have different attributes from their corresponding typed nodesin S9.
In order to support such a unification of nodes we need to allow a mechanismthat specifically identifies two designated nodes, regardless of their attributes.
Theparametric view of nodes facilitates exactly such a mechanism.The attachment operation is an asymmetric operation, like function composition,where a signature module, S1, receives as input another signature module, S2.
Theinformation encoded in S2 is added to S1 (as in the merge operation), but additionally,the exported parameters of S2 are assigned to the imported parameters of S1: Each ofthe exported parameters of S2 is forced to coalesce with its corresponding importedparameter of S1, regardless of the attributes of these two parameters (i.e., whether theyare indistinguishable or not).Definition 13Let S1= ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?
and S2= ?
?Q2,T2,2,Ap2, ?, Int2, Imp2, Exp2?be two consistent signature modules.
S2 can be attached to S1 if the following conditionshold:1.
|Imp1| = |Exp2|2.
for all i, 1 ?
i ?
|Imp1|, if T1(Imp1[i])?
and T2(Exp2[i])?, thenT1(Imp1[i]) = T2(Exp2[i])3.
S1 and S2 are mergeable4.
for all i, j, 1 ?
i ?
|Imp1| and 1 ?
j ?
|Imp1|, if Imp1[i] ?1 Imp1[j], thenExp2[j]?2 Exp2[i]The first condition requires that the number of formal parameters of the calling modulebe equal to the number of actual parameters in the called module.
The second conditionstates that if two typed parameters are attached to each other, they are marked by thesame type.
If they are marked by two different types they cannot be coalesced.7 Finally,the last two conditions guarantee the antisymmetry of the subtyping relation in theresulting signature module: The third condition requires the two signature modules tobe mergeable.
The last condition requires that no subtyping cycles be created by theattachment of parameters: If q1 is a supertype of q?1 in S1 and q2 is a supertype of q?2 inS2, then q?2 and q2 cannot be both attached to q1 and q?1, respectively.
Notice that as in themerge operation, two signature modules can be attached only if the resulting subtyping7 A variant of attachment can be defined in which if two typed parameters, which are attached to eachother, are marked by two different types, then the type of the exported node overrides the type of theimported node.49Computational Linguistics Volume 37, Number 1relation is indeed a partial order, where the only obstacle can be the antisymmetry of theresulting relation.
The combination of the appropriateness relations, in contrast, cannotcause the attachment operation to fail because any violation of the appropriatenessconditions in signature modules can be deterministically resolved.8Definition 14Let S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?
and S2 = ?
?Q2,T2,2,Ap2, ?, Int2, Imp2, Exp2?be two consistent signature modules.
If S2 can be attached to S1, then the attachment ofS2 to S1, denoted S1(S2), is: S1(S2) = compact(ApCl(compact(S))), where S = ?
?Q,T,,Ap?, Int, Imp,Exp?
is defined as follows: Let ?
be an equivalence relation over Q1 ?
Q2defined by the reflexive and symmetric closure of {(Imp1[i],Exp2[i]) | 1 ?
i ?
|Imp1|}.Then: Q = {[q]?
| q ?
Q1 ?
Q2} T([q]?)
={T1 ?
T2(q?)
there exists q?
?
[q]?
such that T1 ?
T2(q?)??
otherwise = {([q1]?, [q2]?)
| ?q?1 ?
[q1]?
and ?q?2 ?
[q2]?
and (q?1, q?2) ?1 ?
2} Ap = {([q1]?,F, [q2]?)
| ?q?1 ?
[q1]?
and ?q?2 ?
[q2]?
and (q?1,F, q?2) ?Ap1 ?
Ap2} Int = {[q]?
| q ?
Int1 ?
Int2} Imp = {[q]?
| q ?
Imp1} Exp = {[q]?
| q ?
Exp1} the order of Imp and Exp is induced by the order of Imp1 and Exp1,respectivelyWhen a module S2 is attached to a module S1, all the exported nodes of S2 are firstattached to the imported nodes of S1, respectively, through the equivalence relation,???.
In this way, for each imported node of S1, all the information encoded by thecorresponding exported node of S2 is added.
Notice that each equivalence class of???
contains either one or two nodes.
In the former case, these nodes are either non-imported nodes of S1 or non-exported nodes of S2.
In the latter, these are pairs of animported node of S1 and its corresponding exported node from S2.
Hence ???
is triviallytransitive.
Then, similarly to the merge operation, pairs of nodes marked by the sametype and pairs of indistinguishable anonymous nodes are coalesced.
In contrast to themerge operation, in the attachment operation two distinguishable anonymous nodes, aswell as an anonymous node and a typed node, can be coalesced.
This is achieved by theparametric view of nodes and the view of one module as an input to another module.The imported and exported nodes of the resulting module are the equivalenceclasses of the imported and exported nodes of the first module, S1, respectively.
Thenodes of S2 which are neither internal nor exported are classified as external nodes in theresulting module.
This asymmetric view of nodes stems from the view of S1 receivingS2 as input: In this way, S1 may import further information from other modules.8 Relaxed variants of these conditions are conceivable; for example, one can require |Imp1| ?
|Exp2| ratherthan |Imp1| = |Exp2|; or that T1(Imp1[i]) and T2(Exp2[i]) be consistent rather than equal.50Sygal and Wintner Modular Typed Unification GrammarsNotice that in the attachment operation internal nodes facilitate no interactionbetween modules, external nodes facilitate interaction only through naming, and im-ported and exported nodes facilitate interaction both through naming and by reference.Example 10Consider again S1 and S9, the signature modules of Figures 1 and 7, respectively.
LetS1a and S9a be the signature modules of Figure 10 (these signature modules have thesame underlying graphs as those of S1 and S9, respectively, with different classificationof nodes).
Notice that all nodes in both S1a and S9a are non-internal.
Let Imp1a = ?q4, q5?and let Exp9a = ?p9, p10?.
S1a(S9a) is depicted in the same figure.
Notice how q4, q5 arecoalesced with p9, p10, respectively, even though q4, q5 are anonymous and p9, p10 aretyped and each pair of nodes has different attributes.
Such unification of nodes cannotbe achieved with the merge operation.Figure 10Attachment.51Computational Linguistics Volume 37, Number 12.4.4 Example: Parametric Lists.
Lists and parametric lists are extensively used in typedunification-based formalisms, for example in HPSG.
The mathematical foundationsfor parametric lists were established by Penn (2000).
As an example of the utility ofsignature modules and the attachment operation, we show how they can be used toconstruct parametric lists in a straightforward way.Consider Figure 11.
The signature module List depicts a parametric list module.
Itreceives as input, through the imported node q3, a node which determines the type ofthe list members.
The entire list can then be used through the exported node q4.
Noticethat q2 is an external anonymous node.
Although its intended denotation is the typene list, it is anonymous in order to be unique for each copy of the list, as will be shownsubsequently.
Now, if Phrase is a simple module consisting of one exported node, of typephrase, then the signature module obtained by List(Phrase) is obtained by coalescing q3,the imported node of List with the single exported node of Phrase.Other modules can now use lists of phrases; for example, the module Struct usesan imported node as the appropriate value for the feature COMP-DTRS.
Via attachment,this node can be instantiated by List(Phrase) as in Struct(List(Phrase)).
The single nodeof Phrase instantiates the imported node of List, thus determining a list of phrases.
Theentire list is then attached to the signature module Struct, where the root of the listinstantiates the imported node typed by phrase list in Struct.More copies of the list with other list members can be created by different calls to themodule List.
Each such call creates a unique copy of the list, potentially with differenttypes of list elements.
Uniqueness is guaranteed by the anonymity of the node q2 ofList: q2 can be coalesced only with anonymous nodes with the exact same attributes,that is, only with nodes whose appropriate value for the feature FIRST is a node typedFigure 11Implementing parametric lists with signature modules.52Sygal and Wintner Modular Typed Unification Grammarsby phrase.
If q2 would have been typed by ne list it could be coalesced with any othernode marked by the same type, such as other such nodes from different copies of thelist, resulting in a list whose members have various types.
Observe that the uniquenessof each copy of the list could be achieved also by declaring q2 an internal node, but thissolution prevents other modules from referring to this node, as is reasonably desired.
q1(of List) is typed by elist.
Because only one copy of this node is required for all the listcopies, there is no problem with typing this node.Compared with the parametric type signatures of Penn (2000), our implementationof parametric lists is simple and general: It falls out directly as one application ofsignature modules, whereas the construction of Penn requires dedicated machinery(parametric subtyping, parametric appropriateness, coherence, etc.)
We conjecture thatsignature modules can be used to simulate parametric type signatures in the generalcase, although we do not have a proof of such a result.2.4.5 Example: The ?Addendum?
Operator in LKB.
The ?addendum?
operator9 was added tothe type definition language of LKB (Copestake 2002) in 2005, to allow the grammardeveloper to add attributes to an already defined type without the need to repeatpreviously defined attributes of that type.
The need for such an operation arose asa consequence of the development of frameworks that generate grammars from pre-written fragments (e.g., the LINGO grammar matrix, Bender, Flickinger, and Oepen2002), since editing of framework-source files may lead to errors.Signature modules trivially support this operator, either by the merge operation (inwhich case different attributes of a typed node are gathered from different modules)or by attachment, where attributes can be assigned to a specific node, even withoutspecifying its type.2.5 Extending Signature Modules to Type SignaturesSignature modules encode only partial information, and are therefore not required toconform with all the constraints imposed on ordinary signatures.
After modules arecombined, however, the resulting signature module must be extended into a bona fidesignature.
For that purpose we use four algorithms, each of which deals with oneproperty:1.
Name resolution: This algorithm assigns types to anonymous nodes(Section 2.5.1).2.
Appropriateness consolidation: This algorithm determinizes Ap, convertsit from a relation to a function and enforces upward closure (Section 2.5.2).3.
Feature introduction completion: This algorithm (whose use is optional)enforces the feature introduction condition.
This is done using thealgorithm of Penn (2000).4.
BCPO completion: This algorithm extends ??
to a BCPO.
Again, we usethe algorithm of Penn (2000).9 See http://depts.washington.edu/uwcl/twiki/bin/view.cgi/Main/TypeAddendum.53Computational Linguistics Volume 37, Number 1The input to the resolution algorithm is a signature module and its output is a bonafide type signature.Algorithm 1 (Resolve (S))1.
S := NameResolution(S)2.
S := BCPO?Completion(S)3.
S := ApCl(S)4.
S := ApConsolidate(S)5.
S := FeatureIntroductionCompletion(S)6.
S := BCPO?Completion(S)7.
S := ApCl(S)8.
S := ApConsolidate(S)9. return SThe order in which the four algorithms are executed is crucial for guaranteeingthat the result is indeed a bona fide signature.
First, the resolution algorithm assignstypes to anonymous nodes via the name resolution algorithm (stage 1).
The BCPOcompletion algorithm (stage 2) of Penn (2000) adds types as least upper bounds for setsof types which have upper bounds but do not have a minimal upper bound.
However,the algorithm does not determine the appropriateness specification of these types.
Anatural solution to this problem is to use Ap-Closure (stage 3) but this may lead to asituation in which the newly added nodes have multiple outgoing Ap-arcs with thesame label.
To solve the problem, we execute the BCPO completion algorithm beforethe Ap-consolidation algorithm (stage 4), which also preserves bounded completeness.Now, the feature introduction completion algorithm (stage 5) of Penn assumes thatthe subtyping relation is a BCPO and that the appropriateness specification is indeeda function and hence, it is executed after the BCPO completion and Ap-consolidationalgorithms.
However, as Penn observes, this algorithm may disrupt bounded complete-ness and therefore the result must undergo another BCPO completion and thereforeanother Ap-consolidation (stages 6?8).A signature module is extended to a type signature after all the information fromthe different modules have been gathered.
Therefore, there is no need to preserve theclassification of nodes and only the underlying PSS is of interest.
However, because theresolution procedure uses the compactness algorithm which is defined over signaturemodules, we define the following algorithms over signature modules as well.
In caseswhere the node classification needs to be adjusted, we simply take the trivial classifica-tion (i.e., Int = Imp = Exp = ?
).2.5.1 Name Resolution.
During module combination only pairs of indistinguishableanonymous nodes are coalesced.
Two nodes, only one of which is anonymous, can stillbe otherwise indistinguishable but they are not coalesced during combination to ensurethe associativity of module combination.
The goal of the name resolution procedure isto assign a type to every anonymous node, by coalescing it with a typed node with anidentical environment, if one exists.
If no such node exists, or if there is more than onesuch node, the anonymous node is given an arbitrary type.54Sygal and Wintner Modular Typed Unification GrammarsThe name resolution algorithm iterates as long as there are nodes to coalesce.
In eachiteration, for each anonymous node the set of its typed equivalent nodes is computed(stage 1).
Then, using the computation of stage 1, anonymous nodes are coalesced withtheir corresponding typed node, if such a node uniquely exists (stage 2.1).
Coalescing allsuch pairs may result in a signature module that may include indistinguishable anony-mous nodes and therefore the signature module is compacted (stage 2.2).
Compactnesscan trigger more pairs that need to be coalesced, and therefore this procedure is repeated(stage 2.3).
When no pairs that need to be coalesced are left, the remaining anonymousnodes are assigned arbitrary names and the algorithm halts.We first define NodeCoalesce(S, q, q?
): this is a signature module S?
that is obtainedfrom S by coalescing q with q?.Definition 15Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a signature module and let q, q?
?
Q. DefineNodeCoalesce(S, q, q?)
= ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?
where: Q1 = Q\{q} T1 = T |Q1 1= {(q1, q2) | q1  q2 and q1, q2= q} ?
{(p, q?)
| p  q} ?
{(q?, p) | q  p} Ap1 = {(q1,F, q2) | (q1,F, q2) ?
Ap and q1, q2= q} ?
{(p,F, q?)
| (p,F, q) ?
Ap} ?
{(q?,F, p) | (q,F, p) ?
Ap} Int = Imp = Exp = ?The input to the name resolution algorithm is a signature module and its output is asignature module whose typing function, T, is total.
Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?be a signature module, and let NAMES ?
TYPE be an enumerable set of fresh types fromwhich arbitrary names can be taken to mark nodes in Q.
The following algorithm marksall the anonymous nodes in S:Algorithm 2 (NameResolution (S = ?
?Q,T,,Ap?, Int, Imp,Exp?))1.
for all q ?
Q such that T(q)?, compute Qq = {q?
?
Q | T(q?)?
and q?
isequivalent to q}.2. let Q = {q ?
Q | T(q)?
and |Qq| = 1}.
If Q= ?
then:2.1. for all q ?
Q, S := NodeCoalesce(S, q, q?
), where Qq = {q?}2.2.
S := compact(S)2.3. go to (1)3.
Mark remaining anonymous nodes in Q with arbitrary unique types fromNAMES and halt.For a given anonymous node, the calculation of its typed equivalent nodes is mostlytechnical and is therefore suppressed.55Computational Linguistics Volume 37, Number 1Figure 12Name resolution result for S10.Example 11Consider the signature module S6 depicted in Figure 6.
Executing the name resolutionalgorithm on this module results in the signature module of Figure 12 (AGR-labels aresuppressed for readability.)
The two anonymous nodes in S6 are coalesced with thenodes marked nagr and vagr, as per their attributes.
Compare to Figure 1, in particularhow two anonymous nodes in S1 are assigned types from S5 (Figure 6).2.5.2 Appropriateness Consolidation.
For each node q, the set of outgoing appropriatenessarcs with the same label F, {(q,F, q?
)}, is replaced by the single arc (q,F, ql), where ql ismarked by the lub of the types of all q?.
If no lub exists, a new node is added and ismarked by the lub.
The result is an appropriateness relation which is a function, and inwhich upward closure is preserved; feature introduction is dealt with separately.The input to the following procedure is a signature module whose typing func-tion, T, is total; its output is a signature module whose typing function is total andwhose appropriateness relation is a function that maintains upward closure.
Let S =?
?Q,T,,Ap?, Int, Imp,Exp?
be a signature module.
For each q ?
Q and F ?
FEAT, let target(q,F) = {q?
| (q,F, q?)
?
Ap} sup(q) = {q?
?
Q | q?
 q} sub(q) = {q?
?
Q | q  q?
}Algorithm 3 (ApConsolidate (S = ?
?Q,T,,Ap?, Int, Imp, Exp?))1.
Set Int := Imp := Exp := ?2.
Find a node q and a feature F for which |target(q,F)| > 1 and for allq?
?
Q such that q?
?
q, |target(q?,F)| ?
1 (i.e., q is a minimal node withrespect to a topological ordering of Q).
If no such pair exists, halt3.
If target(q,F) has a lub, p, then:(a) for all q?
?
target(q,F), remove the arc (q,F, q?)
from Ap(b) add the arc (q,F, p) to Ap(c) for all q?
?
target(q,F) and for all q??
?
sub(q?
), if p= q??
then add thearc (p, q??)
to 56Sygal and Wintner Modular Typed Unification Grammars4.
(a) Otherwise, If target(q,F) has no lub, add a new node, p, to Q with: sup(p) = target(q,F) sub(p) =?q?
?target(q,F) sub(q?
)(b) Mark p with a fresh type from NAMES(c) For all q?
?
target(q,F), remove the arc (q,F, q?)
from Ap(d) Add (q,F, p) to Ap5.
S := ApCl(S)6.
S := compact(S)7. go to (2)The order in which nodes are selected in step 2 of the algorithm is from supertypesto subtypes.
This is done to preserve upward closure.
When a set of outgoing appro-priateness arcs with the same label F, {(q,F, q?
)}, is replaced by a single arc (q,F, ql), allthe subtypes of all q?
are added as subtypes of ql (stage 3c).
This is done to maintainthe upwardly closed intention of appropriateness arcs (see Example 13).
Additionally,ql is added as an appropriate value for F and all the subtypes of q.
This is achievedby the Ap-Closure operation (stage 5).
Again, this is done to preserve upward closure.If a new node is added (stage 3), then its subtypes are inherited from its immediatesupertypes.
Its appropriate features and values are also inherited from its immediatesupertypes through the Ap-Closure operation (stage 5).
In both stages 3 and 4, a finalstep is compaction of the signature module in order to remove redundant arcs.Example 12Consider the signature module depicted in Figure 12.
Executing the appropriatenessconsolidation algorithm on this module results in the module depicted in Figure 13.Example 13Consider the signature modules depicted in Figure 14.
Executing the appropriatenessconsolidation algorithm on S16, the two outgoing arcs from a labeled with F are firstreplaced by a single outgoing arc to a newly added node, new1, which is the lub ofb and c. During this first iteration, new1 is also added as a supertype of e and f .
Theresult of these operations is S17.
Notice that in S16, the arc (a,F, b) is interpreted as ?theappropriate value of a and F is at least b.?
In particular, this value may be e. S17 maintainsFigure 13Appropriateness consolidation: result.57Computational Linguistics Volume 37, Number 1Figure 14Appropriateness consolidation.this interpretation by means of the subtyping arc that is added from new1 to e. Then, thetwo outgoing arcs from d labeled with F (to e and f ) are replaced by a single outgoing arcto a newly added node, new2, which is the lub of e and f .
The result of these operationsis S18, which is also the final result.3.
Grammar ModulesBefore extending signature modules to grammar modules, we first recall basic notionsof typed unification grammars.
For the following definitions we assume that a typesignature ?TYPE,, FEAT,Approp?
has been specified.Definition 16A path is a finite sequence of features, and the set PATHS = FEAT?
is the collection ofpaths.
 is the empty path.Definition 17A typed pre-feature structure (pre-TFS) is a triple ?
?,?, ?
where: ?
?
PATHS is a non-empty set of Paths ?
: ?
?
TYPE is a total function, assigning a type for all paths ?
?
?
?
is a relation specifying reentrancyA typed feature structure (TFS) is a pre-TFS A = ?
?,?, ?
for which the followingrequirements hold: ?
is prefix-closed: if ??
?
?
then ?
?
?
(where ?,?
?
PATHS) A is fusion-closed: if ??
?
?
and ?
 ??
then ???
?
?
and ??
 ??
?  is an equivalence relation with a finite index (with [] the set of itsequivalence classes) including at least the pair (,) ?
respects the equivalence: if ?1  ?2 then ?
(?1) = ?
(?2)58Sygal and Wintner Modular Typed Unification GrammarsDefinition 18A TFS A = ?
?,?, ?
is well-typed iff whenever ?
?
?
and F ?
FEAT are such that ?F ?
?, then Approp(?(?
),F)?, and Approp(?(?
),F)  ?
(?F).A grammar is defined over a concrete type signature and is a structure including aset of rules (each constructed from a series of TFSs), a lexicon mapping words to sets ofTFSs and a start symbol which is a TFS.We are now ready to define grammar modules and the way in which they interact.A grammar module is a structure M = ?S,G?, where S is a signature module and G is agrammar.
The grammar is defined over the signature module analogously to the wayordinary grammars are defined over type signatures, albeit with two differences:1.
TFSS are defined over type signatures, and therefore each path in the TFSis associated with a type.
When TFSS are defined over signature modulesthis is not the case, because signature modules may include anonymousnodes.
Therefore, the standard definition of TFSS is modified such thatevery path in a TFS is assigned a node in the signature module over whichit is defined, rather than a type.2.
Enforcing all TFSS in the grammar to be well-typed is problematic forthree reasons:(a) Well-typedness requires that ?
(?F) be an upper bound of all the(target) nodes which are appropriate for ?(?)
and F. However,each module may specify only a subset of these nodes.
The wholeset of target nodes is known only after all modules combine.
(b) A module may specify several appropriate values for ?(?)
and F,but it may not specify any upper bound for them.
(c) Well-typedness is not preserved under module combination.
Thenatural way to preserve well-typedness under module combinationrequires addition of nodes and arcs, which would lead to anon-associative combination.To solve these problems, we enforce only a relaxed version of welltypedness.
The relaxation is similar to the way upward closure is relaxed:Whenever ?(?)
= q, ?
(?F) is required to be a subtype of one of the valuesq?
such that (q,F, q?)
?
Ap.
This relaxation supports the partiality andassociativity requirements of modular grammar development(Section 1.1).
After all modules are combined, the resulting grammar isextended to maintain well-typedness.The two combination operators, merge and attachment, are lifted from signaturemodules to grammar modules.
In both cases, the components of the grammars arecombined using simple set union.
This reflects our initial observation (Section 1.1) thatmost of the information in typed formalisms is encoded by the signature, and thereforemodularization is carried out mainly through the distribution of the signature betweenthe different modules; the lifting of the signature combination operation to operationson full grammar modules is therefore natural and conservative.59Computational Linguistics Volume 37, Number 1Figure 15The main fragments of the signature.Figure 16A signature module, Sign.Finally, grammar modules are extended to bona fide typed unification grammarsby extending the underlying signature module into an ordinary type signature andadjusting the grammar accordingly.104.
Modular Construction of the Basic HPSG SignatureTo demonstrate the utility of signature modules for practical grammar engineering weuse signature modules and their combination operators in this section to work out amodular design of the HPSG grammar of Pollard and Sag (1994).
This is a grammar ofEnglish whose signature, covering several aspects of syntax and semantics, is developedthroughout the book.
The signature is given (Pollard and Sag 1994, Appendix A1) as oneunit, making it very hard to conceptualize and, therefore, to implement and maintain.We reverse-engineered this signature, breaking it up into smaller-scale modules thatemphasize fragments of the theory that are more local, and the interactions among suchfragments through ?merge?
and ?attachment?.11 Some of the fragments make use of thesignature module List of Figure 11.10 In practice, an extra adjustment is required in order to restore well-typedness, but we suppress thistechnicality.11 Of course, other ways to break up the given signature to modules are conceivable.
In particular, theSynsem module of Figure 19 may better be broken into two modules.60Sygal and Wintner Modular Typed Unification GrammarsWe begin with a module defining objects (Figure 15), where the type object is themost general type.
This module defines the main fragments of the signature.Figure 16 defines the module Sign.
It consists of the type sign, and its two subtypesword and phrase.
The latter is exported and will be used by other modules, as wepresently show.
In addition, two of the appropriate features of sign are lists; note thatthe values of PHON and RETRIEVED are imported.Next, we consider constituent structure, and in particular headed structures, inFigure 17.
Note in particular that the feature COMP-DTRS, defined at head struc, takesas values a list of phrases; this is an imported type, which is obtained as a result ofseveral attachment operations (Figure 11).Figure 18 describes the fragment of the signature rooted by head.
This is basicallya specification of the inventory of syntactic categories defined by the theory.
Note howsimple it is to add, remove, or revise a category by accessing this fragment only.Figure 19 provides straight-forward definitions of category and synsem, respectively.As another example, Figure 20 depicts the type hierarchy of nominal objects, whichis completely local (in the sense that it does not interact with other modules, exceptat the root).
Finally, Figure 21 abstracts over the internal structure of Phonstring andFigure 17Phrase structure.61Computational Linguistics Volume 37, Number 1Figure 18A signature module, Head.Figure 19Signature modules.Quantifier; these are only representatives of the actual signature modules which definethese fragments.The full HPSG signature consists of several more fragments that we do not depicthere.
With this in mind, the HPSG signature can now be constructed in a modular wayfrom the fragments defined earlier.
The construction is given in Figure 22.First, we produce two lists of phonestring and quantifier, which are merged into onemodule through the operationList(Phonestring) uniondbl List(Quantifier)Then, this module instantiates the two imported nodes phonestring list and quantifier listin the module Sign through the operationSign(List(Phonestring) uniondbl List(Quantifier))Notice how the order of the parameters ensures the correct instantiation.
Now, in thesecond element, List(Sign) both creates a list of phrase (since phrase is an exported62Sygal and Wintner Modular Typed Unification GrammarsFigure 20A classification of nominal objects.Figure 21Parametric signature modules.Figure 22HPSG signature construction.node in the module Sign) and unifies the information in the two modules.
Similarly,ConStruc(List(Sign)) unifies the information in the three modules and instantiates thenode phrase list in the module ConStruc.
In the same way, List(Synsem) both createsa list of synsem (since synsem is an exported node in the module Synsem) and unifiesthe information in the two modules.
Then, Cat(List(Synsem)) unifies the information inthe three modules and instantiates the node synsem list in the module Cat.
Finally, all theinformation from the different modules is unified through the merge operation.
Othermodules can be added, either by merge or by attachment.
Additionally, the internalstructure of each module can be locally modified.
Such changes become much easiergiven the smaller size and theoretical focus of each of the modules.This modular approach has significant advantages over the monolithic approachof Pollard and Sag (1994): The signature of Pollard and Sag is hard to conceptualize63Computational Linguistics Volume 37, Number 1because all the information is presented in a single hierarchy.
In contrast, looking ateach small fragment (module) separately, it is easier to understand the informationencoded in the module.
Contemporary type signatures are in fact much larger; workingwith small fragments in such grammars is instrumental for avoiding or tracking errors.Moreover, grammar maintenance is significantly simplified, because changes can bedone locally, at the level of specific modules.
Of course, when a new grammar is devel-oped from scratch, modularization can be utilized in such a way as to reflect indepen-dent fragments of the linguistic theory in separate modules.While the grammar of Pollard and Sag (1994) is not really large-scale, it is largeenough to reflect the kind of knowledge organization exhibited by linguistically moti-vated grammars, but is at the same time modest enough so that its redesign in a modularway can be easily comprehended.
It is therefore useful as a practical example of howtype signatures can be constructed from smaller, simpler signature modules.
Real-worldgrammars are not only much larger, they also tend to be more complex, and in particularexpress interactions in domains other than the type signature (specifically, as typeconstraints and as phrase-structure rules).
Extending our solution to such interactionsis feasible, but is beyond the scope of this preliminary work.5.
MODALE: A Platform for Modular Development of Type SignaturesTwo leading implementation platforms are available for the development of typedunification grammars: The Linguistic Knowledge Building system (LKB) (Copestake2002) and TRALE (Meurers, Penn, and Richter 2002), an extension of the AttributeLogic Engine (ALE) (Carpenter and Penn 2001).
MODALE (MODular ALE) is a systemthat supports modular development of type signatures in both ALE and TRALE.
Themain features of the system are: The system provides a description language with which signaturemodules can be specified.
The description language is intuitive and is builtupon the description language of ALE.
For example, the description of S1,the signature module of Figure 2, is shown in Figure 23. Signature modules may be combined using either one of the twocombination operators, merge and attachment, or by a complexcombination involving several operators. Signature modules can be resolved to yield bona fide type signatures. The system compiles resolved modules into output files using either ALEor TRALE syntax; these files can be directly manipulated by one of the twosystems. Signature modules can be printed using the syntax of the descriptionlanguage.
This feature allows inspection of a signature module that wascreated as a result of several combination operators.ALE and TRALE share the same underlying core, and are based on data structuresand algorithms that take advantage of type signature properties such as boundedcompleteness, upward closure, and feature introduction, none of which can be assumedwhen working with a signature module.
As a result, our implementation is not a directadaption of the existing ALE/TRALE code, but a new system that was developed from64Sygal and Wintner Modular Typed Unification GrammarsFigure 23MODALE description of S1.scratch.
Extending the algorithms of Penn (2000) from type signatures into signaturemodules is left as a direction for future research.The MODALE system provided us with an opportunity to experimentally evaluatethe time efficiency of module combination.
Indeed, the combination and resolutionalgorithms are computationally inefficient as they require repeated calculations of graphisomorphism, a problem which is neither known to be solvable in polynomial timenor NP-complete.12 However, in the signatures we have experimented with so far, weencountered no time issues.
Furthermore, it is important to note that these calculationsare executed only once, in compile time, and have no impact on the run time ofALE/TRALE, which is the crucial stage in which efficiency is concerned.6.
Discussion and ConclusionsWe presented a complete definition of typed unification grammar modules and theirinteraction.
Unlike existing approaches, our solution is formally defined, mathemati-cally proven, can be easily and efficiently implemented, and conforms to each of thedesiderata listed in Section 1.1, as we now show.Signature focus: Our solution focuses on the modularization of the signature (Sec-tion 2), and the extension to grammar modules (Section 3) is natural and conser-vative.
We do restrict ourselves in this work to standard type signatures withouttype constraints.
We defer the extension of type signatures to include also typeconstraints to future work.Partiality: Our solution provides the grammar developer with means to specify anypiece of information about the signature.
A signature module may specify onlypartial information about the subtyping and appropriateness relations.
Further-more, the appropriateness relation is not a function as in ordinary signatures, and12 Garey and Johnson (1979) provide a list of 12 major problems whose complexity status was open atthe time of writing.
Recognition of graph isomorphism is one of those, and one of the only two whosecomplexity remains unresolved today.65Computational Linguistics Volume 37, Number 1the developer may specify several appropriate nodes for the values of a featureF at a node q.
The anonymity of nodes and relaxed upward closure also providemeans for partiality.
Another relaxation that supports partiality is not enforcingfeature introduction and the BCPO conditions.
Finally, the possibility of distribut-ing the grammar between several modules and the relaxation of well-typednessalso support this desideratum.Extensibility: In Section 2.5 we show how a signature module can be deterministicallyextended into a bona fide signature.Consistency: When modules are combined, either by merge or by attachment, thesignature modules are required to be mergeable or attachable, respectively.
Inthis way, contradicting information in different modules is detected prior to thecombination.
Notice that two signature modules can be combined only if theresulting subtyping relation is indeed a partial order.Flexibility: The only restrictions we impose on modules are meant to prevent subtyp-ing cycles.
(Remote) Reference: This requirement is achieved by the parametric view of nodes.Anonymity of nodes also supports this desideratum.Parsimony: When two modules are combined, they are first unioned; thus the resultingmodule includes all the information encoded in each of the modules.
Additionalinformation is added in a conservative way by compaction and Ap-closure inorder to guarantee that the resulting module is indeed well-defined.Associativity: We provide two combination operations, merge and attachment.
The at-tachment operation is an asymmetric operation, such as the function application,and therefore associativity is not germane.
The merge operation, which is sym-metric, is both commutative and associative and therefore conforms with thisdesideratum.Privacy: Privacy is achieved through internal nodes which encode information thatother modules cannot view or refer to.Modular construction of grammars, and of type signatures in particular, is anessential requirement for the maintainability and sustainability of large-scale grammars.We believe that our definition of signature modules, along with the operations ofmerge and attachment, provide grammar developers with powerful and flexible tools forcollaborative development of natural language grammars, as demonstrated in Section 4.Modules provide abstraction; for example, the module List of Figure 11 defines thestructure of a list, abstracting over the type of its elements.
In a real-life setting, thegrammar designer must determine how to abstract away certain aspects of the devel-oped theory, thereby identifying the interaction points between the defined module andthe rest of the grammar.
A first step in this direction was done by Bender and Flickinger(2005); we believe that we provide a more general, flexible, and powerful framework toachieve the full goal of grammar modularization.This work can be extended in various ways.
First, this work focuses on the modular-ity of the signature.
This is not accidental, and reflects the centrality of the type signaturein typed unification grammars.
An extension of signature modules to include also typeconstraints is called for and will provide a better, fuller solution to the problem ofgrammar modularization.
In a different track, we also believe that extra modularizationcapabilities can still be provided by means of the grammar itself.
This direction is leftfor future research.Although the present work is mainly theoretical, it has important practical implica-tions.
An environment that supports modular construction of large-scale grammars will66Sygal and Wintner Modular Typed Unification Grammarsgreatly contribute to grammar development and will have a significant impact on prac-tical implementations of grammatical formalisms.
The theoretical basis we presentedin this work was implemented as a system, MODALE, that supports modular develop-ment of type signatures (Section 5).
Once the theoretical basis is extended to includealso type constraints, and they, as well as grammar modules, are fully integrated in agrammar development system, immediate applications of modularity are conceivable(see Section 1.1).
Furthermore, although there is no general agreement among linguistson the exact form of modularity in grammar, a good modular interface will provide thenecessary infrastructure for the implementation of different linguistic theories and willsupport their comparison in a common platform.Finally, our proposed mechanisms clearly only fill very few lacunae of existinggrammar development environments, and various other provisions will be needed inorder for grammar engineering to be as well-understood a task as software engineeringnow is.
We believe that we make a significant step in this crucial journey.Appendix: CompactnessWe provide a formal definition of the compactness algorithm in this section.
For anexample of the following two definitions see Example 3.Definition 19Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
(q1, q2) ? is a redun-dant subtyping arc if there exist p1, .
.
.
, pn ?
Q, n ?
1, such that q1  p1  p2  .
.
.
pn  q2.Definition 20Let P = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
(q1,F, q2) ?
Ap is a re-dundant appropriateness arc if there exists q?2 ?
Q such that q2 ?
q?2, q2= q?2 and(q1,F, q?2) ?
Ap.The following definitions set the basis for determining whether two nodes are indis-tinguishable or not.
Because signature modules are just a special case of directed, labeledgraphs, we can adapt the well-defined notion of graph isomorphism to pre-signaturemodules.
Informally, two pre-signature modules are isomorphic when their underlyingPSSs have the same structure; the identities of their nodes may differ without affectingthe structure.
In our case, we require also that an anonymous node be mapped only toan anonymous node and that two typed nodes, mapped to each other, be marked by thesame type.
However, the classification of nodes as internal, imported, and/or exportedhas no effect on the isomorphism since it is not part of the core of the informationencoded by the signature module.Definition 21Two pre-signature modules S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?, S2 = ?
?Q2,T2,2,Ap2?, Int2, Imp2,Exp2?
are isomorphic, denoted S1?S2, if there exists a total, one-to-oneand onto function i (isomorphism) mapping the nodes of S1 to the nodes of S2, suchthat all the following hold:1. for all q ?
Q1, T1(q) = T2(i(q))2. for all q, q?
?
Q1, q 1 q?
iff i(q) 2 i(q?)3.
for all q, q?
?
Q1 and F ?
FEAT, (q,F, q?)
?
Ap1 iff (i(q),F, i(q?))
?
Ap267Computational Linguistics Volume 37, Number 1The environment of a node q is the set of nodes accessible from q via any sequenceof arcs (subtyping or appropriateness, in any direction), up to and including the firsttyped node.
The environment of a typed node includes itself only.Definition 22Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
For all q ?
Q let theenvironment of q, denoted env(q), be the smallest set such that: q ?
env(q) If q??
?
env(q) and T(q??)?
and for some q?
?
Q and F ?
FEAT, either q?
 q?
?or q??
 q?
or (q?,F, q??)
?
Ap or (q?
?,F, q?)
?
Ap, then q?
?
env(q)Definition 23Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module and let Q?
?
Q. Thestrict restriction of S to Q?, denoted S|strictQ?
, is ?
?Q?,T2,2,Ap2?, Int2, Imp2,Exp2?, where: T2 = T|Q? q1 2 q2 iff q1  q2, q1, q2 ?
Q?
and either T(q1)?
or T(q2)?
(or both) (q1,F, q2) ?
Ap2 iff (q1,F, q2) ?
Ap, q1, q2 ?
Q?
and either T(q1)?
or T(q2)?
(or both) Int2 = Int|Q? Imp2 = Imp|Q? Exp2 = Exp|Q?The strict restriction of a pre-signature module, S, to a set of nodes Q?, is thesubgraph induced by the nodes of Q?
without any labeled or unlabeled arcs connectingtwo typed nodes in Q?.Definition 24Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
Two nodes q1, q2 ?
Qare indistinguishable, denoted q1 ?
q2, if S |strictenv(q1 )?
S |strictenv(q2 )via an isomorphism i suchthat i(q1) = q2.Example 14Let S1 be the signature module of Figure A1env(q4) = env(q7) = {q1, q4, q7}, env(q2) = env(q6) = {q1, q2, q6},env(q5) = {q1, q5, q8} and env(q1) = {q1}The strict restrictions of S1 to these environments are depicted in Figure A2.
q2 ?
q4 andq6 ?
q7, where in both cases the isomorphism isi = {q1 ?
q1, q2 ?
q4, q6 ?
q7}68Sygal and Wintner Modular Typed Unification GrammarsFigure A1A signature module with indistinguishable nodes, S1.Figure A2Strict restriction subgraphs.However, q5 is distinguishable from q2 and q4 because T(q8)= T(q6) and T(q8)= T(q7).Notice also that q3 is distinguishable from q2, q4 and q5 because it has no outgoingappropriateness arcs.Proposition 3Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
Then ???
is an equiva-lence relation over Q.Definition 25A pre-signature module S = ?
?Q,T,,Ap?, Int, Imp,Exp?
is non-redundant if it in-cludes no redundant subtyping and appropriateness arcs and for all q1, q2 ?
Q, q1 ?
q2implies q1 = q2.Definition 26Let S = ?
?Q,T,,Ap?, Int, Imp,Exp?
be a pre-signature module.
The coalesced pre-signature module, denoted coalesce(S), is ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?
where: Q1 = {[q]?
| q ?
Q} (Q1 is the set of equivalence classes with respect to ?
) T1([q]?)
= T(q?)
for some q?
?
[q]? 1= {([q1]?, [q2]?)
| (q1, q2) ?}69Computational Linguistics Volume 37, Number 1 Ap1 = {([q1]?,F, [q2]?)
| (q1,F, q2) ?
Ap} Int1 = {[q]?
| q ?
Int} Imp1 = {[q]?
| q ?
Imp and [q]?
/?
Int} Exp1 = {[q]?
| q ?
Exp and [q]?
/?
Int} the order of Imp1 and Exp1 is induced by the order of Imp and Exp,respectively, with recurring elements removedWhen a pre-signature module is coalesced, indistinguishable nodes are identified.Additionally, the parameters and arities are induced from those of the input pre-signature module.
All parameters may be coalesced with each other, as long as theyare otherwise indistinguishable.
If (at least) one of the coalesced nodes is an internalnode, then the result is an internal node.
Otherwise, if one of the nodes is imported thenthe resulting parameter is imported as well.
Similarly, if one of the nodes is exportedthen the resulting parameter is exported.The input to the compactness algorithm is a pre-signature module and its output isa non-redundant signature module which encodes the same information.Algorithm 4 (compact (S = ?
?Q,T,,Ap?, Int, Imp, Exp?))1.
Let S1 = ?
?Q1,T1,1,Ap1?, Int1, Imp1,Exp1?
be such that: Q1 = Q T1 = T 1= {(q1, q2) ?| (q1, q2) is a non-redundant subtyping arc in S} Ap1 = {(q1,F, q2) ?
Ap | (q1,F, q2) is a non-redundantappropriateness arc in S} Int1 = Int Imp1 = Imp Exp1 = Exp2.
S?
= coalesce(S1)3.
If S?
is non-redundant, return S?, otherwise return compact(S?
)The compactness algorithm iterates as long as the resulting pre-signature moduleincludes redundant arcs or nodes.
In each iteration, all the redundant arcs are firstremoved and then all indistinguishable nodes are coalesced.
However, the identifica-tion of nodes can result in redundant arcs or can trigger more nodes to be coalesced.Therefore, the process is repeated until a non-redundant signature module is obtained.Notice that the compactness algorithm coalesces pairs of nodes marked by the sametype regardless of their incoming and outgoing arcs.
Such pairs of nodes may exist in apre-signature module (but not in a signature module).Example 15Consider again S1, the signature module of Figure A1.
The compacted signature moduleof S1 is depicted in Figure A3.
Notice that S1 has no redundant arcs to be removed and70Sygal and Wintner Modular Typed Unification GrammarsFigure A3The compacted signature module of S1.Figure A4A compactness example.that q2 and q6 were coalesced with q4 and q7, respectively.
All nodes in compact(S1) arepairwise distinguishable and no arc is redundant.Example 16Consider S2,S3,S4,S5, the signature modules depicted in Figure A4.
Executing thecompactness algorithm on S2, first the redundant subtyping arc from q1 to q6 is removed,resulting in S3 which has no redundant arcs.
Then, q2 and q3 are coalesced, resulting inS4.
In S4, {q2, q3} ?
{q4} and {q5} ?
{q6}, and after coalescing these two pairs, the resultis S5 which is non-redundant.Proposition 4The compactness algorithm terminates.Proposition 5The compactness algorithm is deterministic: it always produces the same result.Proposition 6If S is a signature module then compact(S) is a non-redundant signature module.Proposition 7If S is a non-redundant signature module then compact(S) ?
S.71Computational Linguistics Volume 37, Number 1AcknowledgmentsThis research was supported by theIsrael Science Foundation (grants 136/01,137/06).
We are grateful to Nurit Melnikand Gerald Penn for extensive discussionsand constructive feedback, and to theCL reviewers for detailed, usefulcomments.
All remaining errors are, ofcourse, our own.ReferencesAbeille?, Anne, Marie-He?le`ne Candito,and Alexandra Kinyon.
2000.
FTAG:developing and maintaining awide-coverage grammar for French.
InErhard Hinrichs, Detmar Meurers, andShuly Wintner, editors, Proceedings of theESSLLI-2000 Workshop on Linguistic Theoryand Grammar Implementation, pages 21?32.Basili, R., M. T. Pazienza, and F. M. Zanzotto.2000.
Customizable modular lexicalizedparsing.
In Proceedings of the SixthInternational Workshop on ParsingTechnologies (IWPT 2000), pages 41?52,Trento.Bender, Emily M., Dan Flickinger, andStephan Oepen.
2002.
The grammarmatrix: An open-source starter-kit for therapid development of cross-linguisticallyconsistent broad-coverage precisiongrammars.
In Proceedings of the Workshopon Grammar Engineering and Evaluationat the 19th International Conference onComputational Linguistics, pages 8?14,Taipei.Bender, Emily M. and Dan Flickinger.
2005.Rapid prototyping of scalable grammars:Towards modularity in extensions to alanguage-independent core.
In Proceedingsof IJCNLP-05, pages 203?208, Jeju Island.Bender, Emily M., Dan Flickinger, FredrikFouvry, and Melanie Siegel.
2005.
Sharedrepresentation in multilingual grammarengineering.
Research on Language andComputation, 3:131?138.Brogi, Antonio, Evelina Lamma, andPaola Mello.
1993.
Composing open logicprograms.
Journal of Logic and Computation,3(4):417?439.Brogi, Antonio, Paolo Mancarella, DinoPedreschi, and Franco Turini.
1990.Composition operators for logic theories.In J. W. Lloyd, editor, ComputationalLogic ?
Symposium Proceedings,pages 117?134.Brogi, Antonio, Paolo Mancarella, DinoPedreschi, and Franco Turini.
1994.Modular logic programming.
ACMTransactions on Programming Languagesand Systems, 16(4):1361?1398.Brogi, Antonio and Franco Turini.
1995.
Fullyabstract compositional semantics for analgebra of logic programs.
TheoreticalComputer Science, 149:201?229.Bugliesi, Michele, Evelina Lamma, andPaola Mello.
1994.
Modularity in logicprogramming.
Journal of LogicProgramming, 19?20:443?502.Candito, Marie-He?le`ne.
1996.
Aprinciple-based hierarchical representationof LTAGs.
In COLING-96, pages 194?199,Copenhagen.Carpenter, Bob.
1992.
The Logic of TypedFeature Structures.
Cambridge Tracts inTheoretical Computer Science.
CambridgeUniversity Press, Cambridge.Carpenter, Bob and Gerald Penn.
2001.ALE?the attribute logic engine: User?sguide.
Technical report, Department ofcomputer science, University of Torontoand SpeechWorks Research.Cohen-Sygal, Yael and Shuly Wintner.
2006.Partially specified signatures: A vehiclefor grammar modularity.
In Proceedingsof the 21st International Conference onComputational Linguistics and 44th AnnualMeeting of the Association for ComputationalLinguistics, pages 145?152, Sydney.Copestake, Ann.
2002.
Implementing typedfeature structures grammars.
CSLIPublications, Stanford, CA.Copestake, Ann and Dan Flickinger.
2000.An open-source grammar developmentenvironment and broad-coverage Englishgrammar using HPSG.
In Proceedingsof the Second Conference on LanguageResources and Evaluation (LREC-2000),pages 591?600.Crabbe?, Benoit and Denys Duchier.
2004.Metagrammar redux.
In Proceedings ofThe International Workshop on ConstraintSolving and Language Processing (CSLP),pages 32?47.Dalrymple, Mary.
2001.
Lexical FunctionalGrammar, volume 34 of Syntax andSemantics.
Academic Press, Oxford.Debusmann, Ralph.
2006.
ExtensibleDependency Grammar: A Modular GrammarFormalism Based On Multigraph Description.Ph.D.
thesis, University of Saarlandes.Debusmann, Ralph, Denys Duchier, andAndreas Rossberg.
2005.
Modulargrammar design with typed parametricprinciples.
In Proceedings of FG-MOL 2005:The 10th Conference on Formal Grammar andThe 9th Meeting on Mathematics of Language,pages 113?122.72Sygal and Wintner Modular Typed Unification GrammarsDuchier, Denys and Claire Gardent.
1999.
Aconstraint-based treatment of descriptions.In Third International Workshop onComputational Semantics (IWCS-3),pages 71?85.Erbach, Gregor and Hans Uszkoreit.
1990.Grammar engineering: Problems andprospects.
CLAUS report 1, Universityof the Saarland and German ResearchCenter for Artificial Intelligence.Fodor, Jerry.
1983.
The Modularity of Mind.MIT Press, Cambridge, MA.Gaifman, Haim and Ehud Shapiro.
1989.Fully abstract compositional semanticsfor logic programming.
In 16th AnnualACM Symposium on Principles of LogicProgramming, pages 134?142, Austin, TX.Garey, Michael R. and David S. Johnson.1979.
Computers and Intractability: A Guideto the Theory of NP-Completeness.
W. H.Freeman, New York.Hinrichs, Erhard W., W. Detmar Meurers,and Shuly Wintner.
2004.
Linguistic theoryand grammar implementation.
Research onLanguage and Computation, 2:155?163.Jackendoff, Ray.
2002.
Foundations ofLanguage.
Oxford University Press, Oxford.Joshi, Aravind K., Leon S. Levy, and MasakoTakahashi.
1975.
Tree adjunct grammars.Journal of Computer and System Sciences,10(1):136?163.Kahane, Sylvain.
2006.
Polarized unificationgrammars.
In Proceedings of the 21stInternational Conference on ComputationalLinguistics and 44th Annual Meeting of theAssociation for Computational Linguistics(COLING-ACL 2006), pages 137?144,Sydney.Kallmeyer, Laura.
2001.
Local treedescription grammars.
Grammars,4(2):85?137.Kaplan, Ronald M., Tracy Holloway King,and John T. Maxwell.
2002.
Adaptingexisting grammars: The XLE experience.In COLING-02 Workshop on GrammarEngineering and Evaluation, pages 1?7,Morristown, NJ.Kasper, Walter and Hans-Ulrich Krieger.1996.
Modularizing codescriptivegrammars for efficient parsing.
InProceedings of the 16th Conference onComputational Linguistics, pages 628?633,Copenhagen.Keselj, Vlado.
2001.
Modular HPSG.
InProceedings of the 2001 IEEE Systems,Man, and Cybernetics Conference,pages 2867?2872, Tucson, AZ.King, Tracy Holloway, Martin Forst, JonasKuhn, and Miriam Butt.
2005.
The featurespace in parallel grammar writing.Research on Language and Computation,3:139?163.Mancarella, Paolo and Dino Pedreschi.1988.
An algebra of logic programs.
InRobert A. Kowalski and Kenneth A.Bowen, editors, Logic Programming:Proceedings of the Fifth InternationalConference and Symposium,pages 1006?1023, Cambridge, MA.Melnik, Nurit.
2006.
A constructionalapproach to verb-initial constructions inmodern Hebrew.
Cognitive Linguistics,17(2):153?198.Meurers, W. Detmar, Gerald Penn, and FrankRichter.
2002.
A Web-based instructionalplatform for constraint-based grammarformalisms and parsing.
In Proceedings ofthe ACL Workshop on Effective Tools andMethodologies for Teaching NLP and CL,pages 18?25.Mitchell, John C. 2003.
Concepts inProgramming Languages.
CambridgeUniversity Press, Cambridge.Mu?ller, Stefan.
2007.
The Grammix CDROM.
A software collection for developingtyped feature structure grammars.
InTracy Holloway King and Emily M.Bender, editors, Grammar Engineeringacross Frameworks 2007, Studies inComputational Linguistics ONLINE.CSLI Publications, Stanford, CA,pages 259?266.Oepen, Stephan, Dan Flickinger, HansUszkoreit, and Jun-Ichi Tsujii.
2000.Introduction to this special issue.
NaturalLanguage Engineering, 6(1):1?14.Oepen, Stephan, Daniel Flickinger, J. Tsujii,and Hans Uszkoreit, editors.
2002.Collaborative Language Engineering: A CaseStudy in Efficient Grammar-Based Processing.CSLI Publications, Stanford, CA.O?Keefe, R. 1985.
Towards an algebra forconstructing logic programs.
In J. Cohenand J. Conery, editors, Proceedings ofIEEE Symposium on Logic Programming,pages 152?160, New York.Penn, Gerald B.
2000.
The Algebraic Structureof Attributed Type Signatures.
Ph.D. thesis,School of Computer Science, CarnegieMellon University, Pittsburgh, PA.Perrier, Guy.
2000.
Interaction grammars.In Proceedings of the 18th Conference onComputational Linguistics (COLING 2000),pages 600?606.Pollard, Carl and Ivan A.
Sag.
1994.Head-Driven Phrase Structure Grammar.University of Chicago Press and CSLIPublications, Stanford, CA.73Computational Linguistics Volume 37, Number 1Ranta, Aarne.
2007.
Modular grammarengineering in GF.
Research on Languageand Computation, 5(2):133?158.Sygal, Yael and Shuly Wintner.
2008.
Typesignature modules.
In Philippe de Groote,editor, Proceedings of FG 2008: The13th Conference on Formal Grammar,pages 113?128.Sygal, Yael and Shuly Wintner.
2009.Associative grammar combinationoperators for tree-based grammars.Journal of Logic, Language and Information,18(3):293?316.Vijay-Shanker, K. 1992.
Using descriptionsof trees in a tree adjoining grammar.Computational Linguistics, 18(4):481?517.Wintner, Shuly.
2002.
Modular context-freegrammars.
Grammars, 5(1):41?63.Wintner, Shuly, Alon Lavie, and BrianMacWhinney.
2009.
Formal grammarsof early language.
In Orna Grumberg,Michael Kaminski, Shmuel Katz, andShuly Wintner, editors, Languages:From Formal to Natural, volume 5533of Lecture Notes in Computer Science.Springer Verlag, Berlin and Heidelberg,pages 204?227.XTAG Research Group.
2001.
A lexicalizedtree adjoining grammar for English.Technical Report IRCS-01-03, IRCS,University of Pennsylvania.Zajac, Re?mi and Jan W. Amtrup.
2000.Modular unification-based parsers.In Proceedings of the Sixth InternationalWorkshop on Parsing Technologies(IWPT 2000), pages 278?288, Trento.74
