Proceedings of COLING 2014, the 25th International Conference on Computational Linguistics: Technical Papers,pages 37?47, Dublin, Ireland, August 23-29 2014.Hierarchical Topical Segmentation with Affinity PropagationAnna Kazantseva & Stan SzpakowiczSchool of Electrical Engineering and Computer ScienceUniversity of OttawaOttawa, Ontario, Canada{ankazant,szpak}@eecs.uottawa.caAbstractWe present a hierarchical topical segmenter for free text.
Hierarchical Affinity Propagation forSegmentation (HAPS) is derived from a clustering algorithm Affinity Propagation.
Given a doc-ument, HAPS builds a topical tree.
The nodes at the top level correspond to the most prominentshifts of topic in the document.
Nodes at lower levels correspond to finer topical fluctuations.For each segment in the tree, HAPS identifies a segment centre ?
a sentence or a paragraph whichbest describes its contents.
We evaluate the segmenter on a subset of a novel manually segmentedby several annotators, and on a dataset of Wikipedia articles.
The results suggest that hierarchicalsegmentations produced by HAPS are better than those obtained by iteratively running severalone-level segmenters.
An additional advantage of HAPS is that it does not require the ?goldstandard?
number of segments in advance.1 IntroductionWhen an NLP application works with a document, it may benefit from knowing something about thisdocument?s high-level structure.
Text summarization (Haghighi and Vanderwende, 2009), question an-swering (Oh et al., 2007) and information retrieval (Ponte and Croft, 1998) are some of the examplesof such applications.
Topical segmentation is a lightweight form of such structural analysis: given asequence of sentences or paragraphs, split it into a sequence of topical segments, each characterized bya certain degree of topical unity.
This is particularly useful for texts with little structure imposed by theauthor, such as speech transcripts, meeting notes or literature.The past decade has witnessed significant progress in the area of text segmentation.
Most of the topicalsegmenters (Malioutov and Barzilay, 2006; Eisenstein and Barzilay, 2008; Kazantseva and Szpakowicz,2011; Misra et al., 2011; Du et al., 2013) can only produce single-level segmentation, a worthy endeavourin and of itself.
Yet, to view the structure of a document linearly, as a sequence of segments, is in certaindiscord with most theories of discourse structure, where it is more customary to consider documents astrees (Mann and Thompson, 1988; Marcu, 2000; Hernault et al., 2010; Feng and Hirst, 2012) or graphs(Wolf and Gibson, 2006).
Regardless of the theory, we hypothesize that it may be useful to have an ideaabout fluctuations of topic in documents beyond the coarsest level.
It is the contribution of this work thatwe develop such a hierarchical segmenter, implement it and do our best to evaluate it.The segmenter described here is HAPS ?
Hierarchical Affinity Propagation for Segmentation.
It isclosely based on a graphical model for hierarchical clustering called Hierarchical Affinity Propagation(Givoni et al., 2011).
It is a similarity-based segmenter.
It takes as input a matrix of similarities betweenatomic units of text in the sequence to be segmented (sentences or paragraphs), the desired number oflevels in the topical tree and a preference value for each data point and each level.
This value capturesa priori belief about how likely it is that this data point is a segment centre at that level.
The preferencevalues also control the granularity of segmentation: how many segments are to be identified at each level.The output is a topical tree.
For each segment at every level, HAPS also finds a segment centre, a datapoint which best describes the segment.This work is licensed under a Creative Commons Attribution 4.0 International Licence.
Page numbers and proceedings footerare added by the organisers.
Licence details: http://creativecommons.org/licenses/by/4.0/37The objective function maximized by the segmenter is net similarity ?
the sum of similarities betweenall segment centres and their children for all levels of the tree.
This function is similar to the objectivefunction of the well-known k-means algorithm, except that here it is computed hierarchically.It is not easy to evaluate HAPS.
We are not aware of comparable hierarchical segmenters other thanthat in (Eisenstein, 2009) which, unfortunately, is no longer publicly available.
Therefore we comparedthe trees built by HAPS to the results of running iteratively two state-of-the-art flat segmenters.
Theresults are compared on two datasets.
A set of Wikipedia articles was automatically compiled by Carroll(2010).
The other set, created to evaluate HAPS, consists of nine chapters from the novel Moonstone byWilkie Collins.
Each chapter was annotated for hierarchical structure by 3-6 people.The evaluation is based on two metrics, windowDiff (Pevzner and Hearst, 2002) and evalHDS (Car-roll, 2010).
Both metrics are less then ideal.
They do not give a complete picture of the quality oftopical segmentations, but the preliminary results suggest that running a global model for hierarchicalsegmentation produces better results then iteratively running flat segmenters.
Compared to the baselinesegmenters, HAPS has an important practical advantage.
It does not require the number of segments asan input; this requirement is customary for most flat segmenters.We also made a rough attempt to evaluate the quality of the segment centres identified by HAPS.
Using20 chapters from several novels of Jane Austen, we compared the centres identified for each chapteragainst summaries produces by a recent automatic summarizer CohSum (Smith et al., 2012).
The basisof comparison was the ROUGE metric (Lin, 2004).
While far from conclusive, the results suggest thatsegment centres identified by HAPS are rather comparable with the summaries produced by an automaticsummarizer.A Java implementation of HAPS and the corpus of hierarchical segmentations for nine chapters ofMoonstone are publicly available.
We consider these to be the main contributions of this research.2 Related workMost work on topical text segmentation has been done for single-level segmentation.
Contemporaryapproaches usually rely on the idea that topic shifts can be identified by finding shifts in the vocabulary(Youmans, 1991).
We can distinguish between local and global models for topical text segmentation.Local algorithms have a limited view of the document.
For example, TextTiling (Hearst, 1997) operatesby sliding a window through the input sequence and computing similarity between adjacent units.
Byidentifying ?valleys?
in similarities, TextTiling identifies topic shifts.
More recently, Marathe (2010)used lexical chains and Blei and Moreno (2001) used Hidden Markov Models.
Such methods are usuallyvery fast, but can be thrown off by small digressions in the text.Among global algorithms, we can distinguish generative probabilistic models and similarity-basedmodels.
Eisenstein and Barzilay (2008) model a document as a sequence of segments generated by latenttopic variables.
Misra et al.
(2011) and Du et al.
(2013) have similar models.
Malioutov and Barzilay(2006) and (Kazantseva and Szpakowicz, 2011) use similarity-based representations.
Both algorithmstake as input a matrix of similarities between sentences of the input document; the former uses graphcuts to find cohesive segments, while the latter modifies a clustering algorithm to perform segmentation.Research on hierarchical segmentation has been more scarce.
Yaari (1997) produced hierarchicalsegmentation by agglomerative clustering.
Eisenstein (2009) used a Bayesian model to create topicaltrees, but the system is regrettably no longer publicly available.
Song et al.
(2011) develop an algorithmfor hierarchical segmentation which iteratively splits a document in two at a place where cohesion linksare the weakest.
A second pass transforms a deep binary tree into a shallow and broad structure.Any flat segmenter can certainly be used iteratively to create trees of segments by subdividing eachsegment, but this may be problematic.
Topical segmenters are not perfect, so running them iteratively islikely to compound the error.
Most segmenters also require the number of segments as an input.
Thisestimate is feasible for flat segmentation.
To know in advance the number of segments and sub-segmentsat each level is not a realistic requirement when building a tree.This work describes a hierarchical model of text segmentation.
It takes a global view of the documentand of the topical hierarchy.
Each iteration attempts to find the best assignment of segments for the38whole tree.
It does not need to know the exact number of segments.
Instead, it takes a more abstractparameter, preference values, to specify the granularity of segmentation at each level.
For each segmentit also outputs a segment centre, a unit of text which best captures the contents of the segment.3 Creating a corpus of hierarchical segmentationsBefore embarking on the task of building a hierarchical segmenter, we wanted to study how peopleperform such a task.
We also needed a benchmark corpus which could be used to evaluate the quality ofsegmentations produced by HAPS.To this end, we annotated nine chapters of the novel Moonstone for hierarchical structure.
We settledon these data because it is a subset of a publicly available dataset for flat segmentation (Kazantsevaand Szpakowicz, 2012).
In our study, each chapter was annotated by 3-6 people (4.8 on average).
Theannotators, undergraduate students of English, were paid $50 dollars each.Procedure.
The instructions asked the annotator to read the chapter and split it into top-level segmentsaccording to where there is a perceptible shift of topic.
She had to provide a one-sentence description ofwhat the segment is about.
The procedure had to be repeated for each segment all the way down to thelevel of individual paragraphs.
Effectively, the annotators were building a detailed hierarchical outlinefor each chapter.Metrics.
Two different metrics helped estimate the quality of our hierarchical dataset: windowDiff(Pevzner and Hearst, 2002) and S (Fournier and Inkpen, 2012).windowDiff is computed by sliding a window across the input sequence and checking, for each windowposition, whether the number of reference breaks is the same as the number of breaks in the hypotheticalsegmentation.
The number of erroneous windows is then normalized by the total number of windows.
InEquation 1, N is the length of the input sequence and k is the size of the sliding window.windowDiff =1N ?
kN?k?i=1(|ref ?
hyp| 6= 0) (1)windowDiff is designed to compare sequences of segments, not trees.
That is why we compute it foreach level between each pair of annotators who worked on the same chapter.
It should be noted thatwindowDiff is a penalty metric: higher values indicate less agreement (windowDiff= 0 corresponds totwo identical segmentations).The S metric allows us to compare trees and take into account situations when the segmenter places aboundary at a correct position but at a wrong level.
S is an edit-distance metric.
It computes the numberof operations necessary to turn one segmentation into another.
There are three types of editing operations:add/delete, transpose and substitute (change the level in the tree).
The sum is normalized by the numberof possible boundaries in the sequence.
S has an unfortunate downside of being too optimistic, but itallows the breakdown of error types and it explicitly compares trees.Unlike windowDiff, S is a similarity metric: higher values correspond to more similar segmentations.The value of S between two identical segmentations is 1.S(bsa, bsb, n) =1?
|boundary distance(bsa, bsb, n)|pb(D)(2)Here boundary distance(bsa, bsb, n) is the total number of edit operations needed to turn a segmen-tation bsainto bsb, n is the threshold defining the maximum distance of transpositions.
pb(D) is themaximum possible number of edits.
Segmentations bsaand bsaare represented as strings of sets ofboundary positions.
For example bsa= ({2}, {1,2}, {1,2}) corresponds to a hierarchical segmentation ofa three-unit sequence in the following manner: a segment boundary at level 1 after the first unit, segmentboundaries at levels 1 and 2 after the second unit and the third unit.Corpus Analysis.
On average, the annotators took 3.5 hours to complete the task (?
= 1.6).
Theaverage depth of the tree is 3.00 levels (?
= 0.65), suggesting that the annotators prefer shallow but broadstructures.
Table 1 reports the average breadth of the tree at different levels.
In the Table and further39in this paper we refer to the bottom level of the tree (i.e., the leaves of the tree or the most fine-grainedlevel of segmentation) as level 1.
In Table 1, level 4 refers to the top level of the tree (the coarsestsegmentations).
The values were computed using only the breaks explicitly specified by the annotators(i.e., we did not assume that a break at a coarse level implies a break at a more detailed level).The average breadth of the trees at the bottom (level 1) is lower than that at level 2, indicating that onlya small percentage of the entire tree was annotated more than three levels deep.
The table also shows theaverage values of windowDiff computed for each possible pair of annotators.
The values worsen towardthe bottom of the tree, suggesting that the annotators agree more about top-level segments and less andless about finer fluctuations of topic.We hypothesize that these shallow broad structures are due to the fact that it is difficult for people tocreate deep recursive structures in their mental representations.
We do not, however, have any hard datato support this hypothesis.
Many of the annotators specifically commented on the difficulty of the task.
9out of 23 people included comments ranging from notes about specific places to general comments abouttheir lack of confidence.
4 annotators found several (specific) passages they had trouble with.The average value of pairwise S is 0.79.
We have noted earlier that the S metric tends to be optimistic(that is due to its normalization factor) but it provides a breakdown of disagreements between the anno-tators.
According to S, 46.14% of disagreements are errors of omission (some of the annotators did notinclude segment breaks where others did), 47.56% are disagreements about the level of segmentation(the annotators placed boundaries in the same place but at different levels) and only 6.31% are errorsof transposition (the annotators do not agree about the exact placement but place boundaries within 1position of each other).
This distribution is more interesting than the overall value of S. Among otherthings, it shows why it is so important to take into account adjacent levels when evaluating topical trees.4 The HAPS algorithm14.1 Factor graphsThe HAPS segmenter is based on factor graphs, a unifying formalism for such graphical models asMarkov or Bayesian networks.
A factor graph is a bi-partite graph with two types of nodes, factor orfunction nodes and variable nodes.
Each factor node is connected to those variable nodes which areits arguments.
Running the well-known Max-Sum algorithm (Bishop, 2006) on a factor graph finds aconfiguration of variables which maximizes the sum of all component functions.
This is a message-passing algorithm.
All variable nodes send messages to their factor neighbours (functions in which thosenodes are variables) and all factor nodes send messages to their variable neighbours (their arguments).A message ?x?fsent from a variable node x to a function node f is computed as a sum of all incomingmessages to x, except the message from the recipient function f :?x?f=?f??N(x)\f?f?
?x(3)N(x) is the set of all function nodes which are x?s neighbours.
Intuitively, the message reflects evi-dence about the distribution of x from all functions which have x as an argument, except the functioncorresponding to the receiving node f .
A message ?f(x,...)?xsent from the factor node f(x, ...) to the1The derivation of the HAPS algorithm, quite involved, is unlikely to interest many readers.
We only present the bareminimum of facts about the algorithm, the framework of factor graphs and the derivation of HAPS from the underlying modelof Affinity Propagation.
A detailed account appears in (Kazantseva, 2014).Table 1: Average breadth of manually created topical trees and windowDiff value across different levelsLevel Average breadth windowDiff4 (top) 6.53 0.353 17.55 0.462 17.63 0.471 (bottom) 8.80 0.5040Cl?11Cl?1iCl?1Nel?11el?1iel?1NEl?11Eil ?
1El?1NIl?11Il?1iIl?1Ncl?111cl?11icl?11Ncl?1i1cl?1iicl?1iNcl?1N1cl?1Nicl?1NNS11l?1Sl?11iS1Nl?1Sl?1i1Sl?1iiSl?1iNSl?1N1Sl?1NiSl?1NNLevel l - 1Cl1CljClNel1eljelNEl1EljElNIl1IliIlNcl11cl1jcl1Ncli1clijcliNclN1clNjclNNS11lSl1jS1NlSli1SlijSliNSlN1SlNjSlNNLevel l(a) Fragment of the factor graph for levels l ?
1 and l(b) Types of messagessent in the HAPS modelFigure 1: Factor graph for HAPS ?
Hierarchical Affinity Propagation for Segmentationvariable node x is computed as a maximum of the value of f(x) plus all messages incoming to f(x, ...)other than the message from the recipient node x:?f?x= maxN(f)\x(f(x1, .
.
.
, xm) +?x??N(f)\x?x?
?f) (4)N(f) is the set of all variable nodes which are f ?s neighbours.
The message reflects the evidence aboutthe distribution of x from function f and its neighbours other than x.4.2 Hierarchical Affinity Propagation for SegmentationThis work aims to build trees of topical segments.
Each segment is characterized by a centre which bestdescribes its content.
The objective function is net similarity, the sum of similarities between all centresand the data points which they exemplify.
The complete sequence of data points is to be segmented ateach level of the tree, subject to the following constraint: centres at each level l, l > 1, must be a subsetof the centres from the previous level l ?
1.
Figure 1a shows a fragment of the factor graph describingHAPS corresponding to levels l and l?1.
The tree has L levels, from the root (l = L) down to the leaves(l = 1).
The superscripts of factor and variable nodes denote the level.At each level, there areN2variable nodes clijandN variable nodes elj(N is the number of data pointsin the sequence to segment).
A variable?s value is 0 or 1: clij= 1?
the data point i at level l belongs tothe segment centred around data point j; elj= 1?
there is a segment centred around j at level l.Four types of factor nodes in Figure 1a are I , E, C and S. The I factors ensure that each data pointis assigned to exactly one segment and that segment centres at level l are a subset of those from levell ?
1.
The E nodes ensure that segments are centred around the segment centres in solid blocks (ratherthan unordered clusters).
The values of I and E are 0 for valid configurations and -?
otherwise.
The Sfactors capture similarities between data points.
Slij= sim(i, j) if clij= 1; Slij= 0 if clij= 0.2The Cfactors handle preferences in an analogous manner.
Running the Max-Sum algorithm on the factor graphin Figure 1a maximizes the net similarity between all segment centres and their children at all levels:max{clij},{elj}S({clij}, {elj}) =?i,j,lSli,j(clij) +?i,lIli(cli1, .
.
.
, cliN, el?1i) +?j,lElj(cl1j, .
.
.
, clNj, elj) +?j,lClj(elj) (5)2The value sim(i, j) is specified in the input matrix.41Figure 1b shows a close-up view of the messages that must be sent to find the optimizing configurationof variables.
Messages ?, ?, ??
do not need to be sent explicitly: their values are subsumed by other typesof messages.
We only need to compute explicitly and send four types of messages: ?, ?, ?
and ?
.Algorithm 1 shows the pseudo-code for the HAPS algorithm.3Intuitively, different parts of the updatemessages in Algorithm 1 correspond to likelihood ratios between two hypotheses: whether a data point iis or is not part of a segment centred around another data point j at a given level l. For example, here isthe availability (?)
message sent from a potential segment centre j to itself at level l:?lij= plj+ ?lj+jmaxs=1(j?1?k=s?lkj) +Nmaxe=j(e?k=j+1?lkj) (6)Here pljincorporates the information about the preference value for the data point j at the level l. ?ljbrings in the information from the coarser level of the tree.
The summand maxjs=1(?j?1k=s?lkj) encodesthe likelihood that there is a segment starting before j given the values of responsibility messages for alldata points i such that i < j ?
hence the information from a more detailed level of the tree as well asthe similarities between all data points i (i < j) and j.
The summand maxNe=j(?ek=j+1?lkj) does thesame for the tail-end of the segment (all data points i such that i > j).Complexity analysis.
The HAPS model contains N2clijnodes at each level.
In practice, however, thematrix of similarities SIM does not need to be fully specified.
It is customary to compute this matrixwith a large sliding window; the size should be at least twice the anticipated average length.
On eachiteration, we need to send L*M*N messages ?
and ?, resulting in the complexity O(L*M*N).
Here L isthe number of levels, N is the number of data points in the sequence and M (M ?
N ) is the size of thesliding window used for computing similarities.
The computation of ?
and ?
messages is independentfor each row and column respectively, so the algorithm would be easy to parallelize.Parameter settings.
An important advantage of HAPS is that it does not require the number ofsegments in advance.
Instead, the user needs to set the preference values for each level.
However, HAPSis fairly resistant to changes in preferences and this generic parameter is a convenient knob for fine-tuningthe desired granularity of segmentation, as opposed to specifying the exact number of segments at eachlevel of the tree.
In this work we set preferences uniformly, but it is possible to incorporate additionalknowledge through more discriminative settings.In all our experiments, preference values are set uniformly for each level of the tree, so effectivelyall data points are equally likely to be chosen as segment centres at each level.
As a starting point,the preference value for the most detailed level of the tree should be about approximately equal to themedian similarity value (as specified in the input matrix).
A near-zero preference value tends to result ina medium number of segments and is thus suitable to the middle levels of the tree.
A negative preferencevalue results in a small number of segments and is appropriate for identifying the most pronouncedsegment breaks.5 Experimental evaluationIn order to evaluate the quality of topical trees produced by HAPS, we ran the system on two datasets.We compared the results obtained by HAPS against topical trees obtained by iteratively running twohigh-performance single-level segmenters.Datasets.
We used the Moonstone corpus described in Section 2, and the Wikipedia dataset com-piled by Carroll (2010).
Created automatically from metadata on Web pages, the dataset consists of 66Wikipedia entries on various topics; the annotations and the results concern sentences.
In the Moonstonecorpus we work with paragraphs.
To simplify evaluation and interpretation, we produced three-tier trees.This is in line with the average depths of manual annotations in the Moonstone data.3It is not possible to include a detailed derivation of the new update messages in the space allowed here.
The interested readercan find these details in (Kazantseva, 2014).
The derivation follows the same logic as (Givoni et al., 2011) and (Kazantseva andSzpakowicz, 2011).42Algorithm 1 Hierarchical Affinity Propagation for Segmentation1: input: 1) L pairwise similarity matrices {SIMl(i, j)}(i,j)?
{1,...,N}2 ; 2) L preferences pl(one perlevel l) indicating a priori likelihood of point i being a segment centre at level l2: initialization: ?i, j : ?ij= 0 (set all availabilities to 0)3: repeat4: iteratively update ?, ?, ?
and ?
messages5:?i, l : ?l?1i= max[0, ?ii?maxk 6=i(slik+ ?lik)]6:?i, j, l : ?lij=????
?min(0, ?li)?maxk 6=i(slik+ ?lik) if i = jslij+ min[max(0,??li)?
?lii,?maxk*i,j(slik+ ?lik)] if i 6= j7:?i, j, l : ?lij=??????????????????????????????????????????????????
?plj+ ?lj+jmaxs=1(j?1?k=s?lkj) +Nmaxe=j(e?k=j+1?lkj) if i = j?lij,i<j= min[(imaxs=1i?1?k=s?lkj+j?k=i+1?lkj+Nmaxe=je?k=j+1?lkj) + plj+ ?lj,imaxs=1i?1?k=s?lkj+jmins=i+1s?1?k=i+1?lkj] if i < jmin[(jmaxs=1j?1?k=s?lkj+i?1?k=j?lkj+Nmaxe=ie?k=i+1?lkj) + plj+ ?lj,i?1mine=ji?1?k=e+1?lkj+Nmaxe=ie?k=i+1?lkj]8:?j, l : ?l+1j= pl(j) + ?ljj+jmaxs=1(j?1?k=s?lkj) +Nmaxe=j(e?k=j+1?lkj)9: until convergence10: compute optimal configuration: ?i, j i is in the segment centred around j iff ?ij+ ?ij> 011: output: segment centres and segment boundariesBaselines.
Regrettably, we are not aware of another publicly available hierarchical segmenter.
That iswhy we used as baselines two recent flat segmenters: MCSeg (Malioutov and Barzilay, 2006) and BSeg(Eisenstein and Barzilay, 2008).
Both were first run to produce top-level segmentations.
Each segmentthus computed was a new input document for segmentation.
We repeated the procedure twice to obtainthree-tiered trees.
MCSeg cannot be run without knowing the number of segments in advance.
Therefore,on each iteration, we had to specify the correct number of segments in the reference segmentation.
BSegdoes not need the exact number of segments, so we had two settings: with and without knowing thenumber of segments.Evaluation metrics.
We did our best to obtain a realistic picture of the results, but each metric hasits shortcomings.
We compared topical trees using windowDiff and evalHDS (Carroll, 2010).
Bothmetrics are penalties: the higher the values, the worse the hypothetical segmentation.
evalHDS computeswindowDiff for each level of the tree in isolation and weighs the errors according to their prominence in43the tree.
We computed evalHDS using the publicly available Python implementation (Carroll, 2010).4When computing windowDiff, we treated each level of the tree as a separate segmentation and com-pared each hypothetical level against a corresponding level in the reference segmentation.To ensure that evaluations are well-defined at all levels, we propagated the more pronounced referencebreaks to lower levels (in both annotations and in the results).
In effect, the whole sequence is segmentedat each level ?
otherwise windowDiff would not be not well-defined.
Conceptually this means that ifthere is a topical shift of noticeable magnitude (e.g., at the top level), there must be at least a shift of lesspronounced magnitude (e.g., at an intermediate level).The Moonstone dataset has on average 4.8 annotations per chapter.
It is not obvious how to combinethese multiple annotations.
We evaluated separately each hypothetical segmentation against each avail-able gold standard.
We report the averages across all annotators ?
for both evalHDS and windowDiff ?per level.Preprocessing.
The representations used by HAPS and the MCSeg are very similar.
Both systemscompute a matrix of similarities between atomic units of the document (sentences or paragraphs).
Eachunit was represented as a bag of words.
The vectors were further weighted by the tf.idf value of the termand also smoothed in the same manner as in (Malioutov and Barzilay, 2006).
We computed cosine simi-larity between vectors corresponding to each sentence or paragraph.
We used tenfold cross-validation onthe Wikipedia dataset and fourfold cross-validation on the smaller Moonstone data.The quality of the segment centres.
In addition to finding topical shifts, HAPS identifies segmentcentres ?
sentences or paragraphs which best capture what each segment is about.
In order to get a roughestimate of the quality of the centres, we extracted paragraphs identified as segment centres at the second(middle) level of HAPS trees.
These pseudo-summaries were then compared to summaries created byan automatic summarizer CohSum.
We used ROUGE-1 and ROUGE-L metrics (Lin, 2004) as a basisfor comparison.
CohSum identifies the most salient sentences in a document by running a variant of theTextRank algorithm (Mihalcea and Tarau, 2004) on the entire document.
In addition to using lexicalsimilarity, the summarizer takes into account coreference links between sentences.
We ran CohSum at10% compression rate.The summarization experiment was performed on the Moonstone corpus.
We also collected 20 chap-ters from several other XIX century novels and used it in a separate experiment.
The ROUGE packagerequires manually written summaries to compare with the automatically created ones.
We obtained thesummaries from the SparkNotes website.56 Results and discussionTable 2 shows the results of comparing HAPS with two baseline segmenters using windowDiff andevalHDS.
HAPS was run without knowing the number of segments.
MCSeg required that the exactnumber be specified.
BSeg was tested with and without that parameter.
Therefore, rows 3 and 4 inTable 2 correspond to baselines considerably more informed than HAPS.
This is especially true of thebottom levels where sometimes knowing the exact number of segments unambiguously determines theonly possible segmentation.The results suggest that HAPS performs well on the Moonstone data even when compared to moreinformed baselines.
This applies to both metrics, windowDiff and evalHDS.
BSeg performs slightlybetter at the bottom levels of the tree when it has the information about the exact number of segments.We hypothesize that the advantage may be due to this additional information, especially when segmentingalready small segments at level 1 into a predefined number of segments.
Another explanation may bethat when using windowDiff as the evaluation metric, HAPS was fine-tuned so as to maximize the valueof windowDiff at the top level, effectively disregarding lower levels of segmentation.4When working with the Moonstone dataset, we realized that the software produces very low values, almost too good to betrue.
That is because the bottommost annotations are very fine-grained.
Sometimes each paragraph corresponds to a separatesegment.
This causes problems for the software.
So, when we report evalHDS values for the Moonstone dataset, we onlyconsider two top levels of the tree, disregarding the leaves.
We also remove the ?too good to be true?
outliers, though the ?bad?tail is left intact.
We applied the same procedure to all three segmenters, only for the Moonstone dataset.5http://www.sparknotes.com/44Level Moonstone Wikipedia Moonstone WikipediawindowDiff windowDiff evalHDS evalHDSHAPS3 (top) 0.337 (?
0.060) 0.421 (?
0.060) 0.353 0.4502 (middle) 0.422 (?
0.060) 0.447 (?
0.070) (?
0.072) (?
0.015)1 (bottom) 0.556 (?
0.070) 0.617 (?
0.080)MinCutSeg-iter.3 (top) 0.375 0.440 (?
0.075) 0.377 0.4442 (middle) 0.541 0.424 (?
0.064) (?
0.002) (?
0.002)segm.
known 1 (bottom) 0.601 0.471 (?
0.057)BayesSeg-iter.3 (top) 0.353 (?
0.071) 0.391 (?
0.070) 0.367 0.3702 (middle) 0.406 (?
0.053) 0.344 (?
0.033) (?
0.089) (?
0.019)segm.
known 1 (bottom) 0.504 (?
0.064) 0.354 (?
0.033)BayesSeg-iter.3 (top) 0.600 (?
0.071) 0.637 (?
0.070) 0.453 0.4372 (middle) 0.447 (?
0.053) 0.877 (?
0.033) (?
0.089) (?
0.022)segm.
unknown 1 (bottom) 0.545 (?
0.064) 0.952 (?
0.033)Table 2: Evaluation of HAPS and iterative versions of APS, MCSeg and BSeg using windowDiff per level(mean windowDiff and standard deviation for cross-validation)Moonstone corpus Austen corpusROUGE-1 ROUGE-L ROUGE-1 ROUGE-LSegment centres 0.341 0.321 0.291 0.301(0.312, 0.370) (0.298, 0.346) (0.272, 0.311) (0.293, 0.330)CohSum 0.294 0.269 0.305 0.307summaries (0.243, 0.334) (0.226, 0.306) (0.290, 0.320) (0.287, 0.327)Table 3: HAPS segment centres compared to CohSum summaries: ROUGE scores and 95% confidenceintervalsAll segmenters perform worse on the Wikipedia dataset.
Using that scale, informed BSeg performs thebest, but it is interesting to note a significant drop in performance when the number of segments is notspecified.Overall, HAPS appears to perform better than, or comparably to, the more informed baselines, andmuch better than the baseline not given information about the number of segments.We also made a preliminary attempt to evaluate the quality of segment centres by comparing them tothe summaries created by the CohSum summarizer.
In addition to working with the Moonstone corpus,we collected a corpus of 20 chapters from various novels by Jane Austen.Table 3 shows the results.
They are not conclusive because there is no evidence that ROUGE scorescorrelate with the quality of automatically created summaries for literature.
According to the scores inTable 3, however, the summaries created by CohSum cannot be distinguished from simple summariescomposed of segment centres identified by HAPS.
We interpret this as a sign that the centres identifiedby HAPS are approximately as informative as those created by an automatic summarizer.7 A brief conclusionThis paper presented HAPS, a hierarchical segmenter for free text.
Given an input document, HAPScreates a topical tree and identifies a segment centre for each segment.
One of the advantages of HAPSis that it does not require the exact number of segments in advance.
Instead, it estimates the numberof segments given information on generic preferences with regard to segmentation granularity.
We alsocreated a corpus of hierarchical segmentations which has been annotated by 3-6 people per chapter.A Java implementation of HAPS and the Moonstone corpus are publicly available.6AcknowledgementsWe thank Chris Fournier (for computing S values using a beta version of SegEval software for hierar-chical datasets), Lucien Carrol (for help and discussion of the evalHDS software and representation) andChristian Smith (for allowing us to use his implementation of CohSum).6http://www.eecs.uottawa.ca/?ankazant/45ReferencesChristopher M. Bishop.
2006.
Pattern Recognition and Machine Learning.
Springer.David Blei and Pedro Moreno.
2001.
Topic segmentation with an aspect hidden Markov Model.
In Proceedings ofthe 24th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval,pages 343?348.Lucien Carroll.
2010.
Evaluating Hierarchical Discourse Segmentation.
In Human Language Technologies: The2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics,pages 993?1001.Lan Du, Wray Buntine, and Mark Johnson.
2013.
Topic Segmentation with a Structured Topic Model.
InProceedings of the 2013 Conference of the North American Chapter of the Association for ComputationalLinguistics: Human Language Technologies, pages 190?200, Atlanta, Georgia.Jacob Eisenstein and Regina Barzilay.
2008.
Bayesian Unsupervised Topic Segmentation.
In Proceedings of the2008 Conference on Empirical Methods in Natural Language Processing, pages 334?343, Honolulu, Hawaii.Jacob Eisenstein.
2009.
Hierarchical Text Segmentation from Multi-Scale Lexical Cohesion.
In Proceedings ofthe 2009 Conference of the North American Chapter of the Association for Computational Linguistics: HumanLanguage Technologies, pages 353?361.
The Association for Computational Linguistics.Vanessa Wei Feng and Graeme Hirst.
2012.
Text-level Discourse Parsing with Rich Linguistic Features.
InProceedings of the 50th Annual Meeting of the Association for Computational Linguistics (Volume 1: LongPapers), pages 60?68, Jeju Island, Korea, July.
Association for Computational Linguistics.Chris Fournier and Diana Inkpen.
2012.
Segmentation Similarity and Agreement.
In Proceedings of the 2012Conference of the North American Chapter of the Association for Computational Linguistics: Human LanguageTechnologies, pages 152?161, Montr?eal, Canada.Inmar E. Givoni, Clement Chung, and Brendan J. Frey.
2011.
Hierarchical Affinity Propagation.
In Uncertaintyin AI, Proceedings of the Twenty-Seventh Conference (2011), pages 238?246.Aria Haghighi and Lucy Vanderwende.
2009.
Exploring Content Models for Multi-Document Summarization.
InProceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapterof the Association for Computational Linguistics, pages 362?370, Boulder, Colorado, June.Marti A. Hearst.
1997.
TextTiling: segmenting text into multi-paragraph subtopic passages.
ComputationalLinguistics, 23(1):33?64.Hugo Hernault, Helmut Prendinger, David A. duVerlea, and Mitsuru Ishizuka.
2010.
HILDA: A Discourse ParserUsing Support Vector Machine Classification.
Dialogue and Discourse, 3:1?33.Anna Kazantseva and Stan Szpakowicz.
2011.
Linear Text Segmentation Using Affinity Propagation.
In Proceed-ings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 284?293, Edinburgh,Scotland.Anna Kazantseva and Stan Szpakowicz.
2012.
Topical Segmentation: a Study of Human Performance and a NewMeasure of Quality.
In Proceedings of the 2012 Conference of the North American Chapter of the Associationfor Computational Linguistics: Human Language Technologies, pages 211?220, Montr?eal, Canada.Anna Kazantseva.
2014.
Topical Structure in Long Informal Documents.
Ph.D. thesis, University of Ottawa.
?http://www.eecs.uottawa.ca/?ankazant/?.Chin-Yew Lin.
2004.
ROUGE: A Package for Automatic Evaluation of summaries.
In Text SummarizationBranches Out, Proceedings of the ACL Workshop, pages 74?81, Barcelona, Spain.Igor Malioutov and Regina Barzilay.
2006.
Minimum Cut Model for Spoken Lecture Segmentation.
In Pro-ceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of theAssociation for Computational Linguistics, pages 25?32, Sydney, Australia.William C. Mann and Sandra A. Thompson.
1988.
Rhetorical Structure Theory: Toward a functional theory oftext organization.
Text, 8(3):243?281.Meghana Marathe.
2010.
Lexical Chains Using Distributional Measures of Concept Distance.
Master?s thesis,University of Toronto.46Daniel Marcu.
2000.
The Theory and Practice of Discourse Parsing and Summarization.
MIT Press, Cambridge,Mass.Rada Mihalcea and Paul Tarau.
2004.
Textrank: Bringing order into texts.
In Dekang Lin and Dekai Wu, editors,Proceedings of the Conference on Empirical Methods in Natural Language Processing 2004, pages 404?411,Barcelona, Spain.Hemant Misra, Franc?ois Yvon, Olivier Capp?e, and Joemon M. Jose.
2011.
Text segmentation: A topic modelingperspective.
Information Processing and Management, 47(4):528?544.Hyo-Jung Oh, Sung Hyon Myaeng, and Myung-Gil Jang.
2007.
Semantic passage segmentation based on sentencetopics for question answering.
Information Sciences, an International Journal, 177:3696?3717.Lev Pevzner and Marti A. Hearst.
2002.
A Critique and Improvement of an Evaluation Metric for Text Segmenta-tion.
Computational Linguistics, 28(1):19?36.Jay M. Ponte and W. Bruce Croft.
1998.
A Language Modeling Approach to Information Retrieval.
In SIGIR?98: Proceedings of the 21st Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval, pages 275?281, Melbourne, Australia.Christian Smith, Henrik Danielsson, and Arne Jnsson.
2012.
A more cohesive summarizer.
In 24th InternationalConference on Computational Linguistics, Proceedings of COLING 2012: Posters, pages 1161?1170, Mumbai,India.Fei Song, William M. Darling, Adnan Duric, and Fred W. Kroon.
2011.
An iterative approach to text segmentation.In Proceedings of the 33rd European Conference on Advances in Information Retrieval, ECIR?11, pages 629?640, Berlin, Heidelberg.
Springer-Verlag.Florian Wolf and Edward Gibson.
2006.
Coherence in Natural Language: Data Structures and Applications.
MITPress, Cambridge, MA.Yaakov Yaari.
1997.
Segmentation of Expository Texts by Hierarchical Agglomerative Clustering.
In Proceedingsof International Conference on Recent Advances in Natural Language Processing RANLP97, pages 59?65,Tzigov Chark, Bulgaria.Gilbert Youmans.
1991.
A new tool for discourse analysis: The vocabulary-management profile.
Language,67(4):763?789.47
