A Constructive View of GPSGorHow to Make It WorkStephan BUSEMANNChrista HAUENSCHILDTechnical University of BerlinInstitute for Software and Theoretical Computer ScienceProject Group KITSekr.
FR 5-12Franklinstr.
28/29D-1000 Berlin 10E-mail: busemann@ db0tui 11.bitnetAbstractUsing the formalism of generalized phrase structuregrammar (GF~SG) in an NL system (e.g.
for machine translation(MT)) is promising since the modular structure of theformalism is very well suited to meet some particular needs ofMT.
However, it seems impossible to implement GPSG in its1985 version straightforwardly.
This would involve a vastovergeneration f structures as well as processes to filter outeverything but the admissible tree(s).
We therefore argue for aconstructive rsion of GPSG where information is gathered insubsequent s eps to produce syntactic structures.
As a result,we consider it necessary to incorporate procedural spects intothe formalism in order to use it as a linguistic basis for NLparsing and generation.
The paper discusses the majorimplications of such a modified view of GPSG.
11 IntroductionAny attempt o build a multi-lingual MT system as inEUROTRA \[King, Perschke 1987\] must provide for massivemodularization i order to avoid developing 9 parsers, 9generators and 72 transfer components for the 9 languagesinvolved, not to mention the different but redundantformulations of linguistic knowledge mbodied in them.
Themost obvious approach consists in developing one singleparser, one single generator, and one single transfercomponent, the first two being capable of dealing withgrammars for different languages and the latter with transfer1 This work has been developed in the project KFr-FAST (KIT = KilnstlicheIntelligenz und Textverstehen (Artificial Intelligence and TextUnderstanding); FAST = Functor Argument S ructure for Translation), whichconstitutes the Berlin component of the complementary research project ofEuroWa-D.
It receives grants by the Federal Minister for Research antiTechnology under contract 1013211.rules for different pairs of languages.
Moreover, an MT systemmust be based on a linguistically justified theory of grammar.This theory has to be implemented in the system, where itdetermines the construction of a syntactic representation f asentence during the parsing of some input string as well asduring the generation based on the output of the transfercomponent.The theory of GPSG (see \[Gazdar et al 1985\], henceforth:\[GKPS\]) has been tested for its usefulness for MT\[ttauenschild/Busemann 1988\].
It offers the high degree ofmodul,'u'ity hat is required.
For instance, an implementation ofthe GPSG formalism would be able to run with differentgrammars, and linguistic generalizations would either evolvefrom the formalism (in the case of universals), or beexpressible within the grammars (in the case of language-specific generalizations).
We shall distinguish between theformalism and the grammar in the following way; theformalism consists of the Feature Instantiation Principles(FIPs), the formal definition of syntactic features, categories,Feature Co-occurrence Restrictions (FCRs), ImmediateDominance (ID) rules, Linear Precedence (LP) statements,admissible trees, etc.
The grammars consist of actual sets of IDrules, LP statements, FCRs, and the lexicon.However, a closer look at the axiomatic way GPSG hasbeen defined reveals evere problems for an implementation ofGPSG.
In the next section we shall outline these problems, andin section 3 present our change in perspective towards a GPSGformalism that overcomes these problems.
Some consequencesof this are discussed in the last section.The rest of the paper concentrates onGPSG and its use forprocessing of representations of natural anguage sentences.Nothing can be said here about the necessity of includingtextual knowledge for translation or about the transfer stepitself (but cf.
\[Hauenschild 1986\]).772 Problems With the Implementation f GPSGIn this section we want to justify why we had to develop aconstructive v rsion of the GPSG formalism although it mightseem that the "classical" version of it (as defined in \[GKPS\])can be implemented.
We want to show that this is only true intheory but not in practice.What would it really amount to if we tried to implement theaxiomatic version of GPSG in a straightforward way?
In orderto find all admissible trees corresponding to a given sentence,we would have to do the following things for every local tree(i.e.
trees of depth 1):* build every possible xtension for every category in an IDrule, which means that every feature that is not specified inthe rule may be either absent or specified by any of itsvalues,.
filter out the illegal categories with the aid of the FCRs,.
build all the possible projections of ID rules with theremaining legal categories, thereby creating every possibleorder of the daughters,?
filter out those combinations of categories that areinadmissible according to the Foot Feature Principle (FFP),Control Agreement Principle (CAP) or Head FeatureConvention (HFC),.
filter out those projections that are unacceptable b cause ofsome category contradicting a Feature Specification Default(FSD),?
filter out all those projections that contradict any LPstatement applicable to the daughters.After this, the subset of admissible local trees has to beidentified which yields the desired complex structures in thefollowing way: two (locally) admissible trees may becombined into a larger tree iff one of the daughters of one ofthem is identical with the mother of the other one.The whole process can be regarded as divided up into threemajor steps.
The first step consists in constructing all thepossible projections (possible according to ID rules and FCRs).The second step consists in filtering out local trees that are notadmissible according to the restrictions imposed on them bythe FIPs, the FSDs and the LP statements.
Though thesedevices are not filters in the Chomskyan sense, 2they behave inan analogous way by preventing previously generatedstructures from becoming locally admissible trees.
The laststep consists in forming complex structures out of locallyadmissible trees.In order to show the complexity of such an approach, it isnecessary to give a rough idea of what the first step reallymnounts to; it yields a combinatorial explosion of the set ofcategories.
Assuming the 25 atomic and the 4 category-valued2 This was pointed out o us by John Nerbonne ( lectronic mail).features defined for file English grammar in \[GKPS\], a lowerbound for the number of categories to be checked by the FCRsis 10 774 \[Ristad 1986\].
'\['he second of the above mentioned steps is riot trivialeither, though its problems might be solvable after allo For apurely axiomatic view of the GPSG formalism it may bepermissible toneglect the order in which the different filteringcomponents are to be applied, akhough their seem to be someproblems with the definitions of the different FIPs with respectto their logical independence of each other.
For an effectiveimplementation however, the ordering problem becomescrucial.
There are some hints in \[GKPS\] referring tointerdependencies b tween the different filters, but they are notfully specified.
The most problematic case is the order in whichthe HFC and the CAP have to be applied:?
the HFC seems to presuppose the effects of the CAP (and ofthe FFP) because it must not force feature specifications thatare excluded by the CAP on categories in local trees;?
the CAP presupposes the FlEC in the sense that it is basedon semantic types, which are dependent on HEAD features,the distribution ofwhich is in turn governed by the HFC.One possible way out of this dilemma is suggested in\[Shieber 1986\], but it is based on the assumption that HEADfeatures may be split up into two disjoint sets: those HEADfeatures which are prerequisites for the assignment of semantictypes and thus for the applicability of the CAP, and thoseHEAD features that can safely be applied after the CAP hasdone its work.
However, it is not clear whether such adistribution is possible.
Of course, you can always make yourID rules much more informative with respect to featurespecifications than is suggested in \[GKPS\] and therebyguarantee a proper functioning of the FIPs; but that wouldprobably not be in the spirit of GPSG, where the main point isto capture the universal as well as the language-specificgeneralizations.There m'e a number of problems with the CAP; we waut tooutline just one of them, which has led us to modify thisprinciple.
The definition of control in \[GKPS\] implicitlyrestricts the functioning of CAP to structures where the functorhas no more than one argument (with the exception of thosevery special cases of control mediators).
This cannot be seenfrom the definition of control \[GKPS:88\] alone, but may bederived from the interaction of this definition with theconditions on correct type assignment that are imposed onsyntactic structures by the principle of functional realization\[GKPS, chapter 10\]: it follows from beth pm~s of the theolytaken together that a functor can be controlled by its argumentonly in the case where there is no further argument; otherwisethe functor would have to be of a type that differs from what isassumed in the definition of control (intuitively, the type of afunctor depends on how many arguments he functor takes).78This diffictllty seems quite hard to cope with; if we assumerather flat structures (as we do, on independent grounds, in ourGerman syntax \[Preug 1987\], see also \[Uszkoreit 1984\]), thenit is not clear which of the different arguments of a functor is tocontrol it; in the case of subject-predicate agreement inGerman, the subject would have to be marked as the controllc~',which can b~a:dly be done on the basis of the semantic typesalone (becaose there seems to be no semantic reason todistinguish ,;ubjects and objects by their semantic type unlesswe treat subjects as functors operating on VPs as arguments,which would reverse the conlrol relation between them andthus cause all sorts of other problems).
The only possibility wecan conceive of would be analogous to the concept ofargument order as defined in \[GKPS\] :in oi~er to obtaincorrectly the interpretations of direct attd indirect objects, butthis is a language-particular concept (cf.
\[GKPS:214\], whichwould not fit ittto a universal principle.3 A Constntctive View of GPS(~,Aa the previous section shows, the GPSG formalism inits original version is not suitable for computerimplementation.
From a processing point of view, it is anobvious rcqt&ement that the components of GPSG shouldonly conslru,zt he well-formed categories and trees, i.e.
nogarbage should be produced.
In order to utilize GPSG forparsing artd generation in a computer system, a change inperspective becomes necessary; instead of deciding for all fullyspecified categories and all local trees whether they are legalor admissible respectively, we start from a highlyunderspecified local tree that is admitted by an ID rule andgather information by subsequently applying FCRs and FIPs.Eventually we sttall have a fully specified local tree that isadmissible b7 definition.We shall call this view of GPSG constructive since itallows for the construction rather than the selection of asyntactic structure.
In a conslructive version of GPSG, FCRsand F1Ps mainly act as principles of feature transport ratherthan of t'c~atu redistribution.One of d~e most important questions for the constructiveversion is ir~ what order the components of GPSG have to beapplied.
Since each of them may add further featurespecifications to a category in a local tree, the order ofapplication ought to depend on what information must bepresent for a component to work properly.
This can bedetermined in general by using a monotonic operation such asunification for making categories more and more specific.This has led us to dispense with any assertions aboutcategories as they are often used in \[GKPS\].
For instance, thepredicate ~ with the meaning that some feature is undefined(i.e.
it is nn~: contained in the category) is replaced by a featurevalue, ~, which is subject o unification.
We shall thus say thata featurefi~', undefined if it is specified as <f, ~>.Tire predicative character of FCRs is also modifiedtowards a functional one by including the assignment of valuesto features.
Formally, an FCR is written catl ~ cat2, wherecat1 and cat2 are categories.
An FCR applies to a categoryC iff C is an extension of cat1.
C must unify with cat2,otherwise C is not legal.Let us now discuss the role of the FIPs in a constructiveversion.
We shall start with HFC.
In \[GKPS\], HFC is based oilthe free feature specification sets, which are utilized to preventHFC from rejecting local trees because of HEAD featuresspecified ifferently at the mother and tile head daughter(s) byvirtue of ID rnles, FCRs, the FFP, or file CAP.
To generatethese sets would again require all possible projections from anID rule to be produced.
As was shown in the previous section,this must lm avoided if a computer implementation is to besupplied.From the constructive point of view we suggest hat theeffect of using the free feature specification sets can be attainedby ensuring that for a local tree, the work of the FCRs, the FFPand the CAP has been completed before HFC comes into play.tlFC then assures that the so far unspecified HEAD features atthe mother are ktentical with the corresponding HEAD featurespecifications at the head daughter(s) and vice versa therebynever ejecting a local tree 3.
IqFC proceeds as follows; everyhead daughter that can unify with its mother with respect tothe set of HEAD features will do so.
Typically, IJEADincludes features for verb form or clause structure.
Aconstituent is marked as head by a binary feature, head, whichis specified in the ID rules, thus replacing the meta-notation Hin IGKPSI, the meaning of which is completely dependent onits context.This way HFC is supposed to work in an equally general,but much simpler, fashion than it was possible with thedefinition in \[GKPS\].
Moreover, IIFC is capable of copingwith multiple heads used for the treatment of certaincoordination phenomena; feature specifications are found inthe coordinated head daughters, the HEAD feature in questionhas to be undefined at the mother.
This parallels the waymultiple heads are treated in \[GKPS\].The requirement that the CAP be prior to HFC raises,however, the problem that the CAP cannot be based onsemantic types anymore because it is HFC which mightprovide the major feature specifications necessary todetermine tile type of a constituent.
Moreover, to beapplicable to local trees with more than one argument (inthose cases where no control mediator is present), the CAP had3 After HFC has been applied to a local tree, FCRs may become applicable thatwere not before, which in turn should cause the HFC to resume its work etc.until nothing is specified anymore.
Whether this repetition must actuallyoccur, depends on how the grammar is fonnulated.7~to be reformulated, and its place is taken by a purely syntacticmechanism, the Agreement Principle (AP), which is defined~as follows \[Weisweber 1987\]; every daughter in a local treethat is ~ marked for agreement must unify with its mother withrespect to a subset of features, called AGR.
If an AGR featureis undefined, it is ignored by the AP.
Any local tree violatingthe AP is rejected.
AGR typically contains features for case,gender, person, or number.
A constituent is marked foragreemen t by a binary feature, agr, that is specified throughFCRs, e.g.
{<cas, hem>} ~ {<agr, +>} and {<vform, fin>} D{<agr, +>}.
The AP together with HEC provides for subject-verb agreement on the basis of these FCRs.
This way ofcoping with agreement phenomena foregoes with any notionof control.
There are no semantic types involved; whatagrees with what need not be stated explicitly, it is simply theconsequence of the interplay of FCRs, AP, HFC, and theThis approach allows a category to contain featurespecifications arising from different agreement relations.
Animportant hypothesis underlying the revised AP is that this willonly be necessary if that category contains, by virtue of an IDrule, category-valued features, which can by themselves bespecified for agr.
These features are also inspected by therevised AP in order to find members of some agreementrelation in a local tree.
Figure 1 contains a local tree, (3), withthe feature slash (denoted by 7') specified at the mother as anaccusative NP by an ID rule.
This expresses the fact that adirect object is missing in local tree (3).
The revised AP usesthe AGR specifications of the slash value to establishagreement between the direct object and the reflexive pronoun.The AGR specifications of the S, on the other hand, are usedto ensure subject-verb agreement.SNP\[acc, S/NP\[acc, agr2\] 4--___Isic t ,j. S\[agrll/NP\[acc, agr2\] ~,__her ~grl l  ~ ~  ~babe NP\[no.m, 4/ V\[psp\] VP\[zu-inf, agr2\]have agrl \] ~ ~/ / 3..i'ch gebeten NP\[agr2\] .
, , J  V\[zu- nf\]I asked Isich zu beeilen"She is the one I asked to hurry up."
herself to hurry upFig.
1: Establishing Different Agreement Relationsdefinition of the feature sets AGR and HEAD.
Note that theAP does not presuppose HEAD feature specifications and canthus be prior to HFC.However, the AP as defined above cannot account for thefact that a category may participate in some agreementrelations, but not in others (in 'raising' constructions a directobject may have to agree with a reflexive pronoun, but not withthe finite verb).
A more sophisticated version of the AP, whichis presently being developed, is based on different kinds of agrvalues (e.g.
agrl and agr2 instead of +).
A direct object, as wellas the reflexive, is then specified with <agr, agr2> whereassubject and finite verb both have <agr, agrl>.
The revised APrequires categories containing the same agr specification tounify with respect to AGR as described above.80Note that this way of including category-valued featuresspecified in ID rules is independent of which syntacticstructures are used to describe a language, rather tile functionof category-valued features as indicators of long distancerelations is utilized.The feature agr can still be specified by virtue of FCRs,though there seem to be some characteristic exceptions wherethe value is better provided within the ID rules.
For instance, aVP should not always contain <agr, agr2>, as in figure 1,because in the case of 'equi' verbs it would have to agree withthe subject.
44 This relational information cannot be derived from the different subcategor-izations of'raising' and 'equi' verbs alone.Let us conclude tile discussion of the FIPs with the FFP,tile functionir~g of which has by and large been taken overfrom \[GKPSI~ A special treatment is necessary for the wflue ,~.All daughters unify with the mother with respect to a set ofFOOT feature, s  provided that the values ale not spe, cified inthe ID rules.
Daughters that are undefined with respect tosome FOOT feature are ignored by the Flq ~ unless the FOOTfeature is untlefined at every daughter or at the mother; inthat case tile FFP requires all constituents o be undefined withrespect o that FOOT feature.
If a local tree violates the FFP itis rejected.The FFP is only dependent on rite ID rules and is thus ableto be the first t,'IP to apply.
It is in fact prior to the AP since itspoint, we shall look at two rather obvious strategies, omwhich is used in the Berlin GPSG system \[HauensctBusemann 1988\] for parsing and the other for generation.The first one constructs the tree in a bottom-up mar,thereby reducing admissible local trees by unifying tlmothers with the daughters of another local tree.
The bott(up strategy starts from lexical categories, which are admissiby the lexicon.
Each reduction step is followed byapplication of the FIPs to the newly created local tree.
Thusintormation contained in the lexical categories i percolatedhigher levels of the tree, thereby constraining the set of furtlreduction steps allowed by the grammar.
This strategy is uswithin tile parser in the GPSG system \[Weisweber 1987\].Fig.
2: Sequence of Application in a Constructional Version of GPSGresults may ~rigger FCRs that specify the agr feature.
FCRshave to be applied at each step where a feature might havebeen specified in a local tree, namely after tile FFP, the AP,and the HFC_ LP statements can only be guaranteed to apply 5properly on fully specified categories.
Thus they operate in thelast place (cf.
figure 2) 6.The next question to be addressed is how complexstructures arc built from local trees.
Since in the constructionalversion nothing forces a daughter of one local tree mid tilemother of ~,nother one to have the same set of featuresspecified with the same values, the two categories are notrequired to be identical, as in \[GKPS\], rather they must unify inorder to be combined into a larger tree.For each of tile two categories involved in the unification,additional features may be specified.
This specification byconstruction, when combined with the application of FCRs andFIPs, makes the results of transporting feature specificationswithin local trees immediately available to other locN treks.Tile precise way of interaction with FCRs and FIPs depends onthe strategy adopted for tree formation.
In order to clarify theFor parsing, LP statements work as filters whereas for generation, theyconstructively order the branches in a local tree \[Busemana 1987\].Note that a similar ordering discovered byShieber \[Shieber 1986\] results frominvestigations f underlying assumptions f \[GKPS\].The second strategy consists of top-down tree formationWith this type of proces , local trees are expanded by unifyin~their daughters with mothers of other local trees.
The top.down strategy starts from a local tree (with mother S, foJinstance), the categories of which have feature specificationsby virtue of all ID rule only.
FCRs and FlPs cannot be appliedduring tree expansion because there is too little informationavailable for deciding upon e.g.
the value of agr (for the samereason, FCRs attd FlPs are not applied to ID rules directly),rather they apply in a bottom-up manner as with the firststrategy after the lexical insertion has been completed.The latter strategy is utilized within the generationcomponent \[Busemann 1987\] in the GPSG system, which hasto introduce, for instance, number and case information i to thestructure that it is about to generate.
This takes place in thecourse of tree expansion by adding relevant featurespecifications to categories in the tree (to an NP mother, forinstance).
This information is usually not available in localtrees at a deeper level, especially at local trees with lexicalcategories.
Therefore the lexicon should contain word stems(rather than word forms) and, con'espondingly, categories thatare unspecified for e.g.
number and case.
7This makes a situation possible that has not been discussedyet; namely, that when FIPs apply to local trees at these deeperlevels they may have to cope with unspecified features.
ThereB\]is indeed no requirement that AGR or HEAD features musthave a value in order to unify.
We should like the FIPs to workproperly even if features have not yet received a value.
In thesecases, the feature values in question are co-specified, i.e.
theywill have the same value as soon as one of them is specified.
Inour example, number and case specifications are spread overthe sub-structure dominated by the NP as soon as the FIPsapply to the local tree where they have been introduced.However, such a delayed specification makes it more difficultto maintain control over whether a category is still legal andwhether a local tree still complies with the LP statements.
Foran elegant solution see \[Weisweber 1988\], in this volume.In our present version of GPSG, we use neither metarulesnor FSD.
However, the linguist ought to still have thepossibility of expressing elegantly language-particulargeneralizations with the aid of metarules.
They will be realizedin a preprocessing component in order to avoid having to applythem during parsing or during generation.As for FSDs, we adopt the working hypothesis that they aresuperfluous if lexical entries are sufficiently specified and freefeature instantiation (in the sense of \[GKPS\]) is not allowed.FSDs are needed in the GPSG version of \[GKPS\] because freefeature instantiation may assign nonsensical values to features,which would never occur if the structure had been built orderlyon the basis of sufficient lexical information.
In the long run itmight be desirable to use the device of FSDs in aconstructional version of GPSG, too; namely, for those caseswbere features have not been specified, thougll the wholestructure has been completed.
However, we shall have to avoidthe complexity of FSDs as defined in \[GKPS\]; a simplifiedsolution might be analogous to our version of HFC for HFC,too, is a default device in the final account.The constructional version of GPSG presented hereconstitutes the linguistic basis for parsing and generation ofEnglish and German sentences within the Berlin GPSG system.The system is fully implemented in Waterloo Core Prologusing the set of predicates defined by the KIT-CORE Prologstandard \[Bittkau et al 1987\], which makes it possible to run itwith several other Prolog dialects, too (e.g.
Symbolics Prolog).At present, it runs on an IBM 4381 under VM/SP, on aSymbolics 3640 Lisp machine, and on an IBM AT.4 ConclusionIt has been shown how our constructive version of GPSGavoids the: problem of combinatorial explosion that would havearisen if we had tried to implement the GPSG formalism in itsaxiomatic version \[GKPS\] in a straightforward way.
OurA stem-form lexicon complemented with lemmatization a d inflectionprocedures i better suited to NL processing anyway, at least if sa'onglyinflecting languages such as German are involved.change in perspective also leads to an impoitant simplificationof the HFC because it is no longer necessary to build all theprojections of an ID rule for the determination of the freefeature specification sets.The dilemma over the ordering of the CAP and the HFChas been removed too, which is crucial for any implementationof the formalism.
But, for this to be achieved, we had tosacrifice part of the generality that characterizes the treatmentof control in \[GKPS\]; ke.
although the qnestion of whichconstituents have to agree with one another is ~Lot answered ir~a purely idiosyncratic way by the ID rules (because most of thecases can be accounted for by FCRs, which are, as it were,language-specific generalizations), the fact that agreementdepends on functor-argument structures i  no longer integratediuto the formalism.This loss, however, is compensated for by the fact that wecan treat agreement in cases which the original CAP could notaccount for (as in the case where a functor is cont,oiled by oneof several arguments).Although we have had to concentrate our presentation onjust a few aspects of the eonsu-uctive view of GPSG, we hopeto have made plausible that our modified formalism is, incontrast o the original one, suitable for parsing and generationwithin an NL processing system.ReferencesBittkau, Oliver; Haider, Christi,'m; and Kietz, Jgrg-Uwe (1987), KI'ICORE-PROLOG Description (Version 1.0), KIT Internal Working Paper No.17, Fachbereich Informatik, Technische Universitat Berlin.Busemann, Stephan (1987), Generierung mit GPSG, in K. Morik (ed.
), l'rocs.llth German WorL~hop on Artificial Intelligence, Berlin, Springer,355-364.Gazdar, Gerald; Klein, Ewan; Pnllum, Geoffrey; and Sag, Ivan (1985),Generalized Phrase Structure Grammar, Oxford, Blackwell.Hauensehild, Christa (1986), KIT/NASEV oder die Problematik des Transfers beider maschinellen (lbersetzung, in I. S. B~ftori and H. J. Weber (eels.
),Neue Ansiitze in maschineller ~lbersetzung.
Wissensrepr?isentation undTextbezug, Tiibingen, Niemeyer, 167-185.Hauen~hild, Christa, and Busemann, Stephan (1988), A Constructive V rsion ofGPSG for Machine Translation, toappear in E. Steiner, P.Schmidt, andC.
Zelinsky-Wibbelt (eds.
), From Syntax to Semantics -lnsights FromMachine Translation, London, Frances Pinter, 1988.King, Mm'garet, and Perschke, Sergej (1987), EUROTRA, in M. King (ed.
),Machine Translation Today: The State of the Art, Edinburgh, EdinburghUniversity Press, 373-391.Preug, Susanne (1987), GPSG-Syntax ffir ein Fragment des Deutschen, KITInternal Working Paper No.
20, Fachbereich Informatik, Techni.~cheUniversitlR Berlin.Ristad, Eric Sven (1986), Computational Complexity ofCurrent GPSG Theory, inProcs.
24th Annual Meeting of the ACL, New York, 30-39.Shieber, Stuart M. (1986), A Simple Reconstruction f GPSG, in Procs.
11thCOLING-86, Bonn, 211-215.Uszkoreit, Hans (1984), Word Order and Constituent S ructure in Gerte~an, Ph.D.Dissertation, University ofTexas, Austin.Weisweber, Wilhelm (1987), Ein Dominanz-ChartoParser fiir GeneralisiectePhrasenstrukturgrartm~atiken, KY~' Report 45, Fachbereich Iu~brmalik,Technische Universit/lt Berlin.Weisweber, Wilhelm (1988), Using Constraints in a Constructive V rsion ofGPSG, in Procs.
12th COLING-88 (this volume), Budapest.82
