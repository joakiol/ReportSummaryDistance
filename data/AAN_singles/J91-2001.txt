Features and FormulaeMark  Johnson"Brown UniversityFeature structures are a representational device used in several current linguistic theories.
Thispaper shows how these structures can be axiomatized in a decidable class of first-order logic,which can also be used to express constraints on these structures.
Desirable properties, suchas compactness and decidability, follow directly.
Moreover, additional types of feature values,such as "set-valued" features, can be incorporated into the system simply by axiomatizing theirproperties.1.
IntroductionMany modern linguistic theories, such as Lexical-Functional Grammar  (Bresnan 1982),Functional Unification Grammar  (Kay 1985), Generalized Phrase Structure Grammar(Gazdar et al 1985), Unification Categorial Grammar  (Haddock et al 1987), (Uszkoreit1986), and Head-Driven Phrase Structure Grammar  (Pollard and Sag 1987), replace theatomic categories of a context-free grammar  with a "feature structure" that representsthe syntactic and semantic properties of the phrase.
These feature structures are spec-ified indirectly in terms of constraints that they must satisfy.
Lexical entries constrainthe feature structures that can be associated with terminal nodes of the syntactic tree,and phrase structure rules simultaneously constrain the feature structures that can beassociated with a parent node and its immediate descendants.That is, lexical entries and syntactic rules used to construct a syntactic phrasestructure tree all contribute constraints on the feature structures that appear as thelabels on nodes in the syntactic tree.
The tree is well formed if and only if all ofthese constraints are simultaneously satisfiable.
Thus for the purposes of recognitiona method for determining the satisfiability of such constraints is required; the precisenature of the satisfying feature structures (of which there may be infinitely many) isof secondary importance.
1A variety of different ypes of feature structures have been proposed in the liter-ature, but most work on unification-based grammar  has centered on a certain type offeature structure known as an attribute-value structure.
The elements in an attribute-value structure come in two kinds: constant elements and complex elements.
Constantelements are atomic entities with no internal structure: i.e.
they have no attributes.Complex elements have zero or more attributes, whose values may be any other ele-ment in the structure, including a complex element.
An element can be the value ofzero, one or several attributes.
Attributes are partial: it need not be the case that everyattribute is defined for every complex element.
* Department ofCognitive and Linguistic Sciences, Providence, RI 02912 USA1 The validity problem is also of interest, since it provides a way of "extracting information" about all ofthe satisfying feature structures.
In the framework developed below, if ~ is a formula representing asystem of constraints and ~b --~ 0 is valid, then 0 is a true description of every feature structuresatisfying ~b.
(~ 1991 Association for Computational LinguisticsComputational Linguistics Volume 17, Number 2"Mary seems to like John"eo-pred =subj =e3comp :seem- 11I num = sgi agre5 ~pers 3rdpred = marypred = likeI pred = johnobj= ~ ~num=e2 ~agr e4~pers =tense = nonesubj = e 3tense = pres3;:11Figure 1An attribute-value structure for Mary seems to like JohnExample 1Figure 1 depicts an attribute-value structure.
The attribute-value element labeled eoin Figure 1 might be associated with the sentence Mary seems to like John.The attribute-value structure depicted in Figure 1 contains ix complex elementseo,..., e5 and eight constant elements seem, like, john, sg, 3rd, mary, none, and pres.
Theelement eo is a complex attribute-value element with four attributes: pred, subj, comp,and tense: the order in which the attributes appear in the diagram is irrelevant.
Thevalue of its pred attribute is the constant seem (which abbreviates the relation denotedby the verb seem), and the value of its tense attribute is the constant element pres(which indicates that the clause is in the present ense).
The values of the subj andcomp attributes are the complex elements e3 and el (which represent the subject and thecomplement of the verb seem, respectively).
The element e3 also appears as the subjectof el, indicating that Mary is also the (understood) subject of the verb likes as well.The element el is a complex attribute-value element with four attributes pred, obj,subj, and tense.
The value of its pred attribute is the constant element like (which abbre-viates the relation denoted by the verb like) and the value of its tense attribute is theconstant element none (which indicates that the clause is untensed).
The values of theattributes obj and subj of el are the complex elements e2 and e3, respectively (whichrepresent the subject and object of the clause).
Both e4 and e5 have the same attributeshum and pets, and the values of these attributes of e4 are identical to the correspondingvalues of these attributes of e5.
Nevertheless, e4and e5 are distinct elements.An operation called unification plays an important role in most accounts of featurestructures (Kay 1985; Shieber 1986).
The unification operation "combines" or "merges"two elements into a single element that agrees with both of the original elements onthe values of all of their defined sequences of attributes, so the unification of twocomplex elements requires the unification of the values of any attributes they havein common.
The unification operation fails if it requires the unification of distinct132Johnson Features and Formulaesalmonswimse'-pred = salmonagr= ~pers= 3rdlp ~~0 L J ,pred = swim~num =subj = agr f =, \[_pers --e" 2" tense = pres3rdFigure 2Lexical entries for salmon and swim"The salmon swims"pred =?
subj =e'e"tense =swim s !l / ;Lpers--~pred = salmonpresFigure 3An example of attribute-value nificationconstant elements (a constant-constant clash) or the unification of a constant elementand a complex element (a constant-complex clash).Example 2A grammar might assign the attribute-value structures in Figure 2 to the NP the salmonand the VP swims, respectively.
Note that e' does not have a num attribute, since thesalmon can be either singular or plural  and that e" does not have a pred attribute.The attribute-value structure for the sentence (the) salmon swims is obtained byunifying e' and e', which corresponds to identifying salmon as the subject of swims.The resulting element inherits the value of the pred attribute from e' and the value ofthe num attribute from e'.
The unification of e' and e" requires the unification of f~ andf" as well.Although it might not be obvious from this simple example, a large number ofsyntactic onstructions from a variety of natural anguages can be described in sucha unification-based framework (many of the analyses presented in Bresnan 1982 canbe expressed in such a "pure" unification-based framework).
Nevertheless, it is oftenconvenient and sometimes necessary to extend the basic unification framework toinclude a wider variety of feature structures.For example, "negative values" and "disjunctive values" allow grammars andlexical entries to be written much more succinctly, as the following examples how(based on Karttunen 1984).133Computational Linguistics Volume 17, Number 2d/e_ _  mcat = determiner/~number: singular-~ \agr= ~_gender: femininel~\ ~number: plural ~ /nomcase= (acc /Figure 4Disjunction in the lexical entry for dieswim I pred = swim l j l  I ~num= sg subj = agr = --, tense  ~ pre s f~eers = 3rd gFigure 5Negation in the lexical entry for swimExample 3In German the determiner die must have accusative or nominative case, and agreeswith either feminine singular nouns or plural nouns of any gender.
In a frameworkwith disjunctive values only one lexical entry for die is required.
2Example 4In the basic unification framework described above the tensed verb swim would requiremultiple lexical entries, since it agrees with first person, second person, and plural thirdperson subjects; i.e., a subject with any agreement features other than third personsingular.
In a framework with "negative values" it requires only the single lexicalentry in Figure 5, where "-~" identifies a "negative value.
"As mentioned earlier, other kinds of feature structures besides attribute-valuestructures have been proposed in the literature.
Johnson and Klein (1986) and Johnsonand Kay (1990) show how "set-valued" features can be used to express Discourse Rep-resentation Theory (Kamp 1981) in a complex-feature based grammar formalism.
Thehighly simplified example below is meant solely to show one way in which set-valuedfeatures can be used--no claims are made for its linguistic correctness.2 "Disjunctive" features are depicted using angle brackets, since curly brackets are used in this paper todepict "set-valued" features.
Below we reinterpret the "disjunctive" and "negative" features depictedin this example and the next as disjunctions and negations of constraints.134Johnson Features and Formulae~ at = NPlindex ~ s Jshe -- I refs-in = s | womanu ~efs-out = s~I cat = Nr index = i' JJj refs-in = s'i refs-out = s' u { i' } v \ [ _Figure 6Set-values in the lexical entries for she and woman~ at = N ,I index = iI refs-in = { }v ~efs-out = { i'}Figure 7The result of unifying s' in Figure 6 with the empty setExample  5A naive theory of anaphoric dependencies between indefinite NPs and anaphoric pro-nouns can be constructed as follows.
Each NP has an index attribute whose value isa "reference marker," and two NPs are coreferential iff they share the same referencemarker.
3 Every feature structure associated with a node in the syntactic tree has at-tributes refs-in and refs-out, whose values are the sets of discourse entities availablepreceding and following this node, respectively.
The grammar constrains the valueof the refs-out attribute of an indefinite NP to be the union of its refs-in attribute andthe singleton set containing the value of the NP's index attribute; this adds the NP'sindex to the set of available indices.
Similarly, the grammar equires the values of apronoun's refs-in and refs-out attributes to be identical, and that its index attribute be amember of the value of its refs-in attribute.
This requires that the pronoun refer to anentity previously introduced into the discourse.
In a framework with set values thelexical entries for (a) woman and she could be as seen in Figure 6.Unifying the value s' of the refs-in attribute of the lexical entry for woman with theempty set (which corresponds to the empty discourse context) produces the featurestructure depicted in Figure 7.Further, the unification of the value of the refs-out attribute in Figure 7 with thevalue of the refs-in attribute of u in Figure 6 (the lexical entry for she), which corre-sponds to interpreting the pronoun as an anaphor within the context established bythe single NP a woman produces the feature structure depicted in Figure 8.Extending the possible feature structures beyond the basic attribute-value f aturescomplicates the basic unification operation, however.
For example, Moshier and Rounds(1987) and Pereira (1987) point out that it is not obvious how to extend unification3 Reference markers in DRT correspond approximately to the referential indices associated with NPs inGB theory.135Computational Linguistics Volume 17, Number 2cat = NP \[\]index = i'I refs-in = { i'}u ~efs-out = { i'}Figure 8The result of unifying the value of the refs-out attribute of Figure 7 with s in Figure 6this > def= Tnum= sgu agrv  L pers = 3rdthese.def = +num = pl~agr-- LPers= 3rdU' V'salmon > IP red= salm?n3rd\] 1e, Lagr =f\[Pe rs=swim rpre i pers nUm sgllagr= 3rd subj =eg ~ tense = presFigure 9Feature structures demonstrating interaction of negative values and unificationto negative feature values; specifically, some apparently plausible extensions lose theassociativity property of unification.Example 6Consider the feature structures in Figure 9, which might be assigned to the singulardeterminer this, the plural determiner these, the noun salmon, and the verb swim (thelatter two structures are the same as those depicted in Figures 2 and 5).
These can beused to analyze utterances such as these salmon swim and (the ill-formed utterance) thissalmon swim, which involve the unification of u, e', and e or u', e', and e, respectively.Suppose a negative value is interpreted as a constraint hat a feature structureeither satisfies or does not satisfy, and suppose further that in Figure 9 the negativefeature constraint f is satisfied by the value f'.
Then e' and e in Figure 9 unify, andmoreover further unification of e ~ with either u ~ or u succeeds, undesirably in the lattercase.
(Reinterpreting the negative constraint f so that f' fails to satisfy it does not help,since the unification of e, e', and u ~ should succeed).
On the other hand, we obtain theresults we desire if e' is unified with u or u ~ before being unified with e. If e' is firstunified with u, then f~ is unified with v, and further unification of e' with e fails, sincev does not satisfy f. If e' is first unified with u' then f' is unified with v' and furtherunification of e' with e succeeds, since v' does satisfy f. Thus under this interpretation136Johnson Features and Formulaeof negation and unification, the success or failure of a sequence of unifications dependson the order in which they are performed.
42.
Feature Structures and Function-free FormulaeThese problems have generated a considerable body of work on the mathematicalproperties of feature structures and the constraints and operations that apply to them.Following Kaplan and Bresnan (1982), Pereira and Shieber (1984), Kasper and Rounds(1986, 1990), and Johnson (1988, 1990a) the constraints hat determine the feature struc-tures are regarded as formulae from a language for describing feature structures, ratherthan as feature structures themselves.Disjunction and negation appear only in expressions from the description lan-guage, rather than as components of the feature structures that these expressions de-scribe.
Thus the lexical entries in the examples above will be interpreted as formulaethat constrain the feature structures that can be associated with these lexical items ina syntactic tree, rather than the feature structures themselves.
For example, the featurematrices depicted in Figures 2, 4-6, and 9 will be interpreted as graphical depictions offormulae xpressing constraints on linguistic objects, rather than the linguistic objectsthat satisfy these constraints.
This avoids any need to refer to "negative" or "disjunc-tive" objects as entities appearing in a feature structure.As explained below, the familiar attribute-value "unification algorithm" can beinterpreted as computing the atomic consequences of a purely conjunctive formula(where the graphs it operates on are data structures efficiently representing such for-mulae), and unification failure corresponds to the unsatisfiability of that conjunction(Kasper and Rounds 1990; Johnson 1988, 1990a; Pereira 1987).The most widely known model of feature structures and constraint language isthe one developed to explain disjunctive feature values by Kasper and Rounds (1986,1990) and Kasper (1986, 1987).
The Kasper-Rounds treatment resolves the difficultiesin interpreting disjunctive values by developing a specialized language for expressingthese constraints.
Various proposals to extend the Kasper-Rounds approach to dealwith negative feature values are described by Moshier and Rounds (1987), Moshier(1988), Kasper (1988), Dawar and Vijayashanker (1989, 1990), Langholm (1989); otherextensions to this framework are discussed by D6rre and Rounds (1989), Smolka (1988,1989), and Nebel and Smolka (1989); and Shieber (1989) discusses the integration ofsuch feature systems into a variety of parsing algorithms.One difficulty with this approach is that the constraint language is "custom built,"so important properties, such as compactness and decidability, must be investigatedfrom scratch.
Moreover, it is often unclear if the treatment can be extended tohandle other types of feature structures as well.
Rounds (1988) proposes a modelfor set-valued features, but he does not provide a language for expressing constraintson such set-valued entities, or investigate the computational complexity of systems ofsuch constraints.This paper follows an alternative strategy suggested in Johnson (1990a): axiomatizethe relevant properties of feature structures in some well-understood language (herefirst-order logic) and translate constraints on these structures into the same language.4 It is possible to avoid these problems by augmenting feature structures with "inequality arcs," as wasfirst proposed (to my knowledge) by Karttunen (1984) and discussed in Johnson (1990a), Johnson (inpress) and pages 67-72 of Johnson (1988).
However, it is hard to justify the existence of such arcs iffeature structures are supposed tobe linguistic objects (rather than data structures that representformulae manipulated during the parsing process).137Computational Linguistics Volume 17, Number 2Thus the satisfiability problem for a set of constraints on feature structures i reducedto the satisfiability problem for the axioms conjoined with the translation of theseconstraints in the target language.
Importantly, techniques used to determine satisfia-bility in the target language can be used to determine the satisfiability of the featureconstraints as well.
In this paper the properties of attribute-value structures and con-straints on them are expressed in a decidable class of first-order formulae: this meansthat the satisfiability problem for such formulae, and hence the feature constraints thatthey express, is always decidable.Of course, some linguistic analyses make use of feature structure constraint sys-tems that can encode undecidable problems.
For example, subsumpt ion  constraints,which are useful in the description of agreement phenomena in coordination con-structions (Shieber 1989) can be used to encode undecidable problems, as D6rre andRounds (1989) have shown.
Clearly such constraints cannot be expressed in a decidableclass, but often they can be axiomatized in other standard logics.
Johnson (1991) showshow (positively occurring) subsumption constraints can be axiomatized in first-orderlogic, and sketches treatments of sort constraints and nonmonotonic devices such asANY values (Kay 1985) and 'constraint equations' (Kaplan and Bresnan 1982) can beformalized in second-order logic using circumscription.2.1 Axiomatizing Feature Structures with Function-Free FormulaeThis section shows how the important properties of feature structures can be axioma-tized using formulae from the Sch6nf inke l -Bernays class, which is the class of first-orderformulae of the form3X1.
.
.
Xn~yl .
.
.
yng~where ~ contains no function symbols or quantifiers.
(Thus no existential quantifiercan appear in the scope of a universal quantifier.)
This class of formulae was chosenbecause it is both decidable (see e.g.
Lewis and Papadimitriou 1981) and can expressthe quantification eeded to describe the particular set operations proposed here, aswell as a variety of other interesting types of feature structures and constraints.
(Fora general discussion of decidable classes ee Gurevich 1976 and Dreben and Goldfarb1979.)
The next section shows how the various kinds of constraints on feature struc-tures described above can be translated into this class of formulae, so any system ofsuch feature constraints is decidable as well.The elements of a feature structure, both complex and constant, constitute thedomain of individuals in the intended interpretation.
The attributes are binaryrelations over this domain, s We proceed by axiomatizing the conditions under whichan interpretation corresponds to a well-formed feature structure, formulating them inessentially the same way as Smolka (1988, 1989) does.The axiomatization begins by describing the properties of the constant elements ofattribute-value structures.
The attribute-value constants are the denotation of certainconstant symbols of the language of first-order logic, but not all constants (of the first-order language) will denote attribute-value constants ince it is convenient to haveconstants that denote other entities as well.
The following axiom schemata express therequirement that attribute-value constants have no attributes and that all attribute-5 This differs from earlier work (Johnson 1988) in which values and attributes were both conceptualizedas individuals.
In fact, research inprogress indicates that it is advantageous to conceptualize ofattributes as individuals and attribute relations in terms of a 3-place relation arc, where arc(x, a, y) istrue iff the value of x's attribute a is y.
This permits the quantification ver attributes needed to defineboth simple and parameterized sorts to be expressed.138Johnson Features and Formulaevalue constants are distinct; i.e., that distinct attribute-value constants denote differententities.1.
For all attribute-value constants c and attributes a, V x -~a(G x).2.
For all distinct pairs of attribute-value constants Cl, c2, Cl # c2.The next axiom schema requires attributes to be single-valued.3.
For all attributes a,V xyz a(x,y) Aa(x,z) ~ y = z.This completes the axiomatization f attribute-value feature structures.
6 The claim isthat any interpretation that satisfies these axioms is an attribute-value structure, i.e.1-3 constitute a definition of attribute-value structures.
Such interpretations can beviewed as (possibly infinite and disconnected) irected graphs, where the individualsconstitute the graph's nodes and the attribute relations the arcs between those nodes.Thus these axioms admit a much wider class of models than do most other treat-ments of feature structures (e.g., Kasper and Rounds (1990) require feature structuresto be a certain type of finite automata).
In fact it is easy to add axioms requiringattribute-value structures to have additional properties uch as acyclicity.
But sincethe axioms that define attribute-value structures are in effect assumptions that stipulatethe nature of linguistic entities, we obtain a more general theory the weaker theseaxioms are.
Thus 1-3 are intended to stipulate only the properties of attribute-valuestructures that are required by linguistic analyses.Note that the partiality of attributes is of crucial importance: if attributes wererequired to be total rather than partial functions, we could not axiomatize them withformulae from the Sch6nfinkel-Bernays class.
(An axiom schema requiring attributesto be total functions would have instances of the form Vx 3y a(x,y), which do notbelong to the Sch6nfinkel-Bernays class).Example 7The interpretation corresponding to the attribute-value structure depicted in Figure 1has as its domain the set D = {seem, like, john, sg, 3rd, mary, pres, none} U {e0,..., es}.The attributes denote relations on D x D. For example, pred denotes the relation{leo~seem), (el, like), le2,johnl~ (e3~ maryl}.
It is straightforward to check that all of theaxioms hold in this interpretation.Instead of providing entities in the interpretation that serve as the denotation for "dis-junctive" or "negative" features, we follow Kasper and Rounds (1986, 1990), Moshierand Rounds (1987), and Johnson (1988, 1990) in permitting disjunction and negationonly in the constraint language.
Since the classical semantics of disjunction and nega-tion for first-order languages i  consistent and monotonic, a consistent, monotonicsemantics for negative and disjunctive feature constraints follows directly.
(An exam-ple is presented below; see Johnson (1990) and especially Section 2.10 of Johnson (1988)for further discussion).We turn now to the set-valued features.
The most straightforward way of introduc-ing set-valued features would be to combine some standard axiomatization f set the-ory with the axiomatization f attribute-value structures just presented.
Unfortunately,6 This axiomatization is finite iff the sets of attribute symbols and constant symbols are finite.
In theintended computational nd linguistic applications this is always the case.139Computational Linguistics Volume 17, Number 2all of the formulations of set-theory I am aware of, such as Zermelo-Fraenkel set-theory, are expressed in languages whose satisfiability problem is undecidable.
Whilethis does not imply that the satisfiability problem for set-valued feature-structure con-straints is also undecidable (since the feature constraint language may have restrictedexpressiveness), it does mean that its decidability cannot be shown by noting that atranslation into a decidable class of formulae exists.Also, as an anonymous reviewer points out, since the intended linguistic applica-tions only require finite sets and operations uch as union and intersection, standardtheories of sets (such as Zermelo-Fraenkel set-theory) are much more powerful thanneeded.Instead, we axiomatize just those properties of set-valued features that our featureconstraints require using formulae from the Sch6nfinkel-Bernays class.
We interpretthe two-place relation in as the membership relation; in(x ,  y)  is true in a model iff x is amember of y.
We place no restrictions on this relation, but in other formulations axiomsof foundation and extensionality could be used to ensure that the in relation can beinterpreted as the set-membership relation of Zermelo-Fraenkel set theory.
Thus thisaxiomatization presented here will admit models in which the values of set-valued fea-tures do not have these properties.
7 These additional properties of the set-membershiprelation don't seem to be needed in linguistic analyses, so such stipulations are notmade here.The axiom of foundation requires that all sets are well founded; i.e., that the tran-sitive closure of the set-membership relation is irreflexive, or more informally, that noset directly or indirectly contains itself as a member.
Versions of set-theory that relaxthis restriction have been proposed by, e.g., Aczel (1988), and Rounds (1988) arguesthat non-well  founded sets may be appropriate models of set values in feature struc-tures.
The paradoxes associated with non-well  founded set theories are avoided herebecause the axiom of comprehension that asserts the existence of paradoxical sets isnot included in this axiomatization; i.e., the only way of defining a set is either byexplicitly listing its members or by means of union and intersection operations.The axiom of extensionality requires that if sets $1 and $2 contain exactly the samemembers then $1 = $2; without extensionality it is possible for two different sets tocontain exactly the same members.
Admittedly the primary reason for omitting anextensionality axiom is that it does not appear to be axiomatizable using Sch6nfinkel-Bernays' formulae, but three other reasons motivate this decision.First, as noted in Shieber (1986) and in Example 1 above, feature structures ingeneral are not extensional (e.g., two distinct attribute-value elements can have ex-actly the same attributes and values), and it seems reasonable to treat set-values in anonextensional fashion as well.Second, extensionality could produce undesirable interactions with the attribute-value component of feature structures.
Since set-valued features can also have at-tributes (for example, in LFG (Kaplan and Bresnan 1982)) a conjunction is associatedwith a set-value that also has attributes), extensionality would prohibit there being7 In fact here are Sch6nfinkel-Bernays xioms that require the in relation to be acyclic.
Define a newrelation, say in + , by the axiomsV es in(e,s) ---* in+(e,s)V ess' in+(e,s) A in+(s,s ') ~ in+(e,J).Then in any model in + denotes asuperset of the transitive closure of the in relation.
The followingaxiom requires that this transitive closure is irreflexive, i.e.
that no set is contained in itself.v s ~in + (s, s).140Johnson Features and Formulaetwo set-valued features that contain exactly the same elements but that differ on thevalue of some attribute, something a linguistic analysis might reasonably require.Third, as far as I am aware, no linguistic analysis requires sets to be extensional.Appealing to the same general considerations that were used to justify the attribute-value axioms, since the assumption that sets are extensional is not required, the stip-ulation is not made here.It is necessary to define some predicates that describe set-values.
We begin by pre-senting a general first-order axiomatization of these predicates, and then approximatethese with formulae from the Sch6nfinkel-Bernays class.Most of the definitions are straightforward, and are given without explanation, sThe unary predicate null is true of an element iff that element has no members.4.
Vx null(x) ~ -~y  in(y,x)The ternary relation union(x, y, z) is true only if every element in z is in x or y.5.
Vxyz union(x,y,z) ~ Vu in(u,z) ~ in(u,x) V in(u,y)The ternary relation intersection(x, y z) is true only if every element in z is in x and in y.6.
Vxyz intersection(x,y,z) ~ Vu in(u,z) *--* in(u,x) A in(u,y)The binary relation singleton(u, x) is true if and only if u is the only member of x.7.
Vux singleton(u, x) ~ in(u, x) A Vv in(v, x) ~ u = vUnfortunately the axioms 4-7 do not belong to the Sch6nfinkel-Bernays class, so wecannot guarantee the decidability of systems of constraints defined using them simplyby noting a translation into this class exists.
However, in all of the linguistic applica-tions I am aware of these predicates always appear positively, and in this case theseaxioms can be replaced by the corresponding "one-sided" axioms given below.
(Thepredicate null is an exception, since some HPSG analyses (Pollard and Sag 1987) re-quire the set of unsaturated arguments of some phrases to be non-null.
However, itis possible to require that a set s is nonempty by introducing a new constant u andrequire that in(u, s).)4'.
Vxy null(x) --* -,in(y, x)5'.
Vuxyz union(x,y,z) --.
(in(u,z) ~ in(u,x) V in(u,y))6'.
Vuxyz intersection(x,y,z) --.
(in(u,z) ~ in(u,x) A in(u,y))7'.
Vuxv singleton(u, x) --.
(in(u, x) A in(v, x) --* u = v)These one-sided efinitions are incorrect when these predicates appear negatively (i.e.,in the scope of an odd number of negation symbols after all other proposition con-nectives have been expressed in terms of A, V, and -,).
For example, an interpretation8 In the following axioms all of the connectives are to be interpreted asright-associative.141Computational Linguistics Volume 17, Number 2with an empty in relation can satisfy =null(x).
As Johan van Benthem and the anony-mous reviewer independently pointed out to me, it is possible to prove that so long asthe relations null, union, intersection, and singleton appear only positively in linguisticconstraints, any model satisfying 4'-7' differs from a :model satisfying 4-7 at most inthe denotation of these relations; other relations, in particular the attribute relations oreven the in relation, are not affected by the one-sided approximation.
The followingproposition expresses this.PropositionLet x be a tuple of variables, A be any relation symbol, ~(A) be any formula in whichA appears only positively, and ~(x) be a formula in which A does not appear.
Then(i) .M ~ @(A) A Vx A(x) *-+ ~(x)if and only if there is a model M'  differing from A4 only on the denotation it assignsto A such that(ii) A4' ~ @(A) A Vx A(x) -+ ~(x).ProofThe left to right direction is obvious.
The proposition follows from right to left asfollows.
Let A,/' be any model that satisfies (ii).
A model A4 that satisfies (i) can beconstructed as follows.
Let A4 be the model that agrees with A4' except possibly on A,where IAIM = IAI~, U ~Ax~(x)~,.
Now we check that M satisfies (i).
Since ~A~ 2~A~, and A appears only positively in @(A), A4 ~ ~(A).
Further dr4 ~ VxA(x) *-- ~(x)by construction.
Since A does not appear in ~(x), ~Ax~(x)~ = ~Ax~(x)~,, and since~A~M D \ [A~, ,  M ~ VxA(x) --+ ~(x) as well.
Thus M satisfies (i) as required.
Infact we have shown something stronger; the denotation of A in A4' is a subset of thedenotation of A in d~4.
?2.2 Expressing ConstraintsA feature structure is specified implicitly by means of the constraints hat it must sat-isfy.
This section shows how such constraints can be translated into quantifies-free andfunction-free prenex formulae.
There is a plethora of different notations for expressingthese constraints: the constraint requiring that the value of attribute a of (the entitydenoted by) x is (the entity denoted by) y is written as Ix a / -- y in PATR-II (Shieber1986), as (x a) = y in GFG (Kaplan and Bresnan 1982), and as x(a) ~ y in Johnson(1988), for example.
Here we express attribute-value constraints using the attributerelations a, so this constraint would be expressed as a(x, y).
Set-valued constraints areexpressed using the relations in, null, union, and singleton defined in the previous ec-tion.
The propositional connectives are used to express negative and disjunctive featureconstraints.
This section shows how constraints on feature bundles can be specifiedusing equality, the attribute relations, and the set predicates axiomatized in the lastsection.
(In fact as far as the theoretical results of this paper are concerned all that isimportant is that the constraints are taken to mean the same thing as these formulae,irrespective of the notation in which they are expressed.
)142Johnson Features and FormulaeExample 2 (continued)The lexical entries for salmon and swims in Figure 2 are the following formulae, wheree ~, e', f~, f"  and g" are constants of the first-order language that are not attribute-valueconstants.
98a.
pred(e'~ salmon) A agr(e', f') A pers(f', 3rd)8b.
pred(g", swim)A tense(g", pres)A subj(g", e")A agr(e',f")Anum(f", sg)A pers(f", 3rd).Example 3 (continued)The lexical entry for the determiner die of Figure 4 is the following formula, where x isa (non-attribute-value) constant hat denotes the feature structure of the determiner,and y and z are constants that are not attribute-value constants.9.
cat(x, determiner) A agr( x, y ) A (case(x, nom ) V case(x, acc )) A(number(y, plural) V (number(y, singular)A gender(y, feminine) )Example 4 (continued)The lexical entry for the verb swim of Figure 5 is the following formula, where g is aconstant hat denotes the feature structure of the verb, and e and f are constants thatare not attribute-value constants.
1?10.
pred(g, swim)A tense(g, pres)A subj(g, e)A agr(e,f)A-~(num(f, sg)A pers(f , 3rd) )The lexical entries for the determiners this and these of Figure 9 are the followingformulae, where u, v, u ~ and v ~ are constants that are not attribute-value constants,and u denotes the feature structure of this and u ~ denotes the feature structure of these.11.
def(u, +) A agr(u, v) A num(v, sg) A pers(v, 3rd)12. def(u', +) A agr(u', v') A num(v',pl) A pers(v',3rd)9 Instead of naming all of the nonroot attribute-value elements with constants as is done here, it ispossible to merely assert heir existence using an existential quantification.
For example, the lexicalentry for salmon could be the formula3f'pred(e', salmon) A agr(e', f I) A pers(f , 3rd)where fr is an existentially quantified variable.
This formulation has the advantage that no 'renaming'is needed when determining subsumption of systems of attribute-value constraints.
(The subsumptionrelation between systems of constraints i used in certain types of 'unification based' parsers (Shieber1989).)
That is, a system of constraints represented by a formula ~ subsumes another system ofconstraints represented by 8 iff A ~ 0 ~ ~, where A is the conjunction of the axioms defining therelevant types of feature structures.10 The formulation (10) of the negative constraint depicted in Figure 5 does not imply that f has either anum or pers attribute.
Conceivably, one might want to interpret such a negative constraint as requiringf to have both num and pers attributes with values differing from either sg or 3rd, respectively.
Theformula below expresses this interpretation.pred(g, swim) A tense(g, pres) A subj(g, e) A agr(G f) Ahum(f+ u) A pers(f , v) A -~(u = sg A v = 3rd)143Computational Linguistics Volume 17, Number 2Example 5 (continued)The lexical entries for she and woman of Figure 6 are the formulae (13) and (14), whereu denotes the feature structure of the pronoun, v denotes the feature structure of thenoun, and w, s, s', s', i, and i' are constants that are not attribute-value constants.13.
cat(u, np) A refs-in(u, s) A refs-out(u, s) A index(u, i) A in(i, s)14. cat(v, n)A index(v, i')A refs-in(v, s')A refs-out(v, s")A singleton(i', w)Aunion(s', w, s")In general then, a system of feature structure constraints can be viewed as a function-free and quantifier-free formula.
These constraints are satisfiable if and only if there isan interpretation that simultaneously satisfies the corresponding formula and the ax-ioms presented in the previous ection, or equivalently, the conjunction of this formulaand the relevant axioms from the axiomatization.
This conjunction is itself a formulafrom the Sch6nfinkel-Bernays class, and so the satisfiability problem for systems offeature structure constraints i decidable.Further, we can apply results on the computational complexity of the satisfiabilityproblem for the Sch6nfinkel-Bernays class to determine the computational complexityof the satisfiability problem for systems of such feature constraints.
Since (universal)quantifiers appear only in the axiomatization of feature structures and not in thefeature constraints themselves, the number of quantifiers appearing in the conjunctionof the feature constraints and the axiomatization is a constant, and does not vary withthe size of the system of feature constraints.
By Proposition 3.2 of Lewis (1980), thesatisfiability problem for a formula F with u universal quantifiers in the Sch6nfinkel-Bernays class requires nondeterministic time polynomial in IFI u, so the problem is inNP.
The reductions presented in Kasper and Rounds (1986) and Johnson (1988) canbe used to show that the problem is NP-hard, so the satisfiability problem for featureconstraints with set-values (as defined above) is NP-complete.2.3 Unification and SatisfactionThis section discusses the relationship between unification and the axiomatizationpresented above.Unification identifies or merges exactly the elements that the axiomatization im-plies are equal.
The unification of two complex elements e and e' causes the unificationof the values of all attributes a that are defined on both e and e'.
Similarly, the con-junction of the formulae = e', a(6 f), a(e', f') and the axioms given above implies thatf = f ,  since axiom schema (3) requires that attributes are single valued.Similarly, the unification of two attribute-value structures fails either when twodistinct constant elements are unified (a constant-constant clash) or when a constantand a complex element are unified.
The formula x = x ~ is unsatisfiable under exactlythe same circumstances in the theory axiomatized above.
The formula x = x' conjoinedwith x = c and x' = c' for distinct attribute-value constants c, c' is unsatisfiable, sincec ?
c' by axiom schema (2).
Also, x = x' is unsatisfiable when conjoined with a(x,y)for any y and x' = c, since ~a(c,y) by axiom schema (1).If attention is restricted to purely conjunctive attribute-value systems, the corre-sponding formulae can be represented as a directed graph, where nodes represent(first-order) constants, and an arc labeled a from x to y encodes the atom a(x,y).Then the standard attribute-value 'unification algorithm' can be used as a specializedinference procedure that takes as input such a graph encoding of a conjunction of144Johnson Features and Formulaeattribute-value r lations and returns (the graph encoding of) the conjunction of all oftheir atomic consequences.As Kasper (1986, 1987) noted in a different setting, the steps of the attribute-valueunification algorithm are just applications of the axioms 1-3.
It 'forward chains' usingaxiom schema (3) (for which the graph representation provides efficient indexing),and checks at each step that 1 and 2 are not falsified; if they are falsified the unifi-cation algorithm halts and reports a unification failure.
Atomic equalities x = y arerepresented by a 'forwarding pointer' from x to y (as in the UNION-HND algorithm(Gallier 1986; Nelson and Oppen 1980; Johnson in press)).Example 2 (continued)The unification of e ~ and e" in Figures 2 and 3 corresponds to conjoining the formulae ~ = e" to the conjunction of 8a and 8b, resulting in the formula 15a.15a.
e '= e"A pred(e', salmon) A agr(e', f') A pers(f', 3rd)A pred(g", swim)Atense(g", pres)A subj(g", e")A agr(e", f")A num~f", sg )A pers(~", 3rd).This formula can be simplified by substituting e r for e" to yield 15b (this substitutioncorresponds exactly to the first step of the unification algorithm, viz.
redirecting e"to e0.
The affected subformulae are in boldface below.15b.
e' = e"A pred(e'~ salmon)A agr(e',f')A pers~f', 3rd)A pred(g"~ swim)Atense(g", pres)A subj(g"~ e')A agr(e'~f")A num(f", sg)A pers(f", 3rd).Since 15b contains the conjunction of agr(e',f') and agr(e',f"), axiom schema (3) re-quires that f' = f", so 15b can be further simplified by substituting f' for f" toyield 15c.15c.
e' = e"A f' = f"A pred(e', salmon)A agr(e',f')A pers(f', 3rd)Apred(g", swim)A tense(g"~ pres)A subj(g", e')A agr(e'~ f')A num~f'~ sg)Apers(f'~ 3rd).The duplicate occurrences of agr(d,f') and pers(fr,3rd) can be deleted, yielding 15d(these last two steps correspond exactly to the unification of f~ and f" in Figure 3).15d.
e' = e"A f '=  f"A pred(e', salmon)A agr(e',f')A pers(f',3rd)Apred(g", swim )A tense(g", pres )A subj(g", e')A num(f', sg).No further simplifications are possible, and 15d is satisfiable.
In fact 15d describes thestructure depicted in Figure 3, as expected.The standard unification algorithm is unable to handle negative constraints correctly,as noted above.
However, because negation is interpreted eclaratively (in fact, clas-sically) in the first-order language used to express constraints here, its treatment isstraightforward and unproblematic, and suggests ways of extending the unificationalgorithm to cover these cases (Johnson 1990b, to appear).145Computational Linguistics Volume 17, Number 2- pred = swimI pred = salmonsubj = \[ agr = -!
num= ~sg 1~'L 3fLpers= 3rdtense = presFigure 10A graphical depiction of the formula 16bExample 4 (continued)The unification of e ~ and e (i.e.
the lexical entries for salmon and swim) of Figure 9corresponds to the conjunction of the formula e = e I to the conjunction of 8a and 10,which is the formula 16a.16a.
e = e'A pred(e', salmon)A agr(e',f)A pers(f', 3rd)A pred(g, swim)Atense(g, pres)A subj(g, e)A agr( G f)A -~(num(f , sg)A pers(f , 3rd)This can be simplified by straightforward applications of axiom schema (3), equalitysubstitution, and propositional equivalences to obtain 16b.16b.
e = e'A f = f'A pred(G salmon)A pers(f, 3rd)A pred(g, swim)Atense(g, pres)A subj(g, e)A agr(G f)A -~num(f , sg).This formula could be depicted as in Figure 10, where such matrices are now to beunderstood as graphical depictions of formulae.
The further unification of e' with u,the lexical entry for this, corresponds to the conjunction of e ~ = u to the conjunction ofthe formulae 16b and 11, which is the formula 16c.16c.
e = e'A f = f'A e' = uA pred(G salmon)A pers(f, 3rd)A pred(g, swim)Atense(g, pres)A subj(g, e)A agr(e, f)A -~num(f , sg)A def(u, +)A agr(u, v)Anum(v, sg)A pers(v, 3rd).By substituting e for both e I and u in 16c, we obtain 16d.16d.
e = e'A f = f'A e = uA pred(e, salmon)A pers(f, 3rd)A pred(g, swim)Atense(g, pres)A subj(g, e)A agr(e,f)A -~num(f, sg)A def(e~ +)A agr(e~ v)Anum(v, sg)A pers(v, 3rd).Again, since 16d contains the conjunction of agr(e,f) and agr(G v), axiom schema (3)requires that f = v, so 16d can be further simplified by substituting f for v, yielding 16e.16e.
e = e'A f = f'A e = uA f = vA pred(e, salmon)A pers(f, 3rd)Apred(g, swim)A tense(g, pres)A subj(g, e)A agr( G f)A -~num(~, sg)Adef(G +)A agr(e,f)A num(f, sg)A pers(f,3rd).146Johnson Features and Formulae- pred =subje,e,utense =swim- pred = salmondef = +agr= Inum=pl  1 !,~ pers = 3rd)resF igure  11A graphical depiction of the formula 16f'The formula 16e is unsatisfiable, since it contains conjunction of both num(f, sg) andits negation -~num(f, sg).
This is the desired result, since the utterance this salmon swimis ill formed.On the other hand, the unification e' in 16b (c.f.
Figure 10) is with u', the lexicalentry for these, corresponds to the conjunction of e' = u', 16b and 12, which is theformula 16c'.16c'.
e = e'A f = f'A e' = u'A pred(e, salmon)A pers(f, 3rd)A pred(g, swim)Atense(g, pres)A subj(g, e)A agr(e, d)A -~numff , sg)A def(u', +)A agr(u', v')Anum(v', pl)A pers(v', 3rd).By following the same steps as were used to simplify 16c to 16e, 16c' can be simplifiedto 16e'.16e'.
e = e'A f =f 'A  e = u'A f = v'A pred(e, salmon)A pers(f, ard)Apred(g, swim)A tense(g, pres)A subj(g, e)A agr(e, f)A -~nurn(f , sg)Adef(e, +)A agr(e,f)A num(f , pl)A pers(f , 3rd).One of duplicate conjuncts agr(e,f) can be deleted, and since num(f, pl) implies-~num(f, sg) (by instances g  pl of (2) and Vxyz num(x,y) A num(x,z) --+ y = z of(3)), 16e' can be further simplified to 16f', where -~num(f, sg) has also been deleted.16f'.
e = e'A f = f'A e = u'A f = v'A pred(e, salmon)A pers(f, 3rd)Apred(g, swim)A tense(g, pres)A subj(g, e)A agr(e, f)A def(e, +)A num(f , pl)Apers(f, 3rd).This formula is satisfiable, as desired, since the utterance these salmon swim is wellformed.
This formula could be depicted as in Figure 11, where again the matrix is tobe understood as a graphical depiction of the formula 16f'.The set-valued examples are somewhat more complicated because they involve quan-tification.147Computational Linguistics Volume 17, Number 2Example 5 (continued)The unification of s' with the empty set in Figure 6 corresponds to the conjunction of14 with the formula null(s'), as given in 17a.17a.
cat(v, n)A index(v, i')A refs-in(v, s')A refs-out(v~ s")A singleton(i', w)Aunion(d, w, s")A null(s').Now singleton(i', w) A union(d, w, s") implies by axioms (5) and (7) that Vu in(u~ s') *-*u = i' V in(u, s').
Further, since null(s') implies by axiom (4) that Vu-~in(u, s'), it followsthat 17a is equivalent to 17b.17b.
cat(v, n)A index(v, i')A refs-in(v, s')A refs-out(v, s')A singleton(i', w)Aunion(s',w,s")A null(s')A Vu (in(u,s") ~ u = i').Unifying the value of the refs-out attribute of Figure 7 with the value of the refs-inattribute of u in Figure 6 corresponds to conjoining s = s" with the conjunction of 17band 13, yielding 17c.17c.
s = s"A cat(u, np)A refs-in(u,s)A refs-out(u,s)A index(u, i)A in(i,s)Acat(v, n)A index(v, i')A refs-in(v, s')A refs-out(v, s')A singleton( i', w)Aunion(s',w,s")A null(s')A Vu (in(u,s') ~ u = i').This can be simplified by substituting s for s" and noting that Vu (in(u, s) ~ u = i')and in(i, s) implies that i = i', as required.17d.
s = s'A cat(u, np)A refs-in(u, s)A refs-out(u, s)A index(u, i)A in(i, s)Acat(v, n)A index(v, i)A refs-in(v, s')A refs-out(v, s)A singleton(i, w)Aunion(d, w, s)A null(s')A Vu (in(u, s) ~ u = i).3.
ConclusionThe general approach adopted here of separating the feature structures and the con-straints that they must satisfy is used in most accounts of feature structures.
The novelaspect of this work is that feature structures are axiomatized in and the constraints onfeature structures are expressed in a decidable class of first-order logic, so importantresults such as decidability and compactness follow directly.
The Sch6nfinkel-Bernaysclass of formulae used in this paper are sufficiently expressive so that "set-valued"features can be axiomatized quite directly.We conclude with some tentative remarks about the implementation f the systemdescribed here.
Although a general-purpose first-order logic theorem prover couldbe used to determine the satisfiability of Sch6nfinkel-Bernays formulae, it should bepossible to take advantage of the syntactic restrictions these formulae satisfy to obtaina more efficient implementation.
One way in which this might be done is as follows.First, the axioms should be expressed in clausal form, i.e.
in the form3xl ... xnV yl ... yn A1 A ... A Am --~ B1 V ... V Bnwhere the Ai and Bj are atoms.
These can be used in a 'forward chaining' inference pro-cedure using 'semi-naive valuation' (see Genesereth and Nilsson (1987) for details).148Johnson Features and FormulaeFor example, the clausal form expansion of axiom (5') for union is18a.
V xyzu union(x,y,z) A in(u,z) ~ in(u,x) V in(u,y)18b.
V xyzu union(x,y,z) A in(u,x) --* in(u,z)18c.
V xyzu union(x,y,z) A in(u,y) ~ in(u,z).Second, if efficiency comparable to the standard (purely conjunctive) unification algo-rithm is to be achieved, it is necessary to efficiently index atoms on their arguments(both from the original constraints and those produced as consequences during the in-ference process just described).
If we were dealing with only purely conjunctive formu-lae we could use a graph-based representation similar to the one used in the standardattribute-value unification algorithm, but since axioms such as 18a have disjunctiveconsequents we need a data structure that can represent nonconjunctive formulae,even if all of the linguistic constraints associated with lexical entries and syntacticrules are purely conjunctive.
This problem is an instance of the general problem ofdisjunction, and it seems that some of the techniques proposed in the feature-structureliterature to deal with disjunction (e.g.
Eisele and D6rre 1988; D6rre and Eisele 1990;Maxwell and Kaplan 1989a, 1989b) can be applied here too.AcknowledgmentsI would like to thank Nick Asher, JochenD6rre, Andreas Eisele, Martin Emele,Martin Kay, Ron Kaplan, Lauri Karttunen,Harry Lewis, John Maxwell, Bill Rounds,Gert Smolka, Stuart Shieber, RichThomason, Johan van Benthem, and J6rgenWedekind as well as an anonymousreviewer and audiences at the CLIN Dag inUtrecht and at the DFKI in Saarbrficken fortheir important contributions tothe materialpresented in this paper.
The idea oftranslating feature constraints into aspecialized language with desirablecomputational properties arose inconversation with J/irgen Wedekind.
HarryLewis noted that attribute-value structurescould be axiomatized using formulae fromthe Sch6nfinkel-Bernays class, and guidedme to the relevant results.
Naturally, allerrors remain my own.
The final revision ofthis paper was completed at the Institut f/Jrmaschinelle Sprachverarbeitung, UniversitatStuttgart, which I thank for providing acongenial research environment.ReferencesAczel, P. (1988).
Non-Well-Founded Sets.CSLI Lecture Notes Series, University ofChicago Press, Chicago.Bresnan, J.
(1982).
The Mental Representationof Grammatical Relations.
The MIT Press,Cambridge, Mass.Dawar, A. and Vijayashanker, K. (1990).Three-Valued Interpretation fNegation inFeature Structure Descriptions.
Universityof Delaware Technical Report 90-03.Dawar, A. and Vijayashanker, K. (1989).
"AThree-Valued Interpretation f Negationin Feature Structures," in The 27th AnnualMeeting of the Association of ComputationalLinguistics, Vancouver.D6rre, J. and Eisele, A.
(1990).
"FeatureLogic with Disjunctive Unification," inThe Proceedings ofCOLING--1990,Helsinki, Finland.D6rre, J. and Rounds, W. (1989).
OnSubsumption and Semiunification in FeatureAlgebras.
IWBS Report, IBM Germany.Dreben, B. and Goldfarb, W. D. (1979).
TheDecision Problem: Solvable Classes ofQuantificational Formulas.
Addison-Wesley,Reading, Mass.Eisele, A. and D6rre, J.
(1988).
"Unificationof Disjunctive Feature Descriptions," inThe Proceedings ofthe 26th Annual Meetingof the Association for ComputationalLinguistics, Buffalo, New York, 286--294.Gallier, J. H. (1986).
Logic for ComputerScience.
Harper and Row, New York.Gazdar, G.; Klein, E.; Pullum, G.; and Sag, I.(1985).
Generalized Phrase StructureGrammar.
Blackwell, Oxford, England.Genesereth, M. and Nilsson, N. (1987).Logical Foundations of Artificial Intelligence.Morgan Kaufmann, Los Altos.Gurevich, Y.
(1976).
"The Decision Problemfor Standard Classes," The Journal ofSymbolic Logic.
41.2, 460-464.Haddock, N. J.; Klein, E.; and Morrill, G.(1987).
Categorial Grammar, Unification149Computational Linguistics Volume 17, Number 2Grammar.
University of EdinburghEdinburgh Working Papers in CognitiveScience 1.Johnson, M. (1991).
"Logic and FeatureStructures," in Proceedings ofIJCAI 1991,Sydney.Johnson, M. (1990a).
"ExpressingDisjunctive and Negative FeatureConstraints with Classical First-orderLogic," in The Proceedings ofthe 28thAnnual Meeting of the Association forComputational Linguistics, Pittsburgh, PA.Johnson, M. (1990b).
"Features, Frames andQuantifier-Free Formulae," inP.
Saint-Dizier and S. Szpakowicz, eds.,Logic and Logic Grammars for LanguageProcessing, Ellis Horwood, New York.Johnson, M. (1988).
Attribute-Value Logic andthe Theory of Grammar.
CSLI Lecture NotesSeries, University of Chicago Press,Chicago.Johnson, M. (in press).
"Attribute-ValueLogic and Natural Language Processing,"in J. Wedekind, ed., Studies in UnificationGrammar, The MIT Press, Cambridge,Mass.
(originally presented at the TitiseeConference, Germany, 1988).Johnson, M. and Kay, M. (1990).
"SemanticOperators and Anaphora," in TheProceedings of COLING 1990, Helsinki,Finland.Johnson, M. and Klein, E.
(1986).
"Discourse, Parsing and Anaphora," inThe Proceedings ofCOLING 1986, Bonn,West Germany.Kamp, H. (1981).
"A Theory of Truth andSemantic Representation," inJ.
A. G. Groenendijk, T. M. V. Janssemand M. B. J. Stokhof, eds., Formal Methodsin the Study of Language, MathematicalCentre Tracts, Amsterdam.Kaplan, R. and Bresnan, J.
(1982).
"Lexical-functional grammar, a formalsystem for grammatical representation,"in J. Bresnan, ed., The MentalRepresentation f Grammatical Relations,The MIT Press, Cambridge, Mass.Karttunen, L. (1984).
"Features and Values,"in COLING-1984, The Association forComputational Linguistics, StanfordUniversity.Kasper, R. T. (1988).
"ConditionalDescriptions in Functional UnificationGrammar," in Proceedings ofthe 26thAnnual Meeting of the Association forComputational Linguistics, Buffalo, NewYork.Kasper, R. T. (1987).
"A Unification Methodfor Disjunctive Feature Structures," in TheProceedings of the 25th Annual Meeting ofthe Association for ComputationalLinguistics, Stanford University.Kasper, R. T. (1986).
Feature Structures: ALogical Theory with Application to LanguageAnalysis, Ph.D. Thesis, University ofMichigan.Kasper, R. T. and Rounds, W. C.
(1990).
"The Logic of Unification in Grammar,"Linguistics and Philosophy.
13.1, 35-58.Kasper, R. T. and Rounds, W. C. (1986).
"ALogical Semantics for Feature Structures,"in The Proceedings ofthe 24th AnnualMeeting of the Association for ComputationalLinguistics, Columbia University, NewYork.Kay, M. (1985).
"Unification in Grammar,"in V. Dahl and P. Saint-Dizier, eds.,Natural Language Understanding and LogicProgramming, North Holland, Amsterdam,The Netherlands.Langholm, T. (1989).
How to Say No withFeature Structures.
Department ofMathematics, University of Oslo,COSMOS Report No.
13.Lewis, H. (1980).
"Complexity Results forClasses of Quantificational Formulae,"Journal of Computer and System Sciences.
21,317-353.Lewis, H. and Papadimitriou, C. (1981).Elements of the Theory of Computation.Prentice Hall, New Jersey.Maxwell, J. and Kaplan, R. (1989a).
AMethod for Disjunctive ConstraintSatisfaction.
Xerox PARC ms.Maxwell, J. T., III and Kaplan, R.
(1989b).
"An Overview of Disjunctive ConstraintSatisfaction," in International Workshop onParsing Technologies, Carnegie Mellon,Pittsburgh, PA.Moshier, M. (1988).
Extensions to UnificationGrammar for the Description of ProgrammingLanguages, Ph.D. Thesis, University ofMichigan.Moshier, M. D. and Rounds, W. C.
(1987).
"A Logic for Partially Specified DataStructures," in The ACM Symposium on thePrinciples of Programming Languages,Association for Computing Machinery,Munich, Germany.Nebel, B. and Smolka, G. (1989).Representation a d Reasoning withAttributive Descriptions.
IBM StuttgartIWBS Report 81.Nelson, G. and Oppen, D. C. (1980).
"FastDecision Procedures Based onCongruence Closure," Journal of theAssociation for Computing Machinery.
27.2,245-257.Pereira, E C. N. (1987).
"Grammars andLogics of Partial Information," in TheProceedings of the International Conferenceon Logic Programming, Melbourne,150Johnson Features and FormulaeAustralia.Pereira, E C. N. and Shieber, S. M.
(1984).
"The Semantics of Grammar FormalismsSeen as Computer Languages," inCOLING-84, The Association forComputational Linguistics, StanfordUniversity.Pollard, C. and Sag, I.
(1987).Information-Based Syntax and Semantics,Volume 1.
CSLI Lecture Notes, ChicagoUniversity Press, Chicago.Rounds, W. (1988).
Set Values forUnification-Based Grammar Formalisms andLogic Programming.
Center for the Studyof Language and Information CSLIReport 129.Shieber, S. M. (1989).
Parsing and TypeInference for Natural and ComputerLanguages.
SRI International TechnicalNote 460.Shieber, S. M. (1986).
An Introduction toUnification-Based Approaches to Grammar.CSLI Lecture Notes Series, University ofChicago Press, Chicago.Smolka, G. (1989a).
Attributive ConceptDescriptions with Unions and Complements.IBM Stuttgart IWBS Report 68.Smolka, G. (1989b).
Feature Constraint Logicsfor Unification Grammars.
IBMDeutschland Wissenschaftliches ZentrumIWBS Report No.
93.Smolka, G. (1988).
A Feature Logic withSubsorts.
IBM Deutschland GmbH.
LilogReport No.
33.Uszkoreit, H. (1986).
"Categorial UnificationGrammar," in COLING-86, 187-194.151
