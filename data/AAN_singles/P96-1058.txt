Maximizing Top-down Constraints for Unification-based SystemsNor iko  TomuroSchool of Computer  Science, Telecommunicat ions and Informat ion SystemsDePaul  UniversityChicago, IL 60604cphdnt@ted.cs .depaul .eduAbst rac tA left-corner parsing algorithm with top-down filtering has been reported to showvery efficient performance for unification-based systems.
However, due to the non-termination of parsing with left-recursivegrammars, top-down constraints must beweakened.
In this paper, a general methodof maximizing top-down constraints i  pro-posed.
The method provides a procedureto dynamically compute *restrictor., aminimum set of features involved in an in-finite loop for every propagation path; thustop-down constraints are maximally prop-agated.1 In t roduct ionA left-corner parsing algorithm with top-down filter-ing has been reported to show very efficient perfor-mance for unification-based systems (Carroll, 1994).In particular, top-down filtering seems to be very ef-fective in increasing parse efficiency (Shann, 1991).Ideally all top-down expectation should be propa-gated down to the input word so that unsuccess-ful rule applications are pruned at the earliest ime.However, in the context of unification-based parsing,left-recursive grammars have the formal power of aTuring machine, therefore detection of all infiniteloops due to left-recursion is impossible (Shieber,1992).
So, top-down constraints must be weakenedin order for parsing to be guaranteed to terminate.In order to solve the nontermination problem,Shieber (1985) proposes restrictor, a statically pre-defined set of features to consider in propagation,and restriction, a filtering function which removesthe features not in restrictor from top-down expec-tation.
However, not only does this approach fail toprovide a method to automatically generate the re-strictor set, it may weaken the predicative power oftop-down expectation more than necessary: a glob-ally defined restrictor can only specify the least com-mon features for all propagation paths.In this paper, a general method of maximizingtop-down constraints is proposed.
The methodprovides a procedure to dynamically compute*restrictor*, a minimum set of features involved inan infinite loop, for every propagation path.
Fea-tures in this set are selected by the detection func-tion, and will be ignored in top-down propagation.Using .vestrictor., only the relevant features par-ticular to the propagation path are ignored, thustop-down constraints are maximally propagated.2 Notat ionWe use notation from the PATR-II formalism(Shieber, 1986) and (Shieber, 1992).
Directedaeyclie graphs (dags) are adopted as the representa-tion model.
The symbol -" is used to represent theequality relation in the unification equations, andthe symbol ?
used in the form of pl ?
p2 representsthe path concatenation f pl and p2.The subsumption relation is defined as "Dag Dsubsumes dag D ~ if D is more general than D'.
"The unification of D and D ~ is notated by D tJ D ~.The extraction function D/pl extracts the subdagunder path pl for a given D, and the embeddingfunction D \ pl injects D into the enclosing dag D'such that D'/pl = D. The filtering function p issimilar to (Shieber, 1992): p(D) returns a copy of Din which some features may be removed.
Note thatin this paper .restrictor.
specifies the features tobe removed by p, whereas in (Shieber, 1985, 1992)restrictor specifies the features to be retained by re-striction which is equivalent to p.3 Top-down Propagat ionTop-down propagation can be precomputed to forma teachability table.
Each entry in the table is acompiled ag which represents he relation betweena non-terminal category and a rule used to rewritethe constituents in the teachability relation (i.e., re-flexive, transitive closure of the left-corner path).For example, consider the following fragment ofa grammar used in the syntax/semantics integratedsystem called LINK (Lytinen, 1992):381s~m ~ own~D(1)emD(2)Ic (~ ._ .~eadownerD(3)Figure 1: DAGs used in the examplehe?
rZ=sere ~ owflerD(4)r l  : NPo -+ NP1 POS NP2(NPo head) = (NP2 head)(YPo head sem owner) - (NP1 head sem)(This rule is used to parse phrases uch as "Kris'sdesk" .
)The dag D(1) in Figure 11 represents the initialapplication of r l  to the category NP.
Note thatthe subdag under the lc arc is the rule used torewrite the constituent on the left-corner path, andthe paths from the top node represent which top-down constraints are propagated to the lower level.Top-down propagation works as follows: given adad D that represents a teachability relation anda rule dad R whose left-hand side category (i.e.,root) is the same as D's left-corner category (i.e.,under its (lc 1) path), the resulting dag is D1 =p(D') U (R \ lc), where D' is a copy of D in whichall the numbered arcs and lc arc are deleted andthe subdag which used to be under the (lc 1) pathis promoted to lie under the lc arc.
Dags after thenext two recursive applications of r l  (D(2) and D(3)respectively 2) are shown in Figure 1.Notice the filtering function p is applied only toD'.
In the case when p(D') = nil, the top node inD1 will have no connections to the rule dag underthe lc arc.
This means no top-down constraints arepropagated to the lower level, therefore the parsingbecomes pure bottom-up.In many unification-based systems, subsumptionis used to avoid redundancy: a dag is recorded inthe table if it is not subsumed by any other one.Therefore, if a newly created dag is incompatibleor more general than existing dags, rule applicationcontinues.
In the above example, D(2) is incompat-ible with D(1) and therefore gets entered into thetable.
The owner arc keeps extending in the subse-quent recursive applications (as in D(3)), thus thepropagation goes into an infinite loop.1 Category symbols are directly indicated in the dadnodes for simplicity.2In this case, p is assumed to be an identity function.3.1 P roposed  MethodLet A be a dag created by the first application ofthe rule R and B be a dad created by the secondapplication during the top-down propagation.
3 Inthe proposed method, A and B are first checked forsubsumption.
If B is subsumed by A, the propaga-tion for this path terminates.
Otherwise a possibleloop is detected.
The detection function (describedin the next subsection) is called on A and B andselected features are added to the .
restr ictor.
set.
4Then, using the updated *restrictor*, propagationis re-done from A.When R is applied again yielding B', while B'is not subsumed by A, the following process is re-peated: if B' is incompatible with A, the detectionfunction is called on A and B' and propagation is re-done from A.
If B' is more general than A, then Ais replaced by B' (thereby keeping the most generaldag for the path) and propagation is re-done fromB'.
Otherwise the process tops for this propagationpath.
Thus, the propagation will terminate whenenough features are detected, or when *restrictor*includes all the (finite number of) features in thegrammar.
5In the example, when the detection function iscalled on D(1) and D(2) after the first recursive ap-plication, the feature owner is selected and added to*restrictor*.
After the propagation is re-done fromD(1), the resulting dad D(4) becomes more generalthan O(1).
6 Then D(1) is replaced by 0(4),  andthe propagation is re-done once again.
This timeit results the same D(4), therefore the propagation3 In the case of indirect recursion, there are some in-tervening rule applications between A and B.4A separate *restrictor* must be kept for each prop-agation path.51n reality, category feature will never be in*restrictor* because the same rule R is applied to deriveboth A and B'.6Remember 0(4) = p(D(1)') U (rl \ le) where p filtersout owner arc.382terminates.3.2 Detect ion  Funct ionThe detection function compares two dags X and Yby checking every constraint (unification equation)x in X with any inconsistent or more general con-straint y in Y.
If such a constraint is found, thefunction selects a path in x or y and detects its lastarc/feature as being involved in the possible loop.
7If x is the path constraint pl - p2 where pl andp2 are paths of length > I, features may be detectedin the following cases: 8?
(case 1) If both pl and p2 exist in Y, and thereexists a more general constraint y in Y in theform pl ?
p3 - p2 - p3 (length of p3 is also > 1),the path p3 is selected;?
(case 2) If both pl and p2 exist in Y, but thesubdag under pl and the subdag under p2 donot unify, or if neither pl  nor p2 exists in Y,whichever of pl or p2 does not contain the lcarc, or either if they both contain the lc arc, isselected; and?
(case 3) If either pl or p2 does not exist in Y,the one which does not exist in Y is selected.If x is the constant constraint pl  - c (where c issome constant), features may be detected in the fol-lowing cases:?
(case 4) If there exists an incompatible con-straint y of the form pl - d where d 7~ c inY, or if there is no path pl in Y, pl  is selected;and?
(case 5) If there exists an incompatible con-straint y of the form pl ?
p2 - c, then p2 isselected.4 Re la ted  WorkA similar solution to the nontermination problemwith unification grammars in Prolog is proposed in(Samuelsson, 1993).
In this method, an operationcalled anti-unification (often referred to as general-ization as the counterpart of unification) is appliedto the root and leaf terms of a cyclic propagation,and the resulting term is stored in the reachablitytable as the result of applying restriction on bothterms.
Another approach taken in (Haas, 1989)eliminates the cyclic propagation by replacing thefeatures in the root and leaf terms with new vari-ables.The method proposed in this paper is more gen-eral than the above approaches: if the Selection or-dering is imposed in the detection function, featuresin .restrictor.
can be collected incrementally as thecyclic propagations are repeated.
Thus, this method7This scheme may be rather conservative.8Note the cases in this section do not represent allpossible situations.is able to create a less restrictive *restrictor.
thanthese other approaches.5 D iscuss ion  and  Future  WorkThe proposed method has an obvious difficulty:the complexity caused by the repeated propaga-tions could become overwhelming for some gram-mars.
However, in the experiment on LINK sys-tem using a fairly broad grammar (over 130 rules),precompilation terminated with only a marginallylonger processing time.In the experiment, all features (around 40 syntac-tic/semantic features) except for one in the examplein this paper were able to be used in propagation.In the preliminary analysis, the number of edges en-tered into the chart has decreased by 30% comparedto when only the category feature (i.e., context-freebackbone) was used in propagation.For future work, we intend to apply the proposedmethod to other grammars.
By doing the empiri-cal analysis of precompilation and parse efficiencyfor different grammars, we will be able to concludethe practical applicability of the proposed method.We also indend to do more exhaustive case analysisand investigate the selection ordering of the detec-tion function.
Although the current definition coversmost cases, it is by no means complete.ReferencesCarroll, J.
(1994).
Relating complexity to practicalperformance in parsing with wide-coverage uni-fication grammars.
In Proceedings of the 32ndAnnual Meeting of the Association for Computa-tional Linguistics, pp.
287-293.Haas, A.
(1989).
A parsing algorithm for unificationgrammar, Computational Linguistics, 15(4), pp.219-232.Lytinen, S. (1992).
A unification-based, integratednatural language processing system.
Computersand Mathematics with Applications, 23(6-9), pp.403-418.Samuelsson, C. (1993).
Avoiding non-terminationin unification grammars.
In Proceedings of Natu-ral Language Understanding and Logic Program-ming IV, Nara, Japan.Shann, P. (1991).
Experiments with GLR and chartparsing.
In Tomita, M. Generalized LR Parsing.Boston: Kluwer Academic Publishers, p. 17-34.Shieber, S. (1985).
Using restriction to extendparsing algorithms for complex-feature-based for-malisms.
In Proceedings of the 23rd AnnualMeeting of the Association for ComputationalLinguistics, Chicago, IL, pp.
145-152.Shieber, S. (1986).
An Introduction to Unification-Based Approaches to Grammar.
Stanford, CA:Center for the Study of Language and Informa-tion.Shieber, S. (1992).
Constraint-based Grammar For-malisms.
Cambridge, MA: MIT Press.383
