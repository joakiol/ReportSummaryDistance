Simpler and More General Minimizationfor Weighted Finite-State AutomataJason EisnerDepartment of Computer ScienceJohns Hopkins UniversityBaltimore, MD, USA 21218-2691jason@cs.jhu.eduAbstractPrevious work on minimizing weighted finite-state automata(including transducers) is limited to particular types of weights.We present efficient new minimization algorithms that applymuch more generally, while being simpler and about as fast.We also point out theoretical limits on minimization algo-rithms.
We characterize the kind of ?well-behaved?
weightsemirings where our methods work.
Outside these semirings,minimization is not well-defined (in the sense of producing aunique minimal automaton), and even finding the minimumnumber of states is in general NP-complete and inapproximable.1 IntroductionIt is well known how to efficiently minimize a determin-istic finite-state automaton (DFA), in the sense of con-structing another DFA that recognizes the same languageas the original but with as few states as possible (Aho etal., 1974).
This DFA also has as few arcs as possible.Minimization is useful for saving memory, as whenbuilding very large automata or deploying NLP systemson small hand-held devices.
When automata are built upthrough complex regular expressions, the savings fromminimization can be considerable, especially when ap-plied at intermediate stages of the construction, since (forexample) smaller automata can be intersected faster.Recently the computational linguistics community hasturned its attention to weighted automata that computeinteresting functions of their input strings.
A traditionalautomaton only returns an boolean from the set K ={true, false}, which indicates whether it has acceptedthe input.
But a probabilistic automaton returns a prob-ability in K = [0, 1], or equivalently, a negated log-probability in K = [0,?].
A transducer returns an outputstring from K = ??
(for some alphabet ?
).Celebrated algorithms by Mohri (1997; 2000) haverecently made it possible to minimize deterministic au-tomata whose weights (outputs) are log-probabilities orstrings.
These cases are of central interest in languageand speech processing.However, automata with other kinds of weights canalso be defined.
The general formulation of weightedautomata (Berstel and Reutenauer, 1988) permits anyweight set K, if appropriate operations ?
and ?
are pro-vided for combining weights from the different arcs ofthe automaton.
The triple (K,?,?)
is called a weightsemiring and will be explained below.
K-valued func-tions that can be computed by finite-state automata arecalled rational functions.How does minimization generalize to arbitrary weightsemirings?
The question is of practical as well as theoret-ical interest.
Some NLP automata use the real semiring(R,+,?
), or its log equivalent, to compute unnormalizedprobabilities or other scores outside the range [0, 1] (Laf-ferty et al, 2001; Cortes et al, 2002).
Expectation semir-ings (Eisner, 2002) are used to handle bookkeeping whentraining the parameters of a probabilistic transducer.
Abyproduct of this paper is a minimization algorithm thatworks fully with those semirings, a new result permittingmore efficient automaton processing in those situations.Surprisingly, we will see that minimization is noteven well-defined for all weight semirings!
We willthen (nearly) characterize the semirings where it is well-defined, and give a recipe for constructing minimizationalgorithms similar to Mohri?s in such semirings.Finally, we follow this recipe to obtain a specific, sim-ple and practical algorithm that works for all divisionsemirings.
All the cases above either fall within thisframework or can be forced into it by adding multiplica-tive inverses to the semiring.
The new algorithm providesarguably simpler minimization for the cases that Mohrihas already treated, and also handles additional cases.2 Weights and MinimizationWe introduce weighted automata by example.
The trans-ducer below describes a partial function from strings tostrings.
It maps aab 7?
xyz and bab 7?
wwyz.
Why?Since the transducer is deterministic, each input (such asaab) is accepted along at most one path; the correspond-ing output (such as xyz) is found by concatenating theoutput strings found along the path.
?
denotes the emptystring.01a:x3b:     ?2a:yb:zza:wwy4b:wwzzz 5b:zb:     ??
and ?
standardly denote the automaton?s transition andoutput functions: ?
(3, a) = 2 is the state reached by theEdmonton, May-June 2003Main Papers , pp.
64-71Proceedings of HLT-NAACL 2003a arc from state 3, and ?
(3, a) = wwy is that arc?s output.In an automaton whose outputs (weights) were num-bers rather than strings like wwy, concatenating themwould not be sensible; instead we would want to add ormultiply the weights along the path.
In general ?
denotesthe chosen operation for combining weights along a path.The ?
operation need not be commutative?indeedconcatenation is not?but it must be associative.
K mustcontain (necessarily unique) weights, denoted 1 and 0,such that 1?
k = k ?
1 = k and 0?
k = k ?
0 = 0 forall k ?
K. An unaccepted input (e.g., aba) is assignedthe output 0.
When ?
is string concatenation, 1 = ?, and0 is a special object ?
defined to satisfy the axioms.If an input such as aa were accepted along multiplepaths, we would have to use another operation ?
to com-bine those paths?
weights into a single output for aa.But that cannot happen with the deterministic automatatreated by this paper.
So we omit discussion of the prop-erties that ?
should have, and do not trouble to spell outits definition for the semirings (K,?,?)
discussed in thispaper.1 We are only concerned with the monoid (K,?
).The following automaton is equivalent to the previousone since it computes the same function:01a:x3b:ww2a:yzb:zzza:yz4b:zzz 5b:     ?b:     ?However, it distributes weights differently along the arcs,and states 1 and 3 can now obviously be merged (as can 2and 4, yielding the minimal equivalent automaton).
For-mally we know that states 1 and 3 are equivalent becauseF1 = F3, where Fq denotes the suffix function of stateq?the function defined by the automaton if the start stateis taken to be q rather than 0.
(Thus, F3(ab) = yz.
)Equivalent states can safely be merged, by deleting oneand rerouting its incoming arcs to the other.We will follow Mohri?s minimization strategy:1.
Turn the first automaton above into the second.
Thisoperation is called pushing (or quasi-determinization).Here, for instance, it ?pushed ww back?
through state 3.2.
Merge equivalent states of the second automaton, byapplying ordinary unweighted DFA minimization (Aho etal., 1974, section 4.13) as if each weighted arc label suchas a:yz were simply a letter in a large alphabet.3.
Trim the result, removing useless states and arcs thatare not on any accepting path (defined as a path whoseweight is non-0 because it has no missing arcs and its laststate is final).1Though appropriate definitions do exist for our examples.For example, take the ?
of two strings to be the shorter of thetwo, breaking ties by a lexicographic ordering.Mohri (2000) proves that this technique finds the minimalautomaton, which he shows to be unique up to placementof weights along paths.2We will only have to modify step 1, generalizing push-ing to other semirings.
Pushing makes heavy use of leftquotients: we adopt the notation k\m for an element ofK such that k ?
(k\m) = m. This differs from the nota-tion k?1?m (in which k?1 denotes an actual element ofK) because k\m need not exist nor be unique.
For exam-ple, ww\wwzzz = zzz (a fact used above) but wwy\wwzzzdoes not exist since wwzzz does not begin with wwy.If F is a function, ?
is a string, and k is a weight, weuse some natural notation for functions related to F :k ?
F : (k ?
F )(?
)def= k ?
(F (?
))k\F : a function (if one exists) with k ?
(k\F ) = F?
?1F : (?
?1F )(?
)def= F (??)
(standard notation)In effect, k\F and ?
?1F drop output and input prefixes.3 Pushing and Its LimitationsThe intuition behind pushing is to canonicalize states?suffix functions.
This increases the chance that two stateswill have the same suffix function.
In the example of theprevious section, we were able to replace F3 with ww\F3(pushing the ww backwards onto state 3?s incoming arc),making it equal to F1 so {1, 3} could merge.Since canonicalization was also performed at states 2and 4, F1 and F3 ended up with identical representa-tions: arc weights were distributed identically along cor-responding paths from 1 and 3.
Hence unweighted mini-mization could discover that F1 = F3 and merge {1, 3}.Mohri?s pushing strategy?we will see others?is al-ways to extract some sort of ?maximum left factor?
fromeach suffix function Fq and push it backwards.
That is,he expresses Fq = k ?
G for as ?large?
a k ?
K aspossible?a maximal common prefix?then pushes fac-tor k back out of the suffix function so that it is countedearlier on paths through q (i.e., before reaching q).
q?ssuffix function now has canonical form G (i.e., k\Fq).How does Mohri?s strategy reduce to practice?
Fortransducers, where (K,?)
= (?
?, concat), the maxi-mum left factor of Fq is the longest common prefix ofthe strings in range(Fq).3 Thus we had range(F3) ={wwyz, wwzzz} above with longest common prefix ww.For the tropical semiring (R?0 ?
{?
},min,+), wherek\m = m ?
k is defined only if k ?
m, the maximumleft factor k is the minimum of range(Fq).But ?maximum left factor?
is not an obvious notionfor all semirings.
If we extended the tropical semir-2That is, any other solution is isomorphic to the one foundhere if output weights are ignored.3In general we treat Fq as a partial function, so thatrange(Fq) excludes 0 (the weight of unaccepted strings).
Leftfactors are unaffected, as anything can divide 0.ing with negative numbers, or substituted the semiring(R?0,+,?
), keeping the usual definition of ?maximum,?then any function would have arbitrarily large left factors.A more fundamentally problematic example is thesemiring Z[??5].
It is defined as ({m+n?
?5 : m,n ?Z},+,?)
where Z denotes the integers.
It is a stan-dard example of a commutative algebra in which fac-torization is not unique.
For example, 6 = 2 ?
3 =(1 +?
?5) ?
(1 ??
?5) and these 4 factors cannot befactored further.
This makes it impossible to canonicalizeF2 below:01a:12b:13c:14a:3b:(1+sqrt(-5))a:6b:(2+2*sqrt(-5))a:(1-sqrt(-5))b:2What is the best left factor to extract from F2?
We couldleft-divide F2 by either 2 or 1+??5.
The former actionallows us to merge {1, 2} and the latter to merge {2, 3};but we cannot have it both ways.
So this automaton hasno unique minimization!
The minimum of 4 states isachieved by two distinct answers (contrast footnote 2).It follows that known minimization techniques will notwork in general semirings, as they assume state merge-ability to be transitive.4 In general the result of mini-mization is not even well-defined (i.e., unique).Of course, given a deterministic automaton M , onemay still seek an equivalent M?
with as few states as pos-sible.
But we will now see that even finding the minimumnumber of states is NP-complete, and inapproximable.The NP-hardness proof [which may be skipped on afirst reading] is by reduction from Minimum Clique Par-tition.
Given a graph with vertex set V = {1, 2, .
.
.
n}and edge set E, we wish to partition V into as few cliquesas possible.
(S ?
V is a clique of the graph iff ij ?
Efor all pairs i, j ?
S.) Determining the minimum num-ber of cliques is NP-complete and inapproximable: thatis, unless P=NP, we cannot even find it within a factor of2 or 3 or any other constant factor in polynomial time.5Given such a graph, we reduce the clique problem toour problem.
Consider the ?bitwise boolean?
semiring({0, 1}n, OR, AND).
Each weight k is a string of n bits,4A further wrinkle lies in deciding what and how to push; ingeneral semirings, it can be necessary to shift weights forwardas well as backward along paths.
Modify the example above bypushing a factor of 2 backwards through state 2.
Making F2 =F3 in this modified example now requires pushing 2 forwardand then 1 +?
?5 backward through state 2.5This problem is just the dual of Graph Coloring.
For de-tailed approximability results see (Crescenzi and Kann, 1998).denoted k1, .
.
.
kn.
For each i ?
V , define f i, ki,mi ?K as follows: f ij = 0 iff ij ?
E; kij = 1 iff i = j; mij =0 iff either ij ?
E or i = j.
Now consider the followingautomaton M over the alphabet ?
= {a, b, c1, .
.
.
cn}.The states are {0, 1, .
.
.
n, n+1}; 0 is the initial state andn + 1 is the only final state.
For each i ?
V , there is anarc 0 ci:1n??
?i and arcs i a:ki???
(n + 1) and i b:mi???
(n + 1).A minimum-state automaton equivalent to M musthave a topology obtained by merging some states of V .Other topologies that could accept the same language(c1|c2| ?
?
?
|cn)(a|b) are clearly not minimal (they can beimproved by merging final states or by trimming).We claim that for S ?
{1, 2, .
.
.
n}, it is possible tomerge all states in S into a single state (in the automaton)if and only if S is a clique (in the graph):?
If S is a clique, then define k,m ?
K by ki = 1 iffi ?
S, and mi = 1 iff i 6?
S. Observe that for everyi ?
S, we have ki = f i ?
k, mi = f i ?
m. So bypushing back a factor of f i at each i ?
S, one can makeall i ?
S share a suffix function and then merge them.?
If S is not a clique, then choose i, j ?
S so thatij 6?
E. Considering only bit i, there exists no bitpair (ki,mi) ?
{0, 1}2 of which (kii,mii) = (1, 0)and (kji ,mji ) = (0, 1) are both left-multiples.
So therecan exist no weight pair (k,m) of which (ki,mi) and(kj ,mj) are both left-multiples.
It is therefore not pos-sible to equalize the suffix functions Fi and Fj by left-dividing each of them.6 i and j cannot be merged.Thus, the partitions of V into cliques are identical tothe partitions of V into sets of mergeable states, which arein 1-1 correspondence with the topologies of automataequivalent to M and derived from it by merging.
There isan N -clique partition of V iff there is an (N+2)-state au-tomaton.
It follows that finding the minimum number ofstates is as hard, and as hard to approximate within a con-stant factor, as finding the minimum number of cliques.4 When Is Minimization Unique?The previous section demonstrated the existence ofpathological weight semirings.
We now partially charac-terize the ?well-behaved?
semirings (K,?,?)
in whichall automata do have unique minimizations.
Except whenotherwise stated, lowercase variables are weights ?
Kand uppercase ones are K-valued rational functions.
[This section may be skipped, except the last paragraph.
]A crucial necessary condition is that (K,?)
allowwhat we will call greedy factorization, meaning thatgiven f?F = g?G 6= 0, it is always possible to express6This argument only shows that pushing backward cannotgive them the same suffix function.
But pushing forward cannothelp either, despite footnote 4, since 1n on the arc to i has noright factors other than itself (the identity) to push forward.F = f ?
?H and G = g?
?H .
This condition holds formany practically useful semirings, commutative or other-wise.
It says, roughly, that the order in which left factorsare removed from a suffix function does not matter.
Wecan reach the same canonical H regardless of whether weleft-divide first by f or g.Given a counterexample to this condition, one can con-struct an automaton with no unique minimization.
Sim-ply follow the plan of the Z[?
?5] example, puttingF1 = F , F2 = f ?
F = g ?
G, F3 = G.7 For ex-ample, in semiring (K,?)
= ({xn : n 6= 1}, concat), putF2 = x2 ?
{(a,x3), (b,x4)} = x3 ?
{(a,x2), (b,x3)}.Some useful semirings do fail the condition.
Oneis the ?bitwise boolean?
semiring that checks a string?smembership in two languages at once: (K,?,?)
=({00, 01, 10, 11}, OR, AND).
(Let F2 = 01 ?
{(a, 11), (b, 00)} = 01 ?
{(a, 01), (b, 10)}.)
R2 underpointwise ?
(which computes a string?s probability undertwo models) fails similarly.
So does (sets,?,?)
(whichcollects features found along the accepting path).We call H a residue of F iff F = f ?
?
H for somef ?.
Write F ' G iff F , G have a common residue.
Inthese terms, (K,?)
allows greedy factorization iff F 'G when F , G are residues of the same nonzero function.More perspicuously, one can show that this holds iff ' isan equivalence relation on nonzero, K-valued functions.So in semirings where minimization is uniquely de-fined, ' is necessarily an equivalence relation.
Given anautomaton M for function F , we may regard ' as anequivalence relation on the states of a trimmed versionof M :8 q ' r iff Fq ' Fr.
Let [r] = {r1, .
.
.
, rm}be the (finite) equivalence class of r: we can inductivelyfind at least one function F[r] that is a common residueof Fr1 , .
.
.
, Frm .
The idea behind minimization is toconstruct a machine M?
whose states correspond to theseequivalence classes, and where each [r] has suffix func-tion F[r].
The Appendix shows that M?
is then minimal.If M has an arc q a:k?
?r, M?
needs an arc [q]a:k???
[r], wherek?
is such that a?1F[q] = k?
?
F[r].The main difficulty in completing the construction ofM?
is to ensure each weight k?
exists.
That is, F[r] must becarefully chosen to be a residue not only of Fr1 , .
.
.
, Frm(which ultimately does not matter, as long as F[0] is aresidue of F0, where 0 is the start state) but also ofa?1F[q].
If M is cyclic, this imposes cyclic dependen-cies on the choices of the various F[q] and F[r] functions.We have found no simple necessary and sufficient con-dition on (K,?)
that guarantees a globally consistent setof choices to exist.
However, we have given a useful nec-7Then factoring F2 allows state 2 to merge with either 1 or3; but all three states cannot merge, since any suffix functionthat could be shared by 1 and 3 could serve as H .8Trimming ensures that suffix functions are nonzero.essary condition (greedy factorization), and we now givea useful sufficient condition.
Say that H is a minimumresidue of G 6= 0 if it is a residue of every residue of G.(If G has several minimum residues, they are all residuesof one another.)
If (K,?)
is such that every G has a min-imum residue?a strictly stronger condition than greedyfactorization?then it can be shown that G has the sameminimum residues as any H ' G. In such a (K,?),M?
can be constructed by choosing the suffix functionsF[r] independently.
Just let F[r] = F{r1,...,rm} be a mini-mum residue of Fr1 .
Now consider again M ?s arc qa:k?
?r:since a?1F[q] ' a?1Fq ' Fr ' Fr1 , we see F[r] is a(minimum) residue of a?1F[q], so that a weight k?
can bechosen for [q]a:k???
[r].A final step ensures that M?
defines the function F .
Todescribe it, we must augment the formalism to allow aninitial weight ?
(0) ?
K, and a final weight ?
(r) ?
Kfor each final state r. The weight of an accepting pathfrom the start state 0 to a final state r is now defined tobe ?(0)?
(weights of arcs along the path)?
?(r).
In M?
,we set ?
([0]) to some k such that F0 = k ?
F[0], and set?
([r]) = F[r](?).
The mathematical construction is done.5 A Simple Minimization RecipeWe now give an effective algorithm for minimization inthe semiring (K,?).
The algorithmic recipe has one in-gredient: along with (K,?
), the user must give us a left-factor functional ?
that can choose a left factor ?
(F ) ofany function F .
Formally, if ?
is the input alphabet, thenwe require ?
: (??
?
K) ?
K to have the followingproperties for any rational F : ??
?
K and any k ?
K:?
Shifting: ?
(k ?
F ) = k ?
?
(F ).?
Quotient: ?
(F )\?
(a?1F ) exists in K for any a ?
?.?
Final-quotient: ?
(F )\F (?)
exists in K.9The algorithm generalizes Mohri?s strategy as outlinedin section 2.
We just use ?
to pick the left factors duringpushing.
The ?
?s used by Mohri for two semirings werementioned in section 3.
We will define another ?
in sec-tion 6.
Naturally, it can be shown that no ?
can exist in asemiring that lacks greedy factorization, such as Z[?
?5].The 3 properties above are needed for the strategy towork.
The strategy also requires (K,?)
to be left can-cellative, i.e., k ?
m = k ?
m?
implies m = m?
(ifk 6= 0).
In other words, left quotients by k are uniquewhen they exist (except for 0\0).
This relieves us fromhaving to make arbitrary choices of weight during push-ing.
Incompatible choices might prevent arc labels frommatching as desired during the merging step of section 2.9To show the final-quotient property given the other two, itsuffices to show that ?
(G) ?
K has a right inverse in K, whereG is the function mapping ?
to 1 and everything else to 0.Given an input DFA.
At each state q, simultaneously,we will push back ?(Fq).
This pushing constructionis trivial once the ?
(Fq) values are computed.
Anarc q a:k?
?r should have its weight changed from k to?(Fq)\?
(a?1Fq) = ?(Fq)\?
(k ?
Fr), which is well-defined (by the quotient property and left cancellativity)10and can be computed as ?(Fq)\(k??
(Fr)) (by the shift-ing property).
Thus a subpath q a:k?
?r b:`?
?s, with weightk ?
`, will become q a:k???rb:`??
?s, with weight k?
?
`?
=(?
(Fq)\(k ?
?
(Fr))) ?
(?
(Fr)\(` ?
?(Fs))).
In thisway the factor ?
(Fr) is removed from the start of all pathsfrom r, and is pushed backwards through r onto the endof all paths to r. It is possible for this factor (or part ofit) to travel back through multiple arcs and around cycles,since k?
is found by removing a ?
(Fq) factor from all ofk ?
?
(Fr) and not merely from k.As it replaces the arc weights, pushing also replacesthe initial weight ?
(0) with ?
(0) ?
?
(F0), and replaceseach final weight ?
(r) with ?(Fr)\?
(r) (which is well-defined, by the final-quotient property).
Altogether, push-ing leaves path weights unchanged (by easy induction).11After pushing, we finish with merging and trimming asin section 2.
While merging via unweighted DFA mini-mization treats arc weights as part of the input symbols,what should it do with any initial and final weights?
Thestart state?s initial weight should be preserved.
The merg-ing algorithm can and should be initialized with a multi-way partition of states by final weight, instead of just a2-way partition into final vs. non-final.12The Appendix shows that this strategy indeed finds theunique minimal automaton.It is worth clarifying how this section?s effective al-gorithm implements the mathematical construction fromthe end of section 4.
At each state q, pushing replaces thesuffix function Fq with ?(Fq)\Fq.
The quotient proper-ties of ?
are designed to guarantee that this quotient isdefined,13 and the shifting property is designed to ensure10Except in the case 0\0, which is not uniquely defined.
Thisarises only if Fq = 0, i.e., q is a dead state that will be trimmedlater, so any value will do for 0\0: arcs from q are irrelevant.11One may prefer a formalism without initial or final weights.If the original automaton is free of final weights (other than 1),so is the pushed automaton?provided that ?
(F ) = 1 wheneverF (?)
= 1, as is true for all ?
?s in this paper.
Initial weights canbe eliminated at the cost of duplicating state 0 (details omitted).12Alternatively, Mohri (2000, ?4.5) explains how to tem-porarily eliminate final weights before the merging step.13That is, ?(Fq)\Fq(?)
exists for each ?
?
??.
One mayshow by induction on |?| that the left quotients ?
(F )\F (?)
ex-ist for all F .
When |?| = 0 this is the final-quotient property.For |?| > 0 we can write ?
as a?
?, and then ?
(F )\F (?)
=?
(F )\F (a??)
= ?
(F )\(a?1F )(??)
= (?
(F )\?
(a?1F )) ?(?
(a?1F )\(a?1F )(??
)), where the first factor exists by thequotient property and the second factor exists by inductive hy-pothesis.that it is a minimum residue of Fq.14 In short, if the con-ditions of this section are satisfied, so are the conditionsof section 4, and the construction is the same.The converse is true as well, at least for right cancella-tive semirings.
If such a semiring satisfies the conditionsof section 4 (every function has a minimum residue), thenthe requirements of this section can be met to obtain aneffective algorithm: there exists a ?
satisfying our threeproperties,15 and the semiring is left cancellative.166 Minimization in Division SemiringsFor the most important idea of this paper, we turn to acommon special case.
Suppose the semiring (K,?,?
)defines k\m for all m, k 6= 0 ?
K. Equivalently,17 sup-pose every k 6= 0 ?
K has a unique two-sided inversek?1 ?
K. Useful cases of such division semirings in-clude the real semiring (R,+,?
), the tropical semiringextended with negative numbers (R?{?
},min,+), andexpectation semirings (Eisner, 2002).
Minimization hasnot previously been available in these.We propose a new left-factor functional that is fast tocompute and works in arbitrary division semirings.
Weavoid the temptation to define ?
(F ) as?range(F ): thisdefinition has the right properties, but in some semiringsincluding (R?0,+,?)
the infinite summation is quite ex-pensive to compute and may even diverge.
Instead (un-like Mohri) we will permit our ?
(F ) to depend on morethan just range(F ).Order the space of input strings ??
by length, breakingties lexicographically.
For example, ?
< bb < aab <aba < abb.
Now define14Suppose X is any residue of Fq , i.e., we can write Fq =x ?
X .
Then we can rewrite the identity Fq = ?
(Fq) ?(?
(Fq)\Fq), using the shifting property, as x ?
X = x ??(X)?(?(Fq)\Fq).
As we have separately required the semir-ing to be left cancellative, this implies that X = ?
(X) ?(?(Fq)\Fq).
So (?
(Fq)\Fq) is a residue of any residue X ofFq , as claimed.15Define ?
(0) = 0.
From each equivalence class of nonzerofunctions under ', pick a single minimum residue (axiom ofchoice).
Given F , let [F ] denote the minimum residue from itsclass.
Observe that F = f?
[F ] for some f ; right cancellativityimplies f is unique.
So define ?
(F ) = f .
Shifting property:?
(k ?
F ) = ?
(k ?
f ?
[F ]) = k ?
f = k ?
?
(f ?
[F ]) =k?
?
(F ).
Quotient property: ?
(a?1F )?
[a?1F ] = a?1F =a?1(?
(F )?
[F ]) = ?
(F )?
a?1[F ] = ?
(F )?
?
(a?1[F ])?
[a?1[F ]] = ?
(F ) ?
?
(a?1[F ]) ?
[a?1F ] (the last step sincea?1[F ] ' a?1F ).
Applying right cancellativity, ?
(a?1F ) =?
(F )??
(a?1[F ]), showing that ?
(F )\?
(a?1F ) exists.
Final-quotient property: Quotient exists since F (?)
= ?
(F )?
[F ](?
).16Let ?x, y?
denote the function mapping a to x, b to y, andeverything else to 0.
Given km = km?, we have k ?
?m, 1?
=k?
?m?, 1?.
Since the minimum residue property implies greedyfactorization, we can write ?m, 1?
= f ?
?a, b?, ?m?, 1?
=g ?
?a, b?.
Then f ?
b = g ?
b, so by right cancellativityf = g, whence m = f ?
a = g ?
a = m?.17The equivalence is a standard exercise, though not obvious.?
(F )def={F (min support(F )) ?
K if F 6= 00 if F = 0where support(F ) denotes the set of input strings towhich F assigns a non-0 weight.
This ?
clearly has theshifting property needed by section 5.
The quotient andfinal-quotient properties come for free because we are ina division semiring and because ?
(F ) = 0 iff F = 0.Under this definition, what is ?
(Fq) for a suffix func-tion Fq?
Consider all paths of nonzero weight18 fromstate q to a final state.
If none exist, ?
(Fq) = 0.
Oth-erwise, min support(Fq) is the input string on the short-est such path, breaking ties lexicographically.19 ?
(Fq) issimply the weight of that shortest path.To push, we must compute ?
(Fq) for each state q. Thisis easy because ?
(Fq) is the weight of a single, minimum-length and hence acyclic path from q.
(Previous meth-ods combined the weights of all paths from q, even ifinfinitely many.)
It also helps that the left factors at dif-ferent states are related: if the minimum path from q be-gins with a weight-k arc to r, then it continues along theminimum path from r, so ?
(Fq) = k ?
?
(Fr).Below is a trivial linear-time algorithm for computing?
(Fq) at every q.
Each state and arc is considered oncein a breadth-first search back from the final states.
len(q)and first(q) store the string length and first letter of a run-ning minimum of support(Fq) ?
??.1.
foreach state q2.
if q is final then3.
len(q) := 0 (* min support(Fq) is ?
for final q *)4.
?
(Fq) := ?
(q) (* Fq(?)
is just the final weight, ?
(q) *)5. enqueue q on a FIFO queue6.
else7.
len(q) := ?
(* not yet discovered *)8.
?
(Fq) := 0 (* assume Fq = 0 until we discover q *)9. until the FIFO queue is empty10.
dequeue a state r11.
foreach arc q a:k?
?r entering r such that k 6= 012. if len(q) = ?
then enqueue q (* breadth-first search *)13. if len(q) = ?
or (len(q) = len(r) + 1and a < first(q)) then14.
first(q) := a (* reduce min support(Fq) *)15. len(q) := len(r) + 116.
?
(Fq) := k ?
?
(Fr)The runtime is O(|states|+t ?
|arcs|) if ?
has runtime t.If ?
is slow, this can be reduced to O(t ?
|states|+ |arcs|)by removing line 16 and waiting until the end, when theminimum path from each non-final state q is fully known,to compute the weight ?
(Fq) of that path.
Simply finishup by calling FIND-?
on each state q:FIND-?
(state q):1. if ?
(Fq) = 0 and len(q) < ?
then2.
?
(Fq) := ?
(q, first(q))?
FIND-?(?
(q, first(q)))3. return ?
(Fq)18In a division semiring, these are paths free of 0-weight arcs.19The min exists since < is a well-ordering.
In a purely lex-icographic ordering, a?b ?
??
would have no min.After thus computing ?
(Fq), we simply proceed withpushing, merging, and trimming as in section 5.20 Push-ing runs in time O(t ?
|arcs|) and trimming in O(|states|+|arcs|).
Merging is worse, with time O(|arcs| log |states|).7 A Bonus: Non-Division SemiringsThe trouble with Z[?
?5] was that it ?lacked?
neededquotients.
The example on p. 3 can easily be minimized(down to 3 states) if we regard it instead as defined over(C,+,?
)?letting us use any weights in C. Simply usesection 6?s algorithm.This new change-of-semiring trick can be used forother non-division semirings as well.
One can extend theoriginal weight semiring (K,?,?)
to a division semiringby adding ?-inverses.21In this way, the tropical semiring (R?0 ?
{?
},min,+) can be augmented with the negative reals to ob-tain (R ?
{?},min,+).
And the transducer semiring(??
?
{?
},min, concat)22 can be augmented by extend-ing the alphabet ?
= {x, y, .
.
.}
with inverse letters{x?1, y?1, .
.
.
}.The minimized DFA we obtain may have ?weird?
arcweights drawn from the extended semiring.
But the arcweights combine along paths to produce the original au-tomaton?s outputs, which fall in the original semiring.Let us apply this trick to the example of section 2,yielding the following pushed automaton in which F1 =F3 as desired.
(x?1, y?1, .
.
.
are written as X, Y, .
.
., and?
(Fq) is displayed at each q.
)0xyz1yza:     ?3wwyzb:ZYXwwyz 2za:     ?b:ZYzzza:     ?4?b:ZYzzz5?b:     ?b:     ?
:xyzFor example, the z?1y?1zzz output on the 3?4 arc wascomputed as ?
(F3)?1 ?
wwzzz ?
?
(F4) = (wwyz)?1 ?wwzzz?
?
= z?1y?1w?1w?1wwzzz.This trick yields new algorithms for the tropical semir-ing and sequential transducers, which is interesting andperhaps worthwhile.
How do they compare with previ-ous work?Over the tropical semiring, our linear-time pushing al-gorithm is simpler than (Mohri, 1997), and faster by a20It is also permissible to trim the input automaton at the start,or right after computing ?
(note that ?
(Fq) = 0 iff we shouldtrim q).
This simplifies pushing and merging.
No trimming isthen needed at the end, except to remove the one dead state thatthe merging step may have added to complete the automaton.21This is often possible but not always; the semiring must becancellative, and there are other conditions.
Even disregarding?
because we are minimizing a deterministic automaton, it isnot simple to characterize when the monoid (K,?)
can be em-bedded into a group (Clifford and Preston, 1967, chapter 12).22Where min can be defined as in section 6 and footnote 1.log factor, because it does not require a priority queue.
(Though this does not help the overall complexity of min-imization, which is dominated by the merging step.)
Wealso have no need to implement faster algorithms for spe-cial cases, as Mohri proposes, because our basic algo-rithm is already linear.
Finally, our algorithm generalizesbetter, as it can handle negative weight cycles in the input.These are useful in (e.g.)
conditional random fields.On the other hand, Mohri?s algorithm guarantees a po-tentially useful property that we do not: that the weightof the prefix path reading ?
?
??
is the minimum weightof all paths with prefix ?.
Commonly this approximates?
log(p(most probable string with prefix ?
)), perhaps auseful value to look up for pruning.As for transducers, how does our minimization algo-rithm (above) compare with previous ones?
Followingearlier work by Choffrut and others, Mohri (2000) de-fines ?
(Fq) as the longest common prefix of range(Fq).He constrains these values with a set of simultaneousequations, and solves them by repeated changes of vari-able using a complex relaxation algorithm.
His imple-mentation uses various techniques (including a trie anda graph decomposition) to make pushing run in timeO(|states| + |arcs| ?
maxq |?
(Fq)|).23 Breslauer (1996)gives a different computation of the same result.To implement our simpler algorithm, we representstrings in ??
as pointers into a global trie that extendsupon lookup.
The strings are actually stored reversed inthe trie so that it is fast to add and remove short pre-fixes.
Over the extended alphabet, we use the pointerpair (k,m) to represent the string k?1m where k,m ???
have no common prefix.
Such pointer pairs canbe equality-tested in O(1) time during merging.
Fork,m ?
?
?, k ?m is computed in time O(|k|), and k\min time O(|LCP(k,m)|) or more loosely O(|k|) (whereLCP = longest common prefix).The total time to compute our ?
(Fq) values is thereforeO(|states|+ t ?
|arcs|), where t is the maximum length ofany arc?s weight.
For each arc we then compute a newweight as a left-quotient by a ?
value.
So our total run-time for pushing is O(|states| + |arcs| ?
maxq |?
(Fq)|).This may appear identical to Mohri?s runtime, but in factour |?
(Fq)| ?
Mohri?s, though the two definitions sharea worst case of t ?
|states|.24Inverse letters must be eliminated from the minimizedtransducer if one wishes to pass it to any specialized al-gorithms (composition, inversion) that assume weights23We define |?| = 1 to simplify the O(?
?
?)
expressions.24The |?
(Fq)| term contributed by a given arc from q is abound on the length of the LCP of the outputs of certain pathsfrom q. Mohri uses all paths from q and we use just two, so ourLCP is sometimes longer.
However, both LCPs probably tend tobe short in practice, especially if one bypasses LCP(k, k) withspecial handling for k\k = ?.in ??.
Fortunately this is not hard.
If state q of theresult was formed by merging states q1, .
.
.
qj , define?
(q) = LCS{?
(Fqi) : i = 1, .
.
.
j} ?
??
(where LCS =longest common suffix).
Now push the minimized trans-ducer using ?
(q)?1 in place of ?
(Fq) for all q.
This cor-rects for ?overpushing?
: any letters ?
(q) that were unnec-essarily pushed back before minimization are pushed for-ward again, cancelling the inverse letters.
In our runningexample, state 0 will push (xyz)?1 back and the mergedstate {1,3} will push (yz)?1 back.
This is equivalent topushing ?
(0) = xyz forward through state 0 and the yzpart of it forward through {1,3}, canceling the z?1y?1 atthe start of one of the next arcs.We must show that the resulting labels really are freeof inverse letters.
Their values are as if the original push-ing had pushed back not ?
(Fqi) ?
??
but only its shorterprefix ??
(qi)def= ?(Fqi)/?
(qi) ?
??
(note the right quo-tient).
In other words, an arc from qi to ri?
with weightk ?
??
was reweighted as ??
(qi)\(k ?
??(ri?)).
Any in-verse letters in such new weights clearly fall at the left.So suppose the new weight on the arc from q to r beginswith an inverse letter z?1.
Then ??
(qi) must have endedwith z for each i = 1, .
.
.
j.
But then ?
(qi) was not thelongest common suffix: z?
(qi) is a longer one, a contra-diction (Q.E.D.
).Negative weights can be similarly eliminated afterminimization over the tropical semiring, if desired, bysubstituting min for LCS.The optional elimination of inverse letters or nega-tive weights does not affect the asymptotic runtime.
Acaveat here is that the resulting automaton no longer hasa canonical form.
Consider a straight-line automaton:pushing yields a canonical form as always, but inverse-letter elimination completely undoes pushing (??
(qi) =?).
This is not an issue in Mohri?s approach.8 Conclusion and Final RemarksWe have characterized the semirings over whichweighted deterministic automata can be minimized (sec-tion 4), and shown how to perform such minimization inboth general and specific cases (sections 5, 6, 7).
Ourtechnique for division semirings and their subsemiringspushes back, at each state q, the output of a single, easilyfound, shortest accepting path from q.
This is simpler andmore general than previous approaches that aggregate allaccepting paths from q.Our new algorithm (section 6) is most important forpreviously unminimizable, practically needed divisionsemirings: real (e.g., for probabilities), expectation (forlearning (Eisner, 2002)), and additive with negativeweights (for conditional random fields (Lafferty et al,2001)).
It can also be used in non-division semirings,as for transducers.
It is unpatented, easy to implement,comparable or faster in asymptotic runtime, and perhapsfaster in practice (especially for the tropical semiring,where it seems preferable in most respects).Our approach applies also to R-weighted sequentialtransducers as in (Cortes et al, 2002).
Such automatacan be regarded as weighted by the product semiring(R ?
?
?, (+,min), (?, concat)).
Equivalently, one canpush the numeric and string components independently.Our new pushing algorithm enables not only minimiza-tion but also equivalence-testing in more weight semir-ings.
Equivalence is efficiently tested by pushing the (de-terministic) automata to canonicalize their arc labels andthen testing unweighted equivalence (Mohri, 1997).ReferencesA.
V. Aho, J. E. Hopcroft, and J. D. Ullman.
1974.
The Designand Analysis of Computer Algorithms.
Addison-Wesley.Jean Berstel and Christophe Reutenauer.
1988.
Rational Seriesand their Languages.
Springer-Verlag.Dany Breslauer.
1996.
The suffix tree of a tree and minimizingsequential transducers.
Lecture Notes in Computer Science,1075.A.
H. Clifford and G. B. Preston.
1967.
The Algebraic Theoryof Semigroups.Corinna Cortes, Patrick Haffner, and Mehryar Mohri.
2002.Rational kernels.
In Proceedings of NIPS, December.Pierluigi Crescenzi and Viggo Kann.
1998.
How to find the bestapproximation results?a follow-up to Garey and Johnson.ACM SIGACT News, 29(4):90?97, December.Jason Eisner.
2002.
Parameter estimation for probabilisticfinite-state transducers.
In Proc.
of ACL, Philadelphia, July.John Lafferty, Andrew McCallum, and Fernando Pereira.
2001.Conditional random fields: Probabilistic models for seg-menting and labeling sequence data.
In Proceedings of theInternational Conference on Machine Learning.Mehryar Mohri.
1997.
Finite-state transducers in language andspeech processing.
Computational Linguistics, 23(2).Mehryar Mohri.
2000.
Minimization algorithms for sequentialtransducers.
Theoretical Computer Science, 324:177?201.Appendix: Remaining ProofsLet M be an automaton to minimize and F : ??
?
K be thefunction it defines.
We assume (K,?)
allows greedy factoriza-tion, so ' is an equivalence relation on nonzero functions.
Wefirst prove that M?
with the properties of section 4 is the minimalautomaton computing F .
We will then show, following Mohri,that the algorithm of section 5 finds such an M?
.
(Section 6 is aspecial case of section 5.
)We chose in advance a desired suffix function F[r] for eachstate [r] of M?
, and used these to determine the weights of M?
.To show that the weights were determined correctly, let F?
[r] bethe actual suffix function of [r].
Claim that for all ?
and r,F?[r](?)
= F[r](?).
This is easily proved by induction on |?|.Our choice of initial weight then ensures that M?
computes F .We must now prove minimality.
For ?, ?
?
?
?, say ?
F?
?iff ?
?1F ' ?
?1F .
Note that F?
is an equivalence relation onDdef= {?
?
??
: ?
?1F 6= 0}.2525It is not an equivalence relation on all of ?
?, since ?
6?
D isLet M ?
be any automaton that computes F .
For ?, ?
?
D,we say ?
M??
?
iff ?M?
(0, ?)
= ?M?<(0, ?
), i.e., the prefixes?
and ?
lead from the start state 0 to the same state q in M ?.If ?
M??
?, then ?
F?
?, since ?
?1F = ?
(0, ?)
?
Fq '?
(0, ?)?
Fq = ?
?1F .If ?
F?
?, then ?
?1F ' ?
?1F , so F?M (0,?)
' ?
?1F '?
?1F ' F?M (0,?
), so ?M (0, ?)
' ?M (0, ?
), so ?M??
?
byconstruction of M?
.In short, ?
M??
?
?
?F?
?
?
?M??
?.
So each of the threepartitions of D into equivalence classes is a refinement of thenext.
Hence nM?
?
nF ?
nM?
, where these are the respectivenumbers of equivalence classes.Since M??
has one equivalence class per useful state of M ?
(asdefined in section 2), nM?
is the number of states in a trimmedversion of M ?.
Similarly nM?
is the number of states of M?
(aftertrimming).
Since M ?
was arbitrary, M?
is minimal.Uniqueness: If M ?
has the same number of states as M?
, thenthe two partitions must be equal.
So two prefixes reach the samestate in M ?
iff they do so in M?
.
This gives a ?-preserving iso-morphism between M ?
and M?
.
It follows that the minimal ma-chine is unique, except for the distribution of output labels alongpaths (which may depend on arbitrary choices of residues F[r]).Now we turn to section 5?s effective construction, using ?,of a pushed machine M?
and a merged version M?
.
The proofof minimality is essentially the same as in (Mohri, 2000).
Weknow that M?
computes the same function as M (since pushing,merging, and trimming preserve this).
So it suffices to show?F?
?
?
?M??
?.
The above proof of minimality will then gothrough as before.M and M?
have the same states and transition function ?
;denote their emission functions by ?
and ??.
Fq refers to suf-fix functions in M .
Given ?
F?
?
(so ?, ?
?
D), use thedefinition of F?
to write ?
?1F = k?
?
F ?
and ?
?1F =k?
?
F ?.
Let q = ?
(0, ?
), r = ?
(0, ?
), k = ?
(0, ?
).For any a ?
?, write ??
(q, a) = ?(Fq)\?
(a?1Fq) = (k ??
(Fq))\(k ?
?
(a?1Fq)) = ?
(k ?
Fq)\?
(k ?
a?1Fq) =?(?
?1F )\?(a?1(?
?1F )) = ?(k?
?F ?)\?(a?1(k?
?F ?))
=?
(F ?)\?
(a?1F ?).
By symmetry, ??
(r, a) = ?
(F ?)\?
(a?1F ?
)as well.
Thanks to left cancellativity, left quotients are unique,so ??
(q, a) = ??
(r, a).26So ?
F?
?
?
corresponding arcs from q and r in M?
outputidentical weights.
Since ?a F?
?a as well, the same holds at?
(q, a) and ?
(r, a).
So by induction, regarding M?
as an un-weighted automaton, exactly the same strings in (??K)?
areaccepted from q and from r. So merging will merge q and r,and ?
M??
?
as claimed.related by F?
to every ?.
This corresponds to the fact that a deadstate can be made to merge with any state by pushing 0 backfrom it, so that the arcs to it have weight 0 and the arcs fromit have arbitrary weights.
Our construction of M?
only createsstates for the equivalence classes of D; ?
(0, ?)
for ?
6?
D isundefined, not a dead state.26We must check that we did not divide by 0 and obtain afalse equation.
It suffices to show that k 6= 0 and ?
(Fq) 6=0.
Fortunately, ?
?
D implies both.
(It implies Fq 6= 0, so(??1Fq)(?)
= Fq(?)
6= 0 for some ?.
Hence ?
(Fq) 6= 0since otherwise ?(?
?1Fq) = 0 and ?(??1Fq)\(??1Fq)(?)
isundefined, contradicting the final-quotient property.)
