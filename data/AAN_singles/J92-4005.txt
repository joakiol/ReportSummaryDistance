Squibs and DiscussionsRestriction and Termination in ParsingFeature-Theoretic GrammarswithS.
P. Harrison*University of Western AustraliaT.
M. Ellison*University of Western AustraliaShieber (1987) describes a technique for limiting the number of active dges introduced into a chartby top-down prediction in chart parsers for PATR grammars, without affecting the correctnessor completeness of the parser.
That technique, termed restriction, isextendable toother parsingalgorithms.
It can be employed to increase parsing efficiency and to induce termination for someclasses of grammars that would not otherwise terminate.Here, we describe one class of grammars for which restriction, as described by Shieber, inducesnon-termination.
We do not suggest that the concept of restriction is fatally flawed, however.
Onthe contrary, relatively minor modifications to the implementation f restriction can make it amore flexible tool for fine-tuning PATR grammars.BackgroundShieber (1987) observes that the potentially infinite category domain of feature-theoreticgrammar formalisms like PATR-II makes implementing efficient parsers for such for-malisms difficult.
He concludes that the two earliest approaches to the problem areat best ill-advised.
Parsing with a context-free backbone ffectively ignores informa-tion in fact available to guide the parse and violates the spirit of feature-theoreticgrammar.
Tailoring the parsing algorithm or the grammar itself to the exigencies offeature-theoretic formalisms puts the burden of coping with the problem in the wrongplace, on the end user of a grammar development system.The most obvious alternative to parsing with a context-free backbone is usinggraph unification, rather than atomic symbol identity, to drive the parsing process.Shieber notes that not only is that approach costly (in using information that in fact cannever affect he outcome of a parse) but, for some grammars, induces non-termination.The class of grammars Shieber describes might be termed top-down path building gram-mars, because they are grammars in which the length of a path through the graphincreases as one descends the parse tree.The particular grammar Shieber uses is one that counts the number of terminalsymbols in the string being parsed:(G1)Rule "set end marker'S --* T:= (V)(U)  = a.
* Centre for Linguistics, University ofWestern Australia, Perth, Western Australia(~) 1992 Association for Computational LinguisticsComputational Linguistics Volume 18, Number 4Rule "recursive clause"To ~ T1A:Rule 'base clause'Rule 'lexical insertion"(Tof) = (Tiff).T -+ A.A -+ a.G1 generates trees like the following:SIi ia a aIn the course of a derivation, G1 builds a path (Tnf +) from the root of the graphT, corresponding to each node Tn in the tree.
The 'count' is reflected in the length ofthe path (T,f+ I.
As one descends the tree, the length of the path that is the value ofthe attribute f increases by 1 for each successive node Tn+l:Hence the term top-down path building, characterizing grammars like G1.
Recall that, !na chart parsing regime, for each active edge Em of the form:(i, j, X ---* e~.Yfl)and each rule Ri of the form:y ---, -ythe top-down rule adds an active edge En of the form:(j , j, Y ~ .
'V )520S.
P. Harrison and T. M. Ellison Restriction and Termination i  ParsingIf, associated with Era, there is a graph Gin, and with Ri a graph Gi, then associatedwith En will be a graph Gn = Gi UGm(Y), where Gm(Y) is the subgraph of Gm at Y. AsShieber points out, a parser employing this top-down rule will not terminate wheninterpreting rammar G1.
On initialization (with Rule 'set end marker'), the parsergenerates an active edge seeking a constituent of category T. The top-down rule thenuses that edge and the Rule 'recursive clause' to generate a new active edge seekinga constituent of category T. That active edge then generates a new (and, crucially, adistinct) active edge not subsumed by any existing edge, "and so forth, ad infinitum.
"In other words, each top-down recursion anticipates a different erminal string that isone symbol longer than that predicted on the previous recursion; because the graphsassociated with those anticipated strings are distinct, the normal chart parsing checksfail to prevent looping.Shieber's olution to the problem posed by grammar G1 is to introduce a notionhe terms restriction.
Under restriction, the graph associated with an edge generated bythe top-down rule (applied to an active edge Em and a grammar ule Ri) is not a graphG = Gi U Gm (X), where Gi is the graph associated with Ri and Gm (X) is that portionof the graph (associated with Era) corresponding to the left hand side of Ri.
Rather,G = Gi U (Gm(X)!~), where Gm(X)!~) is a graph G' resulting from filtering out of Gmall those paths not explicitly sanctioned by ~.
The filter ?
is termed a restrictor, andis represented as a set of paths P. The graph G' (= G!
@) is derived from G by filteringout all those paths that are not members of p.1Given a restrictor that passes through only the (cat) path, the termination problemfor grammar G1 vanishes.
Since the active edges generated by the top-down rulepass on only their category information, each time the rule 'recursive clause' is calledrecursively, the edge it generates i the same (underspecified) edge generated on thefirst call to that rule, and already on the chart.The following observations regarding the restrictors Shieber describes might bemade at this point:1.
The graph for the active edge generated by the top-down rule with aparser using restriction is no less specific (has no less information) thanthe graph stipulated by the rule used; i.e., it is information from the extantactive edge that is suppressed.2.
The restrictor provides a positive restriction, i.e., it stipulates which pathsare included in the restricted graph, not which paths are suppressed.A Problem: Bottom-up Path BuildingThe following grammar might be considered almost the inverse of the grammar G1described by Shieber (1987).
It parses strings of length 1, and generates one node T in1 Shieber's definition of restriction isas follows:"Given a relation F between paths and labels, and a dag D, we define D!F to be the mostspecific dag D ~ (D D D ~) such that for every path p either Dr(p) is undefined, or D~(p) isatomic, or for every l C dom(D~(p))~ p@l. That is, every path in the restricted dag is eitherundefined, atomic, or specifically allowed by the restrictor.
"That definition might seem to suggest that paths that are instantiated (atom valued) are not filtered outby the restrictor.
His examples demonstrate that that is not the correct interpretation f his definition.Rather, itwould seem that atomic paths (i.e.
'leaves'), and not atomic-valued paths, fall through thefilter.521Computational Linguistics Volume 18, Number 4the parse tree for each arc labeled g in the graph corresponding to the item recognized:(G2)Rule 'copy attribute'S ~ AT:Rule 'recursive clause'To ~ TI:Rule 'base clause"T --~:Rule 'lexical insertion a'A~a:Rule 'lexical insertion b'A- ,b :(Ag,) = (Tg).
(Togg) = (Tlg).
(Tg) = e.(Aggg) = e.(Agg) = e.G2 generates exactly two trees:Tree2a.Sa T 2Tree2b.$ /Nb T 1each of which is associated with a distinct graph:Dag2a.
Dag2b.?
?I'J'A ToJ e522S.
P. Harrison and T. M. Ellison Restriction and Termination i  ParsingFor this grammar, the length of the path (Tng +) in each subgraph Tn increases asone ascends the tree.
Hence the term bottom-up ath building is used to characterizegrammars of this sort.Using the same restrictor (i.e.
(cat)) employed for G1, a parser interpreting G2 willnot terminate on any grammatical input.
As in G1, only one active edge generatedfrom the Rule 'recursive clause' is put onE1x01, 1, Xo --+ .Xl,XlThe rule 'base clause' of G2 generates theE2the chart:: I cat:TIcat lg: EIpassive edge:I1,1,X---,., X: g: eThe fundamental rule then applies to E1 and E2 to yield the passive edge:Eax0:\ [ ca t :T \ ]  X1 : g : \ [~e1, 1,Xo --* X l .
~and then applies to E1 and E3 to yield:E41, 1,X0 ~ XI.,Xo : g: \]\[ cat : T 1 X1 : g:~\ ]  ~g : e\]and so forth, ad infinitum.
Ultimately, the fundamental rule will generate a passiveedge with a graph G such that G(g) = {Gi: T'(g)}, for the passive edge:(0, 1, S --', A.T, Gi)where {Gi : T'(g)} is the subgraph corresponding to the constituent T. At that point,the parser, in effect, will have parsed the input string.
Nonetheless, it will continueto add new passive edges, each with a graph whose/g+/path is one arc longer thanthat of the passive edge from which it is generated.Bottom-up ath building grammars are not without interesting linguistic applica-tions.
Consider, for example, the following PATR implementation f the append oper-ation on lists employed in HPSG (Pollard and Sag 1987; Section 2.2):(G3)Rule 'collect lists'Top --~ Left Right Append:(Append list1/ = ( Left list/(Append list2/ = (Right list /(Top list/ = {Append list/.523Computational Linguistics Volume 18, Number 4Rule 'base case'Append --*:(Append list} = (Append list2)(Appendlistl) = ().Rule 'recursive clause'Append0 ~ Append1:(Append0 list first}(Append0 list rest)(Append0 list1 rest)(Append1 list2)= (Append0 list1 first}= (Append1 list}= (Append1 list1)= (Append0 list2).Given the rules 'base case' and 'recursive clause,' one need only introduce a 'dummy'constituent Append (whose only function is to collect the list-valued attributes list1and list2 in a single list), and appropriate constraints on some list-valued attribute, inorder to simulate the HPSG append in PATR.
Unfortunately, because these two rules arean instance of the bottom-up ath building problem, no derivation employing theserules will terminate.
2SolutionsThe source of the bottom-up ath building problem is the active edge E1 above, whose~g+} path is of indeterminate length.
Because the parser does not know how long thatpath should be, it keeps adding to it ad infinitum.
Observe, however, that the parserhad the required information (obtained from the (g) attribute of constituent A), butwas induced by the restrictor to throw that information away.There are at least three solutions to the problem posed by bottom-up ath buildinggrammars under restriction:1.
Impose a finite limit on the path (g+}.2.
Convert he grammar to top-down path building.3.
Change the nature and implementation f restriction.We consider each of these proposals in turn in the following paragraphs.Solution 1 involves picking an arbitrary upper limit on the length of (g+}, andadding a corresponding path to the restrictor.
The parser would then terminate forany input whose (g+} path length is less than or equal to that of the stipulatedpath.
For example, a parser interpreting G2 above would terminate with the restrictor{(cat}(g  g)}.
But that is a "Band-Aid" solution at best.2 The append operation is necessary whenever  a grammar  demands  that two list-valued attributes becombined; for example, when the SUBCAT of a constituent is defined as the union of the values ofSUBCAT for its daughters,  or when the l ist-valued SKELETON of a syllable is defined as theSKELETON of the onset followed by the SKELETON of the rhyme.
One would, of course, prefer tohave PATR extended to accommodate append, rather than have to simulate the append operation in purePATR, but that is not the issue here.
The point we are making is s imply that one could simulate appendin pure PATR, were it not for the restriction regime of the PATR standard efined in Shieber (1989).524S.
P. Harrison and T. M. Ellison Restriction and Termination in ParsingSolution 2 might involve a grammar like G4, a top-down path building grammarweakly equivalent to G2.
G4 does not, however, have the termination problem of G2:(G4)Rule 'base case'S --> T:Rule 'recursive clause'To -* TI:Rule 'copy path"T-+A:Rule 'lexical insertion a'A-*a :Rule 'lexical insertion b'A-+b:(Tg) = e.(Tog) = (Ylgg).
(Tg) = (Ag).
(Aggg) = e.(Agg) = e.(The following are the trees, and corresponding complex feature structures, generatedby G4:S SIAIaA T2OA vlSe525Computational Linguistics Volume 18, Number 4Note that the length of the path g+ increases as one descends the tree.)
Similarly,grammar G5 provides a top-down path building solution to the append operation:(G5)Rule 'collect lists'Append --.
Left Right:(Append residue) = (Append list)(Append list1) = (Left list)(Append list2) -- (Right list).Rule 'append base case'Top ~ Append:(Top list) = (Append list)(Append residue) = (Append list2)(Append list1) -- ().Rule 'append recursive clause'Append0 --~ Append\]:(Append0 list) = (Append1 list)(Append0 list1) = (Append1 list1 rest)(Append0 list2) = (Append1 list2)(Append0 residue) = (Append1 residue rest)(Append1 residue first) = (Append1 list1 first).Consider the case of two descendants, Left and Right, of a node Top, where the valueof (Left list) is (a, b), the value of (Right list) is (c, d), and the value of (Top list) isappend ((L list), (R list)).
G3 assigns to that construction the parse tree:Left Right Aplend oAppend 1ApJend 2526S.
P. Harrison and T. M. Ellison Restriction and Termination in Parsingand the complex feature structure:Top:Left :Right :Append 0:Append1 :Append 2:Ilist : ~-~1I1 \[first: ~ \ ] i res t :  ~L_23 ~ I \]\] ist :~-~ f-Z\] first : brest ()I \[first: i l i s t : r3 \ ]  \] 1\] first : d rest : rest :list : \ [ \ ]  restfirst ::list1: ~-\] restfirst: ~ :list2 : E\]list : ~\]list1 : ~\]list2 : \[~listl :list2first : \[~rest :first :rest :G5, by contrast, assigns it the parse tree:TopIAplendoAppend 1Left Right527Computational Linguistics Volume 18, Number 4and the complex feature structure:Top:Left :Right :Append 0:Append 1:Append 2:\[,ist lfirst :.
i s t : \ [ \ ]  rest:I first :l i s t : \ [ \ ]  rest:list : ~-~residue : ~-~list1 : \ [ \ ]list2 : ~3~list : ~i~residue : \ [ \ ]list1 : ~-~list2 : \ [ \ ]list :residue :list1 :list2 :6-arest: ()c \]\]first : drest : ( )rest\[ rfierStt:: ~ \ ]first :restfirst : ~restAs noted above, G3 provides a 'dummy' constituent Append that one might wantultimately to prune, since its only function is to assemble the appended list.
By con-trast, G5 assembles the appended list in successive Append nodes dominating theconstituents Left and Right.
One might want to argue that the latter solution is less fe-licitous than the former because the Append nodes dominate lexical material.
In anyevent, as Shieber stresses, the grammar writer should not be constrained to choosebetween weakly equivalent grammars by the demands of the grammar developmentsystem.Let us now consider solution 3, modifying the nature and implementation f re-striction.
We choose to term the sort of restriction Shieber describes positive restriction.In positive restriction, the restrictor tells the parser how much of the information forwhich paths to retain (in the graph corresponding to the active edge used by the top-down rule).
If a path is not explicitly mentioned in the restrictor, no information aboutthat path is retained.
An empty restrictor in effect ells the parser to throw away allthe information in the restricted graph.
(An anonymous reviewer for Computational Linguistics points out that grammarsG2 and G3, in contrast to Shieber's G1, are not offiine parsable \[in the sense of Bresnanand Kaplan 1982:263ff and Johnson 1988:95ff\], and suggests that this failure of offiineparsability is a necessary condition for membership n the class of grammars that are528S.
P. Harrison and T. M. Ellison Restriction and Termination i  Parsingnonterminating under positive restriction.
The constituent s ructures generated by agrammar are offiine parsable iff:i. they contain no nonbranching dominance chains in which the samecategory \[label\] appears twice, andii.
all terminal nodes dominate lexical materialG2 and G3 fail both these conditions, since neither the T node chain of G2 nor theAppend node chain of G3 either branch or dominate lexical material.
We make twoobservations in this regard.
First, while it may indeed be the case that failure of offiineparsability is a necessary condition for non-termination u der positive restriction, it iscertainly not a sufficient one, since G4 and G5 both fail condition i. above, and are thusnot offiine parsable, but do terminate under positive restriction.
Second, though G2through G5 fail the letter of an offiine parsability constraint, hey do not fail its spirit.Offiine parsability has been proposed as a constraint on grammars guaranteeingthe decidability of the recognition problem for feature-theoretic grammars of the sortconsidered here.
For grammars that satisfy offiine parsability, it will be the case thatthe number of nodes of any parse tree assigned to some string will be a computablefunction of the length of the string being parsed.
This is not the case for G2 throughG5.
What is the case, however, is that the number of nodes in a parse tree generatedby those grammars i a computable function of the graphs associated with the lexicalmaterial covered by the tree.
This is because ach of these grammars makes crucialreference ither to a list-valued or path-valued attribute of lexical items, where thelength of the list or path is finite and stipulated in the lexicon.
The number of iden-tical nodes in any nonbranching dominance chain generated by these grammars i afunction of the length of a \[bounded\] list or path.
)Positive restriction can be contrasted with what might be termed negative restric-tion.
Under negative restriction, the restrictor tells the parser what information tothrow away.
For stipulated paths, the effects of positive and negative restriction arethe same: a restrictor (ggg) tells the parser to (positively) retain all information up toand including an atomic value for the path (ggg), or to (negatively) throw away allinformation about any nonatomic extension of (ggg).
The difference is in the interpre-tation of paths not explicitly mentioned; under positive restriction these are thrownaway; under negative restriction they are retained.In formal terms, a restrictor, for Shieber, is a relation between paths and the singleedges that are permitted to extend those paths: If ?
is a restrictor, p a path and 1 someedge label, then the restrictor permits the path pl iff p~l.
But Shieber does not usethe full power of this formalism.
He considers only what we term positive restrictors.Mathematically, if P is some finite set of paths, one can define a positive restrictor q~+to be the relation defined by:p@+l iff 3 q E P, p~qwhere p < q means that p is a (perhaps improper) prefix to the path q.
By contrast, henegative restriction regime proposed here allows paths not explicitly disallowed:p~pl i f f (3rEP~ r<p)=~qEP,  pGq (1)In other words, whereas the positive restrictor admits those paths obeying the condi-tion "is a prefix of a member of the restrictor set," the negative restrictor only applies529Computational Linguistics Volume 18, Number 4this condition to paths extending members of the restrictor set.
Paths not extendingmembers of the restrictor set are themselves not subject o restriction.It is an easy matter to show that any positive restrictor p can be defined in terms ofa negative restrictor.
If the null path is included in the restrictor set, then the antecedentof the implication in the definition of ~-  (1 above) is always true (except if p = //),and the consequent 3q E P U {/ /}, P ~ q is equivalent to 3q E P, p <_ q (except whenP = / /)- If p is the null path, then the antecedent is always true and so / /~p-u{0} lis equivalent to //~+l.
For other p, //~u{0}l = //~+l.
So, ~{0} = ~+" Thus, animplementation using negative restriction can simulate any positive restrictor and,therefore, can necessarily solve all problems olvable by positive restriction, as well asthose problems, described earlier, where positive restriction fails.Note that we have limited ourselves, as Shieber has, to finite restrictor sets.
Thislimitation is not necessary.
A more general proposal allows restrictor sets consistingof all paths expressable by some regular expression.
Restrictors can then be imple-mented as finite state automata.
An implementation f this sort would not impose alarge computational burden and would allow much greater flexibility in the choice ofrestrictor relations.We have demonstrated that any restriction definable by a positive restrictor canalso be defined by a negative restrictor.
It follows that any parser requiring positiverestriction to guarantee termination will also terminate for the same set of grammarsusing negative restriction.
But we have also demonstrated that the reverse does nothold.
Therefore, it would seem that negative restriction is superior to positive restric-tion in the implementation f parsers for feature-theoretic grammars.ReferencesJohnson, M. (1988).
"Attribute-value logicand the theory of grammar."
CSLI LectureNotes, 16.Kaplan, R., and Bresnan, J.
(1982).
"Lexical-functional grammar, a formalsystem for grammatical representation.
"In The Mental Representation of GrammaticalRelations, edited by J. Bresnan, 173-281.MIT Press.Pollard, C., and Sag, I.
A.
(1987).
"Information-based syntax andsemantics."
CSLI Lecture Notes, 13(1).Shieber, S. M. (1987).
"Using restriction toextend parsing algorithms forcomplex-feature-based formalisms.
"Proceedings, 23rd Annual Meeting of theACL.
154-52.530
