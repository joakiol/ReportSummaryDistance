A Simple Reconstruction of GPSGStuart  M. ShieberArtificial Intell igence CenterSRI Internat ionalandCenter  for the Study of Language and InformationStanford UniversityAbst rac tLike most linguistic theories, the theory of generalized phrasestructure grammar (GPSG) has described language axiomati-cally, that is, as a set of universal and language-specific con-attaints on the well-formedncss of linguistic elements of some sort.The coverage atttl detailed analysis of English grammar in theambitious recent volume by Gazdar, Klein, Pullum, and Sag enti-tled Generalized Phrase Structure Grammar \[2\] are impressive, inpart because of the complexity of the axiomatic system developedby the authors.
In this paper, we examine the possibility thatsimpler descriptions of the same theory can be achieved througha slightly different, albeit still axiomatic, method.
Rather thancharacterize the well-formed trees directly, we progress in twostages by procedurally characterizing the well-formedness axiomsthemselves, which in turn characterize the trees.1 In t roduct ion  ILike most llngafistic theories, the theory of generalized phrasestructure grammar (GPSG) has described language axiomati-cally, that is, as a set of universal and language-specific con-straints on the we\[l-formedncss of linguistic elements of somesort.
In the case of GPSG, these elements are trees whose nodesare themselves structured entltics from a domain of categories(a type of feature ~trueture \[6\]).
The proposed axioms have be-come quite complex, culminating in the ambitious recent volumeby Gazdar, Klein, Pullum, and Sag entitled Generalized PhraseStructure Grammar \[2\].
The coverage and detailed analysis ofEnglish grammar in this work are impressive, in part because ofthe complexity of the axiomatic system developed by the author .In this paper, we examine the possibility that simpler descrip-tions of the same theory can be achieved through a slightly dif-ferent, albeit still axiomatic, method.
Rather than characterizethe well-formed trees driectly, we progress in two stages by pro-cedurally characterizing tim well-formedaess axioms themselves,which in turn charaetei'ize the trees.
In particular, we give a pro-cedure which converts GPSG gramma~ into gramma~ writtenlThls research was m~de possible by a gift.
from the System DevelopmentFoundation.I am indebted to Lauri K~rttuncn and Ray Perrault for their eomrael~teon earlier drafts, and to Roger Evans, Gerald Gszdsr~ Ivan S~.$t l enryThompson, and members of the Foundations of Grammar project at theCenter for the Study of Language and Information for their helpful dis-cussions during the development of this work.in a unification-b~qed formalism, the PATR-II formalism devel-oped at SRI International (henceforth PATR) \[5\], which h~s itsown declarative semmltics, and which can therefore be viewed &san axiomatization of string well-formedness constraints.
2The characterization of GPSG thus obtained is simpler andbetter defined than the version described by Gazdar et al Thesemantics of the formalism is given directly through the reductionto PATR.
Also, the PATR axiomatization has a clear construe-tire interpretation, unlike that used in Gazdar et al, thus mak-ing the system more amenable to computational implementation.Finally, the characteristics of the coml~ilation--the difficulty orease with which the various devices can be encoded in PATR--can provide a measure of the expressiveness and indispensabilityof these devices in GPSG.2 The  GPSG Ax ioms2.1 A Summary  o f  the  P r inc ip lesGPSG describes natural languages in terms of various types ofconstraints on local sets of nodes in trees.
Pcrtlncnt o the ensu-ing discussion are the following:?
ID (immediate dominance) rules, which state constraints ofimmediate dominance among categories;?
metarules, which state generalizations coI~ccraing classes ofID rules;?
LP (linear precedence) rules, which constrain the Ihwar or-der of sibling categories;?
feature cooccurrencc restrictions (FCR), which constrain thefeature structures as to which arc permissiHe categories;a feature specification defaults (FS1)), which provide valuesfor features that are otherwise unspecified;and, most importantly,21towever, a caveat is \]n order th:~t the detailed ~u~alysis from this perspec-tive of the full range of GPSG devices (especially immediate dominance(ID) rules, and feature cooccurrence r strictions) is not discussed filllyhere, nor do I completely understand them.
(See Section 3.4.}
And whilein a confessional mood, I should add that the Msorlthm given here has notactually been implemented.211?
universal feature instantiation principles, which constrainthe allowable local sets of nodes in trees; these feature in-stantiation principles include the head feature convention(HFC), the foot feature principle (FFP), and the controlagreement principle (CAP).In GPSG all of these constraints are applied simultaneously.A local set of nodes in a tree is admissible under the constraintsif mad only if there is some base or derived ID rule (which wewill call tile licensing rule) for which the parent node's categoryis an extension of the left-hand-side category in the rule, and thechildren arc respective extensions of right-hand-side categories inthe rule, and, in addition, the set of nodes simultaneously satis-fies all of the separate feature instantiation principles, orderingconstraints, etc.
By eztension, we mean that the constituent hasall the feature values of the corresponding category in the licens-ing rule, and possibly some additional feature values.
The formertype of values are called inherited, the latter instantiated.The feature instantiation principles are typically of the follow-ing form: if a certain feature configuration holds of a local setof nodes, then some other configuration must also be present.For instance, the antecedent of the control agreement principleis stated in terms of the existence of a controller and eontrolleewhich notions are themselves defined in terms of feature configu-rations.
The consequent concerns identity of agreement features.2.2 In teract ion  o f  P r inc ip lesMuch care is taken in the definitions of the feature instantia-tion principles (and their ancillary notions such as controller,eontrollee, fl'ce features, privileged features, etc.)
to control thecomplex interaction of the various constraints.
For instance, theFFP admits local sets of nodes with 8la~h feature values on parentand child where no such values occur in the licensing ID rule, i.e.,it allows instantiation of slash features.
But the CAP's above-mentioned efinition of control is sensitive to the value of theslash feature associated with the various constituents.
A simpledefinition of the CAP would ignore the source of the slash value,whether inherited, instantiatcd by the FFP, or instantlated insome other manner, llowevcr, the appropriate definition of con-trol needed for the CAP must ignore instantiated slash features,but not inherited ones.
Say Gazdar et al:We must modify the definition of control in such a waythat it ignores perturbations of semantic type occa-sioned by the presence of instantiated FOOT features.12, p. 87\]Thus, the CAP is in some sense blind to the work of the PFP.As Gazdar ctal .
note, this requirement makes stating the CAPa much more complex task.The increased complexity of the principles resulting from thisneed for tracking the origins of feature values is evident not onlyin the CAP, but in the other principles as well.
The head featureconvention requires identity of the head features of parent and!,,ad child.
The features ayr and slash--features that can beitfimrited from an ID rule or instantiated by the CAP or FFP,respectively--are h ad features and therefore potentially subjectto this identity condition.
However, great care is taken to removesuch instantiated head features from obligatory manipulation bythe tIFC.
This is accomplished by limiting the scope of the ItFCto the so-called free head features.Intuitively, the free feature specifications on a category\[the ones the HFC is to apply to\] is the set of featurespecifications which can legitimately appear on exten-sions of that category: feature specifications which con-flict with what is already part of the category, eitherdirectly, or in virtue of the FCRs, FFP, or CAP, arenot free on that category.
\[2, p. 95\]That is, the FFP and CAP take precedence (intuitively viewed)over the ItFC.Finally, all three principles are seen to take precedence overfeature specification defaults in the following quotation.In general, a feature is exempt from assuming its defaultspecification if it has been assigned a different valuein virtue of some ID rule or some principle of featureinstantiation.
\[2, p. 1001Qazdar et al accomplish this by defining a class of privilegedfeatures and excluding such features from tile requirement thatthey take on their default value.
Of course, instantiated head fea-tures, slash features, and so forth are all considered privileged.However, a modification of these exemptions i necessary in thecase of lexical defaults, i.e., default values instantiated on lexicalconstituents.
We will not discuss here the rather idiosyncraticmotivation for this distinction, bnt merely note that Icxical con-stituent defaults are to be insensitive to changes engendered bythe HFC, as revealed in' this excerpt:ftowever, this simpler formulation is inadequate sinceit entails that lexical heads will always be exempt fromdefaults that relate to their ttEAD features .... Accord-ingly, tile final clause needs to distinguish lexical cate-gories, which become xempt from a default only if theycovary with a sister, and nonlexieal categories, whichbecome exempt from a default if they covary (in rele-vant respects) with any other category in the tree.
\[2,p.
103\]Thus the interaction of these principles is controlled throughcomplex definitions of the various classes of features they areapplicable to.
These definitions conspire to engender the fol-lowing implicit precedence ordering on tire principles, principlesearlier in the ordering being blind to the instantiatlons from laterprinciples, which are themselves sensitive to (and exempt fromapplying to) features instantlated by the earlier principles)CAP ~.4 FFP ~'- FSDuz ~ tlFC >- FSDno,a~Of course, all ID rules, both base and derived arc subject toall these principles; yet met,rule application is not contingent oninstantiations of the base ID rules.
Conversely, LP constraintsare sensitive to the full range of instantiatcd features.
The prece-dence ordering can thus be extended as follows:SCurrent efforts by at least certain GPSG practitioners are placing theGPSG type of analysis directly in a PATR-like formalism.
This formal-ism, Pollard's head-drlven phrase structure grammar (ltPSG) variant ofGPSG, uses a run-time algorithm similar to the one described in this pa-per \[4\].
Highly suggestive is the fact that the \]IPSG run-time algorithmalso happens to order the principles in substantially the same way.4We use the symbol ~- to denote one principle "taking precedence over"another.212META ~- CAP ~- FFP >- FSDttx~- ItFC >- FSDno,u~ ~" LPThe existence of such an ordering on the priority of axioms is,of course, not a necessary condition for the coherence of such anaximaatic theory.
Undoubtedly, this inherent ordering was notapparent o the developers of the theory, and may even be thesource of some surprise to them.
Yet, the fact that this orderingexists and is strict leads us to a substantial simplification of thesystem.
Instead of applying all the constraints imultaneously,we might do so sequentially, so that the precedence ordering--tile blindness of earlier principles in the ordering to the effects oflater ones emerges imply because the later principles have notyet applied.This solution harkens back to earlier versions of GPSG inwhich the semantics of the formalism was given in terms ofcompilation of the various principles and constraints into purecontext-free I~lles.
This compilation process can be combinato-rially explosive, yielding vast numbers of context-free rules.
In-deed, the whole point of the GI'SG decomposition is to succinctlyexpress generalizations about tile possible phrasal combinationsof natural languages, ltowever, by carefully choosing a systemfor stating constraints on local sets of nodes--a formalism morecompact in its representation than context-free grammars--wecall compile out the various principles and constraints withoutrisking this explosion in practice.The GPSG principles are stated in terms of identities of fea-tures.
What we need to avoid the combinatorial problems of pureCF rules is a formalism in which such equalities can be stateddirectly, without generating all the ground instances that satisfythe equalities.
What is needed, in fact, is a unification-basedgrammar formalism \[6\].
We will use a variant of PATR \[5\] asthe fi)rmalism into which (H)SG grammars are compiled.
In par-tieular, we assume a version of PATR that has been extendedby the familiar decomposition i to an immediate-dominance andlinear-precedence omponent.
Ttfis will allow us to ignore theLP portion of GPSG for the nonce.PATR is ideal for two reasons.
First, it is the simplest of theunification-based grammar formalisms, possessing only the appa-ratus that is needed for this exercise.
Second, a semantics for theformalism has been provided, so that, by displaying this compi-lation, we implicitly provide a semantics for GPSG grammars aswell.
In the remainder of the paper, we will assume the reader'sfamiliarity with the rudiments of the PATR formalism.3 The Compilation AlgorithmWe postpone for the time being discussion of the metarules, LPconstraints, and feature eooccurrence restrictions, concentrat-ing instead on the central principles of GPSG, those relating tofeature instantiation.
The following nondeterministic algorithmgenerates well-formed PATR rules from GPSG ID rules.
A GPSGgrammar is compiled into the set of PATR rules generated by thisalgorithm.is written in unordered PATR asXo~Xt ,  X2(Xo n) =-(Xo ~) =+(Xo bar) = 2 (R~)(Xo s,,O) = +(X l  bar )  = 2(x2 s.O) =-Note that abbreviations (like 5' for l -n ,  +v, bar2,-t.subj\]) havebeen mad(; explicit.In fact, we will make one change in tile structure of categories(to simplify our restatement of the HFC) by placing all headfeatures under the single feature head in tile corresponding PATRrule.
We do not, however, add an analogous fcature foot.
s Tirosthe preceding rule becomesXo --* Xi, Xz(Xo head n) = .-(Xo head v) = -t-(xo head bar) = e (~)(Xo head subj) = +(Xt head bar) = 2(X2 head sub l) = -We use an operation addc (read "add conservatively') whichadds an equation to a PATI~ rule conservatively, in Ihc sensethat the equation is added only if thc equations arc not therebyrendered unsolvable.
If addition would yield uosolvability, thcn aweaker set of unifications arc added (conserw~tively)instead, onefor each feature in the domain of tile value being equated.
For in-stance, suppose that the operation add~((Xo head) = (Xt head))is called for, where the domain of the head feature wdues (i.e.,the various head features) arc a, b, and c. If the equations inthe rule already Sl)ccify that (X0 head a) # (X1 hc~,d a) thenthis operation would add only the two equations (X0 head b) =(Xl head b) and (Xo head c) = (Xt head c), sincc the additionof the given equation itself would cause rule failure.
Thus theearlier constraint of values for the a feature is given precedenceover the constraint o be added.In the description of the algorithm, a nonempty path p is saidto be defined for a feature structure X if and only if p is a unitpath (\]) and f ~ dora(X) or p = (h?)
and p' is defined forX( f ) .
Our notion of a feature's being defined for a constituentcorresponds to the GPSG concepts of being instantiated or ofcovarying with some other feature.As in the previous definition, we will be quite lax with respcctto our notation for paths, using ((a b) c) and (a (b e) ) assynonymous with (ab  c) .
Also, we will eonsistcntly blur thedistinction betwcen a set of equations and the fcaturc structureit determines.
(Sce Shleber \[7\] for details of the mapping thatmakes this possible.
)3.2 The  A lgor i thm I t se l fNow our algorithm for compiling a G PSG grammar into a PATRgrammar follows:3.1 Pre l iminar iesWe first observe that a GPSG ID rule is only notationally dis-tinct from an unordered PAI'R rule.
Thus, the first step in thealgorithm is trivial.
For example, the ID rule,'~ -+ x ~, I I \ [ -  ,ub j\] ( RI ) 5But recall that dawh is a head feature and titus would fall tinder the p~th (head slash) .213For each ID rule of GPSG (basic or derived by metarule) X0 "--'X1 , .
.
.
,X,,:CAP  If Xi controls Xy (determined by Type(Xi) and Type(Xj)),then adde((Xl con) = (Xj con)) where(head slash) if (head slash) is defined for X icon = (head acr) otherwiseFFP  For each foot feature path  p (e.g., (head slash} ), i fp  is notdefined for Xo , then adde((Xi p) = (Xo p) ) for zero or morei such that 0 < i <_ n and such that p is not defined for X,'.
6FSDtez For all paths p with a default value, say, d, and for all isuch that 0 < i < n, if (Xi bar) = 0 and p is not defined forXi, then add,((X?
1) = d).HFC For X / the  head of X0, add~((Xi head) = (Xo head)).FSDnont~z For all paths p with a default value, say, d, and forall i such that 0 < i _< n, if (Xi bar) # 0 and p is not definedfor X?, then add?((X?
J) = d).3.3 An ExampleLet us apply this algorithm to the prcceding rule RI.
7 We startwith the PArR  equivalent Rs.
By checking the existing controlrelationships in this rule as currently instantiated, we concludetbat the subject X1 controls the bead )(2.
We conservatively addthe unification (X2 head agr) = (XI).
This can be safely added,and therefore is.Next, the FFP  step in the algorithm can instant iate the rulefurther.
Suppose we choose to instant iate a slash feature on X2.Then we add the equation (Xo head .dash) = (X2 head slash).Lexical default values rcqulre no new equations, since no con-st ituents in the rule are given as 0 bar at this point.The t lFC conservatively adds the equation (X0 head) =(X2 head), as )(2 is the head of Xo.
But this equation, as itstands, would lead to the entire set of equations being unsolv-able, since we already have conflicting values for the head featuresubj.
Thus the following set of unifications is added instead: s{X0 head n) = (X2 head n)(Xo head v) = (X2 head v)(Xo head bar) = (X2 head bar){X0 head agr) = (X2 head agr)(Xo head ;nv) = (x2 head in,)6Several comments are pertinent to this portion of the algorithm.
First,it is the FFP portion that is responsible for its nondeterminism.
Second,the operation add?
is actually superfluous here.
The equation can simplybe added directly, since we have already guaranteed that the pertinentfeatures are not yet instantiated.
By a similar argument, we can concludethat only the addc operations in the CAP and HFG are actually necessary.We will use adds, however, for uniformity.
Finally~ we assume that an FSDwill place the value ~ on any remaining constituents unmarked for footfeatures.7We do not include here the effect of the rule on every feature postulatedby Gazdar etal.
but only a representative sample.8A more efficient representation f such sets could be achieved by the intro-duction of nonmonotonic operations such as overwriting or priority union.But such considerations eed not concern us here.214Finally, nonlexieal defmdts are introduced for features not inthe domains of const i tuents2 Since the path (head inv) is de-fined for the const i tuents X0 and X2, l?
the defanlt value (i.e.,' - '  according to FSD 1 of Gazdar et al) is not instant iated oneither constituent.
Similarly, the case default value (ace, FSD10) is not instant iated on tile subject NP.
But the conj featuredefault t ( '~ ' )  will be instant iated on all three constituents withthe equations(Xo eo.~, )  = ~(x l  conj)  = ~(xz eonj) = ~The (partial) generated rule is the following:Xs -* X~, Xz(Xo head n) = -(Xo head v) = +(Xo head bar} = 2(Xo head subl) = +(X1 head bar) = 2(X2 head subl) = -(X2 head agr) = (X1)(Xo head slash) = (Xz head slash)(xo head .)
= (xz head .
)(Xo head v) = (X2 head v)(Xo head ~ar) = (xz head bar)(Xo head aor) = (X~ head a~r)(Xo head inv) = (-)(2 head inv)(x  0 co@ = ~(X ,  co@ = ~(X2 so .
j )  = ~3.4 Problems and Extens ionsSeveral problems have been glossed over in tile previous discns-sion.
First, we have not mentioned the role of LP rules.
Twopossibil ities are available for their interpretation: a "rtm-time"and a "eompile-tlme" interpretation.
We can augment ile PATRformalism with I,P rules in tbe same way as Gazdar et al, pro-viding for local sets of nodes to satisfy an unordered PATR ruleif and only if the nodes are extensions of elements in the ID rulesuch that the LP rules are all satisfied.
Alteruatively, we cangenerate at compile t ime all possible orderlngs of tile unorderedrules compatible with ttle LP statements,  but this leads us intothe problem of interpreting LP statements relative to partial lyinstant iated categories, an issue beyond the scope of tiffs paper.Second, feature eooeeurrenee r strictions were ignored in theprevious discussion.
Again, we will l imit ourselves to a brief dis-eussion of the possibilities.
One alternative is to modify the lat-OWe have made the simplifying assumption that feature specification de-faults are stated in terms of simple default values for features, rather thanthe more complex boolean conditions used in the Gazdar et al text.The modifications to allow the more complex FSDs may or may net bestraightforward.t?The value of the feature head on the constituent Xo has the feature inv inits domain because the unification (Xo head iuv} = (X2 head inv) givesas value to (Xo head inv} a variable, the same variable as the value for(X2 head ins) .
Thus the path (head lay} is defined for Xo and, similarly,for X:.IIWe assume here, contra Gazdar et al, that '~' is a fnll-fledged value inits own right, at least as interpreted in this compilation.
Since this valuefails to unify with any other value, e.g., '+' or ' - ' ,  it has exactly thebehavior desired, namely, that the feature is prohibited from taking anyof its standard values.tice of categories relative to which unification is defined tz in sucha way that all categories violating the FCILs are simply removed.Then unification over this revised lattice will be used insteadof the simpler w!rsion and FCRs will automatically always beobeyed.
Unfortunately, tire possibility exists that unification overtile revised lattice may not bear the same ordcr-in(lependenceproperties that characterize unification over the freely-generatedlattice.. Of course, if this turns out to be the ease, it c~,~ts doubton the well-fomMedness of the original Gazdar et al interpre:tation of FCRs as well, apd tlms is an interesting question topursue.Another alternative involves checking the FCRs at every pointin the algorithm, throwing out any rules which violate them atany point.
In addition, FCRs would be required to be checkedduring rau-time as well.
This alternative, though more direct,violates the spMt of the enterprise of giving a compilation fromthe eoml>lex Gazdar et al formulation to n simpler system.A final problenl concerns the ordering of the III"C and the(JAIL The definitions of eontroller and controllee necessary forstating ttw CAP depend on the assigmnent of semantic types tr)constitncnts, which in turn deltend on the configuration of fea-tures in {;he categorical.
We have ah'eady noted that the featurespertinent o tit(!
definition of sen(antic type (and hence control)do not include instantiatcd fi)ot featttrcs.
Indeed, Gazdar et alclaim that "it is just IlEAl) feature specifications (other thanthose which are also I?OOT feature specifications) and inheritedFOOT fl,aturc specifications that determitre the semantic typesrelevant o the definition of control."
\[2, p. 87\] Unfortunately,the orderiug we have giveu lu'ecludes instantiated head featuresfrom participating in the definition of semantic type and hencethe CAI)) "~ It seems that the III"C nmst apply before che CAPlot the (Mini\[ion of semantic type, but after the CAP so that theCAI' instantiatlons of head features take ln,eeedence.
Tbus, ourearlier claim of strict ordering may be falsified by this case.Of com-se, the :~et of features neeessat T for type determinationand the :act; instantiated by tile CAP may be disjoint.
In thiscase, we can merely split the application of the IIFC in two, in-start\[taring the flu'met' class beibre the CAP and tile latter classafter the FFP ms originally described.
Alternatively, it might bepossible to notate head features on the head constituent ratherthan tim l)arent as is conventlally dtate.
In this case, tile infor-mation needed by tile CAP is inherited, (tot instantiated, headfeature wdues, atnl titus not subject to the ordering problem.On the other hand, if the sets are nondisjoint, this presents aproblem not only for our algorithmic analysis, but for the deti-nltion of GI'SG given by Gazdar et al Suppose that the IlFCdetermines types in such a way that the CAP is required to ap-ply and instantiates head features thereby overriding the originalvalues (since the CAP takes preeedence) attd changing the typedetermination so that the CAP does not apply.
We wouhl thusrequire the CAP to apply if and only if it does not apply.
Thisparadox :qtpears as an ordcring cych: in our algorithm; in thedeclarative detinition of Gazdar et al, it would be manifestedin the inadmissability of all local set.~ of nodes 11\], at( equallyunattractive effect.
We leave the resolution of this problem openfor the time being, merely noting that it is a di|fieulty for GPSGiu general, and not only for our characterization.l~For the technicM background of st\[d\[ a move, see the discussion of PATRsemantics \[3\].~uI am indt:bted to Roger Evens and William Keller for pointing this problemout, to me and for helpful discussion of solution alternatives.4 ConclusionThe axiomatic formulation of generalized phrase structure gram?mar by Gazdar et al is a quite subtle and complex system.
Yet,as we have qhown, GPSG grammars cm~ be substantially con-verted to grammars in a simpler, attd constructive, axiomaticsystem through a straightforward (albeit procedural) mapping.Intrinsic iu this conversion is the use of a unification-based gram-mar formalism, so that axioms can be stated schematically, with-out enumerating all nf their possible instantiations.
In fact, wewouhl contend that defining the semantics of a GI)SG grammarin this way yields a much simpler fornmlation.
The need for sucha reconstruetinn is evident o anyone who has studied tit\[: C;azdaret al text.Of course, even if certain parts of the GPSG for'realism notdiscussed fully here, i.e., FCRs att(I l,l ) constraints, arc found notto be reducible to PATR, this in itself wouhl be an interesti,gfact.
It wouhl slmw that exactly those porticos of the formalismwere truly essential for stating certain analyses, i.e., that analysesusing those formal devices do so necessarily.We find a hopefid sign in the recent work in (\]PSG that is pro-.ceeding iu the direction of using unilication directly in the rules,in addition to its implicit m~e iu featuce instantiation principles.Wc hope that this paper has provided evidence that such a sys-tem may be able to more simply state the kiuds of generalizationsthat linguists claim, and has pointed out I)oth the possibilitiesand difllcultics inherent in these tcehniques.i \ [ t~e i~re~ces\[1\] Gerahl Cazdac.
l'ecsonal communication, 1986.\[2\] Gerald Cazdar, Ewan Klein, Geoffrey K, I'ullum, att(l IvanA.
Sag.
Generalized Phrase Structure Grammar.
BlaekwellPnblishing, Oxford, l(,ngland, atnl l\]arvard University Press,Candwidge, Massachusetts, 1985.\[3\] l,'ernando C. N. l'ercira and Stuart M. Shieber.
The semaa otics of gran|mar formaIisms een as COmlmter languages, InProeecding,~ of the Tenth lntcrnational Conference on Com..putation.l Linguistics, Stanford University, Stauh)r(l, Califor-nia, 2-7 July 1984.\[4\] Carl Pollard.
l,ecture notes ou hcad-driven phrase-structuregrammar.
Fcbruary 1985.
Center for thc Study of l,anguagcand Information, unpublished.\[5\] Stuart M. Shieber.
The design of a computer language for lin-guistic information.
In Proeecding~ ofthe "l~nth InternationalConference on Computational Lt'ngui,~tic~, Stanford Univer-sity, Stanford, California., 2-7 July 1984.\[6\] Stuart M. Shiel)er.
Art Introduction to Unification-Ba.~cd Ap.proache~ to Grammar.
CSLI Lectu)v Note Series, Center forthe Study of Language aud Information, Stanford, California,Forthcoming.\[7\] Stnart M. Shieber.
Usiug restriction to extend parsing algo-rithms for complex-feature-based formalisms.
In Proceedingsof the 22nd Annual Meeting of the Association for Compu-tational Linguistic.~, Univel~ity of Chicago, Chicago, lllinoi%July 1985.215
