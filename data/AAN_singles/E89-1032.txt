AN ALGORITHM FOR GENERATION IN UNIF ICAT IONCATEGORIAL  GRAMMARJonathan Calder, Mike Reape and Henk ZeevatUniversity of EdinburghCentre for Cognitive Science2 Buccleuch PlaceEdinburghEH8 9LWAbstractWe present an algorithm for the generation ofsentences from the semantic representations ofUnification Categorial Grammar.
We discuss avariant of Shieber's semantic monotonicityrequirement and its utility in our algorithm.
Weindicate how the algorithm may be extended to othergrammars obeying the same requirement.
Appendicescontain a full listing of the program and a trace ofexecution of the algorithm.1.
IntroductionIn this paper we present an algorithm forgenerating sentences using unification categorialgrammars (UCGs, Zeevat et al 1987) but whichextends to any categorial grammar with unification(e.g., categorial unification grammars, Uszkoreit1986, Karttunen 1987).
We relate the algorithm toproposals by Shieber (1988).
Following Shieber, weaddress the basic generation problem; that is, given asyntactic ategory K and a semantic representation ~,generate every possible string def'med by the grammarof category K with a semantic representation that islogically equivalent to ~.
In more concrete terms,this means that we dispense with any planningcomponent and directly address the intrinsiccomplexity of the basic generation problem.
Thedevelopment of such algorithms i  as fundamentallyimportant as the corresponding work on parsingalgorithms.We also discuss the properties of a semanticrepresentation language (SRL) and the manner of itsconstruction which makes our algorithm effective.The crucial property is a stricter form of Shieber's(1988) property of semantic monotonicity.
We notonly require that the semantics introduced by allsubconstituents of an expression appear within thesemantics of the expression as a whole; we alsorequire that the semantics of any containingexpression be a further instantiation of one of itssubexpressions.We introduce the algorithm on a case-by-casebasis, at each stage xtending its coverage and includea listing of the program implementing thisalgorithm, as appendix A.2.
Basis of the algorithmThe most important feature of categorialgrammars i  the close correspondence of syntactic andsemantic ftmctors.
In generation, if the semanticfunctor of an expression can be identified, possiblevalues of the syntactic functor can also be determined.Under these circumstances, a simple recursiveprocedure can be stated which implements a mixedtop-down and bottom-up strategy, alternatelydetermining the functor of an expression andgenerating the arguments to that functor.
In thepresentation of the basic algorithm below we willmake the simplifying assumption that for anyformula of the semantic representation language, thesyntactic and semantic functors are immediatelyidentifiable.
We will have to relax this restriction inorder to deal with phenomena such as type raising andidentity semantics.UCG employs only two types of phrasestructure rules.
First, there are two binary rules offorward and backward application.
Schematically,these can be represented asfollows.Result -~ Functor/Active ActiveResult --~ Active Functor\ActiveThe first of the actual rules is stated below.The second is just like the first except hat pre issubstituted for post and the order of the daughters ireversed.
Notice the use of the order feature.
If asign is an argument, then its order value is pre(post) if it precedes (follows) its functor.- 233 -I phonology: Wf+Wa\] syntax: X | semantics: S | "-'> order: 0 J- phonology: Wf  -\[phonology: Wa\]x, lsY ntax: Y /syntax: "~'| semantics: Sa \[\[.order: post _1semantics: S- order: Ophonology: Wa\]syntax: Y lsemanticsi Sa /order: post .
!Second, UCG employs a small set of unary rulesof the form a --> ~ where a and I~ are UCG signs.Unary rules have several uses.
These include thetreatment of unbounded dependencies, syntactic formsof type-raising (e.g., generic noun to np rules) andsubcategorization for optional modifiers.
In general,unary rules relate one category to another.
Inparticular, unary rules can change the category of afunctor.
This will require a modification to the basicstrategy we present below.The language InL (Indexed Language) is avariant of Kamp's (1981) Discourse RepresentationTheory.
Its most important properties are i) everyexpression has a privileged variable (its index) and ii)every variable is sorted, so indicating the ontologicalcategory of the object denoted by the variable.
Theonly logical connectives are conjunction andimplication.
The semantics of an expression isconstructed compositionally via unification.
Asdiscussed further below, the semantic representationof any sentence in UCG is simply a furtherinstantiation of the semantics associated lexicallywith one element of the sentence.3.
A sketch of the algorithmBelow we present he basic algorithm whichimplements he informal description given above.
Wegive the algorithm in Prolog for convenience b causevarious refinements tothe algorithm to be discussedbelow (e.g., the use of a chart) depend irectly on theprocedural spects of Prolog's control strategy.
Thisbasic version of the algorithm requires that UCGsigns be encoded as first order terms and that termunification is used.
This includes both InL formulasand sorted indices.
A graph encoding of signs andgraph unification could be used but this would makethe presentation f the basic ideas more complicated.Unary rules are not covered in~ this firstapproximation.generate (Sign) :-path__value (semantics, Sign, InL),path value (semant ics, SignO, InL),lexical (SignO),reduce (SignO, Sign) .reduce (Sign, Sign) .reduce (Sign0, Sign) :-path value (syntax: active, Sign0,Active) ,apply ( Sign0, Active, Result  ),generate (Active),reduce (Result, Sign) .The predicate path_value(Path,Sign,Value)succeeds if the value of the path Path through thesign Sign is Value.
lexicai(Sign) succeeds if thesign Sign can be unified with a lexical entry.apply(FunctorActive,ResulO implements he rulesof forward and backward functional application asdiscussed above.generate(Sign) generates a sign Sign withphonology ~, syntactic ategory K and semantics Zby creating a new sign SignO with phonology ~',syntactic category K' and semantics Z, unifying thesign with a lexical entry and then reducing SignO toSign in a bottom-up fashion.
Thus generateimplements the top-down half of the control strategyby "predicting" the syntactic category of Sign on thebasis of which lexical entries unify with it.
Thebottom-up reduction is necessary as it is notnecessarily the case that ?
= ~' or that K = K'.
Inparticular, unless ~.
corresponds to a nonfunctorlexical entry, SignO will be of the schematic formX/Y  (i.e., a lexical functor).reduce has two clauses.
The first reduces asign Sign to itself.
The second reduces a sign SignOto a sign S ign  if S ign0  is a functorFunctor/Active which when applied to Active byone of the rules of functional application gives theresult sign Resu l t ,  the sign Act ive  can begenerated and Result can be reduced to Sign.
Asample execution of the algorithm, using only theabove clauses for the two predicates, is given inAppendix B.There is a major deficiency in this algorithm.Unification is the only method used to test thelogical equivalence of two semantic representations.This means that not even the axioms ofcommutativity or associativity are available fortesting logical equivalence 1.
One of the1Strictly speaking, we test for a very strict formof consistency.
Two LFs are considered logically- 234-consequences of this is that, given a semanticrepresentation ~b, it may not be possible to generate asentence with semantic representation 0', where ~ and0' are logically equivalent.
In fact, it may not bepossible to generate any sentence ven though thereare sentences defined by the grammar which havesemantic representations which are equivalent to ~b.So, for example, an semantic representation which isproduced by parsing a nontopicalised sentence cannotbe used to generate a topicalised sentence.Shieber (1988) claims that the problem oflogical equivalence reduces to the knowledgerepresentation problem.
The claim is that there willbe no full solution to this problem in the near future.To satisfy our definition of generation however, wemust generate all sentences whose semanticrepresentations are logically equivalent o thesemantic representation being generated under therules of inference and axioms of the semanticrepresentation language.
In the case of InL, theprimary axioms are simply associativity andcommutativity.
However, these two axioms alonegive the equivalence problem factorial complexity.We will discuss these issues below after we haveintroduced some refinements othe algorithm.4.
Refinements to the basic algorithmThe algorithm presented above is deficient inother respects.
There are three other aspects of UCGanalyses that are not covered.
First, all Nl's are type-raised.
The standard UCG analysis of non-lexieal NPsis adequately handled using the above definitions, asthe resulting semantic structure contains informationintroduced by the determiner.
On the other hand, alexical NP such as Harry will bind a variable in thesemantics of an expression indicating that thetranslation of Harry is a constant.
However, noother semantic material will be introduced fromwhich the need to generate a lexical NP could beinferred.
This is remedied quite easily by adding thecondition, to the second clause of reduce above, thatthe category of SignO is not np, and by adding thefollowing clause to reduce:reduce(Sign0, Sign) :-path_value(category:active,Sign0, Active),path_value(category, Active, np),path_value(semantics, Active,Index),proper name(Index),equivalent if their sorted indices are consistent but therest of the formula is logically equivalent.
We returnto this point briefly below.typeraise_np (Active,TypeRaisedNP ),apply (TypeRaisedNP, Sign0,Mother) ,generate (TypeRaisedNP),reduce (Mother, Sign) .The most important part of the above def'mitionis the restriction of the clause to the generation ofelements which satisfy the predicate proper name;we assume this test to be appropriately definedaccording to the semantic representation languageused.
In our case, it is a simple test for instantiation.The predicate typeraise_np(Active, TypeRaisedNP)relates a non-type-raised to a type-raised NP.
Notethat in the call to generate, we attempt to generatefrom the constructed type-raised NP.
The reasons forthis are that lexical NPs have to be type-raised priorto the lexical lookup in generate and that theargument to the type-raised NP is generated inexactlythe same manner as other arguments.Two further problems are the treatment ofunaryrules and functors with what Shieber (1988) callsvestigial semantics, which we prefer to call identitysemantics.
The latter identify the semantics of theirargument with their own semantics.
That is, they aresemantically vacuous.
Examples from English arecomplementisers and case-marking prepositions.Again, we add an additional clause to reduce whichenumerates the set of relations that may hold betweensigns under unary rules and under functors withidentity semantics, using the auxiliary predicatetransform.
The clause re.cursively invokes reduceas it may be the case that a unary rule or functorwith identity semantics introduces further syntacticarguments.reduce (Sign0, Sign) :-transform(Sign0, Sign1),reduce (Sign1, Sign) .transform(Daughter, Mother) :-unary_rule(Mother, Daughter).transform(Sign0, Sign) :-path_value(category:active,Sign1, Sign0),identity(Sign1),apply(Sign1, Sign0, Sign).identity enumerates those lexical entrieswhose semantics is the same as that of one of itsarguments.
Note that both of these clauses continuethe basic bottom-up reduction strategy.
Essentially,we must freely apply both identity semantics functorsand unary rules to guarantee completeness of thealgorithm.
Given that we apply unary rules andidentity functors freely, our algorithm will onlyterminate if the bottom-up closure of such elements- 235  -with respect to elements of the lexicon is finite.
Inother words, we require that the grammar adhere tothe offline parsability constraint (Kapland andBresnan 1982).
If this condition does not hold, thealgorithm will not terminate.5.
Optimizations of the algorithmGiven the fairly high degree of top-downcontrol, it should be obvious that the generator willgenerate some subformulas of its input repeatedly asit explores the search space.
The obvious olution isto use a lemma table or chart (as discussed by Pereiraand Warren 1984 and Shieber 1988).
Shieber (1988)states that to guarantee completeness in using aprecomputed entry in the chart, the entry mustsubsume the formula being generated top-down.However, empirical tests have shown that a naivechart strategy results in the chart never being used atall.
This is to be expected given the nature ofgeneration; since most of the signs being generatedtop-down are very partial (often they will have onlythe semantics instantiated) and chart entries will bevery complete (since most information is projectedfrom the lexicon) it will almost never be the case thata top-down sign is subsumed by the chart.The result is that we must either abandon theidea of using a chart I or else devise a strategy for itsuse which is complete, does not rely on thesubsumption test and does not put too many entriesin the chart We have followed the latter strategy.This technique depends crucially on avoiding any top-down instantiation of candidate chart entries and byguaranteeing bottom-up completeness of chart entriesconsistent with a restriction of the top-down sign.The nature of the restriction that we use depends onproperties of the semantic representation languageitself.
In particular, the only use of variables in thelanguage is in representing existentially quantifiedvariables over individuals.
Thus every appearance ofavariable can only be further instanfiated by a semanticindividual constant and so the semantic representationafter generation cannot be further instantiated in sucha way that the denotation of that expression differsfrom that of the input semantic representation.1A recent implementation of a similaralgorithm by Thierry Guillotin and Agnes Plainfoss6(Personal communication) suggests that the top-downapplication of unary rules, while making itimpossible to guarantee completeness if making useof a chart, nevertheless leads to an overallimprovement in efficiency by limiting the searchspace engendered by unary rules.
This supports thecontention that unary rule application is the dominantcost in generation with UCG.The program presented in Appendix Aillustrates the use of the chart.
The reader will noticethat the instruction to add information to the chartfollows calls to generate but precedes calls toreduce.
This strategy means that we keep the chartfree of the top-down instantiations caused by equatinga bottom-up solution (the first argument of reduce)to a top-down goal (the second argument of reduce).Another method for reducing the search space isto use the technique of freezing in cases where thepremature instantiation of variables will lead toavoidable backtracking.
In the case of our currentUCG grammar, it is often the case that the orderfeature is not instantiated when apply is called.
Ifthe argument is generated before the phonology isinstantiated, then unnecessary generations with thewrong word order can be prevented.
Therefore, wefreeze the value of the phonology and order attributesuntil after an argument is generated.
This requiressome care to ensure that the freezing interacts withthe chart strategy correctly.
This is illustrated in thefull program listing below.
It is to be expected thatmore complex grammars would benefit from anextension of this technique to other attributes withmut~j~lly dependent values.6.
Extension to other grammaticalformalismsWe alluded above to our assumption about herelationship between the semantics of lexical andnon-lexical expressions.
To recap, any semanticrepresentation is a further instantiation of thesemantic representation f some lexical item.
Thisassumption will not hold for any grammar in whichsemantic material is introduced by rule (i.e.syncategorematically).
Thereason for this should beobvious given the definition of generate above.
If aparticular semantic representation possibly containssemantic structure not present in the lexicon, thenany attempt to find an appropriate l xical functor onthe basis of the semantics of an expression is notguaranteed to succeed.
Relaxing this assumptionwould effectively remove all top-down predictivecapacity for generation.
The only solution in thecontext of this algorithm would then be to allow top-down application of all rules and to delay calls tolexical lookup until after rule application.
Thisgenerate and test strategy is not only likely to beinefficient, it will also result in non-termination formany grammars.In contrast, for grammars which do adhere toour assumption, our algorithm is effective, even ifrules other than simple binary and unary rules areused.
To see this, consider the following extension toreduce:- 236  -reduce(SignO,  Sign) - -ru le (Morn ,  SignO, Kids),generate_s i s te rs  (Kids) ,reduce (Morn, Sign) .Note that this clause is very similar instructure to the second clause for reduce, the maindifference being that the new clause makes fewerassumptions about the feature structures beingmanipulated, rule enumerates rules of the grammar,its first argument representing the motherconstituent, i s second the head daughter and its thirda list of non-head daughters which are to berecursively generated by the predicategenerate_sisters.
(We assume, as with UCG, thatinformation indicating the resulting phonology andorder of constituents is contained within the featurestructures of the rule).
The behaviour of this clause isjust like that of the clause for reduce whichimplements he UCG rules of function application.On the basis of the generated lexical sign SignO anapplication of the rule is hypothesised and we thenattempt to prove that hat rule application will lead toa new sign Morn which reduces to the original goalSign.The same conditions apply to the generalizedform of the predicate as to the clause for unary rules,namely the algorithm will terminate if the bottom-upclosure of the rules of the grammar is finite.
Weconjecture that his algorithm extends naturally to therules of composition, division and permutation ofCombinatory Categorial Grammar (Steedman 1987)and the Lambek calculus (1958).7.
ImplementationThe algorithm discussed in this paper has beenimplemented in C-Prolog.
Recent work has looked atgeneration from semantic representations which arenot in canonical format but which are equivalent,under the axioms of associativity and commutativityto the canonical semantics of sentences recognised bythe grammar.
Our effort is directed at formulatingappropriate notions of "semicanonicality", whichlessen the strict (and in many cases unobtainable)requirement that the representation to be generatedfrom is identical to that obtained as the result ofparsing.
Such notions would increase the utility ofgenerators such as we have presented while avoidingthe dangers of factorial complexity.A further source of inefficiency is the naivelexical indexing strategy used by the predicatelexical.
We have presented the algorithm as ifiexical simply enumerates the lexicon.
This isclearly inefficient and some form of indexing strategyseems essential.
The simplest is to choose theprincipal functor of the semantic representation t  useas the index for lexical entries which have the sameprincipal functor in their semantics.
Much of thetime however, the principal functor is simply theconjunction operator.
A more sophisticated indexingstrategy involves calculating the best (set of) key(s)to identify candidate l xical entries.
This necessarilyinvolves considerable complexity itself.Furthermore, if such indexing is to be automatic,very sophisticated compilation techniques andmetaknowledge about the possible structure ofsemantic representations are required.
We are alsoinvestigating these possibilities.AcknowledgementsThe work reported here is supported by ESPRITproject P393 ACORD: The Construction andInterroagtion of Knowledge Bases using NaturalLanguage text and Graphics.
Thanks are due toPhilippe Alcouffe, Lee Fedder, Thierry Guillotin,Dieter Kohl and Agnes Plainfoss6 for discussions ofproblems in generation with UCG.
All errors are ofCOurSO Our OWrl.ReferencesKaplan R.. M. and Bresnan J.
(1982) Lexical-Functional Grammar: a formal system forgrammatical representation, Chapter 4 in J.Bresnan (ed.)
The Mental Representation fGrammatical Relations, 173-281, MIT Press,Cambridge Mass.Karttunen, L. (1986) Radical Lexicalism.
ReportNo.
CSLI-86-68, Center for the Study ofLanguage and Information, December, 1986.Paper presented atthe Conference on AlternativeConceptions of Phrase Structure, July 1986,New York.Lambek, J.
(1958) The mathematics of sentencestructure.
American Mathematical Monthly,65, 154-170.Pereira, F. C. and Warren, D. H. (1983) Parsing asDeduction.
In Proceedings ofthe 21st AnnualMeeting of the Association for ComputationalLinguistics, Massachusetts Institute ofTechnology, Cambridge, Mass., June, 1983,137-144.Shieber, S. (1988) A Uniform Architecture forParsing and Generation.
In Proceedings ofthe12th International Conference onComputational Linguistics, Budapest, 22-27August, 1988, 614-619.Steedman, M. J.
(1987) Combinatory Grammars andParasitic Gaps.
Natural Language andLinguistic Theory, 5, 403-439.- 237-Uszkoreit, H. (1986) Categorial UnificationGrammars.
In Proceedings of the 11thInternational Conference on ComputationalLinguistics and the 24th Annual Meeting of theAssociation for Computatinoal Linguistics,Institut fur Kommunikationsforschung undPhonetik, Bonn University, Bonn, 25-29August, 1986, 187-194.Zeevat H., Klein, E. and Calder, J.
(1987) AnIntroduction to Unification CategorialGrammar.
In Haddock, N.J., Klein, E. andMorril, G.
(eds.)
Edinburgh Working Papers inCognitive Science, Volume 1: CategorialGrammar, Unification Grammar and Parsing.Appendix A: program listingThis listing contains all code discussed in thetext for generation with UCG and includes a correcttreatment of the chart.
The second argument togenerate is not discussed above: its function issimply to disable the check that determines whetherto add information to the chart when that informationhas just been retrieved from the chart./* generate/2 */generate(Sign, chart) :-verify(unifies with chart(Sign)),unifies_with_chart(Sign).generate(Sign, nonchart) :-path_value(semantics, Sign, Sem),path value(semantics, Sign0, Sem),lexicon(Sign0),reduce(Sign0, Sign).
!,/* reduce/2 */reduce(Sign, Sign).reduce(Sign0, Sign) :-path_value(category:active, Sign0,Active),path value(category, Active, np),path_value(semantics, Active, Index),proper_name(Index),typeraise_np(Active, TypeRaisedNP),apply(TypeRaisedNP, Sign0, Mother, \[\],Freezer),generate(TypeRaisedNP, Chart),unfreeze(Freezer, I\]),add to chart(TypeRaisedNP, Chart),reduce(Mother, Sign).reduce(Sign0, Sign) :-path value(category:active, Sign0,Active),pathvalue(category, Active, Category),not Category =np,  not Category = pp,apply(Sign0, Active, Mother, \[\],Freezer),generate(Active, Chart),unfreeze(Freezer,\[\]),add to chart(Active, Chart),reduce(Mother, Sign).reduce(Sign0, Sign) :-transform(Sign0, Signl, \[\], Freezer),unfreeze(Freezer,\[\]),add to chart(Signl, nonchart),reduce(Signl, Sign)./*transform/4 */transform(Daughter, Mother, Freezer,Freezer) :-unary_rule(Mother, \[Daughter\]).transform(Sign0, Sign, Freezer0, Freezer):-path_value(category:active, Signl,Sign0),identity(Signl),apply(Signl, Sign0, Sign, Freezer0,Freezer)./* apply/5 */apply(Sl, S2, S3, F0,\[freeze(Order2,Phonology,WI,W2) IF0\]) :-Sl = sign(Wi,Catl/S2,Seml,Order),$2 = sign(W2,Cat2, Sem2,Order2),S3 = sign(Phonology,Catl,Seml,Order)./* typeraise_np/2 */typeraise_np(Sign0,Sign) :-Sign0 = sign(_,np,_,_),Sign = sign( ,Cat/sign(_,Cat/sign( ...... Order),Sem0, Order),Sem,_),Sign = sign( ,/ s ign(  , /Sign0, , ),~,  ) ?/* proper_name/l */proper_name(N) :- nonvar(N) ./* unifies with chart/l */unifies with chart(S) :-chart(S)./* add to chart/2 */add to chart(S, nonchart) :-verify(unifies_with_chart(S)),add to chart(S, nonchart) :-assertz(chart(S)).add to chart(_, chart).!
.- 238 -/*  unfreeze/2 */unfreeze(\[\], \[\]).unfreeze(\[freeze(pre,Wl+W2,WI,W2) IR\],F) :-unfreeze(R,F).unfreezer(\[freeze(post,W2+Wi,WI,W2) \[R\],F) :-unfreeze(R,F)./*  verify/l */verify(Goal) :- \+ \+(Goal).Appendix B: A trace of program executionIn this example, wc use only the first twoclauses of reduce/2 above.
Figure 1 gives agraphical representation f the information flowduring generation, reduce(I) indicates a use of thefirst, base clause, and reduce(2) ause of the second.Circled numbers in the figure refer to the subsequentattribute value structures.
We omit (8) and (13) as thecorresponding feature structures are easily determinedby inspection, corresponding to the base clause ofreduce/2.ActivelexiconMothergeneratelexiconActivereducegenerate(1)lex iconreduce (1)O:0uGFigure 1: A trace of execution for the sentenceEvery boy dreamsrphon: w -\]\[cat: sent \[(1) \[sem: s:lmp:\[m:boy:\[\],e:dream:\[m\]\]\[Lorder: Order .I- 239 -\['phon: W \]|eat: Cat(2) \[sere: s:imp:\[m:boy:\[\],e:dream:\[m\]\]Lorder: Order(3)vPhon: everyVPhon: Wf q/ r ph?n: Wall eat: np\ [eat:  Cat'Cat: Cat~ sem:m / / /XI / Lorder: o , , /J l sem:  e:dream:tm\] lI I-order: Oa _1|sere :  s:lmp:\[m:boy:\[\],e:dream:\[m\]\]'-- order: Ofrphon: Wn 1/eat: noun /where X = |sem: m:boy:\[\]lLorder: pre 3rphon: Wn 1leat: noun \[(4) \[sere: m:boy:\[\] /Lorder: pre l(5)vP hon: every+Wn 1 FPhon: Wf q / r ph?n: Well cat: np lcat: CatJeat: Cat sem: m / /I 1 L?rder: Oa// ' J I /sere: e:dre.m:l:m\] /I I-order: Oa -Jsem: s:lmp: \[re:boy: \[\],e:dream: \[m\]\]order: Of\[-phon: Wn \]/eat: Cat I(6) isem: re:boy:i l lLorder: Order 3rphon: boy \]/cat: noun l(7)/sem: m:boy:\[\] /Lorder: Order 3(9) Iphon: Wf 3FP h?n: wq/lcat: np / /cat: Catlsem" m l |I.order: Oa / \ ]sere: e:dream:\[m\] |order: Oa .Jrphon: every+boy+Wf "1|cat: Cat J(10) |sere: s:|mp:\[m:boy:\[\],e:dream:\[m\]\]\[Lorder: Of _1Fphon: Wf "1|cat: Cat |(11) |sere: e:dream:\[m\] ILorder: Oa .JFPhon: dreams q| r phOn: Wa l |\[ Jcat: np / \ [o2) l?
't: sentqsem: in l /J Lorder: preJJlsem: e:dream:\[In\] |l-order: Oa _lrPhon: every+boy+dreams l.... /cat: sent l(14)/sere: s:imp:\[m:boy:\[\],e:dream:\[m\]\] /Lorder: Of 3- 240 -
