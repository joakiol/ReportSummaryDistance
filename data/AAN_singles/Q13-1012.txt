Transactions of the Association for Computational Linguistics, 1 (2013) 139?150.
Action Editor: Joakim Nivre.Submitted 12/2012; Revised 3/2013; Published 5/2013.
c?2013 Association for Computational Linguistics.Efficient Stacked Dependency Parsing by Forest RerankingKatsuhiko Hayashi and Shuhei Kondo and Yuji MatsumotoGraduate School of Information Science Nara Institute of Science and Technology8916-5, Takayama, Ikoma, Nara 630-0192, Japan{katsuhiko-h,shuhei-k,matsu}@is.naist.jpAbstractThis paper proposes a discriminative for-est reranking algorithm for dependency pars-ing that can be seen as a form of efficientstacked parsing.
A dynamic programmingshift-reduce parser produces a packed deriva-tion forest which is then scored by a discrim-inative reranker, using the 1-best tree outputby the shift-reduce parser as guide features inaddition to third-order graph-based features.To improve efficiency and accuracy, this pa-per also proposes a novel shift-reduce parserthat eliminates the spurious ambiguity of arc-standard transition systems.
Testing on theEnglish Penn Treebank data, forest rerankinggave a state-of-the-art unlabeled dependencyaccuracy of 93.12.1 IntroductionThere are two main approaches of data-driven de-pendency parsing ?
one is graph-based and the otheris transition-based.In the graph-based approach, global optimiza-tion algorithms find the highest-scoring tree withlocally factored models (McDonald et al 2005).While third-order graph-based models achieve state-of-the-art accuracy, it has O(n4) time complexityfor a sentence of length n. Recently, some prun-ing techniques have been proposed to improve theefficiency of third-order models (Rush and Petrov,2012; Zhang and McDonald, 2012).The transition-based approach usually employsthe shift-reduce parsing algorithm with linear-timecomplexity (Nivre, 2008).
It greedily chooses thetransition with the highest score and the result-ing transition sequence is not always globally op-timal.
The beam search algorithm improves pars-ing flexibility in deterministic parsing (Zhang andClark, 2008; Zhang and Nivre, 2011), and dy-namic programming makes beam search more effi-cient (Huang and Sagae, 2010).There is also an alternative approach that in-tegrates graph-based and transition-based models(Sagae and Lavie, 2006; Zhang and Clark, 2008;Nivre and McDonald, 2008; Martins et al 2008).Martins et al(2008) formulated their approach asstacking of parsers where the output of the first-stageparser is provided to the second as guide features.
Inparticular, they used a transition-based parser for thefirst stage and a graph-based parser for the secondstage.
The main drawback of this approach is thatthe efficiency of the transition-based parser is sacri-ficed because the second-stage employs full parsing.This paper proposes an efficient stacked pars-ing method through discriminative reranking withhigher-order graph-based features, which works onthe forests output by the first-stage dynamic pro-gramming shift-reduce parser and integrates non-local features efficiently with cube-pruning (Huangand Chiang, 2007).
The advantages of our methodare as follows:?
Unlike the conventional stacking approach, thefirst-stage shift-reduce parser prunes the searchspace of the second-stage graph-based parser.?
In addition to guide features, the second-stagegraph-based parser can employ the scores ofthe first-stage parser which cannot be incorpo-139axiom(c0) : 0 : (0, 1,w0) : ?goal(c2n) : 2n : (0, n, s0) : ?shift :state p?
??
??
: ( , j, sd|sd?1| .
.
.
|s1|s0) :?
+ 1 : (j, j + 1, sd?1|sd?2| .
.
.
|s0|wj) : (p) i < nreduce?
:state p?
??
?
: (i, j, s?d|s?d?1| .
.
.
|s?1|s?0) : pi?state q?
??
??
: (j, k, sd|sd?1| .
.
.
|s1|s0) : pi?
+ 1 : (i, k, s?d|s?d?1| .
.
.
|s?1|s?0?s0) : pi?s?0.h.w ?= w0 ?
p ?
pireduce?
:state p?
??
?
: (i, j, s?d|s?d?1| .
.
.
|s?1|s?0) : pi?state q?
??
??
: (j, k, sd|sd?1| .
.
.
|s1|s0) : pi?
+ 1 : (i, k, s?d|s?d?1| .
.
.
|s?1|s?0?s0) : pi?p ?
piFigure 1: The arc-standard transition-based dependency parsing system with dynamic programming: means ?takeanything?.
a?b denotes that a tree b is attached to a tree a.rated in standard graph-based models.?
In contrast to joint transition-based/graph-based approaches (Zhang and Clark, 2008;Bohnet and Kuhn, 2012) which require a largebeam size and make dynamic programming im-practical, our two-stage approach can integrateboth models with little loss of efficiency.In addition, the elimination of spurious ambiguityfrom the arc-standard shift-reduce parser improvesthe efficiency and accuracy of our approach.2 Arc-Standard Shift-Reduce ParsingWe use a beam search shift-reduce parser with dy-namic programming as our baseline system.
Fig-ure 1 shows it as a deductive system (Shieber et al1995).
A state is defined as the following:?
: (i, j, sd|sd?1| .
.
.
|s1|s0) : piwhere ?
is the step size, [i, j] is the span of the top-most stack element s0, and sd|sd?1| .
.
.
|s1 showsa stack with d elements at the top, where d is thewindow size used for defining features.
The ax-iom is initialized with an input sentence of length n,x = w0 .
.
.wn where w0 is a special root symbol $0.The system takes 2n steps for a complete analysis.pi is a set of pointers to the predictor states, each ofwhich is the state just before shifting the root words0.h.t ?
s0.lc.t ?
s0.lc2.t s0.h.t ?
s0.rc.t ?
s0.rc2.ts1.h.t ?
s1.lc.t ?
s1.lc2.t s1.h.t ?
s1.rc.t ?
s1.rc2.ts0.h.t ?
s0.lc.t ?
s0.lc2.t ?
q0.ts0.h.t ?
s0.rc.t ?
s0.rc2.t ?
q0.ts0.h.t ?
s1.h.t ?
q0.t ?
q1.ts0.h.w ?
s1.h.t ?
q0.t ?
q1.tTable 1: Additional feature templates for shift-reduceparsers: q denotes input queue.
h, lc and rc are head, left-most child and rightmost child of a stack element s. lc2and rc2 denote the second leftmost and rightmost chil-dren.
t and w are a part-of-speech (POS) tag and a word.of s0 into stack1.
Dynamic programming mergesequivalent states in the same step if they have thesame feature values.
We add the feature templatesshown in Table 1 to Huang and Sagae (2010)?s fea-ture templates.Dynamic programming not only makes the shift-reduce parser with beam search more efficient butalso produces a packed forest that encodes an expo-nential number of dependency trees.
A packed de-pendency forest can be represented by a weighted(directed) hypergraph.
A weighted hypergraph is apair H = ?V,E?, where V is the set of vertices andE is the set of hyperedges.
Each hyperedge e ?
Eis a tuple e = ?T (e), h(e), fe?, where h(e) ?
V is1Huang and Sagae (2010)?s dynamic programming is basedon a notion of a push computation (Kuhlmann et al 2011).
Thedetails are out of scope here and readers may refer to the paper.140X($)saw0, 7IXher(saw)1, 7IXher(saw)1, 4IX(saw)1, 3X(I)1, 2IX(saw)2, 3sawX(her)3, 4herIXher,with(saw)1, 7Xwith(her)3, 7Xman(with)4, 7X(with)4, 5withaX(man)5, 7X(a)5, 6aX(man)6, 7manFigure 2: An example of packed dependency (derivation) forest: each vertex has information about the topmost stackelement of the corresponding state to it.its head vertex, T (e) ?
V + is an ordered list of tailvertices, and fe is a weight for e.Figure 2 shows an example of a packed forest.Each binary hyperedge corresponds to a reduce ac-tion, and each leaf vertex corresponds to a shift ac-tion.
Each vertex also corresponds to a state, andparse histories on the states can be encoded into thevertices.
In the example, information about the top-most stack element is attached to the correspondingvertex marked with a non-terminal symbol X.Weights are omitted in the example.
In practice,we attach each reduction weight to the correspond-ing hyperedge, and add the shift weight to the reduc-tion weight when a shifted word is reduced.3 Arc-Standard Shift-Reduce Parsingwithout Spurious AmbiguityOne solution to remove spurious ambiguity in thearc-standard transition system is to give priority tothe construction of left arcs over that of right arcs(or vice versa) like Eisner (1997).
For example, anEarley dependency parser (Hayashi et al 2012) at-taches all left dependents to a word before right de-pendents.
The parser uses a scan action to stop theconstruction of left arcs.We apply this idea to the arc-standard transitionsystem and show the resulting transition system inFigure 3.
We introduce the ?
symbol to indicate thatthe root node of the topmost element on the stackhas not been scanned yet.
The shift and reduce?
ac-tions can be used only when the root of the topmostelement on the stack has already been scanned, andall left arcs are always attached to the head beforethe head is scanned.The arc-standard shift-reduce parser without spu-rious ambiguity takes 3n steps to finish parsing, andthe additional n scan actions add surplus verticesand (unary) hyperedges to a packed forest.
How-ever, it is easy to remove them from the packed for-est because the consequent state of a scan action hasa unique antecedent state and all the hyperedges go-ing out from a vertex corresponding to the conse-quent state can be attached to the vertex correspond-ing to the antecedent state.
The scan weight of theremoved unary hyperedge is added to each weight ofthe hyperedges attached to the antecedent.4 Experiments (Spurious Ambiguity vs.Non-Spurious Ambiguity)We conducted experiments on the English PennTreebank (PTB) data to compare spurious and non-spurious shift-reduce parsers.
We split the WSJpart of PTB into sections 02-21 for training, sec-tion 22 for development, and section 23 for test.
Weused the head rules (Yamada and Matsumoto, 2003)to convert phrase structure to dependency structure.141axiom(c0) : 0 : (0, 1,w0) : ?goal(c3n) : 3n : (0, n, s0) : ?shift :state p?
??
??
: ( , j, sd|sd?1| .
.
.
|s1|s0) :?
+ 1 : (j, j + 1, sd?1|sd?2| .
.
.
|s0|w?j ) : (p)j < nscan : ?
: (i, j, sd|sd?1| .
.
.
|s1|s?0) : pi?
+ 1 : (i, j, sd|sd?1| .
.
.
|s1|s0) : pireduce?
:state p?
??
?
: (i, j, s?d|s?d?1| .
.
.
|s?0|s?0) : pi?state q?
??
??
: (j, k, sd|sd?1| .
.
.
|s1|s?0) : pi?
+ 1 : (i, k, s?d|s?d?1| .
.
.
|s?1|s?0?s?0) : pi?s?0.h.w ?= w0 ?
p ?
pireduce?
:state p?
??
?
: (i, j, s?d|s?d?1| .
.
.
|s?1|s?0) : pi?state q?
??
??
: (j, k, sd|sd?1| .
.
.
|s1|s0) : pi?
+ 1 : (i, k, s?d|s?d?1| .
.
.
|s?1|s?0?s0) : pi?p ?
piFigure 3: The dynamic programming arc-standard transition-based deductive system without spurious ambiguity: thesymbol represents that the root node of the topmost element on the stack has not been scanned yet.8 16 32 64 128spurious UAS (w/o punc.)
92.5 (93.5) 92.7 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6)dev.
sec.
(per sent.)
0.01 0.017 0.03 0.06 0.13non-sp.
UAS (w/o punc.)
92.5 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6) 92.6 (93.6)sec.
(per sent.)
0.01 0.018 0.03 0.07 0.13spurious UAS (w/o punc.)
92.7 (93.3) 92.7 (93.3) 92.7 (93.3) 92.8 (93.3) 92.8 (93.3)test sec.
(per sent.)
0.01 0.017 0.03 0.06 0.13non-sp.
UAS (w/o punc.)
92.8 (93.4) 92.9 (93.5) 92.9 (93.5) 92.9 (93.5) 92.9 (93.5)sec.
(per sent.)
0.01 0.018 0.03 0.06 0.13Table 2: Unlabeled accuracy scores (UAS) and parsing times (+forest dumping times, second per sentence) for parsingdevelopment (WSJ22) and test (WSJ23) data with spurious shift-reduce and proposed shift-reduce parser (non-sp.
)using several beam sizes.We used an early update version of the averaged per-ceptron algorithm (Collins and Roark, 2004; Huanget al 2012) to train two shift-reduce dependencyparsers with beam size of 12.Table 2 shows experimental results of parsing thedevelopment and test datasets with each of the spu-rious and non-spurious shift-reduce parsers usingseveral beam sizes.
Parsing accuracies were eval-uated by unlabeled accuracy scores (UAS) with andwithout punctuations.
The parsing times were mea-sured on an Intel Core i7 2.8GHz.
The average cputime (per sentence) includes that of dumping packedforests.
This result indicates that the non-spuriousparser achieves better accuracies than the spuriousbeam size 8 32 128% of distinct trees (10) 93.5 94.8 95.0% of distinct trees (100) 81.8 84.9 87.2% of distinct trees (1000) 70.6 73.1 77.6% of distinct trees (10000) 62.1 64.3 65.6Table 3: The percentages of distinct dependency trees in10, 100, 1000 and 10000 best trees extracted from spuri-ous forests with several beam sizes.parser without loss of efficiency.Figure 4 shows oracle unlabeled accuracies ofspurious k-best lists, non-spurious k-best lists, spu-rious forests, and non-spurious forests.
We extractan oracle tree from each packed forest using the for-1420.960.9650.970.9750.980.9850.990.9950  500  1000  1500  2000  2500  3000oracleunlabeledaccuracyave.
# of hyperedgesbeam 16beam 64beam 64"kbest""forest""non-sp-kbest""non-sp-forest"Figure 4: Each plot shows oracle unlabeled accuracies ofspurious k-best lists, spurious forests, and non-spuriousforests.
The oracle accuracies are evaluated using UASwith punctuations.est oracle algorithm (Huang, 2008).
Both forestsproduce much better results than the k-best lists, andnon-spurious forests have almost the same oracle ac-curacies as spurious forests.However, as shown in Table 3, spurious forestsencode a number of non-unique dependency treeswhile all dependency trees in non-spurious forestsare distinct from each other.5 Forest Reranking5.1 Discriminative Reranking ModelWe define a reranking model based on the graph-based features as the following:y?
= argmaxy?H?
?
fg(x, y) (1)where ?
is a weight vector, fg is a feature vector (gindicates ?graph-based?
), x is the input sentence, yis a dependency tree and H is a dependency for-est.
This model assumes a hyperedge factorizationwhich induces a decomposition of the feature vectoras the following:?
?
fg(x, y) =?e?y?
?
fg,e(e).
(2)The search problem can be solved by simply usingthe (generalized) Viterbi algorithm (Klein and Man-ning, 2001).
When using non-local features, the hy-peredge factorization is redefined to the following:?
?
fg(x, y) =?e?y?
?
fg,e(e) + ?
?
fg,e,N (e) (3)where fg,e,N is a non-local feature vector.
Thoughthe cube-pruning algorithm (Huang and Chiang,2007) is an approximate decoding technique basedon a k-best Viterbi algorithm, it can calculate thenon-local scores efficiently.The baseline score can be taken into the rerankeras a linear interpolation:y?
= argmaxy?H?
?
sctr(x, y) + ?
?
fg(x, y) (4)where sctr is the score from the baseline parser (tr in-dicates ?transition-based?
), and ?
is a scaling factor.5.2 Features for Discriminative Model5.2.1 Local FeaturesWhile the inference algorithm is a simple Viterbialgorithm, the discriminative model can use all tri-sibling features and some grand-sibling features2(Koo and Collins, 2010) as a local scoring factor inaddition to the first- and sibling second-order graph-based features.
This is because the first stage shift-reduce parser uses features described in Section 2and this information can be encoded into vertices ofa hypergraph.The reranking model also uses guide features ex-tracted from the 1-best tree predicted by the firststage shift-reduce parser.
We define the guide fea-tures as first-order relations like those used in Nivreand McDonald (2008) though our parser handlesonly unlabeled and projective dependency struc-tures.
We summarize the features for discriminativereranking model as the following:?
First- and second-order features: these featuresare the same as those used in MST parser3.?
Grand-child features: we define tri-gram POSfeatures with POS tags of grand parent, parent,and rightmost or leftmost child.?
Tri-sibling features: we define tri-gram featureswith three POS-tags of child, sibling, and tri-sibling.
We also define tri-gram features withone word and two POS tags of the above.2The grand-child and grand-sibling features can be usedonly when interacting with the leftmost or rightmost child andsibling.
In case of local reranking, we did not use grand-siblingfeatures because in our experiments, they were not effective.3http://www.seas.upenn.edu/?strctlrn/MSTParser/MSTParser.html143?
Guide feaures: we define a feature indicatingwhether an arc from a child to its parent ispresent in the 1-best tree predicted by the first-stage shift-reduce parser, conjoined with thePOS tags of the parent and child.?
PP-Attachment features: when a parent word isa preposition, we define tri-gram features withthe parent word and POS tags of grand parentand the rightmost child.5.2.2 Non-local FeaturesTo define richer features as a non-local factor, weextend a local reranking algorithm by augmentingeach k-best item with all child vertices of its headvertex4.
Information about all children enables thereranker to calculate the following features when re-ducing the head vertex:?
Grand-child features: we define tri-gram fea-tures with one word and two POS tags of grandparent, parent, and child.?
Grand-sibling features: we define 4-gram POSfeatures with POS tags of grand parent, parent,child and sibling.
We also define coordinationfeatures with POS tags of grand parent, parentand child when the sibling word is a coordinateconjunction.?
Valency features: we define a feature indicat-ing the number of children of a head, conjoinedwith each of its word and POS tag.When using non-local features, we removed the lo-cal grand-child features from the model.5.3 Oracle for Discriminative TrainingA discriminative reranking model is trained onpacked forests by using their oracle trees as the cor-rect parse.
More accurate oracles are essential totrain a discriminative reranking model well.While large size forests have much more accurateoracles than small size forests, large forests have toomany hyperedges to train a discriminative model onthem, as shown in Figure 4.
The usual forest rerank-ing algorithms (Huang, 2008; Hayashi et al 2011)4If each item is augmented with richer information, evenfeatures based on the entire subtree can be defined.remove low quality hyperedges from large forests byusing inside-outside forest pruning.However, producing large forests and pruningthem is computationally very expensive.
Instead, wepropose a simpler method to produce small forestswhich have more accurate oracles by forcing thebeam search shift-reduce parser to keep the correctstate in the beam buffer.
As a result, the correct treewill always be encoded in a packed forest.6 Experiments (Discriminative Reranking)6.1 Experimental SettingFollowing (Huang, 2008), the training set (WSJ02-21) is split into 20 folds, and each fold is parsed byeach of the spurious and non-spurious shift-reduceparsers using beam size 12 with the model trainedon sentences from the remaining 19 folds, dumpingthe outputs as packed forests.The reranker is modeled by either equation (1) or(4).
By our preliminary experiments using develop-ment data (WSJ22), we modeled the reranker withequation (1) when training, and with equation (4)when testing5 (i.e., the scores of the first-stage parserare not considered during training of the rerankingmodel).
This prevents the discriminative rerankingfeatures from under-training (Sutton et al 2006;Hollingshead and Roark, 2008).A discriminative reranking model is trained onthe packed forests by using the averaged percep-tron algorithm with 5 iterations.
When training non-local reranking models, we set k-best size of cube-pruning to 5.For dumping packed forests for test data, spuriousand non-spurious shift-reduce parsers are trained bythe averaged perceptron algorithm.
In all experi-ments on English data, we fixed beam size to 12 fortraining both parsers.6.2 Test with Gold POS tagsWe show the comparison of dumped spurious andnon-spurious packed forests for training data in Ta-ble 4.
Both oracle accuracies are 100.0 due to the5The scaling factor ?
was tuned by minimum error ratetraining (MERT) algorithm (Och, 2003) using developmentdata.
The MERT algorithm is suited to tune low-dimensionalparameters.
The ?
was set to about 1.2 in case of local rerank-ing, and to about 1.5 in case of non-local reranking.144system w/ rerank.
sec.
(per sent.)
UAS (w/o punc.
)sr (12) ?
0.011 92.8 (93.3)(8) w/ local 0.009 + 0.0056 93.03 (93.69)(12) w/ local 0.011 + 0.0079 93.03 (93.68)(32) w/ local 0.03 + 0.019 93.07 (93.67)(64) w/ local 0.06 + 0.039 93.0 (93.61)(12, k=3) w/ non-local 0.011 + 0.0085 93.17 (93.78)(64, k=3) w/ non-local 0.06 + 0.046 93.19 (93.78)non-sp sr (12) ?
0.012 92.9 (93.5)(8) w/ local 0.01 + 0.005 93.05 (93.73)(12) w/ local 0.012 + 0.0074 93.21 (93.87)(32) w/ local 0.031 + 0.0184 93.22 (93.84)(64) w/ local 0.061 + 0.0375 93.23 (93.83)(12, k=3) w/ non-local 0.012 + 0.0083 93.28 (93.9)(64, k=3) w/ non-local 0.061 + 0.045 93.39 (93.96)Table 7: Unlabeled accuracy scores and cpu times per sentence (parsing+reranking) when parsing and reranking testdata (WSJ23) with gold POS tags: shift-reduce parser is denoted as sr (beam size, k: k-best size of cube pruning).sp.
non-sp.ave.
# of hyperedges 141.9 133.3ave.
# of vertices 199.1 187.6ave.
% of distinct trees 82.5 100.01-best UAS w/ punc.
92.5 92.6oracle UAS w/ punc.
100.0 100.0Table 4: Comparison of spurious (sp.)
and non-spurious(non-sp.)
forests: each forest is produced by baselineand proposed shift-reduce parsers using beam size 12 for39832 training sentences with gold POS tags.method described in Section 5.3.
The 1-best accu-racy of the non-spurious forests is higher than thatof the spurious forests.
As we expected, the resultsshow that there are many non-unique dependencytrees in the spurious forests.
The spurious forestsalso get larger than the non-spurious forests.Table 5 shows how long the training on spuriousand non-spurious forests took on an Opteron 83562.3GHz.
It is clear from the results that training onnon-spurious forests is more efficient than that onspurious forests.Table 6 shows the statistics of spurious and non-spurious packed forests dumped by shift-reduceparsers using beam size 12 for test data.
The trendsare similar to those for training data shown in Ta-ble 4.
We show the results of the forest rerank-ing algorithms for test data in Table 7.
Each spu-rious and non-spurious shift-reduce parser producesreranker pre-comp.
trainingspurious 16.4 min.
34.9 min.non-spurious 15.5 min.
32.9 min.spurious non-local 17.3 min.
64.3 min.non-spurious non-local 16.2 min.
60.3 min.Table 5: Training times on both spurious and non-spurious packed forests (beam 12): pre-comp.
denotescpu time for feature extraction and attaching features toall hyperedges.
The non-local models were trained set-ting k-best size of cube-pruning to 5, and non-local fea-tures were calculated on-the-fly while training.packed forests using four beam sizes 8, 12, 32, and64.
The reranking on non-spurious forests achievesbetter accuracies and is slightly faster than that onspurious forests consistently.6.3 Test with Automatic POS tagsTo compare the proposed reranking system withother systems, we evaluate its parsing accuracy ontest data with automatic POS tags.
We used the Stan-ford POS tagger6 with a model trained on sections02-21 to tag development and test data, and used10-way jackknifing to tag training data.
The taggingaccuracies on training, development, and test datawere 97.1, 97.2, and 97.5.Table 8 lists the accuracy and parsing speed of6http://nlp.stanford.edu/software/tagger.shtml145sp.
non-sp.ave.
# of hyperedges 127.0 119.1ave.
# of vertices 178.6 168.5ave.
% of distinct trees 82.4 100.01-best UAS w/ punc.
92.8 92.9oracle UAS w/ punc.
97.0 97.0Table 6: Comparison of spurious (sp.)
and non-spurious(non-sp.)
forests: each forest is produced by baseline andproposed shift-reduce parsers using beam size 12 for testdata (WSJ23) with gold POS tags.system tok./sec.
UAS w/o punc.sr (12) 2130 92.5w/ local (12) 1290 92.8non-sp sr (12) 1950 92.6w/ local (12) 1300 92.98w/ non-local (12, k=1) 1280 93.1w/ non-local (12, k=3) 1180 93.12w/ non-local (12, k=12) 1060 93.12Huang10 sr (8) 782 92.1Rush12 sr (16) 4780 92.5Rush12 sr (64) 1280 92.7Koo10 ?
93.04Rush12 third 20 93.3Rush12 vine 4400 93.1H-Zhang12 third 50 92.81H-Zhang12 (label) 220 93.06Y-Zhang11 (64, label) 680 92.9Bohnet12 (80, label) 120 93.39Table 8: Comparison with other systems: the results wereevaluated on testing data (WSJ23) with automatic POStags: label means labeled dependency parsing and the cputimes of our systems were taken on Intel Core i7 2.8GHz.our proposed systems together with results from re-lated work.
The parsing times are reported in to-kens/second for comparison.
Note that, however,the difference of the parsing time does not representthe efficiency of the algorithm directly because eachsystem was implemented in different programminglanguage and the times were measured on differentenvironments.The accuracy of local reranking on non-spuriousforests is the best among unlabeled shift-reduceparsers, but slightly behind the third-order graph-based systems (Koo and Collins, 2010; Zhang andMcDonald, 2012; Rush and Petrov, 2012).
It islikely that the difference comes from the fact thatour local reranking model can define only some ofthe grand-child related features.w/ guide.
w/o guide.PPPPPPPfeatureUAS 92.98 92.86Linear (first) 89,330 89,215CorePos (first) 1,047,948 1,053,796TwoObs (first) 1,303,911 1,325,990Sibling (second) 290,291 292,849Trip (second) 19,333 19,267Grand-child 16,975 16,951Guide 4,934 ?Tri-sibling 277,770 279,720PP-Attachment 32,695 32,993total 3,083,187 3,110,781Table 9: Accuracy and the number of non-zero weightedfeatures of the local reranking models with and withoutguide features: the first- and second-order features arenamed for MSTParser.To define all grand-child features and other non-local features, we also experimented with the non-local reranking algorithm on non-spurious packedforests.
It achieved almost the same accuracy as theprevious third-order graph-based algorithms.
More-over, the computational overhead is very small whensetting k-best size of cube-pruning small.6.4 AnalysisOne advantage of our reranking approach is thatguide features can be defined as in stacked parsing.To analyze the effect of the guide features on parsingaccuracy, we remove the guide features from base-line reranking models with and without non-localfeatures used in Section 6.3.
The results are shownin Table 9 and 10.
The parsing accuracies of thebaseline reranking models are better than those ofthe models without guide features though the num-ber of guide features is not large.
Additionally, eachmodel with guide features is smaller than that with-out guide features.
This indicates that stacking has agood effect on training the models.To further investigate the effects of guide features,we tried to define unlabeled versions of the second-order guide features used in (Martins et al 2008;McClosky et al 2012).
However, these features didnot produce good results, and investigation to findthe cause is an important future work.We also examined parsing errors in more de-tail.
Table 11 shows root and sentence completerates of three systems, the non-spurious shift-reduce146w/ guide.
w/o guide.PPPPPPPfeatureUAS 93.12 93.04Linear (first) 88,634 88,934CorePos (first) 1,035,897 1,045,242TwoObs (first) 1,274,834 1,301,103Sibling (second) 284,341 288,796Trip (second) 19,201 19,219Guide 4,916 ?Tri-sibling 272,418 276,025PP-Attachment 32,085 32,577Grand-child 718,064 730,663Grand-sibling 72,865 73,103Valency 49,262 49,677total 3,852,517 3,905,339Table 10: Accuracy and the number of non-zero weightedfeatures of the non-local reranking models with and with-out guide features: the first- and second-order features arenamed for MSTParser.system UAS root comp.non-sp sr 92.6 95.8 45.6local 92.98 96.1 48.1non-local 93.12 96.3 48.2Table 11: Unlabeled accuracy, root correct rate, and sen-tence complete rate: these scores are measured on testdata (WSJ23) without punctuations.parser, local reranking, and non-local reranking.The two reranking systems outperform the shift-reduce parser significantly, and the non-local rerank-ing system is the best among them.Part of the difference between the shift-reduceparser and reranking systems comes from the correc-tion of coordination errors.
Table 12 shows the headcorrect rate, recall, precision, F-measure and com-plete rate of coordination structures, by which wemean the head and siblings of a token whose POStag is CC.
The head correct rate denotes how cor-rect a head of the CC token is.
The recall, precision,F-measure are measured by counting arcs betweenthe head and siblings.
When the head of the CC to-ken is incorrect, all arcs of the coordination structureare counted as incorrect.
Therefore, the recall, preci-sion, F-measure are greatly affected by the head cor-rect rate, and though the complete rate of non-localreranking is higher than that of local reranking, theresults of the first three measures are lower.non-sp sr local non-localhead correct 87.73 88.97 88.83recall 82.38 84.35 84.11precision 83.07 84.57 83.98F-measure 82.72 84.46 84.05comp.
62.92 64.52 65.18Table 12: Head correct rate, recall, precision, F-measure,and complete rate of coordination strutures: these aremeasured on test data (WSJ23).system recall precision F-measurenon-sp sr 91.58 92.5 92.04local 91.96 92.95 92.45non-local 92.44 93.07 92.75Table 13: Recall, precision, and F-measure of grand-childstructures whose grand parent is an artificial root symbol:these are measured on test data (WSJ23).We assume that the improvements of non-localreranking over the others can be mainly attributedto the better prediction of the structures around thesentence root because most of the non-local featuresare useful for predicting these structures.
Table 13shows the recall, precision and F-measure of grand-child structures whose grand parent is a sentenceroot symbol $.
The results support the above as-sumption.
The root correct rate directly influenceson prediction of the overall structures of a sentence,and it is likely that the reduction of root predictionerrors brings better results.6.5 Experiments on ChineseWe also experiment on the Penn Chinese Treebank(CTB5).
Following Huang and Sagae (2010), wesplit it into training (secs 001-815 and 1001-1136),development (secs 886-931 and 1148-1151), andtest (secs 816-885 and 1137-1147) sets, and use thehead rules of Zhang and Clark (2008).
The trainingset is split into 10 folds to dump packed forests fortraining of reranking models.We set the beam size of both spurious and non-spurious parsers to 12, and the number of perceptrontraining iterations to 25 for the parsers and to 8 forboth rerankers.
Table 14 shows the results for thetest sets.
As we expected, reranking on non-spuriousforests outperforms that on spurious forests.147system UAS root comp.sr (12) 85.3 78.6 33.4w/ non-local (12, k=3) 85.8 79.4 34.2non-sp sr (12) 85.3 78.4 33.7w/ non-local (12, k=3) 85.9 79.6 34.3Table 14: Results on Chinese Treebank data (CTB5):evaluations are performed without punctuations.7 Related Works7.1 How to Handle Spurious AmbiguityThe graph-based approach employs Eisner and Satta(1999)?s algorithm where spurious ambiguities areeliminated by the notion of split head automatongrammars (Alshawi, 1996).However, the arc-standard transition-based parserhas the spurious ambiguity problem.
Cohen et al(2012) proposed a method to eliminate the spuriousambiguity of shift-reduce transition systems.
Theirmethod covers existing systems such as the arc-standard and non-projective transition-based parsers(Attardi, 2006).
Our system copes only with the pro-jective case, but is simpler than theirs and we showits efficacy empirically through some experiments.The arc-eager shift-reduce parser also has a spuri-ous ambiguity problem.
Goldberg and Nivre (2012)addressed this problem by not only training with acanonical transition sequence but also with alternateoptimal transitions that are calculated dynamicallyfor a current state.7.2 Methods to Improve Dependency ParsingHigher-order features like third-order dependencyrelations are essential to improve dependency pars-ing accuracy (Koo and Collins, 2010; Rush andPetrov, 2012; Zhang and McDonald, 2012).
Areranking approach is one effective solution to intro-duce rich features to a parser model in the context ofconstituency parsing (Charniak and Johnson, 2005;Huang, 2008).Hall (2007) applied a k-best maximum spanningtree algorithm to non-projective dependency analy-sis, and showed that k-best discriminative rerank-ing improves parsing accuracy in several languages.Sangati et al(2009) proposed a k-best dependencyreranking algorithm using a third-order generativemodel, and Hayashi et al(2011) extended it to aforest algorithm.
Though forest reranking requiressome approximations such as cube-pruning to inte-grate non-local features, it can explore larger searchspace than k-best reranking.The stacking approach (Nivre and McDonald,2008; Martins et al 2008) uses the output of onedependency parser to provide guide features for an-other.
Stacking improves the parsing accuracy ofsecond stage parsers on various language datasets.The joint graph-based and transition-based approach(Zhang and Clark, 2008; Bohnet and Kuhn, 2012)uses an arc-eager shift-reduce parser with a jointgraph-based and transition-based model.
Thoughit improves parsing accuracy significantly, the largebeam size of the shift-reduce parser harms its effi-ciency.
Sagae and Lavie (2006) showed that com-bining the outputs of graph-based and transition-based parsers can improve parsing accuracies.8 ConclusionWe have presented a discriminative forest rerankingalgorithm for dependency parsing.
This can be seenas a kind of joint transition-based and graph-basedapproach because the first-stage parser is a shift-reduce parser and the second-stage reranker uses agraph-based model.Additionally, we have proposed a dynamic pro-gramming arc-standard transition-based dependencyparser without spurious ambiguity, along with aheuristic that encodes the correct tree in the outputpacked forest for reranker training, and shown thatforest reranking works well on packed forests pro-duced by the proposed parser.To improve the accuracy of reranking, we will en-gage in feature engineering.
We need to further in-vestigate effective higher-order guide and non-localfeatures.
It also seems promising to extend the un-labeled reranker to a labeled one because labeled in-formation often improves unlabeled accuracy.In this paper, we adopt a reranking approach, buta rescoring approach is more promising to improveefficiency because it does not have the overhead ofdumping packed forests.AcknowledgmentsWe would like to thank the anonymous reviewersfor their valuable comments.
This work was partly148supported by Grant-in-Aid for Japan Society for thePromotion of Science (JSPS) Research Fellowshipfor Young Scientists.ReferencesH.
Alshawi.
1996.
Head automata for speech translation.In Proc.
the ICSLP.G.
Attardi.
2006.
Experiments with a multilanguagenon-projective dependency parser.
In Proc.
of the 10thConference on Natural Language Learning, pages166?170.B.
Bohnet and J. Kuhn.
2012.
The best of bothworlds ?a graph-based completion model for transition-basedparsers.
In Proceedings of the 13th Conference ofthe European Chapter of the Association for Compu-tational Linguistics, pages 77?87.E.
Charniak and M. Johnson.
2005.
Coarse-to-fine n-best parsing and maxent discriminative reranking.
InProceedings of the 43rd Annual Meeting of the Associ-ation for Computational Linguistics, pages 173?180.S.
B. Cohen, C.
Go?mez-Rodr?
?guez, and G. Satta.
2012.Elimination of spurious ambiguity in transition-baseddependency parsing.
Technical report.M.
Collins and B. Roark.
2004.
Incremental parsing withthe perceptron algorithm.
In Proceedings of the 42ndAnnual Meeting of the Association for ComputationalLinguistics (ACL?04).J.
M. Eisner and G. Satta.
1999.
Efficient parsing forbilexical context-free grammars and head automatongrammars.
In Proceedings of the 37th Annual Meet-ing of the Association for Computational Linguistics,pages 457?464.J.
Eisner.
1997.
Bilexical grammars and a cubic-timeprobabilistic parser.
In Proceedings of the 5th Inter-national Workshop on Parsing Technologies (IWPT),pages 54?65.Y.
Goldberg and J. Nivre.
2012.
A dynamic oracle forarc-eager dependency parsing.
In Proceedings of the24rd International Conference on Computational Lin-guistics (Coling 2012).K.
Hall.
2007.
K-best spanning tree parsing.
In Proceed-ings of the 45th Annual Meeting of the Association ofComputational Linguistics, pages 392?399.K.
Hayashi, T. Watanabe, M. Asahara, and Y. Mat-sumoto.
2011.
The third-order variational rerankingon packed-shared dependency forests.
In Proceedingsof the 2011 Conference on Empirical Methods in Nat-ural Language Processing, pages 1479?1488.K.
Hayashi, T. Watanabe, M. Asahara, and Y. Mat-sumoto.
2012.
Head-driven transition-based parsingwith top-down prediction.
In Proceedings of the 50thAnnual Meeting of the Association for ComputationalLinguistics, pages 657?665.K.
Hollingshead and B. Roark.
2008.
Reranking withbaseline system scores and ranks as features.
InCSLU-08-001, Center for Spoken Language Under-standing, Oregon Health and Science University.L.
Huang and D. Chiang.
2007.
Forest rescoring: Fasterdecoding with integrated language models.
In Pro-ceedings of the 45th Annual Meeting of the Associationof Computational Linguistics, pages 144?151.L.
Huang and K. Sagae.
2010.
Dynamic programmingfor linear-time incremental parsing.
In Proceedings ofthe 48th Annual Meeting of the Association for Com-putational Linguistics (ACL?10), pages 1077?1086.L.
Huang, S. Fayong, and Y. Guo.
2012.
Structured per-ceptron with inexact search.
In Proceedings of the2012 Conference of the North American Chapter ofthe Association for Computational Linguistics: Hu-man Language Technologies, pages 142?151.L.
Huang.
2008.
Forest reranking: Discriminative pars-ing with non-local features.
In Proceedings of the 46thAnnual Meeting of the Association for ComputationalLinguistics, pages 586?594.D.
Klein and C. D. Manning.
2001.
Parsing and hyper-graphs.
In Proceedings of the 7th International Work-shop on Parsing Technologies.T.
Koo and M. Collins.
2010.
Efficient third-order de-pendency parsers.
In Proceedings of the 48th AnnualMeeting of the Association for Computational Linguis-tics (ACL?10), pages 1?11.M.
Kuhlmann, C.
Go?mez-Rodr?
?guez, and G. Satta.
2011.Dynamic programming algorithms for transition-based dependency parsers.
In Proceedings of the 49thAnnual Meeting of the Association for ComputationalLinguistics, pages 673?682.Andre?
F. T. Martins, D. Das, N. A. Smith, and E. P. Xing.2008.
Stacking dependency parsers.
In Proceedings ofthe 2008 Conference on Empirical Methods in NaturalLanguage Processing, pages 157?166.D.McClosky, W. Che, M. Recasens, M.Wang, R. Socher,and C. D. Manning.
2012.
Stanfords system for pars-ing the english web.
In Proceedings of First Work-shop on Syntactic Analysis of Non-Canonical Lan-guage (SANCL) at NAACL 2012.R.
McDonald, K. Crammer, and F. Pereira.
2005.
On-line large-margin training of dependency parsers.
InProceedings of the 43rd Annual Meeting of the Asso-ciation for Computational Linguistics (ACL?05), pages91?98.J.
Nivre and R. McDonald.
2008.
Integrating graph-based and transition-based dependency parsers.
InProceedings of ACL-08: HLT, pages 950?958.J.
Nivre.
2008.
Algorithms for deterministic incremen-tal dependency parsing.
Computational Linguistics,34:513?553.149F.
J. Och.
2003.
Minimum error rate training in statisti-cal machine translation.
In Proc.
the 41st ACL, pages160?167.A.
Rush and S. Petrov.
2012.
Vine pruning for effi-cient multi-pass dependency parsing.
In Proceedingsof the 2012 Conference of the North American Chap-ter of the Association for Computational Linguistics:Human Language Technologies, pages 498?507.K.
Sagae and A. Lavie.
2006.
Parser combination byreparsing.
In Proc.
HLT, pages 129?132.F.
Sangati, W. Zuidema, and R. Bod.
2009.
A generativere-ranking model for dependency parsing.
In Proceed-ings of the 11th International Conference on ParsingTechnologies (IWPT?09), pages 238?241.S.
M. Shieber, Y. Schabes, and F. C. N. Pereira.
1995.Principles and implementation of deductive parsing.
J.Log.
Program., 24(1&2):3?36.C.
Sutton, M. Sindelar, and A. McCallum.
2006.
Reduc-ing weight undertraining in structured discriminativelearning.
In Conference on Human Language Tech-nology and North American Association for Computa-tional Linguistics (HLT-NAACL).H.
Yamada and Y. Matsumoto.
2003.
Statistical depen-dency analysis with support vector machines.
In Pro-ceedings of the 10th International Conference on Pars-ing Technologies (IWPT?03), pages 195?206.Y.
Zhang and S. Clark.
2008.
A tale of two parsers: In-vestigating and combining graph-based and transition-based dependency parsing using beam-search.
In Pro-ceedings of the 2008 Conference on Empirical Meth-ods in Natural Language Processing, pages 562?571.H.
Zhang and R. McDonald.
2012.
Generalized higher-order dependency parsing with cube pruning.
In Pro-ceedings of the 2012 Joint Conference on EmpiricalMethods in Natural Language Processing and Compu-tational Natural Language Learning, pages 320?331.Y.
Zhang and J. Nivre.
2011.
Transition-based depen-dency parsing with rich non-local features.
In Pro-ceedings of the 49th Annual Meeting of the Associa-tion for Computational Linguistics: Human LanguageTechnologies, pages 188?193.150
