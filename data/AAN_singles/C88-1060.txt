An Algorithm for Functional UncertaintyRonald M. KAPLAN and John T. MAXWEI,L I\[IXerox Pale Alto Research Center3333 Coyote Hill RoadPalo Alto, Californid 94304 USAAbstract: The formal device of flmetional uncertainty has beenintroduced into linguistic theory as a means of characterizinglong-distance dependencies alternative to conventionalphrase-structure based approaches.
In this palter we briefly outlinethe uneertMnty concept, and then present an algorithm fordetermining the satisfiability of acyclic gramu~atical descriptionscontaining uncertainty expressions and for synthesizing thegrammatically relevant solutions to those descriptions1.
Long-dis~ance l)ependeneies and Functional UncertaintyIn most linguistic theories hmg-distance dependencies such as arefound in topiealization and relative clause constructions arecharacterized in tcrnrs of categoric,,; and configurations ofphrase-structure nodes.
Kaplan and Zaenen (in press) have comparedthis kind of an analysis with one based on the fimetional organizationof sentence:~, and suggest that tile relevant generalizations are insteadbest stated in functional or predicate-argument terms.
\]'hey definedand investigated a new tbrmal device, called "functional uncertainty"that permit~ a functional statement of constraints on unboundeddependeneie:~.
In this paper, after reviewing their formal specificationof flmctional uncertainty, we present an algorithm for determining thesatisfiability of grammatical descriptions that incorporate uncertaintyspecifications and fro" synthesizing the smallest solutions to suchdescriptions./Kaplan and Zacnen (in press)/ started from an idea that/Kaplan and Bresnan 1982/briefly considered but quickly rejected onmathematical nd (/Kaplan and Zaenerd suggest, mistaken) linguisticgrounds.
They observed that each of the possible underlying positionsof an initial phrase could be specified in a simple equation locallyassociated with that phrase.
In tile topiealized sentence Mary John.telephoned yesterday, the equation (in LFG notatiml) (1' TOPIC):( 1' (mJ) specifies that Mary is to be interpreted as the object of thepredicate telephoned.
In Mary John claimed that Bill telephonedyesterday, the appropriate quation is ( 1' TOHC)=( 1' COMP {mJ),indicating that Mary is still the object of telephoned, which because ofsubsequent words in the string is itself the eonrplement (indicated bythe function name COMP) of the top-level predicate claim.
The sentencecan obviously be extended by introducing additional complementpredicates (Mary John claimed that Bill said that .... that Henrytelephoned yesterday), for each of which stone equation of the generalfm'm ( 1' TOHC)=( 1' COMP ('OMP .... On,I) would be appropriate.
Theproblem, of course, is that this is an infinite family of equations, andhence impossible to enumerate in a finite disjunction appearing on aparticular ule of grammar.
For this technical reason, Kaplan andBresnan abandoned the possibility of specifying unboundeduncertainty directly in fimctional terms.Kaplan and Zaencn reconsidered the general strategy thatKaplan and Bresnan began to explore.
Instead of formulatinguncertainty hy an explicit disjunctive numeration, however, theyprovided a formal specification, repeated here, that characterizes thefamily of equations as a whole.
A characterization f a family ofequations roay be finitely represented in a grammar even though thefamily itself has an infinite number of members.
\]'hey developed thisnotion from the elementary descriptive device in LFG, thefunctional-application expression.
This has the followinginterpretation: /(1) (f s)= e holds if and only if f is an f-structure, s is a symbol,and the pair <s;v> E f.An f-structure is a hierarchical finite function from symbols to eithersymbols, semantic forms, f-structures, or sets of f-structures, and aparenthetic expression thus denotes the value that a thnetion takes for"a particular symbol.
This notation is straightforwardly extended toallow for strings of symbols, as illustrated in expressions such as( I" co,~w (re,l) above, lfx=sy is a string composedofan irfitial symbol sfollowed by a (possibly empty) suffix stringy, then(2) (fxI~((fs)y)(f~) =-/', where c is the empty string.The crucial extension to handle unbounded uncertainty is to allow theargument position in these expressions to denote a set of strings.Suppose u is a (possibly infinite) set of symbol strings.
Then Kaplanand Zaenen say that(3) (f(r)= v holds if and only if ((fs) Suff(s,a))= v for some symbol.s, where Suff(s,a) is the set of suffix strings ysuch that sy 6 a.Thus, an equation with a string-set argnment holds if it wouhl hold fora string in the set that results fl'om a sequence of left-to-right symbolchoices.
This kind of equation is trivially unsatisfiable iffl denotes theempty set.
Ira is a finite set, this fornmlatiou is equivalent to a finitedisiunction of equations over the strings in a.
Passing fi'om finitedisjunction to existential quantification enables us to capture theintuition of unbounded uncertainty as an underspeeifieation of exactlywhich choice of strings in a will ire compatible with tile functionalinformation carried by the surrounding surface nvironment.Kaplan and Zacnen of emu'se imposed the further equh'emmttthat the membership of a be characterized in finite specifications.Specifically, for linguistic, mathematical, nd computational reasonsthey required that a in fact be drawn from the class of regularhmguages.
The characterization of uncertainty in a partieuhu'grammatical equation can then be stated as a regular expression overthe vocabulary of grammatical function names.
The infniteuncertainty for the topicalization example above, for example, can bespecified by the equation (\]' TOPIC)=('\[ COMP*OBJ), involving theKleene closure operator.
A specification for" a broader class oftopiealization sentences might be ( 1' TOPIC)={ T COMP* GF), where GFdenotes the set of primitive grammatical functions {SUFU, OgJ, OBJY,XCOMP, ...}.
Various restrictions on the domain over which thesedependencies can operate--the quivalent of the so-called islandconstraints--can be easily formulated by constraining the uncertaintylanguage in different ways.
\["or example, the restriction for Englishand Icelandic that adjunct clauses are islands (Kaplan & Zaenen, inpress) might be expressed with the equation ( 1" TOPIC) =(\]" (GF-ADJ)* GF).
One noteworthy consequence of this flmetionalapproach is that appropriate predicate-argument relations can bedefined without relying on empty nodes or traces in constituentstructure.In the present paper we study the mathematical andcomputational propertiesofregular uncertainty.
Specifically, we showthat two important problems are decidable and present algorithms forcomputing their solutions.
In LFG the f-structures a signed to a stringare characterized bya functional description ('f-description'), a Booleancombination of equalities and set-membership assertions thatacceptable f-structures must satisfy.
We show first that theverification problem is decidable for any functional description thatcontains regular uncertainties.
We then prove that the satisfiabilityproblem is decidable for a linguistic interesting subset of descriptions,namely, those that characterize acyclic structures.2972.
VerificationThe verification problem is the problem of determining whether or nota given f-structure F satisfies a particular functional description forsome assignment ofelements of F to the variables in the description.This question is important in lexical-functional theory because theproper evaluation of I,FG's constraint equations depends on it.
It iseasy to show that the verification problem for an f-descriptionincluding an uncertainty such as (fa) = v is decidable ifF is a noncyc|icf-structure.
If F is noncyclic, it contains only a finite number offunction-application sequences and thus only a finite number ofstrings that might satisfy the uncertainty equation.
The membershipproblem for the regular sets is decidable and each of those strings cantherefore he tested to see whether it belongs to the uncertaintylanguage, and if so, whether the uncertainty equation holds when theuncertainty is instantiated to that string.
Alternatively, the set ofapplication strings can be treated as a (finite) regular language thatcan be intersected with the uncertainty language to determine the setof strings (if any) for which the equation must be evaluated.This alternative approach easily generalizes to the morecomplex situation in which the given f-structure contains cycles ofapplications.
A cyclic F contains at least one element g that satisfiesan equation of the form (gy)=g for some stringy.
It thus involves aninfinite number of function-application sequences and hence aninfinite number of strings any of which might satisfy an uncertainty.But a finite-state machine can be constructed that accepts exactly thestrings of attributes in these application sequences, for example, byusing the Kasper/Rounds automaton model for f-structures (Kasperand Rounds, 1986).
These strings thus form a regular language whoseintersection with the uncertainty language is a regular set Icontaining all the strings for which the equation must be evaluated.
IfI is empty, the uncertainty is unsatisfiable.
Otherwise, the set may beinfinite, but ifF satisfies the uncertainty equation for any string at all,we can show the equation will be satisfied when the uncertainty isinstantiated toone of a finite number of short strings in I.
Let n be thenumber of states in a minimum-state deterministic finite-stateacceptor for \[ and suppose that the uncertainty equation holds for astring w in I whose length Iwl is greater than n. From the PumpingLemma for regular sets we know there are strings x, y, and z such thatw=xyz, lYl >- l, and for all m -> 0 the string xymz is in L But theselatter strings can be appfication-sequences in F only if y picks out acyclic path, so that ((fx) y) = (fx).
Thus we have( fw)=v i f f(f xyz) = v iff(((fx) y) z)=v iff(fix) z) = v iff(f xz) = uwith xz shorter than w but still in I and hence in the uncertaintylanguage a. lflxz I is greater then n, this argument can be reapplied tofind yet a shorter string that satisfies the uncertainty.
Since w was afinite string to begin with, this process will eventually terminate witha satisfying string whose length is less than or equal to n. We cantherefore determine whether or not the uncertainty holds byexamining only a finite number of strings, namely, the strings in \[whose length is bounded by n.This argument can be translated to an efficient, practicalsolution to the verification problem by interleaving the intersectionand testing steps.
We enumerate common paths from the start-state ofa minimum-state acceptor for a and from the f-structure denoted by finF.
In this traversal we keep track of the pairs of states and subsidiaryf-structures we have encountered and avoid retraversing paths from astate/f-structure pair we have already visited.
We then test theuncertainty condition against he f-structure values we reach alongwith final states in the u acceptor.3.
SatisfiabilityIt is more difficult to show that the satisfiability problem is decidable.Given a functional description, can it be determined that a structuresatisfying all its conditions does in fact exist?
For trivial descriptionsconsisting of a single uncertainty equation, the question is easy toanswer.
If the equation has an empty uncertainty language,containing no strings whatsoever, the description is unsatisfiable.Otherwise, it is satisfied by the f-structure that meets therequirements of any string freely chosen from the language, fro"instance, one of the shortest ones.
For example, the descriptioncontaining only (fTOPIC)=(fCOMP*GF) is obviously satisfiablebecause (fTOPIC) = (fsuBJ) clearly has a model.
There is a large cIass ofnontrivial descriptions where the question is easy to answer foressentially the same reason.
If we know that the satisfiability of thedescription is the same no matter which strings we choose from the(nonempty) uncertainty languages, we can iastantiate theuncertainties with fi'eely chosen strings and evaluate the resultingdescription with any satisfiability procedure (for example, ordinaryattribute-value unification) that works on descriptions withoutuncertainties.
The bnportant point is that for descriptions in this classwe only need to look at a single string from each uncertainty language,not all the stririgs it contains, to determine the satisfiability of thewhole system.
Particular models that satisfy the description willdepend on the strings that instantiate the uncertainties, of course, butwhether or not such models exist is independent of the strings wechoose.Not all descriptions have this desirable free-choicecharacteristic.
If the description includes a conjunction of anuncertainty equation with another equation that defines a property ofthe same variable, the description may be satisfiable tbr someinst,antiations of the uncertainty but not for others.
Suppose that theequation (fTOPIC)=(fCOMP*GF) is conjoined with the equations(f COMe SUBJ NUM) =SG and (f TOPIC NUM) = eL.
This description issatisfiable on the string COMe COMe SUBJ but not on the shorter stringCOMe SUBJ because of the SG/PL ','inconsistency that arises.
Moregenerally, if two equations (fa)=vQ and (f {\])=vp are conjoined in adescription and there are strings in a that share a common prefix withstrings in \[I, then the description as a whole may be satisfiable for somestrings but not for others.
The choice of x from.a and xy from 13, tbrexample, implies a further constraint on the values vQ and v13: (fx)= vaand (fxy) = ((fx) y) = vp can hold only if (v a y) = vii, and this may or maynot be consistent with other equations for vQ.We can formulate more precisely the conditions under whichthe uncertainties in a description may be freely instantiated withoutaffecting satisfiability.
For simplicity, in the analysis below weconsider a particular string of one or more symbols in a non-uncertainapplication expression to be the trivial uncertainty languagecontaining just that string.
Also, although out" satisfiability procedureis actually implemented within the general framework of a directedgraph unification algorithm (the congruence closure method outlinedby /Kaplan and Bresnan 1982/), we present it here as a formularewriting system in the style of/Johnson 1987/.
This enables us toabstract away from specific details of data and control structure whichare irrelevant to the general line of argument.
We begin with a fewdefinitions.
We say that(5) A description is in canonical form if and only if(a) It is in disjunctive normal form,(b) Application expressions appear only as the left-sides ofequations,(c) None of its uncertainty languages i the empty string e,and(d) For any equation f=g  between two distinct variables, oneof the variables appears in no other conjoined equation.There is a simple algorithm for converting any description to alogically equivalent canonical form.
First, every statement containingan application expression (g{\]) not to the left of an equality is replacedby the conjunction of an equation (g \[3)= h, for h a new variable, withthe statement formed by substituting h for (g \[3) in the originalstatement.
This step is iterated until no offending applicationexpressions remain.
The equation (fa) = (g ~), for example, is replacedby the conjunction of equations ( fa )=h A (g{3)=h, and themembership statement (g {\])~f becomes h( f  A (g {\])= h. Next, everyequation of the form (f s)=v is replaced by the equation f=v inaccordance with the identity (2) above.
The description is then2981transtbrmed todisjunctive normal form.
Finally, for every equation oftire form f=g  between two distinct variables both of which appear inother conjoined equations, all occurrences ofg i~ those other equationsare replaced by f Each of these transformations preserves logicalequivalence and the algorithm terminates after introducing only afinite number of new equations and variables and performing a finitenumber of substitutions.Now let Z be the alphabet of attributes in a description anddefine the set of first'attributes in a language a as follows:(5) First(a) ~-{s in E I sz is in u for some string z in E*}Then we say that(6) (a) Two application ex!Sressions (fa) and (g 13) are free if andonly if(i) fand g are distinct, m" (ii) First(a) ~ First(\[l) = O and s isin neither a nor 13.
(b) Two equations are free if and only if their applicationexpressions are pairwi.se free.
(c) A functional description is free if and only if i t ' is incanonical form and all its conjoined equations are pairwisefree.If all the attribute strings on tire same variable in a canonicaldescription differ on their first element, there can be no sharedprefixes.
The fi'ee descriptions are thus exactly those whosesatisfiability is not affected by different uncertainty instantiations.3.1 Remoeing interactionsWe attack the satisfiability problem by providing a procedure fortransforming a thnctional description D to a logically equivalent butfree description D'  any of whose instantiations .can he tested forsatisfiability by traditional algorithms.
We show that this procedureterminates for the desm'iptions that usually appear in linguisticgrammars, namely, the descriptions whose atinimal models are allaeyclic.
Although the procedure can detect that a description mayhave a cyclic minimal model, we cannot yet show that the procedurewill always terminate with a correct answer if a cyclic specificationinteracts with an infinite uncertainty language.The key ingredient of this procedure is a transfornmtion thatconverts a conjunction of two equations that are not free into anequivalent finite disjunction of conjoined equations that are pairwisefree.
Consider the conjoined equations ( fa)= v~ and (f~)=vo for somevalue expressions va and vl~, where (fn) and (fL3) are not free.
Strings xand y arbitrarily chosen frmn a and 13, respectively, might be related inany of three significant ways: Either (a) x is a prefix ofy (y is xy' forsome string y'), (b) y is a prefix ofx (x is yx'), or (c) x and y are identicalup to some point and then diverge (x is zsxx' and y is zsyy' with symbolSx distinct from Sy).
Note that the possibility that x and y are identicalstrings is covered by both (a) and (b) with either y' or x' being empty,and that noninteracting strings fall into case (c) with z being empty.In each of these cases there is a logically equivalent reformulationinvolving either distinct variables or strings that share no firstsymbols:(7) (a) x i sa  prefixofy:(fx) = v~ A (fxy') = v~ iff(f x) = v,~ A ((f x) y') = v~ iff(f x) = vQ A (on y') = V~ (by substituting va for (~x)(b) y is a prefix of x:(fyx') ~- va A (fy) :: el3 iff(v~ x) = v~ A (f)') = Ul~(c) x and y have a (possibly mnpty) common prefix and thendiverge:(f zs~') = o, A (f ZSyy') = v~ iff(f z) = g A (g s~x') =.vo A bX Syy ') = u~for g a new variab!e and symbols ~ ~e syAll ways in which the chosen strings can interact are covered by thedisjunction of these reformulations.
We observe that if these specificattribute strings are considered as trivial uncertainties and if va and vl~are distinct from f, the resulting equations in each case are pairwisefree.In this analysis we transfer the dependencies among chosenstrings into different branches of a disjunction.
Although we havereasoned so far only about specific strings, an analogous line ofargument can be provided for families of strings in infinite uncertaintylanguages.
The strings in these languages fall into a finite set ofclasses to which a similar case analysis applies.
Let <Qq, 8~, qu, Fa,E> be the states, transition function, start state, final states, andalphabet of a (perhaps nondeterministic) finite-state machine thataccepts a and let < QIt, 50, q13, Fl3, E > be an accepter for \[l. Let 8" be theusual extension of 8 to strings in E* and define(8) Prefix(a,q) -= {x\[ q (8*a(qa,x) }(the prefixes of strings in u that lead to state q)Suffix(u,q) -~ {xJS*(q'x)flFn ~: O} ifq~Q~U Suffix(u,p) ifq C QapEq(the suffixes of strings in a whose prefixes lcad to states q)and note that Prefix(a,q) and Suffix(a,q) are regular sets for all q in Q~(since finite-state acceptm's for them can easily be constructed from theaccepter for a).
Further, every string in a belongs to the concatenationof Prefix(a,q) and Suffix(a,q) for some state q in Qa.
The prefixes of allstrings in u thus behmg to a finite number of languages Prefix(n,q),and every prefix that is shared between a string in a and a string in flalso belongs to a finite number of classes formed by intersecting two ofregular sets of this type.
The common prefix languages fill the role ofthe prcfix strings in the three-way analysis above.
All interactions ofthe strings in a and 13 that lead through states q and r, respectively, arecovered by the following possibilities:(9) (a) Strings fi'om a are prefixes of strings fiom 13:(f aCIPrefix(~,r)) = va A (v(~ Suffix(13,r)) = uf~(b) Strings fi'om 13 are prefixes of strings from a:(f \[ff/Prefix(a,q))= ell A (v~ Suffix(a,q))= u a(c) Strings have a common prefix and then diverge on some saand sl~ in Z:(f Prefix(n,q)NPrefix(\[J,r)) == gqv A\[(g'q,r ,%Suffix(u,8~,(q,so)))= vQ A(g,q,,.
s~Suffix(\[3,8~(r,sl0)) = ridwhere the gq,r in (9c) is a new variable and sa:esl~.
Taking thedisjunction of these cases over the cross-product of states in Qa and Q~and pairs of distinct symbols in E, we define the following operatm':(10) Free((fa)=v,, (fl~)=vo)\[(f anPrefix(13, r)) = ua A (v, Suffix(13, r)) = vl3l (a)V \[(f ~(1Prefix(a, q)) = el3 A (v{\] Suffix(u, q)) = ea\] (b)V V \[(f Prefix(a, q)APrefix(13, r))=gq,r Aq( Qa \ /  (c)V \[(gq,,.
sQSuffix(n, Sa(q, sn)))=v~A r~Q~8c~,8\[J~ (gq,r s\[3Suffix(~, 813(r , St3))) :Vii\] \]sa :~ s13This operator is the central component of our satisfiabilityprocedure.
It is easy to show that Free is truth-preserving in the sensethat Free((fa)= va, (f 13)= v0) is logically equivalent to the conjunction(fa) = va A (f13) = v~.
Any strings x and y that satisfy the uncertaintiesin the conjunction must fall into one of the cases in (7).
I fy=xy'  applies(case 7a), we have (f x) ~= va A (va y') = vf~.
But x leads to some state rx inQ~ and therefore belongs to Prefix(~,rx) while y' belongs to Suffix(13,rx).Thus, x satisfies (f a(3Prefix(13,rx))=va and y' satisfies(va Suffix(~,rx) =v~, ann (10a) is satisfied for one of the r x disjunctions.A symmetric argument goes through ifcas e (7b) obtains.Now suppose the strings diverge to SxX' and Syy' for distinct sxand Sy after a common prefix z (case 7c) and that z leads to q in Qa and rin Q~.
Then z belongs to Prefix(a,q)NPrefix(~,r) and satisfies theuncertainty (f  Prefix(a,q)APrefix(~,r))=gq,r.
Since x' belongs to299Suffix(a,Sa(q,sx))) and y' belongs to Suffix(13,Si~(r,sy))), the gq.,.
equationsin the s~,sp disjunction also hold.
Thus, if both original equations aresatisfied, one of the disjunctions in (10) will also be satisfied.Conversely, if one of the disjunctions in (lO) holds for some particularstrings, then we can find other strings that satisfy both originalequations.
If (f oC~Prefix(!3,r)) =va hokts for some string x in a leadingto state r in it's accepter and (va Suffix(ILr))= % holds for some str ingy'in Suffix(\[~,r),then ( fa)=va holds because x is in a and (f\[~)=v~ holdsbecause ((f  x) y') = v~ = (f xy') and xy' is in \[k The argmnents for theother cases in (10) are similarly easy to construct.
Thus, logicalequiwdenee is established by reasoning back and forth between stringsand languages and between strings and their prefixes and suffixes.If the operands to Free are from a description in canonicalform, then the canonical form of the result is a free description--al l  itsconjoined equations are pairwise free.
This is true whether or not theoriginal equations were free, provided that the value expressions vaand v\[3 are distinct from f( i f  either value was f, the original equationswould have only cyclic models, a point we will return to below).
In thefirst two eases in (10), the result ing equations are fi'ee because theyhave distinct variables (if neither vQ nor vp is f).
In the third ease, the fequation is free of the other two because gq,r is a new variable, and thetwo gq,r equations are free because the first symbols of theiruncertainties are distinct.
In sum, the Free operator transforms aconjunction of two non-fl'ee equations into a logically equivalentformula whose canonical form is free.The procedure for converting a description D to free form isnow straightforward.
The procedure has four simple steps:( It)  (a) Place D in canonical form.
(b) If all conjoined equations in D are pairwise free, stop.
D isfree.
(el Pick a conjunction C in D with a pair of non-free equations(f a)=v~ and (f l~)=vi~, and replace C in D with thecanonical form of its other equations conjoined withFree(((fn) = va, (fl~) = %)(d) Go to step (a).3.2 Terminationl fD has only aeylic models, this procedure will terminate after a finitenumber of iterations.
We argue that there are a certain number ofways in which the equations in each conjunction in D's canonical formcan interact.
Initially, for a conjunction C of N equations, the maximalnumber Of non-free pairs is N(N-1)/2, on the worst-ease assumptionthat every equation may potential ly interact with every otherequation.
Suppose step (1 le) is applied to two interacting equations inC.
The result will be a disjunction of conjunctions each of whichincludes the remaining equations from C and new equationsintroduced by one of the eases in (10).
In eases (10a) and (10b) theinteraction is removed from the common variable of the two equations(D and transferred to a new variable (either va or %).
In ease (10c), theinteraction is actually removed from the system as a new variable isintroduced.
Since new variables are introduced only when aninteraction is removed, the number of new variables is bounded.
Thuseach interaction is processed only a bounded number of times before itis either" removed (10el or transferred to a variable that it waspreviously associated with (t0a, b).
ttowever, it can only transfer to aprevious variable if the description has cyclic models.
Suppose that fis reached again through a series of (10a,b) steps Then there is aconjoined sequence of equations (f a) :va ,  (va u t )=vav  ...,(v% an + 11 = f But these can only be satisfied if there is some string xin aat...an+ 1 such that (f x )=f  and this holds only of cyclic models.Since the number of variables introduced is bounded by the originalnumber of possible interactions, all actual interactions in the systemmust eventually disappear either through the application of (10c) or bybeing transferred to a variable whose other equations it does notinteract with.300As we argued above, the satisfiabil ity of a free description canbe determined by arbitrar i ly instantiat ing the residual uncertaintiesto particular strings and then applying any traditional satisfiabil ityalgorithm to the result.
Given the Free operator and the procedure in( l l ) ,  the satisfiabil ity of an arbitrary acyclic description is thusdecidable.
'Phe possibility of nontermination with cyclic descriptions mayor may not be a problmn in l inguistic practice.
Although the formalsystem makes it easy to write descriptions of th i s  sort, very fewlinguistic analyses have made use of them.
The only example we areaware of involves modification structures (such as relative clauses)that both belong to the element they modify (the head) and alsocontain that element internally as an attribute value.
But out'procedure will in fact terminate in these sorts of eases.
The difficultywith cycles crones fl'om their interaction with infinite uncertainties.That is, the desm'iption may have cyclic models, but the cyclicspecifications will not always lead to repeating variable transfers andnontermination.
For example, if the cycle is required by anuncertainty that interacts with no other infinite uncertainty, theprocedure will eventually terminate with a fi'ee description.
This iswhat happens in the modification ease, because the cycle involves agrammatical  function (say RELCLAUSE or  MOD) which belongs to noinfinite uncertainty.I,'or cycles that are not of this type, there is a straightforwardmodification to the procedure in (11) that at least enables them to bedetected.
We maintain with each uncertainty a reem'd of all thevariables that it or any of its ancestors have been associated with, andrecognize a potentially nonterminating cycle when the a transfer to avariable already in the set is attemi~ted.
If we terminate the procedurewhen this happens, assuming in effec~ that all subsequent disjunctionsare unsatisfiable, we cannot be sure that all possible solutions will beaeemmted for and thus cannot guarantee the completeness of ourprocedure in the cyclic case.
We can refine this strategy by recordingand avoiding iteration over combinations of variables and uncertaintylanguages.
We thus safely explore more of the solution possibil itiesbut perhaps ti l l  not all of them.
It is an open question whether or notthere is a satisf iabil ity procedure different from the one we havepresented that terminates correctly in all eases.
On the other band, itis also not clear that potential solutions that might be lost throughearly termination are l inguistical ly significant.
Perhaps they shouldbe excluded by definition, much as /Kaplan and Bresnan 1982/excluded c~structure derivations with nonbranching dominance chainsbecause of their l inguistical ly uninteresting redundancies.4.
The Smal lest  ModelsThe satisf iabil ity of a description in free form is independent of thechoice of str ings from its uncertainty languages, but of course differentstring choices result in different satisfying models for the description.An infinite number of str ings can be chosen from even a very simplefunctional uncertainty such as (f COMP* SUBJ)  : V, and thus there arean infinite nunlber of distinct possible models.
This is reminiscent ofthe infinite nmnber of models for descriptions with no uncertainties atall  (just ( fsunJ)=v),  but in this case the models are systematical lyrelated in the natural subsumption ordering on the f~structure lattice.There is one smallest structure; the others include the information itcontains and thus satisfy the description.
But they also includearbitrary amounts of additional information that the description doesnot call for.
This is discussed by/Kaplan and Bresnan 1982/, where thesubsumption-minimal structure is defined to be the grammatical lyrelevant one.The models corresponding to the choice of different str ingsfrom an infinite uncertainty are also systematical ly related to eachother but on an metrle that is orthogonal to the subsumption ordering.Again appealing to the Pumping Lemma for regular sets, str ings thatare longer than the number of states in an uncertainty's minimal-statefinite-state accepter include a substr ing that is accepted by somerepeating sequence of transitions.
Replicating this substringarbitrar i ly  sti l l  yields a str ing in the uncertainty, so in a certain sensethese replications contribute no new grammatical ly interestinginformation.
Since all the intbrmatim~ is esseutially contained in tileshorter st,rinh~ that has no oeeurreuce of this imrtieular subs(ring, wedefine this t .
be the grammatical ly relevant representative fin" thewhole class.
Thus a description with uncertainties has only a finitenumber of lir~guistically significant models, those that result h'mn the5nite disjunci:ions that are introduced in converting the description toflee form and fl'om choosing among the finite nmnber of Short stringsin the residual uncertainties.5.
Pek'farmmice Cons iderat ionsWe have outlined a general, abstract procedure fro' solving uncertaintydescriptions, making the smallest number of assumptions about thedetails of its operatiml, '\['he efficiency of any i,nphmmntation willdepend in huge nleasure in just how details of data str(u:ture andexplicit COlnp~ttational control are fixed.There are a nuruber of obvious optimizations tbat can be made.First, although not required by the abstract procedure, perfornmncewill clearly be better if deterministic, minimal-state finite-statenmchines are used to represent the uncertainties.
This reduces thesize of the :;late eross-prodnets, which is the leading term in thenumber of disiunctions that nnlst be processed.
Second, the cases inthe Free operatm' are not mutual ly distinct: if identical strings behmgto the two um-ertainty languages, those wonld full into both cases (atand (b) and hence be processed twice with exactly equivalent results.The solution to this redundancy is to restrict one of tile cases (say (at)so that it only handles proper prefixes, consigning the identical stringsto the otber case.
Third, when pairs of symbols are enumerated in the(el case, there is obviously no point in even considering symbols thatare in the alphabet bnt are not First symbols of the suff'ixuncertainties.
This optimization is applied automatical ly if only thetransit ions leaving the start states are enmnerated and thefinite-state machines tire represented with partial transit ion functionspruned of transit ions to failure states.Four(b, a derivative uncertainty produced by the Free opm'atorwill sometimes be empty.
Since equations with empty nncertaintiesare imsatisfiable by definition, tiffs case should be detected and thatdisjunctive brt, nch immediately discarded.
Fifth, the same derivativesuffix and prefix languages of a particular state may appear inpursuing diffecent branches of the disjunction er processing differentcombinations af equations.
Some conq)utaUonal advantage may begained by saving the derivative finite-state machines in a cacheassociated with the states they are based on.
Finally, successiveiterations of the Free procedure may lead to transparentinconsistencies; (an assertion of equality between two distinct symbols;m" equating a synlbol to a variable that is also nsed as a functimi).
It isimportant o detect hese inconsistencies when they first appear andagain discard the corresponding disjunctive branch.
In fact, if' this isdone systemaUcally, iterated application of the Free operator by itselfsimulates the effect of traditional unification algorithms, withvariables corresponding tof-structures or nodes of a directed graph.There are also some less obvious but also quite importantperibrmance considerations.
What we have described is an equationalrewrit ing system that is quite different fl'om the usual reeursiveunification algorithm that operates on directed graptl representations.Directed graph data structures index the information in the equationsso that related structures are quickly accessible through the reem'sivecontrol structure.
Since our procedure does not depend for itscorrectness o~, (he order in which interacting equations arc chosen fori:recessing, it ought to be easy to embed Free as a simple extension of atraditional algorithm.
However, traditional unification algorithms donot deal with disjnnetion gracefully.
In particular, they typically donet expect new disjunctive branches to arise (luring the course of areeursive invocation; this would require inserting a fork in thereeursive control structure or saving a emnplete 'copy of the enrrentcomputational context for each new disjunction.
We avoid this~wkwar(tness by postponing tile processing of the functionaluncertainty nati l  all simple unifications are complete.
Beforeperforming a simple unification step, we remove from the datastruetures all uncertsint ies that need to be resolved and store themwith a pointer to their contahdng structures on a qmme or agenda ofpeuding t.mificaLions.
Uncertainty proceasing can be resumed at alater, more convenient time, after tile sinlpler unil'lcations have hecIlcompleted.
(Indeed, if mm of tile simpler unifications fails, themlcertainty may never be processed at all.)
Waiting until siniplernnifications are done means that no computational state has to bepreserved; only data structures have to be copied to \[wmre theindependence of the various disjunctive paths.We also note that as l<lng as the machinery \[br postponingthnctiona\[ uncertainty 6~r some anmunt of time is needed, it is oftenadvantagemm to postpoue it even hinter than is absohltely necessaryIn i)artieuhu', we fonnd I:lalL il' uncertainties are postl)nned untilpredicates (seulantic form values lilt' PIU'tD attributes) at'(!
assigned tothe I' structures they belong to, the nuluber of cases that must beexplored is dramatical ly reduced.
This is heeause of the coherencecm~dition that I,FG imposes on t\struetures with In'edicates: an\['-structure with a predicate can only contain (.hose govvrnablefunctions that are explicitly mentioned by the predicate.
Any othergovernable \['unctions are considered unacceptable.
Thus, if we wailuntil the predicate is klentified, we need only consider the smallnumber of governable attributes that any particular predicate allows,even though the initial attributes in an uncertainty may include theentire set of governab\[e functions (SUB J, oBJ, and various kinds ofobliques and eonlplmnents), and this may be quite large.
The effect isto make tim processing of hmg distance dependencies sensitive to thesubeategorization fralne of the predicate: we haw=" ahserved eUOFInOUSow,'all  performance ilnprovemetm; from applying this delay strategyNote that m a left.to-right parsing model, the processing h)ad thereforeincreases iu relative clauses just after the predicate is seen, and thismight bare a variety of interesting psycholinguistic implications.Finally, we observe that there is a specialization of the Freeoperator that applies when an uncertainty interacts with severalnon uncertainty equations (equations whose attr ibute expressionshave singleton First set:;), instead of separating one interaction flxunthe uncertainty with each application of Fl'eo, the Itncertainty isdivided in a single step into u minimum nmuber of disjunctivepossibilities eac i le f  which interacts with just one of the.
otherequations.
The disjunction contains one branch for each symbol in theuneertainty's First set that is an initial attribute in one of the otherequations, ohm a single branch tbr all of the residual inithd symbols:(12) ( fa)=u iff (fslSuffix(a,S(qa,st)))-:v ... (fsnSuffix(u,5(q(,,st~)))::::vV (l'n--{s b...s,d~:*) = vThe statement of the generic Free a/gm'ithm (10) is simplified byconsidering specific attr ibutes as trivial regular languages, buL thissuggests that COlnplex finite-state machinery would be roquh'ed toprocess them.
This alternative works in the opposite direction: itreduces leading ternls in an uncertainty to simph.
~attrihutes boil)repursuing their interactions, so that efficient attribute lnatehingroutines of a normal unification procedm'e can be applied.
Thisalternative has a second computational advantage.
The genericalgorithm unwinds the uncertainty one attribute at a time,constructing a residual regular set at each step, which is thenprocessed against he other nml-uncertain equations.
The alternativepr(leesses them all at once, avoiding the construction of theseintermediate residual languages.
This is a very ilnportanloptimization, since we lbund it to be the most colnmon case when weembedded uncertainty resohltion in our reeursive unificationalgorithm.Unem'tainty sl/ecificatlons are at colnI)act way of expressing alarge number of disjunctive possibilities that are uncovered one by oneas our procedure operates.
It might seem that this is an extremelyexpensive descriptive device, one which should lie avoided in tltvor ofapparently simpler 'mechanisms.
Bul; the disjunctions that emergefl'om processing uncertainties arc real: they represent independentgrammatical  possibil ities that would require additional computationalresources no matter how they were expressed.
In theories in whichlong-distance dependencies are based ou empty phase~strueture nodesand implemented, for example, by gap..threading machinery, a'rNtIol,I) lists, and the like, the exact h)cation of these empty nodes is notsignaled by any in(urination directly visible in the sentence.
This301increases the number of phrase.structure rules that can he applied.What we see as the computational cost of functional uncertainty showsup in these systems as additional resources needed forphrase-structure analysis and for functional evaluation of the largernumber of trees that the phrase-structure component produces.Unlike phrasally-based specifications, fnnctional uncertainties in LFGare defined on the same level of representation as thesubcategorization restrictions that constrain how they can he resolved,which our coherence-delay strategy easily takes advantage of.
But thethct remains that functional uncertainties do generate dlsjueetions,and thus strongly highlight he already perceived need for efficientdisjunction-processing techniques if acceptable performance is to beachieved with I,FG and related grammatical formalisms.
Recentdisjunction proposals by/Kasper 1987/and/Eisele and D0rre 1988/areimportant steps in the development of the necessary computationaltechnology.6.
ConclusionThe notion of regular functional uncertainty thus has very nicemathematical properties.
Our state-decomposition algorithm providesa very attractive method for resolving functional uncertainties asother phrasal and functional constraints are computed uring theparse of a sentence.
This algorithm expands the uncertaintiesincrementally, introducing at each point only as much disjunction as isnecessary toavoid interactions with other functional information thathas already been taken into account.
We bare recently added thisalgorithm and the functional uncertainty notation to our LFGGrammar Writer's Workbench, and we can now rigorously but easilytest a wide range of linguistic hypotheses.
We have also begun toinvestigate a number of other computational heuristics for theefficient, controlled expansion of uncertainty.Kaplan and Zaenen (in press) first proposed the idea offunctional uncertainty as sketched in this paper to account for theproperties of long-distance dependencies within the LFG h'amework.In this fi'amework, it has already shed new light on long-standingproblems like island constraints (see, e.g., /Saiki 1985/ for anapplication to Japanese).
But the notion is potentially of much wideruse: first, it can be adapted to other unification grammar formalismsto handle facts of a similar nature; and second, it can be used to handlephenomena that are traditionally not thought of as falling into thesame class as long-distance dependencies but that nevertheless eemto involve nonlocal uncertainty.
A discussion of its application in theLFG framework to infinitival complements can be found in/Johnson1986/for Dutch and/Netter 1986/for German;/Karttunen (i  press)/discusses how similar extensions toCategorial Unification Grammar(CUG) can account in a simple way for related facts in Finnish thatwould otherwise require type-raising.
Halvorsen has suggested thatscope ambiguities in semantic structures might also be characterizedby this device.AcknowledgementsOur understanding of the linguistic applications of functionaluncertainty developed over a long period of time in discussions withJoan Bresnan, Kris Halvorsen and Annie Zaenen.
Discussions withMark Johnson helped us in the early formulations ofthe satisfiabilityprocedure, and Bill Rounds assisted us in understanding thedifficulties of the cyclic case.
We are grateful for the invaluableassistance these colleagues have provided.ReferencesEisele, A. and D6rre, J.
1988.
Unification of disjunctive featuredescriptions.
Proceeedings of the 26th Annual Meeting of theAssociation fo~'Computational Linguistics.Johnson, M. 1986.
An LFG description of the double infinitiveconstruction i Dutch and German, CSLI report.Johnson, M. 1987.
Attribute-value logic and the theory of grammar.Unpublished doctoral dissertation, Stanford University.302Kaplan, R. M. andBresnan, J.
1982.
1,exicaLfunctional grammar: Aformal system for grammatical representation.
In J.
Bresnan(ed.
), The mental representation of grammatical relations.Cambridge: MIT Press.Kapian, R. M. and Zaenen, A.
In press.
Long-distance dependencies,constituent s ructure, and functional uncertainty.
In M. Baltinand A. Kroch (eds.
), Alternative Conceptions ofPhr~tse Structure.Chicago: Chicago University Press.Karttuncn, L. In press.
Radical \[,exicalism.
In M. Baltin and A.
Kroch(eds.
), Alternative Conceptions of Phrase Structure.
Chicago:Chicago University Press.Kasper, R. 1987.
A unification method for disiunetive featuredescriptions.
Proceedings of the 25th Annual Meeting of theAssociation for Computational Linguistics.Kasper, R. and Rounds.
W. 1986.
A logical semantics for featurestructures.
Proceedings of the 24th Annual Meeting of theAssociation for Computational Linguistics.Netter, K. 1986.
Getting Things out of Order.
COLING l 1.Saiki, M. 1985.
On the coordination of gapped constituents inJapanese.
CLS 21.
