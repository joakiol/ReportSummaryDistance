Squibs and DiscussionsStoring Logical Form in a Shared-PackedForestMary  P. Harper  ?Purdue University1.
IntroductionThere are several types of ambiguity in natural anguages, including lexical ambigu-ity, syntactic (or structural) ambiguity, quantifier scope ambiguity, and anaphora (orambiguity of reference).
Each type of ambiguity must be resolved for a natural an-guage understanding program to be effective.
Since syntax often limits the possiblemeanings of a sentence (and the words in the sentence), natural language processingprograms often analyze the structure of a sentence before attempting to determine itsmeaning.
However, additional knowledge sources must often be used in understand-ing, including selectional restrictions, world knowledge, and contextual information.The use of world knowledge and contextual information often requires inference andhence access to the representations of the sentence and possibly its components.
Butat the same time, because of ambiguity, a program might not be able to enumerate allof the possible representations fora sentence and its components, ince just listing allpossible structural analyses for syntactically ambiguous sentences can be impractical,and each structural analysis of a sentence typically produces at least one additionalmeaning.In this paper, we will focus on the problem of efficiently maintaining syntactic am-biguity while determining the logical representation for a sentence.
In particular, wedescribe an approach that combines hared-packed parse forests with semantic on-struction routines.
This approach allows a program attempting toeliminate ambiguityfrom a sentence to apply higher level knowledge sources to the logical representationsof desired constituents in the parse forest (e.g., it could eliminate alternative parses fora noun phrase (NP) whose representation does not match objects in a world model).2.
Methods of Handling Syntactic AmbiguityTree structures, called parse trees, are often used to represent the structural propertiesof a sentence.
Because language is often syntactically ambiguous, it is common fora particular sentence to have more than one parse tree.
For example, the sentence,Every man saw the boy with his binoculars, has two potential parses.
In one parse, theprepositional phrase (PP) with his binoculars is attached to the verb phrase (VP).
In theother, it is attached to the object (NP).
These two structures give rise to very differentmeanings for the sentence.
In the first case, every man is using the binoculars to seethe boy; whereas in the second, the boy has the binoculars.One way to enable a natural anguage program to process the meanings of syn-tactically ambiguous sentences i  to incorporate semantic onstruction routines into a* School of Electrical Engineering, 1285 Electrical Engineering Building, Purdue University, WestLafayette, IN 47907-1285, USA.Q 1994 Association for Computational LinguisticsComputational Linguistics Volume 20, Number 4parser that produces each structural analysis for a sentence, one parse tree at a time,and maps each tree to a separate logical representation.
The program must then at-tempt to determine which meaning for the sentence is the intended one.
One problemwith this approach is that the number of parse trees produced for some ambiguoussentences i quite large.
For example, a parser analyzing sentences with multiple PPscan produce a prohibitively large number of possible parses for the sentence.
As thenumber of PPs in a sentence increases, the number of possible parse trees and theircorresponding representations grows as the Catalan numbers, C,, = \[2n~ 1 (Church \ n ,' n+land Patil 1982).
For example, a sentence with one object and four post-object PPs (i.e.,n = 5) has 42 parses.
Since the number of parses for a sentence with multiple PPsgrows faster than exponentially (Knuth 1975), the time to list all possible trees andtheir corresponding meanings can be prohibitive.
A one-parse-tree-at-a-time approachthat uses no mechanism for storing subresults from a parse (e.g., a chart or parseforest) is inefficient because it cannot reuse the results of the semantic and contextualtests made on a subtree of a rejected parse during the evaluation of an alternativeparse tree.
The need for efficiency dictates the need for another approach to managethe ambiguity of a sentence.The efficiency of this approach can be improved by resolving each indeterminacyin the parse as soon as it arises to prevent backtracking (Briscoe 1987).
However, thisrequires that enough information be available at that point in the parse to select amongthe alternatives.
In many cases, this requirement cannot be met; words occurring laterin the sentence or possibly in subsequent sentences may be needed to resolve theambiguity.
A slightly different alternative is to work with the highest preference choiceonly (Alshawi 1990; Briscoe and Carroll 1993).
Although this approach is efficient, itprovides only the most likely parse (independently of context), not necessarily thecorrect parse.An alternative scheme for coping with syntactic ambiguity is to change the gram-mar rules so that they provide a single parse tree for a syntactically ambiguous en-tence and then wait for the semantic routines to pinpoint the parse.
To illustrate thisstrategy, consider a common way to write a rule for an NP with noun modifiers:NP --+ DET N1N1 --+ NOUNN1 --+ N1 N1This grammar  generates a very large number of possible structures for NPs like thecomputer science school book.
However, it also eliminates from consideration impossiblenoun modifier structures by not allowing crossover between modifiers.
For example,the grammar would never allow a structure such that computer modifies school, whichmodifies book, and science modifies book.
On the other hand, an alternative rule can beused to generate a single structural analysis for the sentence, as shown below:NP --+ DET NOUN* NOUNThis rule ignores the structure of noun modifiers of a head noun, placing them allat the same level in the parse tree.
Without a structure to limit the possible modifierrelations, a semantic routine might incorrectly allow a noun modifier to modify any ofthe nouns that follow it.
To work correctly, the semantic routines would have to encodeinformation already contained in the first set of rules in order to prevent impossiblemodifications.Another possibility is to use a least commitment grammar that provides only oneof the possible modifier structures for an NP.
To allow an interpretation based on one650Mary P. Harper Storing Logical Form in a Shared-Packed Forest24 ((S-MAJ16 S-MAJ) (DOWN (21 23)))23 ((.8 FINALPUNC .)
(DOWN T))22 ((NP14 NP) (DOWN (7 8 19)))21 (($13 S) (DOWN (3 20)))20 ((VP12 VP) (DOWN (6 9 19) (6 22)))19 ((PP+11 PP+ NIL) (DOWN (18)))18 ((PP10 PP NIL) (DOWN (12 17)))17 ((NP9 NP) (DOWN (16 15)))16 ((POSS8 POSS) (DOWN (13)))15 ((POSS-NOM7 POSS-NOM) (DOWN (14)))14 ((BINOCULARS7 NOUN BINOCULARS)(DOWN T))13 ((HIS6 PRONOUN HIS) (DOWN T))12 ((WITH5 PREP WITH) (DOWN T))11 (($6 S) (DOWN (3 10)))10 ((VP5 VP) (DOWN (6 9)))9 ((NP4 NP) (DOWN (7 8)))8 ((BOY4 NOUN BOY) (DOWN T))7 ((THE3 DET THE) (DOWN T))6 ((VERBS3 VERBS) (DOWN (5)))5 ((TENSED-MAIN2 TENSED-MAIN) (DOWN (4)))4 ((SAW2 VERB SEE) (DOWN T))3 ((NP1 NP) (DOWN (1 2)))2 ((MAN1 NOUN MAN) (DOWN T))1 ((EVERY0 DET EVERY) (DOWN T))Figure 1The shared-packed parse forest for Every man saw the boy with his binoculars.of the other possible syntactic structures, the semantic routines operating on the outputof a least commitment parser must be able to adapt he tree for other interpretations.Description Theory (D-theory) (Marcus, Hindle, and Fleck 1983) uses the domi-nation relation to specify structures of trees (rather than the parent relation), formingthe basis of a class of deterministic parsers that build partial descriptions of treesrather than the trees themselves.
D-theory parsers build structures that contain onlythose relations that are common to all consistent trees such that the choice betweenalternatives can be handled by higher level knowledge sources.
However, D-theoryis a purely syntactic theory, which does not construct a semantic interpretation, andin many cases it creates the same underspecified syntactic analysis for sentences thatrequire different ypes of interpretations.
For example, compare I sailed the ship in theocean with Every man saw the boy with his binoculars.
These sentences have very differentinterpretive characteristics.
In the first, the syntactic underspecification s matched by asemantic underspecification; attaching the PP to the NP or VP does not alter the truthvalue of the sentence.
However, the second sentence has two distinct interpretationsdepending on the resolution of the attachment ambiguity.
Hence, for D-theory to beuseful in a system that does semantic interpretation, it would need to be coupled witha semantic interpreter that recognizes the difference between these two examples.The approach taken in this paper is to combine an all-path parsing algorithm(Chester 1980; Earley 1970; Kay 1980; Seo and Simmons 1989; Tomita 1985) with rou-tines for generating logical representations i  order to create a shared-packed parseforest annotated with the logical representations for the constituents in the forest (i.e.,an annotated shared-packed parse forest).
Before discussing the benefits of this ap-proach, we describe the properties of a shared-packed parse forest (Seo and Simmons1989; Tomita 1985, 1987).A shared-packed parse forest is a data structure that stores all parses of a sentencein a compact form.
Consider the packed parse forest produced by an implementation fTomita's parser (Tomita 1985) for the sentence Every man saw the boy with his binocularsshown in Figure 1.
The forest stores both terminal and non-terminal nodes.
Non-terminal nodes contain lists of node numbers of the children that make up a parse651Computational Linguistics Volume 20, Number 4of that constituent.
The start symbol for the grammar is S-MAJ, which in the aboveexample consists of a non-terminal node for an S and a final punctuation terminalnode.
Because a non-terminal node may have descendents with multiple parses, therecan be more than one parse tree for the constituent.
This results from the fact thatthe parser packs forest nodes together when they share a common state vertex andhave the same features.
For example, in Figure 1, the VP with the index of 20 has twoparses, one consisting of nodes with indices 6, 9, and 19, and the other with indices 6and 22.
Early in the parse, node 20 had only one set of children (6 9 19).
Later, afternode 22 was created, the parser added (6 22) to the list of children for the VP node.This node packing occurs when the parser is preparing to reduce the phrase consistingof the subtrees 6 and 22 using a VP rule.
When the new constituent in the parse stackhas the same state vertex on its left and right as the item already stored in the forest,the alternative parse is added to the list of possible children for the already storedconstituent.
Note that nodes which never participate in a sentence parse can appearin the forest (e.g., nodes 10 and 11).
These useless nodes can be easily pruned afterparsing is complete by marking all nodes that participate in a parse beginning withthe start symbol, S-MAJ, and freeing those that are unmarked.Seo and Simmons (1989) have introduced syntactic graphs, which are constructedfrom shared-packed parse forests, to represent ambiguous parses for a sentence.
Thesyntactic graph encodes the modifier links between a head word and its modifiers.An advantage of this approach is that words which participate in multiple parses (bymodifying different words in different ways) have multiple arcs entering the node.For example, if a preposition (as head of a PP) can modify either a noun or a verb,there would be two arcs entering the node for the preposition, one from the noun andone from the verb.
Hence, the point of ambiguity can be pinpointed to the attachmentdecision.
They claim that a parse forest does not give the same direct access to internalambiguity because ambiguous points can be detected only by traversing the forest.Certainly, one cannot immediately detect hat the ambiguity for the sentence resideswith the PP attachment by examining the forest shown in Figure 1.
However, byadding links between each of the nodes in the forest and its parent node and thenpruning the nodes that do not participate in a legal parse for the sentence, the forestdoes give a better view of this ambiguity (see Figure 2).
Nodes with more than oneparent participate in multiple parses for a sentence.
In the example forest of Figure 2,there are two different NPs that contain the and boy, and the PP+ constituent in node17 is a member of either an NP or a VP.
Though this is not quite as compact as asyntactic graph for the same sentence, it does provide some very useful informationon the sources of ambiguity in the sentence.
For example, if an NP containing the wordboy in Figure 2 can either have a PP+ attached to it (as in node 20) or not (as in node9) and the world model does not support he attachment, then the forest can be easilypruned of that possibility by deleting all references to the NP at node 20.
The deletionprocess removes node 20 from the up pointers of node 20's children (i.e., nodes 7, 8,and 17) and deletes parses containing node 20 from node 20's parent node, 18.
Oncethe deletion is complete, the forest is no longer ambiguous, as shown in Figure 3.Rather than transforming the parse forest to a parse graph to represent the syn-tactic structure for ambiguous entences, we prefer to store pointers to parent nodesand utilize the shared-packed parse forest to store logical representations.
Use of anannotated shared-packed parse forest has the following benefits:.
It provides a space savings by packing duplicate nodes into a singleentry in the forest (Earley 1970; Seo and Simmons 1989; Tomita 1985),652Mary P. Harper Storing Logical Form in a Shared-Packed Forest22212019181716151413121110987654321((S-MAJ16 S-MAJ) (DOWN (19 21)) (UP T))((.8 FINALPUNC .)
(DOWN T) (UP 22))((NP14 NP) (DOWN (7 8 17)) (UP 18))(($13 S) (DOWN (3 18)) (UP 22))((VP12 VP) (DOWN (6 9 17) (6 20)) (UP 19))((PP+11 PP+ NIL) (DOWN (16)) (UP 18 20)) ; attatch to an NP or VP((PP10 PP NIL) (DOWN (10 15)) (UP 17))((NP9 NP) (DOWN (14 13)) (UP 16))((POSS8 POSS) (DOWN (11)) (UP 15))((POSS-NOM7 POSS-NOM) (DOWN (12)) (UP 15))((BINOCULARS7 NOUN BINOCULARS) (DOWN T) (UP 13))((HIS6 PRONOUN HIS) (DOWN T) (UP 14))((WITH5 PREP WITH) (DOWN T) (UP 16))((NP4 NP) (DOWN (7 8)) (UP 18))((BOY4 NOUN BOY) (DOWN T) (UP 9 20)) ; in two different NPs((THE3 DET THE) (DOWN T) (UP 9 20)) ; in two different NPs((VERBS3 VERBS) (DOWN (5)) (UP 18))((TENSED-MAIN2 TENSED-MAIN) (DOWN (4)) (UP 6))((SAW2 VERB SEE) (DOWN T) (UP 5))((NP1 NP) (DOWN (1 2)) (UP 19))((MAN1 NOUN MAN) (DOWN T) (UP 3))((EVERY0 DET EVERY) (DOWN T) (UP 3))Figure 2The pruned shared-packed parse forest for Every man saw the boy with his binoculars withpointers to parent nodes.22212019181716151413121110987654321Figure 3An unambiguous parse((S-MAJ16 S-MAJ) (DOWN (19 21)) (UP T))((.8 FINALPUNC .)
(DOWN T) (UP 22))((NP14 NP) (DOWN (7 8 17)) (UP 18))((S13 S) (DOWN (3 18)) (UP 22))((VP12 VP) (DOWN (6 9 17)) (UP 19))((PP+11 PP+ NIL) (DOWN (16)) (UP 18))((PP10 PP NIL) (DOWN (10 15)) (UP 17))((NP9 NP) (DOWN (14 13)) (UP 16))((POSS8 POSS) (DOWN (11)) (UP 15))((POSS-NOM7 POSS-NOM) (DOWN (12)) (UP 15))((BINOCULARS7 NOUN BINOCULARS) (DOWN T) (UP 13))((HIS6 PRONOUN HIS) (DOWN T) (UP 14))((WITH5 PREP WITH) (DOWN T) (UP 16))((NP4 NP) (DOWN (7 8)) (UP 18))((BOY4 NOUN BOY) (DOWN T) (UP 9))((THE3 DET THE) (DOWN T) (UP 9))((VERBS3 VERBS) (DOWN (5)) (UP 18))((TENSED-MAIN2 TENSED-MAIN) (DOWN (4)) (UP 6))((SAW2 VERB SEE) (DOWN T) (UP 5))((NP1 NP) (DOWN (1 2)) (UP 19))((MAN1 NOUN MAN) (DOWN T) (UP 3))((EVERY0 DET EVERY) (DOWN T) (UP 3)); can delete node; attatch to a VPfor Every man saw the boy with his binoculars given a certain world model...thus reducing the overhead when it is necessary to keep all parses until itis possible to make an informed choice among the alternative meanings.It provides a direct method for focusing on the points of ambiguity in asentence when parent links are included for each node.It is able to reuse the semantic decisions made for a subtree of a rejectedparse tree.
When a node in the forest is limited to a single parse, it is653Computational Linguistics Volume 20, Number 4limited for all parses of the sentence containing that node (unlikeone-parse-tree-at-a-time methods).Because of these benefits, we have designed a program to generate a shared-packed parse forest annotated with the logical form developed by Harper (1990, 1992).We augmented a Tomita-style LR parser with the necessary routines for constructingthe logical form representation.
Tomita's parser is a bottom-up LR(k)-based parserthat constructs a forest of all possible parses while using a graph-structured stack andbreadth-first earch to handle non-determinism in the parse.
In the next section, wedescribe three methods for interfacing our logical form routines with Tomita's parser.The conclusions we draw can also be applied to more efficient parsers (Earley 1970;Schabes 1991) that produce other logical representations (e.g., Alshawi and Crouch1992; Hirst 1987; Weischedel 1989) in more compact forests (Nederhof 1993).3.
Combining Logical Form with Forests: A Case StudyPreviously, our logical form routines were interfaced with a one-parse-tree-at-a-time,top-down ATN parser (Harper 1990, 1992).
This made it relatively easy to create com-positional logical form routines and interface them with the parser.
These routineswere developed to construct and store the logical forms for each major type of con-stituent.
Some routines created logical representations for the basic constituents likenouns and verbs, whereas routines for more complex constituents, like VPs, NPs, andsentences, combined the logical representations of several constituents into a largerrepresentation.
Function calls for constructing the logical forms were then added tothe arcs in the grammar networks and were executed whenever the arc was success-fully traversed (after constituent and feature tests succeeded).
Since one parse treewas built at a time, the logical form for each tree was constructed and stored beforeanother tree was produced by the parser's earch mechanism; hence, none of the com-plex logical form routines had to combine more than a single representation for eachof its constituents.
The logical representations were easy to create in this approach,but the parser was impractical because it generated a single parse tree at a time.In the Tomita parser, the grammar rules consist of production rules containing aleft-hand side, a right-hand side, and a set of actions.
These actions include featuretests that must succeed for the reduce operation to proceed and routines for storingfeature values and for constructing and storing the logical form with a node in theforest.
For example, the following rule is used to parse a sentence consisting of an NPand a VP:(S --* (NP VP)((== #$NP (get-the person of #$VP))(=!
#$PHRASE 'statement)(logical-form 'sentence :np #$NP :vp #$VP))); Subject-verb agreement test; Set the MOOD of the sentence; Create the logical formThe left-hand side of this rule is S, and the right-hand side is a list consisting of an NPand a VP.
For the rule to succeed uring parsing, the right-hand side of the rule mustmatch, and the subject-verb agreement test must return true.
If it does, a parse node iscreated with a list of children consisting of #$NP and #$VP, the node numbers of thetwo constituents hat make up the S. Additionally, the feature information and logicalforms for the constituent are stored in the node created for the forest.
To simplifythe forests in examples, we omit the feature information stored on nodes and simplyindicate the number of logical forms stored for a node, not the actual representation.654Mary P. Harper Storing Logical Form in a Shared-Packed ForestUnlike the ATN parser used by Harper (1990, 1992), the Tomita parser is a bottom-up, all-path parsing algorithm that creates a parse forest by packing parse nodes to-gether to save space and time.
Because nodes with two alternative parses often producetwo different semantic representations, our logical form construction routines must beable to store and retrieve multiple logical forms for ambiguous constituents in theforest.
This requirement introduces two problems.
First, packed nodes in a forest rep-resent multiple parses, which produce multiple representations; hence, our routines forconstructing logical forms for sentences (and other complex constituents) may have tocombine multiple representations for each of their constituents.
Second, the annotatedshared-packed parse forest cannot store every representation f a highly ambiguoussentence without using a prohibitively large amount of space.
Any approach thatuses a parse forest to store logical representations for the constituents of a sentencewill have to address these problems.
We will describe three methods for interfacingthe LR parser with logical form routines and illustrate the differences between theseapproaches by using the parse of the sentence, Fred saw frogs in cars with Bill.The first and simplest method is to prevent wo nodes from being packed together(except for the start symbol), if they have different logical forms, as shown in Figure 4.Notice that there are five parses for the S-MAJ at node 36 (i.e., (20 35), (24 35), (26 35),(32 35), and (34 35)) and five logical forms.
All other nodes have a single parse and asingle logical form.
This approach is similar to the method employed by the ATN togenerate the logical forms for a sentence and is equivalent to mapping an individualparse tree to a logical representation.
This method is easy to implement, but it doesnot take advantage of the shared-packed parse forest for compactly storing the logicalforms.
And because different structural variations typically map to different logicalrepresentations, the number of nodes in the forest can be exponential (or worse) forsome ambiguities.The second approach is to store the logical representation directly in the shared-packed parse forest, as shown in Figure 5.
The syntactic ambiguity in the structure ofa child node must affect the ambiguity of the logical representation f ancestor nodes.If a parent node consists of two constituents, one with three logical forms and anotherwith two, the construction routines must be able to store the six logical forms for thatconstituent.
This requires that the logical form routines be constructed to combine thelogical forms for constituents with more than a single representation.
Node packingprovides an additional challenge.
When a new node is packed with an already existingnode in the forest, the logical representation for the new structure must be stored forthat constituent.
Also, all of the ancestors of a newly packed node must update theirlists of logical representations to reflect the addition of the new parse, since packingof a node can occur after many of its ancestors are already members of the forest.
InFigure 5, when the second parse was added to node 21, a second logical form also hadto be added to the logical form list for that node and to the logical form lists of eachof its previously stored ancestors (i.e., 19, 20, and 22) for the forest to be complete.In contrast o the first approach, this method does not increase the number ofnodes in the parse forest; however, an exponential number of logical representationscan be created for sentences in some ambiguous grammars.
Some space savings canbe achieved by using pointers to the representations of a child node when creatingthe representations of a parent node, because many of the nodes (and correspondinglogical forms) in a parse forest are shared by multiple parses.
However, for multiplelogical representations to share the logical representation f a child node, that repre-sentation cannot be affected by the process of constructing the logical form for theparent node, an assumption that does not always hold (e.g., Harper 1990, 1992).
If theassumption does not hold, the logical form of a shared node would require copying655Computational Linguistics Volume 20, Number 436 ((S-MAJ62 S-MAJ) (DOWN (20 35) (24 35) (26 35) (32 35) (34 35)) (UP T)); Store five representations for S-MAJ which combine single representations given the node pairs.35 ((.7 FINALPUNC .)
(DOWN T) (UP 36))34 (($61 S) (DOWN (2 33)) (UP 36)); Store an S representation which combines the representations i  nodes 2 and 33.33 ((VP60 VP) (DOWN (5 7 29)) (UP 34)); Store a VP representation which combines the representations i  nodes 5, 7, and 29.32 (($55 S) (DOWN (2 31)) (UP 36)); Store an S representation which combines the representations i  nodes 2 and 31.31 ((VP54 VP) (DOWN (5 30)) (UP 32)); Store a VP representation which combines the representations i  nodes 5 and 30.30 ((NP51 NP) (DOWN (6 29)) (UP 31)); Store a representation for an NP which combines the representations i  nodes 6 and 29.29 ((PP+48 PP+) (DOWN (28)) (UP 30 33)); Store a representation for a PP+ given the representation in node 28.28 ((PP47 PP) (DOWN (8 27)) (UP 29)); Store a representation for the PP which combines the representations i  nodes 8 and 27.27 ((NP46 NP) (DOWN (9 18)) (UP 28)); Store a representation for an NP which combines the representations i  nodes 9 and 18.26 (($45 S) (DOWN (2 25)) (UP 36)); Store an S representation which combines the representations i  nodes 2 and 25.25 ((VP44 VP) (DOWN (5 7 21)) (UP 26)); Store a VP representation which combines the representations i  nodes 5, 7, and 21.24 (($39 S) (DOWN (2 23)) (UP 36)); Store an S representation which combines the representations i  nodes 2 and 23.23 ((VP38 VP) (DOWN (5 22)) (UP 24)); Store a VP representation which combines the representations i  nodes 5 and 22.22 ((NP35 NP) (DOWN (6 21)) (UP 23)); Store a representation for an NP which combines the representations i  nodes 6 and 21.21 ((PP+32 PP+) (DOWN (11 18)) (UP 22 25)); Store a representation for a PP+ given the representation in nodes 11 and 18.20 (($31 S) (DOWN (2 19)) (UP 36)); Store an S representation which combines the representations i  nodes 2 and 19.19 ((VP30 VP) (DOWN (5 13 18)) (UP 20)); Store a VP representation which combines the representations i  nodes 5, 13, and 18.18 ((PP+27 PP+) (DOWN (17)) (UP 19 21 27)); Store a representation for a PP+ given the representation in node 17.17 ((PP26 PP) (DOWN (14 16)) (UP 18)); Store a representation for the PP which combines the representations i  nodes 14 and 16.16 ((NP25 NP) (DOWN (15)) (UP 17)); Store a representation for an NP given the head noun in node 15.15 ((FRED6 PROPERNOUN FRED) (DOWN T) (UP 16))14 ((WITH5 PREP WITH) (DOWN T) (UP 17))13 ((NP20 NP) (DOWN (6 12)) (UP 19)); Store a representation for an NP given the representations i  nodes 6 and 12.12 ((PP+11 PP+) (DOWN (11)) (UP 13)); Store a representation for a PP+ given the representation in node 11.11 ((PP10 PP) (DOWN (8 10)) (UP 12 21)); Store a representation for the PP which combines the representations i  nodes 8 and 10.10 ((NP9 NP) (DOWN (9)) (UP 11)); Store a representation for an NP given the head noun in node 9.9 ((CARS4 NOUN CAR) (DOWN T) (UP 10 27))8 ((IN3 PREP IN) (DOWN T) (UP 11 28))7 ((NP4 NP) (DOWN (6)) (UP 25 33)); Store a representation for an NP given the head noun in node 6.6 ((FROGS2 NOUN FROG) (DOWN T) (UP 7 13 22 30))5 ((VERBS3 VERBS) (DOWN (4)) (UP 19 23 25 31 33)); Store a representation given node 4.4 ((TENSED-MAIN2 TENSED-MAIN) (DOWN (3)) (UP 5)); Store a representation for the verb in 3.3 ((SAW1 VERB SEE) (DOWN T) (UP 4))2 ((NP1 NP) (DOWN (1)) (UP 20 24 26 32 34)); Store a representation for an NP given the head noun in node 1.1 ((FRED0 PROPERNOUN FRED) (DOWN T) (UP 2))Figure 4Method 1: Two nodes of the parse forest are not packed when they have different logicalforms.656Mary P. Harper Storing Logical Form in a Shared-Packed Forest26 ((S-MAJ196 S-MAJ) (DOWN (20 25)) (UP T))25 ((.7 FINALPUNC .)
(DOWN T) (UP 26))24 ((PP174 PP) (DOWN (8 23)) (UP 21)); Store a representation for the PP which combines the representations i  nodes 8 and 23.23 ((NP165 NP) (DOWN (9 18)) (UP 24)); Store a representation for an NP which combines the representations i  nodes 9 and 18.22 ((NP130 NP) (DOWN (6 21)) (UP 19)); Store two representations for an NP which combine the representation in node 6 with the; two representation in node 21.21 ((PP+113 PP+) (DOWN (11 18) (24)) (UP 22 19)); Store two representations of PP+, one which combines the representations of nodes 11 and 18,; and the other which is the representation stored in node 24.20 ((S106 S) (DOWN (2 19)) (UP 26)); Store five representations of S which combine the representation f node 2 with the; five representations of node 19.19 ((VP95 VP) (DOWN (5 13 18) (5 22) (5 7 21)) (UP 20)); Store five representations for the VP, one which combines the representations; in nodes 5, 13, and 18, two which combine the representation in node 5; with the two representations i  node 22, and two which combine the representation; of node 5 with the representation f node 7 and the two representations of node 21.18 ((PP+84 PP+) (DOWN (17)) (UP 19 21 23)); Store a representation for a PP+ given the representation in node 17.17 ((PP79 PP) (DOWN (14 16)) (UP 18)); Store a representation for a PP which combines the representations i  node 14 and 16.16 ((NP76 NP) (DOWN (15)) (UP 17)); Store a representation for an NP given the head noun in node 15.15 ((BILL6 PROPERNOUN BILL) (DOWN T) (UP 16))14 ((WITH5 PREP WITH) (DOWN T) (UP 17))13 ((NP56 NP) (DOWN (6 12)) (UP 19)); Store a representation for an NP which combines the representations i  nodes 6 and 12.12 ((PP+31 PP+) (DOWN (11)) (UP 13)); Store a representation fo~' a PP+ given the representation in node 11.11 ((PP26 PP) (DOWN (8 10)) (UP 12 21)); Store a representation for the PP which combines the representations i  nodes 8 and 10.10 ((NP23 NP) (DOWN (9)) (UP 11)); Store a representation for an NP given the head noun in node 9.9 ((CARS4 NOUN CAR) (DOWN T) (UP 10 23))8 ((IN3 PREP IN) (DOWN T) (UP 11 24))7 ((NP10 NP) (DOWN (6)) (UP 19)); Store a representation for an NP given the head noun in node 6.6 ((FROGS2 NOUN) (DOWN T) (UP 7 13 22))5 ((VERBS7 VERBS) (DOWN (4)) (UP 19)); Store a representation given node 4.4 ((TENSED-MAIN4 TENSED-MAIN) (DOWN (3)) (UP 5)); Store a representation for the verb in 3.3 ((SAW1 VERB SEE) (DOWN T) (UP 4))2 ((NP1 NP) (DOWN (1)) (UP 20)); Store a representation for an NP given the head noun in node 1.1 ((FRED0 PROPERNOUN) (DOWN T) (UP 2))Figure 5Method 2: Directly store multiple logical forms in a packed forest.and modification before being used in the logical representation of a parent node.
Ifall logical representations are copied and modified as they are combined into higherlogical representations, the parse forest could grow quite large.
However, even if theelements of a logical representation do not require copying, the number of represen-tations created for a sentence using the second approach is precisely the number ofparses for the sentence, which can be exponential in number.A third approach is to store a procedure call for creating the logical form of aconstituent in the forest and to delay the creation of the logical form, as shown in657Computational Linguistics Volume 20, Number 426 ((S-MAJ196 S-MAJ) (DOWN (20 25)) (UP T) (CREATE-S-MAJ-LF :S 20 :PUNC 25))25 ((.7 FINALPUNC .)
(DOWN T) (UP 26))24 ((PP174 PP) (DOWN (8 23)) (UP 21) (CREATE-PP-LF :PREP 8 :OBJ 23))23 ((NP165 NP) (DOWN (9 18)) (UP 24) (CREATE-NP-LF :NOUN 9 :POSTNOUN-MODS 18))22 ((NP130 NP) (DOWN (6 21)) (UP 19) (CREATE-NP-LF :NOUN 6 :POSTNOUN-MODS 21))21 ((PP+113 PP+) (DOWN (11 18) (24)) (UP 22 19)(CREATE-PP+-LF :PP 11 :PP+ 18)(CREATE-PP+-LF :PP 24))20 (($106 S) (DOWN (2 19)) (UP 26) (CREATE-S-LF :NP 2 :VP 19))19 ((VP95 VP) (DOWN (5 13 18) (5 22) (5 7 21)) (UP 20)(CREATE-VP-LF :VERB 5 :OBJ1 13 :PP+ 18 :SUBCAT 'TRANS)(CREATE-VP-LF :VERB 5 :OBJ1 22 :SUBCAT 'TRANS)(CREATE-VP-LF :VERB 5 :OBJ1 7 :PP+ 21 :SUBCAT 'TRANS))18 ((PP+84 PP+) (DOWN (17)) (UP 19 21 23) (CREATE-PP+-LF :PP 17))17 ((PP79 PP) (DOWN (14 16)) (UP 18) (CREATE-PP-LF :PREP 14 :OBJ 16))16 ((NP76 NP) (DOWN (15)) (UP 17) (CREATE-PROPERNOUN-LF :PROPERNOUN 15))15 ((BILL6 PROPERNOUN BILL) (DOWN T) (UP 16))14 ((WITH5 PREP WITH) (DOWN T) (UP 17))13 ((NP56 NP) (DOWN (6 12)) (UP 19) (CREATE-NP-LF :NOUN 6 :POSTNOUN-MODS 12))12 ((PP+31 PP+) (DOWN (11)) (UP 13) (CREATE-PP+-LF :PP 11))11 ((PP26 PP) (DOWN (8 10)) (UP 12 21) (CREATE-PP-LF :PREP 8 :OBJ 10))10 ((NP23 NP) (DOWN (9)) (UP 11) (CREATE-NP-LF :NOUN 9))9 ((CARS4 NOUN CAR) (DOWN T) (UP 10 23))8 ((IN3 PREP IN) (DOWN T) (UP 11 24))7 ((NP10 NP) (DOWN (6)) (UP 19) (CREATE-NP-LF :NOUN 6))6 ((FROGS2 NOUN) (DOWN T) (UP 7 13 22))5 ((VERBS7 VERBS) (DOWN (4)) (UP 19) (CREATE-VERBS-LF :VERBS 4))4 ((TENSED-MAIN4 TENSED-MAIN) (DOWN (3)) (UP 5) (CREATE-VERB-ONLY-LF :VERB 3))3 ((SAW1 VERB SEE) (DOWN T) (UP 4))2 ((NP1 NP) (DOWN (1)) (UP 20) (CREATE-PROPERNOUN-LF :PROPERNOUN 1))1 ((FRED0 PROPERNOUN) (DOWN T) (UP 2))Figure 6Method 3: Store procedure calls to create logical forms in the packed forest.Number Number Forest Size Forest Size Forest Size Forest Sizeof PPs of Parses for No LF for Method 1 for Method 2 for Method 30 1 1,184 (11) 3,450 (11) 3,450 (11) 1,353 (11)1 2 1,803 (19) 9,971 (21) 9,748 (19) 2,200 (19)2 5 2,660 (30) 32,043 (42) 30,704 (30) 3,370 (30)3 14 3,703 (44) 108,291 (93) 107,716 (44) 5,043 (44)4 42 5,003 (61) 389,499 (233) 388,671 (61) 7,114 (61)5 132 6,526 (81) 1,477,644 (651) 1,475,418 (81) 9,658 (81)Figure 7The size of the parse forest in bytes and number of nodes for each method.F igure 6.
Keyword  parameters  are used  to make the procedure  calls more  meaningfu l .Once the parse forest is complete,  the logical  form for any  node  can be created byeva luat ing  the stored procedure  call.
If the node  has mul t ip le  parses,  then mul t ip lelogical  forms wi l l  be created by  the rout ines automatical ly .
Hence,  the logical  formrout ines  used  in this approach  must  be able to combine  proper ly  the mul t ip le  logicalforms for its const i tuents  (just as in the second approach) .
A l l  of the logical  formsfor the sentence can be produced by  eva luat ing  the logical  form rout ine stored wi ththe S-MAJ, resul t ing in a potent ia l ly  large number  of representat ions.
However ,  sincethe procedure  calls s tored wi th  any of the nodes  in the forest can be eva luated  asneeded,  the program is able to generate and  examine  on ly  the representat ions  of658Mary P. Harper Storing Logical Form in a Shared-Packed Forestthe constituents associated with points of ambiguity.
This feature can be used by asemantic processing module to determine which of the NPs in the forest make sensegiven the world model.
For example, in Figure 6, the head nouns in nodes 6 and 9have pointers to five different NPs, whose logical forms can be created and testedagainst he model.
This approach is somewhat reminiscent of the freeze predicate inlogic programming, which specifies that some logic clauses hould be solved only afterothers have already been solved.
In our system, however, the order of evaluation canbe dynamic and context dependent.The previously described methods for generating logical form were each imple-mented and evaluated.
Figure 7 compares the memory size of the forests in bytes alongwith the number of nodes generated in the forest (shown in parentheses) for each ofthe three methods.
The ambiguity in all cases resulted from PP attachment.
The num-ber of nodes and the size of the forest when no logical representation is constructedhave also been included as a baseline.
The third method is superior to the other twomethods for the following reasons: the forest contains the same number of nodes asthe original forest without logical form; the size of the forest augmented with logicalform is much closer to the size of the original forest; and the logical forms for any ofthe nodes in the forest can still be accessed by executing the function call(s) stored inthat node, providing a flexible tool for higher level processing.4.
ConclusionWe have modified an all-path context-free grammar parser to generate a shared-packedparse forest hat provides useful information on the points of ambiguity in a sentence.This forest was also augmented with function calls to construct logical representationsfor the constituents of the forest, providing a compact data structure that containsmultiple sentence parses and access to their corresponding logical representations.Once constructed, this annotated shared-packed parse forest can be utilized by a higherlevel module to provide logical representations for pieces of the sentence or for theentire sentence.
In case of ambiguity, representations for the ambiguous constituentsof the sentence can be constructed and tested for validity against a world model, andthe annotated forest can then be pruned incrementally.AcknowledgmentsThis work was supported in part by PurdueResearch Foundation and NSF grantnumber IRI-9011179.
I would also like tothank Paul Harper and Carl Mitchell fortheir critical reading of this paper and thereferees for their helpful comments.ReferencesAlshawi, Hiyan (1990).
"Resolving quasilogical forms."
Computational Linguistics16:133-144.Alshawi, Hiyan, and Crouch, Richard(1992).
"Monotonic semanticinterpretation."
In Proceedings, 30th AnnualMeeting of the Association for ComputationalLinguistics, 32-39.Briscoe, Edward J.
(1987).
Modelling HumanSpeech Comprehension: A ComputationalApproach.
Ellis Horwood and Wiley.Briscoe, Ted, and Carroll, John (1993).
"Generalized probabilistic LR parsing ofnatural language (corpora) withunification-based grammars.
"Computational Linguistics 19:25-59.Chester, Daniel (1980).
"A parsing algorithmthat extends phrases."
American Journal ofComputational Linguistics 6:87-96.Church, Kenneth, and Patil, Ramesh (1982).
"Coping with syntactic ambiguity or howto put the block in the box on the table.
"Computational Linguistics 8:139-149.Earley, Jay C. (1970).
"An efficientcontext-free parsing algorithm.
"Communications of the ACM, 13:94-102.Harper, Mary P. (1990).
"The representationof noun phrases in logical form.
"Doctoral dissertation, Brown University,Providence, Rhode Island.Harper, Mary P. (1992).
"Ambiguous nounphrases in logical form."
Computational659Computational Linguistics Volume 20, Number 4Linguistics 18:419-465.Hirst, Graeme (1987).
Semantic Interpretationand the Resolution of Ambiguity.
Cambridge:Cambridge University Press.Kay, Martin (1980).
"Algorithm schemataand data structures in syntacticprocessing."
Technical Report CSL-80-12,Xerox Corporation, Palo Alto, California.Knuth, Donald E. (1975)o The Art of ComputerProgramming, Volume I. Reading,Massachusetts: Addison-Wesley.Marcus, Mitchell P., Hindle, Donald, andFleck, Margaret (1983).
"D-theory: Talkingabout talking about trees."
In Proceedings,21st Annual Meeting of the Association forComputational Linguistics, 129-136.Nederhof, Mark-Jan (1993).
"Generalizedlefbcorner parsing."
In Proceedings, SixthConference ofthe European Chapter of theAssociation for Computational Linguistics,305-314.Schabes, Yves (1991).
"Polynomial time andspace shift-reduce parsing of arbitrarycontext-free grammars."
In Proceedings,29th Annual Meeting of the Association forComputational Linguistics, 106-113.Seo, Jungyun, and Simmons, Robert F.(1989).
"Syntactic graphs: Arepresentation for the union of allambiguous parse trees."
ComputationalLinguistics 15:19-32.Tomita, Masaru (1985).
Efficient Parsing forNatural Language.
Boston: KluwerAcademic Publishers.Tomita, Masaru (1987).
"An efficientaugmented context-free parsingalgorithm."
Computational Linguistics13:31-46.Weischedel, Ralph (1989).
"A hybridapproach to representation in the JANUSnatural language processor."
InProceedings, 27th Annual Meeting of theAssociation for Computational Linguistics,193-202.660
