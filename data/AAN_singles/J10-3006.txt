Complexity, Parsing, and Factorizationof Tree-Local Multi-ComponentTree-Adjoining GrammarRebecca Nesson?School of Engineering and AppliedSciences,Harvard UniversityGiorgio Satta?
?Department of Information EngineeringUniversity of PaduaStuart M. Shieber?School of Engineering and AppliedSciencesHarvard UniversityTree-Local Multi-Component Tree-Adjoining Grammar (TL-MCTAG) is an appealing formal-ism for natural language representation because it arguably allows the encapsulation of theappropriate domain of locality within its elementary structures.
Its multicomponent structureallows modeling of lexical items that may ultimately have elements far apart in a sentence, suchas quantifiers and wh-words.
When used as the base formalism for a synchronous grammar, itsflexibility allows it to express both the close relationships and the divergent structure necessaryto capture the links between the syntax and semantics of a single language or the syntax oftwo different languages.
Its limited expressivity provides constraints on movement and, weposit, may have generated additional popularity based on a misconception about its parsingcomplexity.Although TL-MCTAG was shown to be equivalent in expressivity to TAG when it wasfirst introduced, the complexity of TL-MCTAG is still not well understood.
This article offersa thorough examination of the problem of TL-MCTAG recognition, showing that even highlyrestricted forms of TL-MCTAG are NP-complete to recognize.
However, in spite of the provabledifficulty of the recognition problem, we offer several algorithms that can substantially improveprocessing efficiency.
First, we present a parsing algorithm that improves on the baseline parsing?
School of Engineering and Applied Sciences, Harvard University, 38 Plymouth St., Cambridge, MA02141.
E-mail: nesson@seas.harvard.edu.??
Department of Information Engineering, University of Padua, via Gradenigo 6/A, 1-35131 Padova, Italy.E-mail: satta@dei.unipd.it.?
School of Engineering and Applied Sciences, Harvard University, Maxwell Dworkin Laboratory,33 Oxford Street, Cambridge, MA 02138.
E-mail: shieber@seas.harvard.edu.Submission received: 4 November 2008; revised submission received: 13 November 2009; accepted forpublication: 18 March 2010.?
2010 Association for Computational LinguisticsComputational Linguistics Volume 36, Number 3method and runs in polynomial time when both the fan-out and rank of the input grammar arebounded.
Second, we offer an optimal, efficient algorithm for factorizing a grammar to produce astrongly equivalent TL-MCTAG grammar with the rank of the grammar minimized.1.
IntroductionTree-Local Multi-Component Tree-Adjoining Grammar (TL-MCTAG) is an appealingformalism for natural language representation because it arguably allows the encapsu-lation of the appropriate domain of locality within its elementary structures (Kallmeyerand Romero 2007).
Its flexible multicomponent structure allows modeling of lexicalitems that may ultimately have elements far apart in a sentence, such as quantifiers andwh-words.
Its limited expressivity provides constraints on movement and, we posit,may have generated additional popularity based on a misconception about its parsingcomplexity.TL-MCTAG can model highly structurally divergent but closely related elementarystructures, such as the syntax and the semantics of a single word or construction or thesyntax of a single word or construction and its translation into another language, with apair of elementary trees.
This flexibility permits conceptually simple, highly expressive,and tightly coupled modeling of the relationship between the syntax and semantics ofa language or the syntax and semantics of two languages.
As a result, it has frequentlybeen put to use in a growing body of research into incorporating semantics into the Tree-Adjoining Grammar (TAG) framework (Kallmeyer and Joshi 2003; Han 2006; Nessonand Shieber 2006, 2007).
It is also under investigation as a possible base formalismfor use in synchronous-grammar based machine translations systems (Nesson 2009).Similar pairing of elementary structures of the TAG formalism is too constrained tocapture the inherent divergence in structure between different languages or even be-tween the syntax and semantics of a language.
Pairing of more expressive formalisms istoo flexible to provide appropriate constraints and has unacceptable consequences forprocessing efficiency.Although TL-MCTAG was first introduced by Weir (1988) and shown at that timeto be equivalent in expressivity to TAG, the complexity of TL-MCTAG is still notwell understood.
Perhaps because of its equivalence to TAG, questions of processingefficiency have not been adequately addressed.
This article offers a thorough exami-nation of the problem of TL-MCTAG recognition, showing that even highly restrictedforms of TL-MCTAG are NP-complete to recognize.
However, in spite of the provabledifficulty of the recognition problem, we offer several algorithms that can substantiallyimprove processing efficiency.
First, we present a parsing algorithm that improveson the baseline parsing method and runs in polynomial time when both the fan-out(the maximum number of trees in a tree set) and rank (the maximum number oftrees that may be substituted or adjoined into a given tree) of the input grammar arebounded.
Second, we offer an optimal, efficient algorithm for factorizing a grammarto produce a strongly equivalent TL-MCTAG grammar with the rank of the grammarminimized.1.1 Summary of ResultsTAG is a mildly context-sensitive grammar formalism widely used in natural languageprocessing.
Multicomponent TAG (MCTAG) refers to a group of formalisms that444Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGgeneralize TAG by allowing elementary structures to be sets of TAG trees.
One memberof the MCTAG formalism group is Tree-Local MCTAG (TL-MCTAG), in which alltrees from a single elementary tree set are constrained to adjoin or substitute into asingle tree in another elementary tree set.
Weir (1988) shows that this constraint issufficient to guarantee that TL-MCTAG has weak generative capacity equivalent to thepolynomially parsable TAG.Recent work on the complexity of several TAG variants has demonstrated indirectlythat the universal recognition problem for TL-MCTAG is NP-hard.
This result callsinto question the practicality of systems that employ TL-MCTAG as the formalism forexpressing a natural language grammar.
In this article we present a more fine-grainedanalysis of the processing complexity of TL-MCTAG.
We demonstrate (Section 3) thateven under restricted definitions where either the rank or the fan-out of the grammar isbounded, the universal recognition problem is NP-complete.We define a novel variant of multi-component TAG formalisms that treats theelementary structures as vectors of trees rather than as unordered sets (Section 4).
Wedemonstrate that this variant of the definition of the formalism (the vector definition) isconsistent with the linguistic applications of the formalism presented in the literature.Universal recognition of the vector definition of TL-MCTAG is NP-complete whenboth the rank and fan-out are unbounded.
However, when the rank is bounded, theuniversal recognition problem is polynomial in both the length of the input string andthe grammar size.We present a novel parsing algorithm for TL-MCTAG (Section 5) that accommo-dates both the set and vector definitions of TL-MCTAG.
Although no algorithms forparsing TL-MCTAG have previously been published, the standard method for parsinglinear context-free rewriting systems (LCFRS)?equivalent formalisms can be applieddirectly to TL-MCTAG to produce a quite inefficient baseline algorithm in which thepolynomial degree of the length of the input string depends on the input grammar.We offer an alternative parser for TL-MCTAG in which the polynomial degree of thelength of the input string is constant, though the polynomial degree of the grammar sizedepends on the input grammar.
This alternative parsing algorithm is more appealingthan the baseline algorithm because it performs universal recognition of TL-MCTAG(vector definition) with constant polynomial degree in both the length of the input stringand the grammar size when rank is bounded.It may not be generally desirable to impose an arbitrary rank bound on TL-MCTAGsto be used for linguistic applications.
However, it is possible given a TL-MCTAG tominimize the rank of the grammar.
In the penultimate section of the paper (Section 6)we offer a novel and efficient algorithm for transforming an arbitrary TL-MCTAG intoa strongly equivalent TL-MCTAG where the rank is minimized.1.2 Related WorkOur work on TL-MCTAG complexity bears comparison to that of several others.Kallmeyer (2009) provides a clear and insightful breakdown of the different charac-teristics of MCTAG variants and the effect of these characteristics on expressivity andcomplexity.
That work clarifies the definitions of MCTAG variants and the relationshipbetween them rather than presenting new complexity results.
However, it suggeststhe possibility of proving results such as ours in its assertion that, after a standardTAG parse, a check of whether particular trees belong to the same tree set cannotbe performed in polynomial time.
Kallmeyer also addresses the problem of parsing445Computational Linguistics Volume 36, Number 3MCTAG, although not specifically for TL-MCTAG.
The method proposed differs fromours in that MCTAGs are parsed first as a standard TAG, with any conditions on treeor set locality checked on the derivation forest as a second step.
No specific algorithmis presented for performing the check of tree-locality on a TAG derivation forest, so it isdifficult to directly compare the methods.
However, that method cannot take advantageof the gains in efficiency produced by discarding inappropriate partial parses at thetime that they are first considered.
Aside from Kallmeyer?s work, little attention hasbeen paid to the problem of directly parsing TL-MCTAG.S?gaard, Lichte, and Maier (2007) present several proofs regarding the complexityof the recognition problem for some linguistically motivated extensions of TAG that aresimilar to TL-MCTAG.
Their work shows the NP-hardness of the recognition problemfor these variants and, as an indirect result, also demonstrates the NP-hardness of TL-MCTAG recognition.
This work differs from ours in that it does not directly show theNP-hardness of TL-MCTAG recognition and does not further locate and constrain thesource of the NP-hardness of the problem to the rank of the input grammar, nor does itprovide mitigation through rank reduction of the grammar or by other means.Our work on TL-MCTAG factorization is thematically though not formally relatedto the body of work on induction of TAGs from a treebank exemplified by Chen andShanker (2004).
The factorization performed in their work is done on the basis of syn-tactic constraints rather than with the goal of reducing complexity.
Working from atreebank of actual natural language sentences, their work does not have the benefit ofexplicitly labeled adjunction sites but rather must attempt to reconstruct a derivationfrom complete derived trees.The factorization problem we address is more closely related to work on factorizingsynchronous context-free grammars (CFGs) (Gildea, Satta, and Zhang 2006; Zhang andGildea 2007) and on factorizing synchronous TAGs (Nesson, Satta, and Shieber 2008).Synchronous grammars are a special case of multicomponent grammars, so the prob-lems are quite similar to the TL-MCTAG factorization problem.
However, synchronousgrammars are fundamentally set-local rather than tree-local formalisms, which in somecases simplifies their analysis.
In the case of CFGs, the problem reduces to one ofidentifying problematic permutations of non-terminals (Zhang and Gildea 2007) andcan be done efficiently by using a sorting algorithm to binarize any non-problematic per-mutations until only the intractable correspondences remain (Gildea, Satta, and Zhang2006).
This method is unavailable in the TAG case because the elementary structuresmay have depth greater than one and therefore the concept of adjacency relied uponin their work is inapplicable.
The factorization algorithm of Nesson, Satta, and Shieber(2008) is the most closely related to this one but is not directly applicable to TL-MCTAGbecause each link is presumed to have exactly two locations and all adjunctions occurin a set-local rather than tree-local manner.2.
Technical BackgroundA tree-adjoining grammar consists of a set of elementary tree structures of arbitrarydepth, which are combined by the operations of adjunction and substitution.
Auxiliarytrees are elementary trees in which the root and a frontier node, called the foot nodeand distinguished by the diacritic ?, are labeled with the same nonterminal A. Theadjunction operation entails splicing in an auxiliary tree in an internal node withinan elementary tree also labeled with nonterminal A.
Trees without a foot node, whichserve as a base case for derivations and may combine with other trees by substitution,446Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGare called initial trees.
Examples of the adjunction and substitution operations aregiven in Figure 1.
For further background, we refer the reader to the survey by Joshiand Schabes (1997).A TAG derivation can be fully specified by a derivation tree, which records howthe elementary structures are combined using the TAG operations to form the derivedtree.
The nodes of the derivation tree are labeled by the names of the elementary treesand the edges are labeled by the addresses at which the child trees substitute or adjoin.In contrast to CFGs, the derivation and derived trees are distinct.We depart from the traditional definition in notation only by specifying adjunc-tion sites explicitly with numbered links in order to simplify the presentation of theissues raised by multi-component adjunctions.
Each link may be used only once in aderivation.
Adjunctions may only occur at nodes marked with a link.
A numbered linkat a single site in a tree specifies that a single adjunction is available at that site.
Anobligatory adjunction constraint indicates that at least one link at a given node mustbe used (Joshi, Levy, and Takahashi, 1975; Vijay-Shanker and Joshi 1985).
We notateobligatory adjunction constraints by underlining the label of the node to which theconstraint applies.
Because we use explicit links, the edges in the derivation tree arelabeled with the number of the link used rather than the traditional label of the addressat which the operation takes place.Multiple adjunction refers to permitting an unbounded number of adjunctions tooccur at a single adjunction site (Vijay-Shanker 1987; Shieber and Schabes 1994).
Inthe standard definition of TAG, multiple adjunction is disallowed to ensure that eachderivation tree unambiguously specifies a single derived tree (Vijay-Shanker 1987).
Be-cause each available adjunction is explicitly notated with a numbered link, our notationimplicitly disallows multiple adjunction but permits a third possibility: bounded mul-tiple adjunction.
Bounded multiple adjunction permits the formalism to obtain someof the potential linguistic advantages of allowing multiple adjunction while preventingunbounded multiple adjunction.
The usual constraint of allowing only one adjunctionat a given adjunction site may be enforced in our link notation by permitting only onelink at a particular link site to be used.MCTAG generalizes TAG by allowing the elementary items to be sets of trees ratherthan single trees (Joshi and Schabes 1997).
The basic operations are the same but all treesin a set must adjoin (or substitute) into another tree set in a single step in the derivation.To allow for multi-component adjunction, a numbered link may appear on two or morenodes in a tree, signifying that the adjoining trees must be members of the same treeset.
Any tree in a set may adjoin at any link location if it meets other adjunction orsubstitution conditions such as a matching node label.
Thus a single multicomponentFigure 1An example of TAG operations substitution and adjunction used here to model naturallanguage syntax.447Computational Linguistics Volume 36, Number 3Figure 2An example of the way in which two tree sets may produce several different derived trees whencombined under the standard definition of multicomponent TAG.link may give rise to many distinct derived trees even when the link is always usedby the same multicomponent tree set.
An example is given in Figure 2.
This standarddefinition of multicomponent adjunction we will call the set definition for contrast witha variation we introduce in Section 4.
A derivation tree for a multicomponent TAG isthe same as for TAG except that the nodes are labeled with the names of elementarytree sets.An MCTAG is tree-local if tree sets are required to adjoin within a single elementarytree (Weir 1988).
Using the numbered link notation introduced earlier for adjunctionsites, a tree-local MCTAG (TL-MCTAG) is one in which the scope of the link numbersis a single elementary tree.
An example TL-MCTAG operation is given in Figure 3.
Incontrast, an MCTAG is set-local if the trees from a single tree set are required to adjoinwithin a single elementary tree set and an MCTAG is non-local if the trees from a singletree set may adjoin to trees that are not within a single tree set.
In a set-local MCTAGthe scope of a link is a single elementary tree set, and in a non-local MCTAG the scopeof a link is the entire grammar.Weir (1988) noted in passing that TL-MCTAG has generative capacity equivalent toTAG; a combination of well-chosen additional constraints and additions of duplicatesof trees to the grammar can produce a weakly equivalent TAG.
Alternatively, a feature-based TAG where the features enforce the same constraints may be used.
Although thegenerative capacity of the formalism is not increased, any such conversion from TL-MCTAG to TAG may require an exponential increase in the size of the grammar as weprove in Section 3.3.
ComplexityWe present several complexity results for TL-MCTAG.
S?gaard, Lichte, and Maier (2007)show indirectly that TL-MCTAG membership is NP-hard.
For clarity, we present a directFigure 3An example TL-MCTAG operation demonstrating the use of TL-MCTAG to model wh-questionsyntax.448Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGproof here.
We then present several novel results demonstrating that the hardness resultholds under significant restrictions of the formalism.For a TL-MCTAG G we write |G| to denote the size of G, defined as the total numberof nodes appearing in all elementary trees in the tree sets of the grammar.
Fan-out, f ,measures the number of trees in the largest tree set in the grammar.
We show that evenwhen the fan-out is bounded to a maximum of two, the NP-hardness result still holds.The rank, r, of a grammar is the maximum number of derivational children possiblefor any tree in the grammar, or in other words, the maximum number of links in anytree in the grammar.
We show that when rank is bounded, the NP-hardness result alsoholds.A notable aspect of all of the proofs given here is that they do not make use ofthe additional expressive power provided by the adjunction operation of TAG.
Putsimply, the trees in the tree sets used in our constructions meet the constraints of TreeInsertion Grammar (TIG), a known context-free?equivalent formalism (Schabes andWaters 1995).
As a result, we can conclude that the increase in complexity stems fromthe multi-component nature of the formalism rather than from the power added by anunconstrained adjunction operation.3.1 Universal Recognition of TL-MCTAG is NP-CompleteIn this section we prove that universal recognition of TL-MCTAG is NP-complete whenneither the rank nor the fan-out of the grammar is bounded.Recall the 3SAT decision problem, which is known to be NP-complete.
Let V ={v1, .
.
.
, vp} be a set of variables and C = {c1, .
.
.
, cn} be a set of clauses.
Each clause in Cis a disjunction of three literals over the alphabet of all literals LV = {v1, v1, .
.
.
, vp, vp}.We represent each clause by a set of three literals.
The language 3SAT is defined as theset of all conjunctive formulas over the members of C that are satisfiable.Theorem 1The universal recognition problem for TL-MCTAG with unbounded rank and fan-outis NP-hard.ProofLet ?V, C?
be an arbitrary instance of the 3SAT problem.1 We use the derivations of thegrammar to guess the truth assignments for V and use the tree sets to keep track of thedependencies among different clauses in C. Two tree sets are constructed for each vari-able, one corresponding to an assignment of true to the variable and one correspondingto an assignment of false.
The links in the single initial tree permit only one of these twosets to be used.
The tree set for a particular truth assignment for a particular variable vimakes it possible to introduce, by means of another adjunction, terminal symbols takenfrom the set {1, .
.
.
, n} that correspond to each clause in C that would be satisfied by thegiven assignment to vi.
In this way, the string w = 1 ?
?
?
n can be generated if and only ifall clauses are satisfied by the truth assignment to some variable they contain.1 We follow the proof strategy of Satta and Peserico (2005) in this and the proof of Theorem 3.449Computational Linguistics Volume 36, Number 3We define a tree-local MCTAG G containing the following tree sets.
The initial treeset S contains the single tree:In this tree, the ?rows?
correspond to the variables and the ?columns?
to the clauses.Each non-terminal node within a row is labeled with the same link to ensure that a treeset representing a single variable?s effect on each clause will adjoin at each link.For every variable vi, 1 ?
i ?
p, tree set Ti, used when representing an assignment ofthe value true to vi, contains n trees, one for each clause cj, 1 ?
j ?
n, defined as follows:For every variable vi, 1 ?
i ?
p, tree set Fi ?
used when representing an assignmentof the value false to vi ?
contains n trees, one for each clause cj, 1 ?
j ?
n, defined asfollows:For every clause cj, 1 ?
j ?
n, tree set Cj contains a single tree as shown here.
Thistree allows the corresponding clause number terminal symbol to be recognized by anappropriate variable instance.22 Note that because adjunction is not obligatory, the tree from Cj need not adjoin into the tree for aparticular variable.
In fact, to generate w, exactly one instance of Cj must adjoin for each clause even ifmore than one variable satisfies the clause.
If w can be generated, however, we can conclude that at leastone variable must have satisfied each clause.450Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGFrom the definition of G it directly follows that w ?
L(G) implies the existence of atruth assignment that satisfies C. A satisfying truth assignment can be read directly offof any derivation tree for w. If Ti (respectively, Fi) is a child of S in the derivation tree,then vk is true (respectively, false).
The converse can be shown by using a satisfyingtruth assignment for C to construct a derivation for w ?
L(G).
?G, w?
can be constructed in deterministic polynomial time because the number oftree sets in the grammar is 2p + 2n + 1, the total number of trees in the grammar isbounded by n(2p + 2n + 1), and the length of w is n. All trees in the grammar haveconstant size except for the initial tree, which has size np.
Theorem 2The universal recognition problem for TL-MCTAG with unbounded rank and fan-outis in NP.ProofWe show that given an arbitrary TL-MCTAG grammar G and any input string w, thedetermination of w ?
L(G) can be performed in non-deterministic polynomial time.Note that the collection of elementary tree sets of G that can generate the emptystring, E , can be generated in time polynomial in |G| using the standard graph reach-ability algorithm used for context-free grammars in time polynomial in |G| (Sippu andSoisalon-Soininen 1988).We begin by showing that given an arbitrary input string w and derivation tree Dfor w ?
L(G), there must exist a truncated derivation tree for w that has size no largerthan |G| ?
|w|.
We define a truncated derivation tree as a derivation tree in which thechildren of elementary tree sets in E are optionally removed.Consider D. Each node in D represents an elementary structure of G: a tuple ofone or more TAG trees.
We call a node n of D a non-splitting node if a single oneof its children in the derivation tree, ni, generates the same lexical material from theinput string as n itself.3 We call it a splitting node if more than one of its childrengenerates a non-empty part of the portion of the input string generated by n itselfor if n itself contributes lexical material.
We proceed from the root of D examiningchains of non-splitting nodes.
Assume that the root of D is a non-splitting node.
Thismeans that it has a single child node, ni, that generates the lexical material for the entireinput string.
Its other children all generate the empty string (and therefore must also bemembers of E).
We truncate the derivation tree at each child of n other than ni.
We nowiterate the process on node ni.
If during the examination of a chain of non-splittingnodes we encounter a node identical to one that we have already seen, we removethe entire cycle from the derivation tree because it is not essential to the derivation.Because all cycles are removed, the longest possible chain of non-splitting nodes wecan find before encountering a splitting node or reaching the bottom of the derivationtree is |G|.If a splitting node is encountered, we truncate all child nodes that generate theempty string and then iterate the process of non-splitting node identification on those3 The child tree tuple ni may generate the same lexical material in several distinct pieces, which arearranged into the string generated by n when the adjunction occurs.
Because the adjunction necessarilyconnects all of these pieces into a single string in a single predetermined way, it does not matter for ourproof that the lexical material derived by the child may be in any order before the adjunctions.451Computational Linguistics Volume 36, Number 3children that generate lexical material.
In the worst case, the process encounters w ?
1splitting nodes, each of which may be separated by a chain of non-splitting nodesof maximum length bounded by |G|.
This process, therefore, produces a truncatedderivation tree with size bounded by |G| ?
|w|.The truncation of the tree at each node that generates the empty string is necessarybecause the size of the subderivation tree generating the empty string may not bebounded by a polynomial in the size of the grammar.
However, the content of the partof the derivation tree used to generate the empty string is not necessary for determiningmembership of w ?
L(G) because we know that each truncated node is a member of E .To show that TL-MCTAG membership is in NP, we construct a Turing machinethat will non-deterministically guess a truncated derivation tree of size no larger than|G| ?
|w|.
It then checks that the guessed derivation successfully derives w. Because thecorrectness of the derivation can be checked in linear time, this is sufficient to show thatTL-MCTAG membership is in NP.
We know from the equivalence of LCFRS and SL-MCTAG (and the rule-to-tree-tuple conversion method used to prove equivalency) (Weir 1988) and the fact thatLCFRS membership is PSPACE-complete that SL-MCTAG membership is also PSPACE-complete (Kaji et al 1992, 1994).
Until the results shown in Theorems 1 and 2 it wasnot known whether TL-MCTAG was in NP.
Although the difference in generativecapacity between TL-MCTAG and SL-MCTAG is well known, this proven differencein complexity (assuming NP = PSPACE) is novel.To understand the reason underlying the difference, we note that the bound on thelength of non-splitting chains does not hold for set-local MCTAG.
In set-local MCTAGa tree tuple may be non-splitting while also performing a permutation of the order ofthe lexical output generated by its children.
Permutation is possible because set-localityallows the tuple of strings generated by a tree tuple to be held separate for an arbitrarynumber of steps in a derivation.
This directly follows the basis of the reasoning of Kajiet al (1992) in their proof that LCFRS is PSPACE-complete.3.2 Universal Recognition of TL-MCTAG with Bounded Fan-Out is NP-CompleteThe grammar constructed in the proof of Theorem 1 has fan-out n, the number ofclauses.
However, the hardness result proved herein holds even if we restrict tree setsto have at most two elements (TL-MCTAG(2)).4 The result provided here is as tightas possible.
If tree sets are restricted to a maximum size of one (TL-MCTAG(1)), theformalism reduces to TAG and the hardness result does not hold.Theorem 3The universal recognition problem for TL-MCTAG(2) with fan-out limited to two andunbounded rank is NP-complete.ProofLet ?V, C?
be an arbitrary instance of the 3SAT problem.
We define a more complexstring w = w(1)w(2) ?
?
?w(p)wc where wc is a representation of C and w(i) controls the truthassignment for the variable vi, 1 ?
i ?
p. The proof strategy is as follows.
We construct4 We use the postfix (2) to indicate the restriction on the fan-out.452Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGa TL-MCTAG(2) grammar G such that each w(i) can be derived from G in exactly twoways using the left members of tree sets of size 2 that correspond to the variables (and asingle initial tree set of size 1).
We call the part of w comprising w(1)w(2) ?
?
?w(p) the prefixstring.
The prefix string enforces the constraint of permitting only two derivations byrequiring a strictly alternating string of terminal symbols that can only be generatedby the grammar when the truth assignment is stable for a particular variable.
Thederivation of the prefix string w(1)w(2) ?
?
?w(p) therefore corresponds to a guess of a truthassignment for V. The right trees from the tree sets derive the components of wc that arecompatible with the guessed truth assignments for v1, .
.
.
, vp.
Subsequently we explainhow ?G, w?
is constructed given an instance of 3SAT ?V, C?.For every variable vi, 1 ?
i ?
p, let Ai = {cj | vi ?
cj} and Ai = {cj | vi ?
cj} be thesets of clauses in which vi occurs positively and negatively, respectively; let alo mi =|Ai| + |Ai| be the number of occurrences of the variable vi.
Let ??
= {ai, bi | 1 ?
i ?
p}be an alphabet of not already used symbols; let w(i) (again for 1 ?
i ?
p) denote asequence of mi + 1 alternating symbols ai and bi such that if mi is even w(i) = (aibi)mi/2aiand if mi is odd w(i) = (aibi)(mi+1)/2.
We define three functions, ?, ?, and ?, to aid inthe construction.
The functions ?
and ?
are used to produce pieces of the prefix stringand will only produce the correct prefix string for a variable if the truth assignment isconsistent within the derivation.
The function ?
is used to produce strings representingthe clauses satisfied by a particular truth assignment to a variable.
For every variablevi, 1 ?
i ?
p, the clauses ?
(i, 1), ?
(i, 2), .
.
.
, ?
(i, |Ai|) are all the clauses in Ai and theclauses ?
(i, |Ai| + 1), .
.
.
, ?
(i, mi) are all the clauses in Ai.
Further, for every 1 ?
i ?
p, let?
(i, 1) = aibi and let ?
(i, h) = ai if h is even and ?
(i, h) = bi if h is odd, for 2 ?
h ?
mi.
Forevery 1 ?
i ?
p, let ?
(i, h) = ai if h is odd, and ?
(i, h) = bi if h is even for 1 ?
h ?
mi ?
1and let ?
(i, mi) = aibi if mi is odd and biai if mi is even.
The crucial property of ?
and?
is that a string w(i) can be parsed either as a sequence of ?
(i, ?)
or ?
(i, ?)
strings, notintermixed elements.
The grammar must ?commit?
to parsing the string one way or theother, corresponding to committing to a value for the variable vi.We define a TL-MCTAG(2) G to consist of the tree sets described herein.
We con-struct: (1) a tree set of length two for each combination of a variable and clause that thevariable can satisfy under some truth assignment, (2) two filler tree sets for each variable(one for each truth assignment) of length two that only contribute the string indicatingthe truth assignment of the variable but no satisfied clause, and (3) a singleton treeset containing only an initial tree rooted in S. The initial tree has n + 1 branches withthe first branch intended to yield the prefix string w(1) ?
?
?w(p) and the (k + 1)-st branchintended to yield ck where 1 ?
k ?
n. Although it is possible to generate strings not ofthe form of w using this construction, given a pair ?G, w?
where w respects the definitionabove, we show that w ?
L(G) if and only if C is satisfiable.The initial tree set S contains the single tree pictured in Figure 4.5 The name of eachlink in the initial tree set is composed of three indices that indicate the role of the link.The first index, i, corresponds to variable vi.
The second is an index into the series 1 ?
?
?miwhere mi is defined from vi as described previously.
The third index, j, corresponds to aclause cj.
The use of multiple indices to name the links is for clarity only.
They may berenamed freely.5 Although we permit the presence of multiple links at a single node in the S tree, we follow the usual TAGconvention of disallowing multiple adjunction.
If one of the links at a node is used, the other links at thatnode are assumed to be unavailable in the derivation.453Computational Linguistics Volume 36, Number 3Figure 4The start tree for TL-MCTAG(2) grammar G. The multiply-indexed link numbers are for clarityonly and are treated as simple link names.For every variable vi, 1 ?
i ?
p, and index h, 1 ?
h ?
mi: if h ?
|Ai|, tree set T(h)+i contains the following two trees: if h > |Ai|, tree set F(h)+i contains the following two trees:454Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG for all h, tree set T(h)?i contains the following two trees: for all h, tree set F(h)?i contains the following two trees:An illustrative example is provided in Figure 5.
In this example we demonstratederivations of two possible satisfying truth assignments for Boolean formula (x ?
y ?z) ?
(x ?
y ?
z) ?
(y ?
y ?
z).
The truth assignments correspond to whether the T or F treesets are used in the derivation of the prefix string for a particular variable.
As can be seenfrom the example, the structure of the prefix string enforces the requirement that eitherall T tree sets or all F tree sets are chosen for a particular variable.
Each tree set markedwith a + is used to satisfy a single clause.
Which clause a tree set satisfies can be readoff the link number at which it adjoins.Inspection of the grammar and construction of the input string show that |G| and|w| are polynomially related to p and n. The sum of the mi is maximally 3n.
There are noFigure 5Example derivations of two satisfying assignments for the boolean formula(x ?
y ?
z) ?
(x ?
y ?
z) ?
(y ?
y ?
z).455Computational Linguistics Volume 36, Number 3more than 9pn + 1 tree sets and no more than 18pn + 1 total trees.
The size of the initialtree is bounded by 3pn and all other trees have constant size.From a derivation of w ?
L(G) we can find a truth assignment satisfying C byexamining the derivation.
If the tree sets T(h)+i or T(h)?i are children of S for some iand all h where 1 ?
i ?
p and 1 ?
h ?
mi, then vi is true.
If the tree sets F(h)+i or F(h)?iare children of S for some i and all h where 1 ?
i ?
p and 1 ?
h ?
mi, then vi is false.By the construction, if w is of the form just described, for a given variable vi onlytwo derivations of w(i) will be possible, one in which all tree sets corresponding tothat variable are T tree sets and one in which all are F tree sets.
Starting from a truthassignment that satisfies C, we can prove that w ?
L(G) by induction on |V|.That this problem is in NP can be seen from the same reasoning as in the proof ofTheorem 2.
3.3 Universal Recognition of TL-MCTAG with Bounded Rank is NP-CompleteWe now show that universal recognition of TL-MCTAG is NP-complete even when therank is bounded.We briefly recall here the definition of a decision problem called 3PAR.
Let t and si ?t be positive integers, 1 ?
i ?
3m, m ?
1.
The language 3PAR is defined as the set of alltuples ?s1, .
.
.
, s3m, t?, satisfying the following condition: The multiset Q = {s1, .
.
.
, s3m}can be partitioned into multisets Qi, 1 ?
i ?
m, such that for every 1 ?
i ?
m, |Qi| = 3and?s?Qi s = t.Language 3PAR is strongly NP-complete (Garey and Johnson 1979).
This means that3PAR is NP-complete even in case the integers si are all represented in unary notation.Theorem 4The universal recognition problem for TL-MCTAG with rank 1 and unbounded fan-outis NP-complete.ProofWe provide a reduction from 3PAR.6 Let ?s1, .
.
.
, s3m, t?
be an input instance of the 3PARproblem, with all of the integers si represented in unary notation.
Our target grammar Gis defined as follows.
We use a set of nonterminal symbols {S, A}, with S being the startsymbol.
We take the set of terminal symbols to be {a, $}.
G contains two elementarytree sets.
The first set has a single elementary tree ?, corresponding to a context-freeproduction of the form S ?
(AAA$)m?1AAA:6 We follow the proof strategy of Barton (1985) in this proof.456Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGTree ?
has a unique link impinging on all of the 3m occurrences of nonterminalA.
The second (multi)set of G contains elementary trees ?i , 1 ?
i ?
3m.
Each ?i corre-sponds to a context-free production of the form A ?
asi :We also construct a string w = (at$)m?1at.If there exists a partition for multiset Q = {s1, .
.
.
, s3m} satisfying the 3PAR require-ment, we can directly construct a derivation for w in G, by sorting the elementary trees inthe second set accordingly, and by inserting these trees into the link of the elementarytree ?.
Conversely, from any derivation of w in G, we can read off a partition for Qsatisfying the requirement for membership in 3PAR for the input instance of the 3PARproblem.Finally, it is easy to see that G and w can be constructed in linear deterministic timewith respect to the size of the input instance of the 3PAR problem.That this problem is in NP can be seen from the same reasoning as in the proof ofTheorem 2.
3.4 Universal Recognition of TL-MCTAG with Fixed Input String is NP-CompleteWe now show the unusual complexity result that universal recognition of TL-MCTAG isNP-complete even when the input string is fixed.
Although it is uncommon to requirethis result, we rely on it in Section 5 to demonstrate that our parser has better timecomplexity than the baseline parsing method for TL-MCTAG that we generalize fromthe standard parsing method for LCFRS-equivalent formalisms.We reduce from a variant of the 3SAT problem introduced above in which eachvariable occurs in at most four clauses with no repeats in a clause.
This problem wasshown to be NP-complete by Tovey (1984).Theorem 5Universal recognition of TL-MCTAG is NP-complete when the input string is fixed.ProofLet ?V, C?
be an arbitrary instance of the 3SAT problem where each variable occurs inno more than four clauses and does not repeat within a single clause.
As in the proof ofTheorem 1, we use the derivations of the grammar to guess the truth assignments forV and use the tree sets to keep track of the dependencies among different clauses in C.Two tree sets are constructed for each variable, one corresponding to a true assignmentand one corresponding to a false assignment.
The prohibition on multiple adjunctionensures that only one of these two tree sets can be used for each variable.
The tree set ofa particular truth assignment for a particular variable vi makes it possible to satisfy theobligatory adjunction constraints for the nonterminal symbols representing each of theclauses that vi satisfies in the 3SAT formula.7 Additional adjunction sites for each clause7 Obligatory adjunction constraints are standard in the definition of TAG and MCTAG (Joshi, Levy, andTakahashi, 1975; Weir 1988).
However, obligatory adjunction may be avoided in this proof by creating a457Computational Linguistics Volume 36, Number 3provide overflow space in the event that more than one variable satisfies a particularclause.
We fix the input string w to be the empty string.
None of the trees of the grammarcontain any terminal symbols.
However, a successful parse of the empty string can onlybe achieved if all of the obligatory adjunction constraints are satisfied and this occursif and only if all clauses of the formula are satisfied by the truth assignment to somevariable.We define a tree-local MCTAG G containing the following tree sets.
We notateobligatory adjunction constraints by underlining the nodes at which they apply.
Theinitial tree set S contains the single tree:For every variable vi, 1 ?
i ?
p, tree set Ti (respectively, Fi) is used when represent-ing an assignment of the value true (respectively, false) to vi.
Ti (respectively, Fi) containsat most five trees, one for the variable itself and one for each clause cj, 1 ?
j ?
n, suchthat when vi is true (respectively false) cj is satisfied.
More formally, tree set Ti containstrees Vi?
and Cj?
if and only if vi ?
cj, for 1 ?
j ?
n. Tree set Fi contains trees Vi?
and Cj?if and only if vi ?
cj, for 1 ?
j ?
n.Note that the diagram of the initial tree does not show the explicitly notated linklocations that we have used throughout the article.
We omit the link locations to avoidcluttering the diagram.
However, because each variable occurs at most four times in theformula, the total number of links is bounded by pn12.From the definition of G it directly follows that ?
?
L(G) implies the existence of atruth assignment that satisfies C. A satisfying truth assignment can be read directly offof any derivation tree for w. If Ti (respectively, Fi) is a child of S in the derivation tree,then vk is true (respectively, false).
The converse can be shown by using a satisfyingtruth assignment for C to construct a derivation for w ?
L(G).
?G, w?
can be constructed in deterministic polynomial time because the number oftree sets in the grammar is 2p + 1, the total number of trees in the grammar is boundedby n(2p + 1), and the length of w is 0.
All trees in the grammar have constant size exceptfor the initial tree, which has size 3n + p.That this problem is in NP can be seen from the same reasoning as in the proof ofTheorem 2.
larger grammar in which a separate tree set is created for each combination of clauses that may besatisfied by a given variable.
Because each variable may appear in no more than four clauses, thisincreases the number of tree sets in the grammar by 24.
We leave the details of this alternative proofstrategy to the reader.458Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG4.
An Alternative Definition of TL-MCTAG: Tree VectorsThe proof of NP-hardness of TL-MCTAG in the bounded rank case given in Theorem 4depends crucially on the treatment of the elementary structures of the TL-MCTAG asunordered sets.
In order to produce the satisfying partitions for the 3PAR problem, anytree from the second tree set must be able to adjoin at any location of link 1 in the firsttree set.
This is in accordance with the usual definition of multi-component TAG.
Analternative definition of multi-component TAG in which the elementary structures aretreated as vectors is suggested by the explicit use of numbered links at the availableadjunction sites.
Under this definition, each location of a link is also given an index andonly the tree at that index in a given vector may adjoin at that link location.
An examplecontrasting the two definitions is given in Figure 6.The dependence of our bounded-rank proof on the set definition of TL-MCTAGdoes not in itself show that vector-definition TL-MCTAG is polynomial in the boundedrank case.
We show this constructively in Section 5 by presenting a parser for vectordefinition TL-MCTAG for which the polynomial degree of both the length of the in-put string and the grammar size is constant when the rank of the input grammar isbounded.The difference in complexity between the set and vector definitions of TL-MCTAGmakes the vector definition an appealing possibility for research using TL-MCTAG fornatural language applications.
Although all uses of TL-MCTAG in the computationallinguistics literature assume the set definition of TL-MCTAG, the linguistic analysestherein do not require the additional flexibility provided by the set definition (Kallmeyerand Joshi 2003; Nesson and Shieber 2006, 2007; Kallmeyer and Romero 2007; Nesson2009).
This is not a coincidence.
Multicomponent tree sets are generally used to modelsyntactic and semantic constructs in which one tree in the set strictly dominates anotherand has a different syntactic or semantic type: for instance, a quantifier and its boundvariable.
The locations at which the trees in these sets adjoin are not interchangeableboth because of the dominance constraint and because of the difference in type (and,correspondingly, root node label).
As a result, these grammars may be converted to theFigure 6An example contrasting the set definition of MCTAG (shown in Figure 2) with the vectordefinition.459Computational Linguistics Volume 36, Number 3Figure 7The deductive rule generated for tree ?
using the naive TAG parsing method.vector definition without any change in the elementary trees, the generated language, orgrammar size but with crucial gains in the worst case bounds on processing efficiency.85.
ParsingAlthough no algorithms for parsing TL-MCTAG have previously been published, thestandard method for parsing LCFRS-equivalent formalisms can be applied directly toTL-MCTAG to produce an algorithm with complexity O(|G|p|w|q) (Seki et al 1991).
Weoffer a novel parser for TL-MCTAG for which q is constant.
With our algorithm, forthe set definition of TL-MCTAG p depends on both the rank and fan-out of the inputgrammar.
For the vector definition of TL-MCTAG p depends on the rank of the inputgrammar but contains no index of the fan-out.We begin with a brief introduction to TAG parsing before discussing our novel TL-MCTAG parsing algorithm.5.1 CKY-Style TAG ParsingFollowing the method of Seki et al (1991), a naive parser for TAG may be constructedby generating a single inference rule for each tree in the grammar.
For a tree containingr links, the rule will have r antecedents with each antecedent item representing a treethat can adjoin at one of the links.
Each adjoining tree will cover a span of the inputstring that can be represented by four indices, indicating the left and right edges of thespan and of the subspan that will ultimately be dominated by its foot node.
Because thelocation of the links within the consequent tree is known, the indices in the antecedentitems are not entirely independent.
An example is given in Figure 7.
Observation showsthat there will be a worst case of 2(r + 1) independent indices in a given rule.
Becauseeach adjoining tree is independent, there may be r + 1 different trees represented in asingle rule.
This results in a time complexity of O(n2(r+1)|G|r+1) where n is the lengthof the input string, |G| is a representation of the grammar size, and r is the rank of theinput grammar.8 Various sorts of multicomponent TAGs have been proposed for analysis of scrambling (Rambow 1994;Kallmeyer 2005).
Scrambling entails several different trees of the same type adjoining in different orders,and therefore seems like a candidate for making use of the flexibility provided by the set definition.However, in these analyses the elementary tree structures are composed of one VP-rooted auxiliary treeand one VP-rooted initial tree.
Because auxiliary trees and initial trees cannot adjoin at the same linklocation for structural reasons, these analyses do not ultimately make use of the flexibility in the selectionof an adjunction site that the set definition provides.
The different VP-rooted auxiliary trees which couldbenefit from interchanging adjunction sites achieve this flexibility because they appear in different treesets, not because they are members of a single set using the set definition.460Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGFollowing Graham, Harrison, and Ruzzo (1980) in their optimization of the Earleyparser (Earley 1970), the identifiers of specific trees need not be represented in the itemsof the parser.
Rather the tree identifiers may be replaced by the labels of the root nodesof those trees, effectively bundling items of trees that share a root node label and coverthe same span.
This modification to the algorithm reduces the time complexity of theparser to O(n2(r+1)|G|).We refer to this method of reducing complexity by removing unnecessary informa-tion about specific elementary structures from the items of the parser as the GHR opti-mization.
When applied, it reduces the time complexity in the grammar size but doesnot alter the basic form of the time complexity expression.
There remains a single termconsisting of the product of a polynomial in the input string length and a polynomial inthe grammar size.
We will return to this observation when examining the complexity ofTL-MCTAG parsing.Shieber, Schabes, and Pereira (1995) and Vijay-Shanker (1987) apply the Cocke-Kasami-Younger (CKY) algorithm, first introduced for use with CFGs in Chomskynormal form (Kasami 1965; Younger 1967), to the TAG parsing problem to generateparsers with a time complexity of O(n6|G|2).
The speed-up in the parser comes fromtraversing elementary trees bottom-up, handling only one link at a time.
As a result, noinference rule needs to maintain information about more than one link at a time.
If theGHR optimization is applied, the time complexity is reduced to O(n6|G|).In order to clarify the presentation of our TL-MCTAG parser, we briefly review thealgorithm of Shieber, Schabes, and Pereira (1995) with minor modifications, using thedeductive inference rule notation from that paper.
As shown in Figure 8, items in CKY-style TAG parsing consist of a node in an elementary tree and the indices that markthe edges of the span dominated by that node.
Nodes, notated ?
@a  , are specified bythree pieces of information: the identifier ?
of the elementary tree the node is in, theGorn address a of the node in that tree,9 and the link  available at that node if thereis one.
When no link is present, it is indicated by an underscore, .
The node notation?
@a   may be read as ?node ?
at address a with link ?.Each item has four indices, indicating the left and right edges of the span covered bythe node as well as any gap in the node that may be the result of a foot node dominatedby the node.
The indices are constrained to be non-decreasing from left to right in anitem.
Nodes that do not dominate a foot node will have no gap in them, which weindicate by the use of underscores in place of the indices for the gap.
To limit the numberof inference rules needed, we define the following function i ?
j for combining indices:i ?
j =??????
?i j =j i =i i = jundefined otherwiseThe Adjoin rule has two indices, p and q, that appear in the antecedent but not inthe consequent.
These indices specify the gap in one antecedent item and the edges ofthe span in the other antecedent item, indicating that one antecedent item will fill thegap in the span of the other antecedent item.
The Foot Axiom similarly makes use ofunbound indices p and q.
In this rule the entire span of the item is the gap that must be9 A Gorn address uniquely identifies a node within a tree.
The Gorn address of the root node is ?.
The jthchild of the node with address i has address i ?
j.461Computational Linguistics Volume 36, Number 3Figure 8The CKY algorithm for binary-branching TAG.filled when the item adjoins to another item.
As noted in Shieber, Schabes, and Pereira(1995), the parser can be made more efficient by only introducing foot items of this sortonce an appropriate tree to adjoin into has been parsed for the span from p to q.Each item of the form ??
@a  , i, , , l?
maintains the invariant that the input gram-mar can derive a subtree rooted at ?
@a with no foot node that spans wi+1 .
.
.wl.
Itemsof the form ??
@a  , i, j, k, l?
maintain the invariant that the input grammar can derivea subtree rooted at ?
@a with a foot node such that the fringe of the tree is the stringwi+1 .
.
.
wjLabel(Foot(?
))wk+1 .
.
.
wl.
The invariants for items of the form ??
@a  , i, , , l?and ??
@a  , i, j, k, l?
are similar except that no adjunction operation may occur at ?
@a.The side conditions Init(?)
and Aux(?)
hold if ?
is an initial tree or an auxiliarytree, respectively.
Label(?
@a) specifies the label of the node in tree ?
at address a.
Ft(?
)specifies the address of the foot node of tree ?.
Link(?
@a) specifies the link available atnode ?
@a if there is one and null (represented as in the inference rules) otherwise.Adj(?
@a  , ?)
holds if  is a link at which tree ?
may adjoin into tree ?
at address a.Subst(?
@a  , ?)
holds if  is a link at which tree ?
may substitute into tree ?
at addressa.
If  is null or the adjunction or substitution is prevented by other constraints such asmismatched node labels, these conditions fail.462Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGFigure 9The deductive rule generated for tree ?
using the baseline TL-MCTAG parsing method.Consistent with the usual definition of TAG, only one link is permitted at a givennode.
This effectively rules out multiple adjunction.
Bounded multiple adjunction maybe permitted without affecting the complexity of the parsing algorithm by allowing alist of links at a node.
Although it first appears that the introduction of multiple links ata single node could result in an exponential increase in the number of derivations, thisis not the case.
The link diacritics themselves carry no information about the trees whichmay adjoin at the associated adjunction site.
Any restrictions, such as the requirementof a matching node label, arise from the node itself.
As a result, the links are fullyinterchangeable and serve only as counters of the number of available adjunctions at anode.105.2 CKY-Style Tree-Local MCTAG ParsingAs shown in Figure 9, the naive algorithm for parsing TAG may also be applied toTL-MCTAG.
The only difference is that each link may have multiple locations within agiven tree.
Let r and f represent the rank and fan-out of the input grammar, respectively.The time complexity of the naive parser will therefore be O(n2(rf+1)|G|r+1).
However,the GHR optimization cannot straightforwardly be applied because the maintenance oftree locality requires items to carry information about the identities of the specific treesinvolved rather than just the labels of the root nodes.
Theorem 5 addresses the case inwhich the input string length is 0.
Therefore, in this case, any factor in the complexityincluding the input string length cannot contribute to the overall time complexity.
Byshowing that the problem is NP-complete when the input string length is 0, Theorem 5demonstrates that there must be some exponential factor or term in the time complex-ity expression other than the input string length factor.
Due to the earlier observationthat the GHR optimization does not change the form of the time complexity expression,Theorem 5 therefore shows that the GHR optimization cannot reduce the exponentof the grammar size term to a constant unless P = NP.
This leaves open the possibilityof the existence of an algorithm that is polynomial in the grammar size but has an addi-tional exponential term in the time complexity expression.
However, such an algorithm,if it exists, cannot be generated by application of the GHR optimization to the baselineparser.We can generalize the CKY TAG parsing algorithm presented above to the TL-MCTAG case.
This is an improvement over the standard LCFRS algorithm because itreduces the q in the |w|q factor of the complexity to a constant.
The direct specification10 Note, however, that the finite length of the lists of links is necessary for multiple adjunction to remainbenign.463Computational Linguistics Volume 36, Number 3of a CKY-style tree-local MCTAG parser is given in Figures 10 and 11.
For a tree set orvector ?
from G, we notate the trees in the set or vector using indices that are indicatedas subscripts on the tree set identifier.
A tree set or vector ?
from G with length two willtherefore contain trees ?1 and ?2.
Under the set definition these indices serve only as away of differentiating the members of the tree set.
Under the vector definition, the indexmust match the index of the link location where the tree will adjoin.In order to directly parse tree-local MCTAG, items must keep track of the trees thatadjoin at each multicomponent link.
We handle this by adding a link history to eachitem.
Under the set definition, a link history is an associative array of links notated withindices and tree set identifiers notated with indices to identify a unique tree within theset.
Note that because under the set definition a tree may adjoin at any location of alink, the indices of the link and tree set need not match.
The axioms introduce emptylink histories, indicating that no adjunctions have yet occurred.
When an adjunctiontakes place, the tree identifier of the adjoining tree is associated with the link at which itadjoins.
In order for an adjunction to take place at a multicomponent link, the adjoiningtree?s tree set must be the same as that of any tree identifier already stored for thatlink.
This is enforced by the Valid(?)
condition (Figure 12) defined on link histories.
TheFilter(?, ?
@a  ) function removes links that are completely used from the argumentlink history.
An empty link history indicates that tree locality has been enforced for thesubtree specified by the item; thus no additional information need be maintained orpassed on to later stages of the parse.For the vector definition, the link histories may be simplified because each locationof a link fully specifies which tree from within a vector may adjoin there.
As a result, thelink history is an associative array of links (not annotated with indices) and tree vectoridentifiers.
An example contrasting the link histories for the set and vector definitionsis given in Figure 13.Figure 10Modified item form, goal, and axioms for the CKY algorithm for tree-local MCTAG.
Inferencerules of the algorithm are given in Figure 11.464Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGFigure 11Modified inference rules for the CKY algorithm for tree-local MCTAG.
Alternative Adjoin,Substitute, and No Adjoin rules are given for the set and vector definitions of TL-MCTAG.
Theitem form, goal item, and axioms are given in Figure 10.The addition of a link history to each item increases the complexity of the algorithm.The maximum link history length is bounded by the rank of the input grammar, r.Under the set definition, the number of possible values for each element of a link historyis on the order of the number of tree sets in the grammar multiplied by the powerset of the fan-out: |G| ?
2f .
Thus, for the set definition, the complexity of the algorithm465Computational Linguistics Volume 36, Number 3Figure 12Definition of the Valid condition, which ensures that all locations of a link are used by uniquetrees from the same tree set.
Under the set definition there is an entry for each link location andboth the identity of the tree set and the uniqueness of the tree from that tree set must be checked.Under the vector definition only the link name and the tree vector identifier are stored becausethe link locations uniquely select trees from within tree vectors.Figure 13A sample TL-MCTAG with examples of the possible link histories under the set and vectordefinitions when the parser reaches the top of the circled node.
Although the tree sets arenotated in set definition, the reader may substitute angle braces to get the corresponding vectordefinition items.is O(n6|G|r+22rf ).
Under the vector definition, the number of possible values for eachelement of a link history is on the order of the number of tree sets in the grammar.
Thus,for the vector definition, the complexity of the algorithm is O(n6|G|r+2).
Note that thevariable representing fan-out, f , is present only in the complexity of the set definition.This demonstrates the novel result that when rank is bounded, even with unboundedfan-out, parsing the vector definition of TL-MCTAG is polynomial.Permitting multiple adjunction may be accomplished by a method similar to theone described for the TAG algorithm.
Rather than associating each node with at mostone link, we permit nodes to be accompanied by a set of links.
In contrast to theTAG case, here we must use a set rather than a list to allow for the expressivity thatmultiple adjunction can provide.
In the TAG case a list is sufficient because the linksat a node are fully interchangeable.
In the TL-MCTAG case, because the links aredefined not just by the node where they appear but by the full set of nodes at whichlocations of that link appear, the links at a given node are not interchangeable.
It mustbe possible to use them in any order.11 Because the links can be used in any order, the11 For links that share all locations it is still possible to enforce a strict order over them withoutcompromising expressivity.466Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGaddition of multiple adjunction adds a factor of 2r to the time complexity of the parsingalgorithm.6.
Link FactorizationThe parser presented in the previous section has the advantage of running in polyno-mial time if the elementary structures of the input TL-MCTAG are defined as vectorsand if the rank of the grammar is bounded by some constant.
Bounding the rank bya constant might be too strong a limitation in natural language parsing applications,however.
Thus, in the general case the running time of our algorithm contains a factorthat is an exponential function of the rank of the input grammar.
To optimize parsingtime, then, we seek a method to ?factorize?
the elementary trees of the grammar insuch a way that the rank is effectively reduced and the set of derived trees is preserved.Although the precise meaning of factorization should be inferred from the subsequentdefinitions, informally, by factorize we mean splitting a single elementary tree into sev-eral smaller elementary trees without violating the locality constraints of the grammarformalism.
In this section we present a novel and efficient algorithm for factorizing aTL-MCTAG into a strongly equivalent TL-MCTAG in which rank is minimized acrossthe grammar.
Here, strongly equivalent means that the two grammars generate thesame set of derived trees.126.1 PreliminariesLet ?
be some elementary tree.
We write |?| to denote the number of nodes of ?.
For alink l, we write |l| to denote the number of nodes of l.For an elementary tree ?, we call a fragment of ?
a complete subtree rooted at somenode n of ?, written ?
(n), or else a subtree rooted at n with a gap at node n?
in itsyield, written ?
(n, n?).
See Figure 14 for an example.
We also use ?
to denote a genericfragment with or without a gap node in its yield.Consider some fragment ?
of ?.
Let N?
be the set of all nodes of ?
and let N?
be theset of nodes of ?
with the exclusion of the gap node, in case ?
has such a node.
We saythat ?
is an isolated fragment iff ?
includes at least one link and no link in ?
impingesboth on nodes in N?
and on nodes in N?
?
N?.
Figure 14 provides an example.Intuitively, we can ?excise?
an isolated fragment from ?
without splitting apartthe links of ?
itself, and therefore preserving the tree locality.
This operation may alsoreduce the number of links in ?, which is our main goal.
The factorization algorithm wepresent in Section 6.2 is based on the detection and factorization of isolated fragments.Let n be a node from some elementary tree ?.
We write lnodes(n) to denote the setof all nodes from fragment ?
(n) that are part of some link from ?.
Node n is maximal if lnodes(n) = ?
; and n is either the root node of ?
or, for its parent node n?, we havelnodes(n?)
= lnodes(n).12 The trees are not actually the same because of the small, reversible transformation that we make to ensurethat the factorized trees obey the TAG constraint that auxiliary trees must have matching root and footnode labels.
This transformation adds additional nodes into the tree structure but does not change theshape of the trees and can be reversed to produce trees that are actually the same as the derived trees ofthe original grammar.467Computational Linguistics Volume 36, Number 3Figure 14An elementary tree ?
demonstrating fragments, isolation, and maximal nodes.
Fragment?1 = ?
(n1, n2) contains all locations of links 2 and 3 , because links at the root node of afragment are contained within that fragment.
It does not contain any locations of link 4 , becauselinks at the gap node of a fragment are not contained within that fragment.
Because links 2 and3 impinge only on nodes in ?1 and all other links impinge only on nodes not in ?1, ?1 is anisolated fragment.
Fragment ?2 = ?
(n4) is not an isolated fragment because it contains only oneof the link locations of 4 .
Note also that n4 is a maximal node but n5 is not.Note that for every node n?
of ?
such that lnodes(n?)
= ?
there is always a uniquemaximal node n such that lnodes(n?)
= lnodes(n) (see Figure 14).
Thus, for the purposeof TL-MCTAG factorization, we can consider only maximal nodes.
The first criterionin the definition of maximal node, stating that a maximal node always dominates(possibly reflexively) some node involved in a link, will often be implicitly used in thefollowing.We need to distinguish the nodes in lnodes(n) depending on their impinging links.Assume that {l1, l2, .
.
.
, lr} is the set of all links occurring in ?.
For 1 ?
j ?
r, we writelnodes(n, lj) to denote the set of all nodes from fragment ?
(n) with impinging link lj.Thus,?rj=1 lnodes(n, lj) = lnodes(n).
We associate with each maximal node n of ?
asignature ?
(n), defined as a vector of size r and taking values over the subsets oflnodes(n).
For each j, 1 ?
j ?
r, we define?
(n)[j] =??
?lnodes(n, lj), if 0 < |lnodes(n, lj)| < |lj|;?, if |lnodes(n, lj)| = 0 or|lnodes(n, lj)| = |lj|.Observe that, in this definition, ?
(n)[j] = ?
means that none or all of the nodes of lj arefound within fragment ?(n).
The empty signature, written 0, is the signature with all ofits components set to ?.Consider maximal nodes n1 and n2 such that n1 = n2, ?
(n1) = 0, and ?
(n2) = 0.It is not difficult to see that ?
(n1) = ?
(n2) always implies that one of the two nodesdominates the other.
This observation is implicitly used in several places subsequently.When visiting nodes of ?
in a path from some leaf node to the root node,13 onemay encounter several maximal nodes having the same non-empty signature.
In ourfactorization algorithm, we need to consider pairs of such nodes that are as close aspossible.
Consider two maximal nodes n1 and n2, n1 = n2, such that n1 dominates n2.13 We view trees as directed graphs with arcs directed from each node to its parent.468Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGThe ordered pair (n1, n2) is called a minimal pair if ?
(n1) = ?
(n2) = 0 and, for everymaximal node n3 in the path from n2 to n1 with n3 = n1 and n3 = n2, we have ?
(n3) =?(n1).
Consider now a sequence ?n1, n2, .
.
.
, nq?, q ?
2, of nodes from ?.
Such a sequenceis called a maximal chain if each pair (ni?1, ni) is a minimal pair, 2 ?
i ?
q, and all nodesn from ?
with ?
(n) = ?
(n1) are included in the sequence itself.Notice that two maximal nodes belonging to two different maximal chains musthave different signatures, and thus one maximal node cannot belong to more than onemaximal chain.
We now prove some basic properties of the notions just introduced thatwill be used later in the development of our factorization algorithm and in the proof ofsome of its mathematical properties.Lemma 1Let ?
be an elementary tree and let n, n?
be maximal nodes, with n properly dominatingn?
in (ii).
(i) ?
(n) = 0 if and only if ?
(n) is an isolated fragment;(ii) ?
(n) = ?(n?)
if and only if ?
(n, n?)
is an isolated fragment.Proof(i).
If ?
(n) = 0, then for each link l we have that either all nodes impinged on by l aredominated (possibly reflexively) by n or none of these nodes is dominated by n. Becausen is maximal, we further conclude that at least some link l is found within ?
(n).Conversely, if ?
(n) is an isolated fragment then all or none of the nodes impingedon by some link l are dominated by n, and thus ?
(n) = 0.(ii).
Let ?
(n) = ?(n?
), with n properly dominating n?.
For each link lj, there are twopossible cases.
First consider the case where ?
(n)[j] = ?(n?
)[j] = ?.
In order for this to betrue, the link must be in one of three configurations, all of which satisfy the requirementthat the locations of lj must be all inside or all outside of the fragment ?
(n1, n2). lnodes(n, j) = ?.
In this configuration no one of the nodes on which ljimpinges is dominated by n. |lnodes(n, j)| = |lj|.
We distinguish two possible cases.?
lnodes(n?, j) = ?.
In this configuration all the nodes on which ljimpinges are within the fragment ?
(n1, n2).?
|lnodes(n?, j)| = |lj|.
In this configuration all the nodes on which ljimpinges are ?below?
the fragment ?
(n, n?
).Now consider the case where ?
(n)[j] = ?(n?
)[j] = ?.
The nodes in lnodes(n?, j) are dom-inated (possibly reflexively) by n?
and therefore fall ?below?
?
(n, n?).
The remainingnodes on which lj impinges cannot be dominated (possibly reflexively) by n. We thusconclude that no nodes impinged on by lj occur within the fragment ?
(n, n?
).Assume now that ?
(n, n?)
can be isolated.
We can use exactly the same argumentsin the analysis of sets lnodes(n, j) and lnodes(n?, j), and conclude that ?
(n) = ?(n?).
The next lemma will be useful later in establishing that the factorization found byour algorithm is optimal, namely, that it achieves the smallest rank under the imposedconditions.469Computational Linguistics Volume 36, Number 3Lemma 2Let (n1, n2) be some minimal pair.
Then(i) for any node n3 in the path from n2 to n1, ?
(n3) = 0;(ii) for any minimal pair (n3, n4), neither or both of n3 and n4 are found in thepath from n2 to n1.Proof(i).
Because ?
(n2) = 0, there is some link lj for which ?
(n2)[j] = lnodes(n2, j) = ?.
Be-cause n3 dominates n2, n3 dominates the nodes in lnodes(n2, j).
Therefore, the only way?
(n3) could equal 0 is if |lnodes(n3, j)| = |lj|.
But then ?
(n1)[j] = ?
because n1 dominatesn3.
This is a contradiction.(ii).
Assume that n4 is on the path from n2 to n1.
From the definition of minimalpair, there must exist a link lk such that ?
(n4)[k] = ?(n2)[k].
By the same reasoningas in the proof of statement (i) for any link lj such that ?
(n2)[j] = ?, we must have?
(n2)[j] = ?
(n4)[j] = ?(n1)[j].
We thus conclude that ?
(n2)[k] = ?
and ?
(n4)[k] = ?.
Be-cause ?
(n4)[k] = ?
(n3)[k] = ?
and ?
(n2)[k] = ?
(n1)[k] = ?, node n3 must be in the pathfrom n2 to n1.By a similar argument, we can argue that if n3 is on the path from n2 to n1, thennode n4 must be in that path as well.
6.2 Factorization AlgorithmLet G be an input TL-MCTAG grammar.
In this subsection we provide a method for theconstruction of a TL-MCTAG that produces a grammar that generates the same derivedtrees as G and that has minimal rank.
We start with the discussion of some preprocessingof the input.We annotate each elementary tree ?
as follows: We compute sets lnodes(n, lj)for all nodes n and all links lj of ?.
This can easily be done with a bottom upvisit of ?, by observing that if an internal node n has children n1, n2, .
.
.
, nk thenlnodes(n, lj) =?ki=1 lnodes(ni, lj) ?
Xj, where Xj = ?
if lj does not impinge on n and Xj ={n} if it does.
Using sets lnodes(n, lj), we can then mark all nodes n in ?
that are maximal,and compute the associated signatures ?
(n).We also mark all maximal chains within ?.
This simple procedure is reported inFigure 15.
We maintain an associative array with node signatures as entries and nodelists as values.
We visit all maximal nodes of ?
in a top?down fashion, creating a list foreach different signature and appending to such a list all nodes having that signature.In the following algorithm we excise isolated fragments from each elementary tree?.
We now introduce some conventions for doing this.
Although it would be possible toFigure 15Construction of maximal chains in the factorization algorithm.470Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGexcise fragments without the introduction of additional tree structure, we adopt insteadtwo simple tree transformations that preserve auxiliary tree root and foot label matchingand result in some simplification of the notation used by the algorithm, particularly incase the root node of a fragment is the same as the gap node of a second fragment within?.
A schematic depiction of both transformations is given in Figure 16.When a fragment ?
(n) is excised, we leave a copy of the root node n without itsimpinging links that dominates a fresh node n?
with a fresh link indicating obligatorysubstitution of the excised fragment.
The excised fragment consists of ?
(n) includingany links impinging on n, but has a fresh root node immediately dominating n with thesame label as n?.
This is shown in the top row of Figure 16.A similar transformation is used to excise a fragment ?
(n, n?).
Nodes n and n?
ofthe original tree are not altered, and thus they retain their names.
The material betweenthem is replaced with a single new node with a fresh nonterminal symbol and a freshlink.
This link indicates the obligatory adjunction of the excised fragment.
A new rootand gap node are added to ?
(n, n?)
to form the excised fragment.
This is shown in thebottom row of Figure 16.
We remark that any link impinging on the root node of theexcised fragment is by our convention included in the excised fragment, and any linkimpinging on the gap node is not.To regenerate the original tree, the excised fragment ?
(n, n?)
can be adjoined backinto the tree from which it was excised.
The new nodes that have been generated inthe excision may be removed and the original root and gap nodes may be merged backtogether retaining any impinging links.We need to introduce one more convention for tree excision.
Consider a maximalchain c = ?n1, n2, .
.
.
, nq?
in ?, q ?
2.
In case q = 2, our algorithm processes c by excis-ing a fragment ?
(n1, n2) from ?, exactly as explained above.
In case q > 2, a specialprocessing is required for c. Chain c represents q ?
1 minimal pairs, corresponding tofragments ?
(ni?1, ni), 2 ?
i ?
q.
We do not excise these q ?
1 fragments one by one,Figure 16Diagrams of the tree transformations performed when fragments ?
(n) and ?
(n, n?)
are removed.471Computational Linguistics Volume 36, Number 3because this would create q ?
1 > 1 new links within ?.
We follow instead a procedurethat ?binarizes?
c, as explained here.Let us recursively define an elementary tree ?c as follows, for |c| = q and q ?
3: In case q = 3, ?c is a tree composed of two nodes besides the root and thegap nodes, n and n?, with n immediately dominating n?.
Node n hoststhe (obligatory) adjunction of the fragment ?
(n1, n2) and node n?
hoststhe (obligatory) adjunction of ?
(n2, n3).
Both fragments are transformedas previously discussed. In case q > 3, ?c is a tree composed of two nodes besides the root and thegap nodes specified as above, with n?
hosting the (obligatory) adjunctionof the transformed fragment ?
(nq?1, nq).
Node n hosts the adjunction oftree ?c?
, with c?
= ?n1, .
.
.
, nq?1?.Note that each tree ?c has rank two.When processing a maximal chain c with q > 2, the whole fragment ?
(n1, nq) isexcised, using this convention.
This results in a single fresh link added to ?.
In this casethe link refers to the adjunction of a newly created elementary tree ?c, defined as above.An example of the binarization of a maximal chain with q = 4 is reported in Figure 17.We can now discuss the factorization algorithm, reported in Figure 18.
For a maxi-mal node n in an elementary tree ?, we write links(n) to denote the number of links from?
that are entirely contained in fragment ?(n).
We process each tree set I?
of the sourcegrammar and each elementary tree ?
in I?
as follows.Figure 17The binarization procedure applied to a maximal chain c = ?n1, n2, n3, n4?.472Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGFigure 18The factorization algorithm for tree-local MCTAG.In the first phase, we add to an agenda A each maximal node n different from theroot of ?
such that ?
(n) = 0.
We associate this agenda item with the score links(n).
Atthe same time, each maximal chain ?n1, n2, .
.
.
, nq?, q ?
2, is added to A, with associatedscore links(n1) ?
links(nq).In the second phase, we process all items in A, in order of increasing score, ignoringthose items that have a score of one.
If the current item is a maximal node n, we excisethe fragment ?
(n) from ?, leaving in place a fresh node with a single node link denotingobligatory substitution.
If the current item is a maximal chain of the form ?n1, n2?, weexcise from ?
the fragment ?
(n1, n2), leaving in place a fresh node with a single nodelink denoting obligatory adjunction of the excised fragment.
Finally, if the current itemis a maximal chain c = ?n1, .
.
.
, nq?
with q > 2, we excise from ?
the whole fragment?
(n1, nq), and we apply to the chain the binarization procedure described in this sub-section.
This results in the addition to the output grammar of fragments ?
(ni?1, ni), for2 ?
i ?
q, and of newly created elementary tree ?c and elementary trees ?c?
for eachchain c?
that is a proper prefix of c. After the processing of all elementary trees in treeset I?
is completed, the resulting version of set I?
is also added to the output grammar.As a simple example of a run of the factorization algorithm, we discuss the process-ing of the elementary tree ?
depicted in Figure 19.
Tree ?
has four links, called li,1 ?
i ?
4.
Link l1 impinges on nodes n11 and n12, link l2 impinges on nodes n21 andn22.
Links l3 and l4 impinge on a single node each, and the impinging nodes are calledn3 and n4, respectively.
In Figure 19 we have outlined the maximal nodes n, n?, and n?
?473Computational Linguistics Volume 36, Number 3Figure 19An example tree to be processed by the factorization algorithm.that are relevant to this example.
Node n dominates both n?
and n??
but none of n?
and n?
?dominates the other.
Note that within ?
there must exist maximal nodes other than n, n?,and n??.
For instance, there must be a maximal node dominating (possibly reflexively)node n3 but not node n4.
However, this node dominates a single link, and will not beprocessed by the algorithm because of the requirement at line 12 in Figure 18.
We thusignore this and other maximal nodes in what follows.We havelnodes(n?, l1) = {n11}, lnodes(n, l1) = {n11},lnodes(n?, li) = ?, 2 ?
i ?
4, lnodes(n, l2) = {n21, n22},lnodes(n?
?, li) = ?, 1 ?
i ?
2, lnodes(n, l3) = {n3},lnodes(n?
?, l3) = {n3}, lnodes(n, l4) = {n4},lnodes(n?
?, l4) = {n4},and?(n?)
= [{n11}, ?, ?, ?],?(n??)
= 0,?
(n) = ?(n?
).The algorithm in Figure 15 will then mark the chain ?n, n??.
When processing the elemen-tary tree ?, the algorithm in Figure 18 will add to its agenda an item n??
with a score oflinks(n??)
= 2, as well as the above chain, with a score of links(n) ?
links(n?)
= 3 ?
0 = 3.Node n??
is processed first, and fragment ?(n??)
is excised from ?
leaving in its placea fresh link l5.
Later on, the algorithm pops the chain ?n, n??
from the agenda, andfragment ?
(n, n?)
is excised from ?
leaving in its place a fresh link l6.
The algorithmthen stops.
The resulting factorization consists in fragment ?(n??)
with links l3 and l4,fragment ?
(n, n?)
with links l2 and l5, and what is left of the elementary tree ?, withlinks l1 and l6.The discussion of the correctness of the algorithm is reported in the next section,along with some other mathematical properties.474Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAG6.3 Mathematical PropertiesWe discuss in this section some mathematical properties of our factorization algorithm.Let G be the input TL-MCTAG and let G?
be the output of the algorithm.
We start withthe issue of correctness.
First, notice that our algorithm stops after a finite number ofsteps, because the number of possible excisions for G is finite.
Assume now that ?
and??
are two isolated fragments within some elementary tree ?, and ??
is itself a fragmentwithin ?.
It is easy to see that excising ??
from ?
results in a new fragment of ?
that isstill an isolated fragment.
Using this observation together with Lemma 1, we can thenconclude that all fragments that are excised by the algorithm are isolated fragments.This in turn implies that each fragment excision in our algorithm preserves tree locality,and G?
is still a TL-MCTAG.Each fragment that is excised from some source tree must obligatorily be adjoinedback into that tree, at the point from which it was removed.
Thus, G?
generates the samederived trees as G, modulo our trivial tree transformation for the root and the gap nodes.This proves the correctness of our factorization algorithm.One remark is in order here.
Note that we always excise fragments that have atleast two links.
This can be shown inductively as follows.
Consider first the smallestfragments that are excised from some elementary tree ?, that is, those fragments thatdo not contain any other fragment within themselves.
These fragments always haveat least two links, because of the requirement stated in line 12 in the algorithm.
In theinductive case, let ?
be some fragment of ?
from which a second fragment ??
has beenalready excised in some iteration of the loop at lines from 11 to 23.
Fragment ??
is thusreplaced by some link l?.
Because of the definition of maximal node, ?
must contain atleast one link l that is not contained in ??.
In case l itself is part of some excised fragment??
?, there will still be some other fresh link replacing ???.
We thus conclude that, whenexcised, ?
always has at least two links.
Because excised fragments always have at leasttwo links and since we never consider elementary trees as candidate fragments (line 6),we can conclude that our algorithm always finds a non-trivial factorization of G.We can now turn to an analysis of the computational complexity of our algorithm.Consider an elementary tree ?
of G with r links and with a maximum of f nodes perlink.
In the preprocessing phase of the algorithm, the computation of sets lnodes(n, lj)can be carried out in time O(|?| ?
r ?
f ).
To see this, notice that there are no more than|?| ?
r such sets.
Furthermore, we have |lnodes(n, lj)| ?
f for each j, and each node inlnodes(n, lj) is processed in constant time through the union operator, when constructingthe set lnodes(n?, lj) for the parent node n?
of n. Clearly, O(|?| ?
r ?
f ) is also a time upperbound for the computation of quantities ?
(n) and links(n) for all nodes in ?, and forextracting a list of the maximal nodes therein as well.14In what follows, we will need to compare signatures of different nodes for equality.Despite the fact that each signature has r elements, and each element of a signature is aset with O( f ) elements, there are at most |?| different signatures.
We can therefore usean atomic symbol to name each signature (perfect hashing).
In this way, signatures canbe compared in constant time.The marking of all maximal chains within ?, as specified by the algorithm inFigure 15, can be implemented in time O(|?|).
This is done by encoding the associative14 We remark here that a further improvement in efficiency could be achieved by replacing the sets of nodesin a signature with the single node that is the least common ancestor of the set of nodes.
However, usingthe set of nodes substantially improves the clarity of the presentation of the algorithm, so we do notpursue this optimization here.475Computational Linguistics Volume 36, Number 3array L in the algorithm through a one-dimensional array indexed by signature names.Each element of the array points to a linked list of nodes, representing a maximal chain.We now analyze the running time of the factorization function in Figure 18.
Let usfirst consider a single elementary tree ?.
We implement the priority queue A througha heap data structure.
The loops at lines 6 and 9 run in time O(|?| ?
log(|?|)): This isthe standard result for populating a heap; see for instance Cormen et al (2001).
Ateach iteration of the while loop at lines 11 to 23, we extract some fragment ?
(n) or?
(n1, nq).
The processing of each such fragment ?
takes an amount of time O(|?|),where |?| is the number of nodes of ?.
In such an iteration, ?
needs to be re-editedinto a new elementary tree with the number of nodes |?| ?
|?| + c, where c ?
3 is aconstant that depends on the specific transformation in Figure 16 that was applied inthe excision of the fragment tree.
Nonetheless, if a suitable representation is maintainedfor ?, making use of nodes and pointers, the re-editing of ?
can be done in constanttime.
Then a single iteration of the while loop takes time O(|?|), where ?
is the excisedfragment.
We can then conclude that all iterations of the while loop take an amount oftime O(|?| ?
log(|?|)).15Now let ?M be the elementary tree of G with the largest size, and let rG and fG be therank and fan-out of G, respectively.
Putting everything together, the total running timeof the factorization algorithm is O(|G| ?
(rG ?
fG + log(|?M|))), where |G|, the size of theinput grammar, is defined as the sum of terms |?| for all elementary trees ?
of G. Becausewe always have fG ?
|?M|, this upper bound can be rewritten as O(|G| ?
|?M| ?
rG).A special case is worth discussing here.
If the maximum number of links impingingon a node of our elementary trees is bounded by some constant, we have rG ?
fG =O(|?M|).
In this case, the above bound reduces to O(|G| ?
|?M|).
The constant bound onthe number of links impinging on the nodes of a grammar holds for all of the grammarswe have studied in Section 3.We now argue that our algorithm provides the factorization G?
of G with thesmallest possible rank, under the assumption that G and G?
are strongly equivalent,that is, that they generate the same derived trees.A factorization f of G is called maximal if no one of its fragments has a smallerisolated fragment within itself.
We start by observing that the factorization of G foundby our algorithm is maximal.
To see this, consider the excision by our algorithm ofa maximal chain ?n1, .
.
.
, nq?
within an elementary tree ?.
This item is added to thepriority heap at line 10, with a score of links(n1) ?
links(nq).
This score is the number oflinks found in fragment ?
(n1, nq), with the exclusion of the links at the gap node nq.The chain is then factorized into fragments ?
(ni?1, ni), for each i with 2 ?
i ?
q. Assumethat some fragment ?
(ni?1, ni) contains in turn a maximal chain ?n?1, .
.
.
, n?q??
or elsean isolated fragment of the form ?(n?).
In the first case we have links(n?1) ?
links(n?q? )
<links(n1) ?
links(nq) and in the second case we have links(n?)
< links(n1) ?
links(nq).Thus the smaller chain or fragment is processed earlier than our maximal chain, andby the time our maximal chain is processed, the smaller chain or fragment has alreadybeen excised.
A similar argument shows that the excision by our algorithm of an isolatedfragment of the form ?
(n) happens after the excision of any maximal chain or fragmentincluded within ?
(n) itself.15 We mention here a second possible optimization of the algorithm.
The priority queue allows us to excisetree segments always from the input elementary tree ?, making the algorithm easier to analyze.However, as one of the reviewers has pointed out to us, we could do away with the use of the priorityqueue and process fragment trees in any order.
This results in running time O(|?|) for the factorizationfunction in Figure 18.476Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGWe now show that the maximal factorization of G is unique.
Let ?
and ??
be twoisolated fragments of some elementary tree ?.
We say that ?
and ??
partially overlap ifthe set of nodes shared by ?
and ??
is not empty and is a proper subset of the nodes ofboth fragments.
It is not difficult to see that if ?
and ??
partially overlap, then at leastone among ?
and ??
must have the form ?
(n1, n2).Without any loss of generality, we assume that the elementary trees of G are alwaysfactorized at their maximal nodes, as discussed in Section 6.1.
Let us assume that fand f ?
are two distinguishable maximal factorizations of G. Because no fragment of onefactorization can be a sub-fragment of some fragment of the other factorization, theremust be some fragment ?
of f and some fragment ??
of f ?
such that ?
and ??
partiallyoverlap.Assume that ?
has the form ?(n1).
Then ??
must have the form ?
(n2, n3), and n1must be in the path from n3 to n2.
Because ??
is as small as possible, (n2, n3) must be aminimal pair.
We have then established a violation of Lemma 2(i).
Assume now that ?has the form ?
(n1, n2).
Again, (n1, n2) must be a minimal pair.
If ??
has the form ?
(n3),this argument applies again, resulting in a violation of Lemma 2(i).
If ??
has the form?
(n3, n4), then (n3, n4) must be a minimal pair.
Furthermore, n1, n2, n3, and n4 must allbe on the same path within ?, with n1, n2 in alternation with n3, n4.
This establishes aviolation of Lemma 2(ii).
The assumption that f and f ?
partially overlap then leads to acontradiction, and we must conclude that the maximal factorization of G is unique.We can also use this argument against the existence of overlapping fragments toshow that any factorization f of G other than the unique maximal factorization fM mustbe coarser than fM, meaning that each fragment ?
of f is also a fragment of fM, or else?
can be represented as a combination of the fragments of fM (through substitution andadjunction).
This means that no factorization of G can have rank smaller than the rankof the maximal factorization fM.
We conclude that our algorithm is optimal.This discussion on the optimality of the factorization algorithm crucially assumesstrong equivalence with the source TL-MCTAG G. Of course there might be TL-MCTAGs that are weakly equivalent to G, that is, they generate the same language,and have rank strictly smaller than the rank of G?.
However, finding such structurallydifferent grammars is a task that seems to require techniques quite different from thefactorization techniques we have developed in this section.
Furthermore, the task mightbe computationally unfeasible, considering the fact that the weak equivalence problemfor TL-MCTAG is undecidable.
(Such a problem is undecidable even for CFGs.
)We remark here that if we are allowed to change G by recasting its elementary treesin some suitable way, we might be able to further reduce the rank with respect to thealgorithm we have presented in this section.
In this case the output grammar wouldnot preserve the derived trees, that is, we lose the strong equivalence, but still retainthe derivation trees unaltered.
Although this is likely not desirable for applicationsin which the input grammar consists of linguistically motivated trees, there may beother applications for which the preservation of the internal structure of the trees isless important than the processing efficiency that can be gained by more aggressivefactorization.
Furthermore, it is well known that the desired derived tree for the sourcegrammar can be easily reconstructed from the derivation tree.Consider for instance cases in which the input TL-MCTAG is not in binary form,that is, some nodes have more than two children.
Currently, the definition of fragmentdoes not allow splitting apart a subset of the children of a given node from the remainingones.
However, if we allow binarization of the elementary trees of the source grammar,then we might be able to isolate sets of links that could not be factorized in the sourcegrammar itself.
It is not difficult to construct an elementary tree ?
with r links such477Computational Linguistics Volume 36, Number 3that no factorization of ?
is possible if we are required to preserve ?
?s structure, but ifwe drop such a requirement then we could binarize ?
in such a way that a factorizationcan be obtained through the application of the algorithm above, such that any tree in thefactorization has no more than two links.
However, the general problem of restructuringelementary trees in such a way that an optimal factorization is possible is not trivial andrequires further research.
We leave this problem for future work.A second case arises when multiple links impinge on the same node of an elemen-tary tree.
As presented, the factorization algorithm is designed to handle grammars inwhich multiple adjunction is permitted.
However, if multiple adjunction is disallowedand the grammar contains trees in which multiple links impinge on the same node,the use of one link at a node will disqualify any other impinging links from use.
Thisopens up the possibility of further reducing the rank of the grammar by producingtree sets that do not contain any nodes on which multiple links impinge.
This canbe accomplished by performing a first-pass grammar transformation in which a copyof each elementary tree set is added to the grammar for each distinct, maximal, non-conflicting set of links appearing in the tree set.
This transformation in itself may resultin a reduction of the rank of the source grammar.
The factorization algorithm can then beapplied to the new grammar.
However, if the elementary trees in the source grammarcontain clusters of links that are mutually overlapping, the suggested transformationmay blow up the size of the input grammar in a way that is not bounded by anypolynomial function.7.
ConclusionThis paper explores the complexity of TL-MCTAG, showing that recognition is NP-complete under a range of interesting restrictions.
It then provides a parsing algorithmthat performs better than the extrapolation of the standard multiple CFG parsingmethod to TL-MCTAG.
As shown by our proofs, the difficulty in parsing TL-MCTAGstems from the rank of the input grammar.
We offer a novel and efficient algorithm forminimizing the rank of the input grammar while preserving its strong generative capac-ity.
It fits into an active line of research into efficient processing of multicomponent andsynchronous formalisms that appear computationally intractable but have desirablecharacteristics for meeting the expressive needs of natural language.
It presents novelcomplexity results and algorithms for TL-MCTAG, a widely known and used formalismin computational linguistics that may be applied more effectively in natural-languageprocessing using algorithms that process it as efficiently as possible.AcknowledgmentsThis work was supported in part by theNational Science Foundation under awardBCS-0827979.
The second author has beenpartially supported by MIUR under projectPRIN No.
2007TJNZRE 002.ReferencesBarton, G. Edward.
1985.
On the complexityof ID/LP parsing.
ComputationalLinguistics, 11(4):205?218.Chen, John and Vijay K. Shanker.
2004.Automated extraction of TAGs from thePenn treebank.
In H. Blunt, J. Carroll, andG.
Satta, editors, New Developments inParsing Technology.
Kluwer Academic,Amsterdam, pages 73?89.Cormen, Thomas H., Charles E. Leiserson,Ronald L. Rivest, and Clifford Stein.
2001.Introduction to Algorithms.
The MIT Press,Cambridge, MA.Earley, J.
1970.
An Efficient Context-freeParsing Algorithm.
Ph.D. thesis, Universityof California, Berkeley, CA.Garey, M. R. and D. S. Johnson.
1979.Computers and Intractability.
Freeman andCo., New York, NY.Gildea, Daniel, Giorgio Satta, and HaoZhang.
2006.
Factoring synchronous478Nesson, Satta, and Shieber Complexity, Parsing, and Factorization of TL-MCTAGgrammars by sorting.
In The InternationalConference on Computational Linguistics/Association for Computational Linguistics(COLING/ACL-06) Poster Sessionpages 279?286, Sydney.Graham, S. L., M. A. Harrison, and W. L.Ruzzo.
1980.
An improved context-freerecognizer.
ACM Transactions onProgramming Languages and Systems,2:415?462.Han, Chung-Hye.
2006.
Pied-piping inrelative clauses: Syntax and compositionalsemantics based on synchronous treeadjoining grammar.
In Proceedings of the 8thInternational Workshop on Tree AdjoiningGrammars and Related Formalisms (TAG+ 8),pages 41?48, Sydney.Joshi, A. K., L. S. Levy, and M. Takahashi.1975.
Tree adjunct grammars.
Journal ofComputer and System Sciences,10(1):136?163.Joshi, Aravind K. and Yves Schabes.
1997.Tree-adjoining grammars.
In G. Rozenbergand A. Salomaa, editors, Handbook ofFormal Languages, volume 3.
Springer,Berlin, pages 69?124.Kaji, Yuichi, Ryuchi Nakanishi, HiroyukiSeki, and Tadao Kasami.
1992.
Theuniversal recognition problems formultiple context-free grammars and forlinear context-free rewriting systems.IEICE Transactions on Information andSystems, E75-D(1):78?88.Kaji, Yuichi, Ryuchi Nakanishi, HiroyukiSeki, and Tadao Kasami.
1994.
Thecomputational complexity of the universalrecognition problem for parallel multiplecontext-free grammars.
ComputationalIntelligence, 10(4):440?452.Kallmeyer, Laura.
2005.
Tree-localmulticomponent tree adjoining grammarswith shared nodes.
ComputationalLinguistics, 31(2):187?225.Kallmeyer, Laura.
2009.
A declarativecharacterization of different types ofmulticomponent tree adjoining grammars.Research on Language and Computation,7(1):55?99.Kallmeyer, Laura and Aravind K. Joshi.2003.
Factoring predicate argument andscope semantics: Underspecifiedsemantics with LTAG.
Research onLanguage and Computation, 1:3?58.Kallmeyer, Laura and Maribel Romero.2007.
Reflexives and reciprocals inLTAG.
In Proceedings of the SeventhInternational Workshop on ComputationalSemantics ICWS-7, pages 271?282,Tilburg.Kasami, T. 1965.
An efficient recognitionand syntax algorithm for context-freelanguages.
Technical ReportAF-CRL-65-758, Air Force CambridgeResearch Laboratory, Bedford, MA.Nesson, Rebecca.
2009.
Synchronous andMulticomponent Tree-Adjoining Grammars:Complexity, Algorithms and LinguisticApplications.
Ph.D. thesis, HarvardUniversity, Cambridge, MA.Nesson, Rebecca, Giorgio Satta, and StuartShieber.
2008.
Optimal k-arization ofsynchronous tree-adjoining grammar.
Inthe Association for Computational Linguistics(ACL-2008), pages 604?612, Columbus, OH.Nesson, Rebecca and Stuart M. Shieber.2006.
Simpler TAG semantics throughsynchronization.
In Proceedings of the11th Conference on Formal Grammar,pages 129?142, Malaga.Nesson, Rebecca and Stuart M. Shieber.2007.
Extraction phenomena insynchronous TAG syntax and semantics.In Proceedings of Syntax and Structure inStatistical Translation (SSST), pages 9?16,Rochester, NY.Rambow, Owen.
1994.
Formal andcomputational aspects of natural languagesyntax.
Ph.D. thesis, University ofPennsylvania, Philadelphia, PA.Satta, Giorgio and Enoch Peserico.
2005.Some computational complexity results forsynchronous context-free grammars.
InProceedings of Human Language TechnologyConference and Conference on EmpiricalMethods in Natural Language Processing(HLT05/EMNLP05), pages 803?810,Vancouver.Schabes, Yves and Richard C. Waters.
1995.Tree insertion grammar: A cubic-timeparsable formalism that lexicalizescontext-free grammar without changingthe trees produced.
ComputationalLinguistics, 21(4):479?513.Seki, H., T. Matsumura, M. Fujii, andT.
Kasami.
1991.
On multiple context-freegrammars.
Theoretical Computer Science,88:191?229.Shieber, Stuart M. and Yves Schabes.
1994.An alternative conception of tree-adjoiningderivation.
Computational Linguistics,20(1):91?124.Shieber, Stuart M., Yves Schabes, andFernando C. N. Pereira.
1995.
Principlesand implementation of deductive parsing.Journal of Logic Programming, 24(1?2):3?36.Sippu, S. and E. Soisalon-Soininen.
1988.Parsing Theory: Languages and Parsing.Springer-Verlag, Berlin.479Computational Linguistics Volume 36, Number 3S?gaard, Anders, Timm Lichte, andWolfgang Maier.
2007.
On the complexityof linguistically motivated extensions oftree-adjoining grammar.
In RecentAdvances in Natural Language Processing2007, Borovets.Tovey, C. A.
1984.
A simplified NP-completesatisfiability problem.
Discrete AppliedMathematics, 8(1):85?90.Vijay-Shanker, K. 1987.
A study oftree-adjoining grammars.
Ph.D. thesis,Department of Computer and InformationScience, University of Pennsylvania,Philadelphia, PA.Vijay-Shanker, K. and Aravind K. Joshi.
1985.Some computational properties oftree-adjoining grammars.
In Proceedings ofthe 23rd Annual Meeting of the Associationfor Computational Linguistics, pages 82?93,Chicago, IL.Weir, David.
1988.
Characterizing mildlycontext-sensitive grammar formalisms.Ph.D.
thesis, Department of Computer andInformation Science, University ofPennsylvania, Philadelphia, PA.Younger, D. H. 1967.
Recognition andparsing of context-free languages in timen3.
Information and Control, 10(2):189?208.Zhang, Hao and Daniel Gildea.
2007.Factorization of synchronous context-freegrammars in linear time.
In NAACLWorkshop on Syntax and Structure inStatistical Translation (SSST), pages 25?32,Rochester, NY.480
