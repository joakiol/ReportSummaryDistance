Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing, ACL 2010, pages 28?36,Uppsala, Sweden, 16 July 2010. c?2010 Association for Computational LinguisticsMillstream Systems ?
a Formal Model forLinking Language Modules by InterfacesSuna BenschDepartment of Computing Science,Umea?
University, Umea?, Swedensuna@cs.umu.seFrank DrewesDepartment of Computing Science,Umea?
University, Umea?, Swedendrewes@cs.umu.seAbstractWe introduce Millstream systems, a for-mal model consisting of modules and aninterface, where the modules formalisedifferent aspects of language, and the in-terface links these aspects with each other.1 CreditsThis work is partially supported by the projectTree Automata in Computational Language Tech-nology within the Sweden ?
South Africa Re-search Links Programme.
A preliminary but moredetailed version of this article is available as atechnical report (Bensch and Drewes, 2009).2 IntroductionModern linguistic theories (Sadock, 1991; Jack-endoff, 2002) promote the view that different as-pects of language, such as phonology, morphol-ogy, syntax, and semantics should be viewed asautonomous modules that work simultaneouslyand are linked with each other by interfaces thatdescribe their interaction and interdependency.Formalisms in modern computational linguisticswhich establish interfaces between different as-pects of language are the Combinatory CategoricalGrammar (CCG), the Functional Generative De-scription (FGD), the Head-Driven Phrase Struc-ture Grammar (HPSG), the Lexical FunctionalGrammar (LFG), and the Extensible DependencyGrammar (XDG).1 Here, we propose Millstreamsystems, an approach from a formal language the-oretic point of view which is based on the sameideas as XDG, but uses tree-generating modulesof arbitrary kinds.Let us explain in slightly more detail what aMillstream system looks like.
A Millstream sys-tem contains any number of tree generators, called1See, e.g., (Dalrymple, 2001; Sgall et al, 1986; Pollardand Sag, 1994; Steedman, 2000; Debusmann, 2006; Debus-mann and Smolka, 2006).its modules.
Such a tree generator is any devicethat specifies a tree language.
For example, a treegenerator may be a context-free grammar, tree ad-joining grammar, a finite-state tree automaton, adependency grammar, a corpus, human input, etc.Even within a single Millstream system, the mod-ules need not be of the same kind, since they aretreated as ?black boxes?.
The Millstream systemlinks the trees generated by the modules by an in-terface consisting of logical formulas.Suppose that a Millstream system has k mod-ules.
Then the interface consists of interface rulesin the form of logical expressions that establishlinks between the (nodes of the) trees t1, .
.
.
, tkthat are generated by the individual modules.Thus, a valid combination of trees is not just anycollection of trees t1, .
.
.
, tk generated by the kmodules.
It also includes, between these struc-tures, interconnecting links that represent theirrelationships and that must follow the rules ex-pressed by the interface.
Grammaticality, in termsof a Millstream system, means that the individ-ual structures must be valid (i.e., generated by themodules) and are linked in such a way that all in-terface rules are logically satisfied.
A Millstreamsystem can thus be considered to perform indepen-dent concurrent derivations of autonomous mod-ules, enriched by an interface that establishes linksbetween the outputs of the modules, thus con-straining the acceptable configurations.Millstream systems may, for example, be of in-terest for natural language understanding and nat-ural language generation.
Simply put, the taskof natural language understanding is to constructa suitable semantic representation of a sentencethat has been heard (phonology) and parsed (syn-tax).
Within the framework of Millstream sys-tems this corresponds to the problem where we aregiven a syntactic tree (and possibly a phonologi-cal tree if such a module is involved) and the goalis to construct an appropriate semantic tree.
Con-28versely, natural language generation can be seen asthe problem to construct an appropriate syntactic(and/or phonological) tree from a given semantictree.
In abstract terms, the situations just describedare identical.
We refer to the problem as thecompletion problem.
While the current paper ismainly devoted to the introduction and motivationof Millstream systems, in (Bensch et al, 2010) thecompletion problem is investigated for so-calledregular MSO Millstream systems, i.e.
systems inwhich the modules are regular tree grammars (or,equivalently, finite tree automata) and the interfaceconditions are expressed in monadic second-order(MSO) logic.
In Section 7, the results obtained sofar are briefly summarised.Now, let us roughly compare Millstream sys-tems with XDG.
Conceptually, the k modules of aMillstream system correspond to the k dimensionsof an XDG.
In an XDG, a configuration consistsof dependency structures t1, .
.
.
, tk.
The interfaceof a Millstream system corresponds to the princi-ples of the XDG.
The latter are logical formulasthat express conditions that the collection of de-pendency structures must fulfill.The major difference between the two for-malisms lies in the fact that XDG inherently buildsupon dependency structures, whereas the modulesof a Millstream system are arbitrary tree genera-tors.
In XDG, each of t1, .
.
.
, tk is a dependencyanalysis of the sentence considered.
In particu-lar, they share the yield and the set of nodes (asthe nodes of a dependency tree correspond to thewords in the sentence analysed, and its yield is thatsentence).
Millstream systems do not make simi-lar assumptions, which means that they may giverise to new questions and possibilities:?
The purpose of a Millstream system is notnecessarily the analysis of sentences.
For ex-ample, a Millstream system with two mod-ules could translate one language into an-other.
For this, tree grammars representingthe source and target languages could be usedas modules, with an interface expressing thatt2 is a correct translation of t1.
This sce-nario makes no sense in the context of XDG,because the sentences represented by t1 andt2 differ.
Many similar applications of Mill-stream system may the thought of, for exam-ple correction or simplification of sentences.?
As the modules may be arbitrary devicesspecifying tree languages, they contributetheir own generative power and theoreticalproperties to the whole (in contrast to XDG,which does not have such a separation).
Thismakes it possible to apply known results fromtree language theory, and to study the inter-play between different kinds of modules andinterface logics.?
The fact that the individual modules of aMillstream system may belong to differentclasses of tree generators could be linguis-tically valuable.
For example, a Millstreamsystem combining a dependency grammarmodule with a regular tree grammar module,could be able to formalise aspects of a givennatural language that cannot be formalised byusing only one of these formalisms.?
For Millstream systems whose modules aregenerative grammar formalisms (such as reg-ular tree grammars, tree-adjoining grammarsand context-free tree grammars), it will be in-teresting to study conditions under which theMillstream system as a whole becomes gen-erative, in the sense that well-formed config-urations can be constructed in a step-by-stepmanner based on the derivation relations ofthe individual modules.Let us finally mention another, somewhat sub-tle difference between XDG and Millstream sys-tems.
In XDG, the interfaces are dimensionson their own.
For example, an XDG captur-ing the English syntax and semantics would havethree dimensions, namely syntax, semantics, andthe syntax-semantics interface.
An analysis of asentence would thus consist of three dependencytrees, where the third one represents the relationbetween the other two.
In contrast, a correspond-ing Millstream system would only have two mod-ules.
The interface between them is consideredto be conceptually different and establishes directlinks between the trees that are generated by thetwo modules.
One of our tasks (which is, however,outside the scope of this contribution) is a study ofthe formal relation between XDG and Millstreamsystems, to achieve a proper understanding of theirsimilarities and differences.The rest of the paper is organised as follows.In the next section, we discuss an example illus-trating the linguistic notions and ideas that Mill-stream systems attempt to provide a formal basisfor.
After some mathematical preliminaries, which29are collected in Section 4, the formal definition ofMillstream systems is presented in Section 5.
Sec-tion 6 contains examples and remarks related toFormal Language Theory.
Finally, Section 7 dis-cusses preliminary results and future work.3 Linguistical BackgroundIn this section, we discuss an example, roughlyfollowing (Jackendoff, 2002), that illustrates thelinguistic ideas that have motivated our approach.Figure 1 shows the phonological, syntactical andsemantical structure, depicted as trees (a), (b) and(c), respectively of the sentence Mary likes Peter.Trees are defined formally in the next section, forthe time being we assume the reader to be familiarwith the general notion of a tree as used in linguis-tics and computer science.sw1mE@riw2w3laIkcl4sw5pit@rMorphophonologySegmental structure(a)SNP1 VPV2V3 infl4NP5(b) spres situation4likestate3maryagent1 peterpatient5(c)Figure 1: Phonological, syntactical and semanticalstructure of Mary likes Peter.The segmental structure in the phonologicaltree (a) is the basic pronunciation of the sentenceMary likes Peter, where each symbol representsa speech sound.
This string of speech sound sym-bols is structured into phonological words by mor-phophonolgy.
The morphophonological structurein our example consists of the three full phono-logical words mE@ri, laIk, pit@r and of the clitic s.The clitic is attached to the adjacent phonologi-cal word, thus forming a larger phonological con-stituent.
The syntactical tree (b) depicts the syn-tactical constituents.
The sentence S is dividedinto a noun phrase NP and a verb phrase VP.The verb phrase VP is divided into an inflectedverb V and a noun phrase NP.
The inflected verbconsists of its uninflected form and its inflection,which refers, in our example, to the grammaticalfeatures present tense and third person singular.The semantical tree (c) depicts the semantical con-stituents.
In our example, like is a function of typestate and takes two arguments, namely mary andpeter which are of type agent and patient .The structure of Mary likes Peter is not just thesum of its phonological, syntactical and semanti-cal structures.
It also includes the relationships be-tween certain constituents in these tree structures.To illustrate these relationships we use indices inFigure 1.
The sole role of the indices here is toexpress the linguistic relationships among coin-dexed constituents.
The indices do not occur in theformalisation, where they are replaced by logicallinks relating the nodes that, in the figure, carry thesame indices.2 The morphophonological wordw1,for example, is linked with the noun phrase NP1in the syntactical tree and with the conceptual con-stituent maryagent1 in the semantical tree.
This il-lustrates that w1, NP1, and maryagent1 are the cor-responding morphophonological, syntactical andsemantical representations of Mary, respectively.But there are also correspondences that concernonly the phonological and syntactical trees, ex-cluding the semantical tree.
For example, the in-flected word V2 in the syntactical structure corre-sponds to the phonological word w2, but has nolink to the semantical structure whatsoever.4 PreliminariesThe set of non-negative integers is denoted by N,and N+ = N \ {0}.
For k ?
N, we let [k] ={1, .
.
.
, k}.
For a set S, the set of all nonemptyfinite sequences (or strings) over S is denoted byS+; if the empty sequence  is included, we writeS?.
As usual, A1??
?
?
?Ak denotes the Cartesianproduct of sets A1, .
.
.
, Ak.
The transitive and re-flexive closure of a binary relation?
?
A?A ona set A is denoted by ??.
A ranked alphabet isa finite set ?
of pairs (f, k), where f is a symboland k ?
N is its rank.
We denote (f, k) by f (k), orsimply by f if k is understood or of lesser impor-tance.
Further, we let ?
(k) = {f (n) ?
?
| n = k}.We define trees over ?
in one of the standard ways,by identifying the nodes of a tree t with sequencesof natural numbers.
Intuitively, such a sequence2The reader is referred to (Bensch and Drewes, 2009) forthe proper formalisation of the example in terms of a Mill-stream system.30shows that path from the root of the tree to thenode in question.
In particular, the root is theempty sequence .Formally, the set T?
of trees over ?
consists ofall mappings t : V (t) ?
?
(called trees) with thefollowing properties:?
The set V (t) of nodes of t is a finite and non-empty prefix-closed subset of N?+.
Thus, forevery node vi ?
V (t) (where i ?
N+), itsparent v is in V (t) as well.?
For every node v ?
V (t), if t(v) = f (k), then{i ?
N | vi ?
V (t)} = [k].
In other words,the children of v are v1, .
.
.
, vk.Let t ?
T?
be a tree.
The root of t is the node.
For every node v ?
V (t), the subtree of trooted at v is denoted by t/v.
It is defined byV (t/v) = {v?
?
N?
| vv?
?
V (t)} and, for allv?
?
V (t/v), (t/v)(v?)
= t(vv?).
We shall de-note a tree t as f [t1, .
.
.
, tk] if t() = f (k) andt/i = ti for i ?
[k].
In the special case wherek = 0 (i.e., V (t) = {}), the brackets may beomitted, thus denoting t as f .
For a set S of trees,the set of all trees of the form f [t1, .
.
.
, tk] suchthat f (k) ?
?
and t1, .
.
.
, tk ?
S is denoted by?(S).
For a tuple T ?
Tk?, we let V (T ) denotethe set {(i, v) | i ?
[k] and v ?
V (ti)}.
Thus,V (T ) is the disjoint union of the sets V (ti).
Fur-thermore, we let V (T, i) denote the ith componentof this disjoint union, i.e., V (T, i) = {i} ?
V (ti)for all i ?
[k].
A tree language is a subset of T?,for a ranked alphabet ?, and a ?-tree generator (orsimply tree generator) is any sort of formal deviceG that determines a tree language L(G) ?
T?.
Atypical sort of tree generator, which we will use inour examples, is the regular tree grammar.Definition 1 (regular tree grammar).
A regulartree grammar is a tuple G = (N,?, R, S) con-sisting of disjoint ranked alphabets N and ?
ofnonterminals and terminals, where N = N (0), afinite set R of rules A ?
r, where A ?
N andr ?
T?
?N , and an initial nonterminal S ?
N .Given trees t, t?
?
T?
?N , there is a derivationstep t ?
t?
if t?
is obtained from t by replacinga single occurrence of a nonterminal A with r,where A ?
r is a rule in R. The regular treelanguage generated by G isL(G) = {t ?
T?
| S??
t}.It is well known that a string language L iscontext-free if and only if there is a regular treelanguage L?, such that L = yield(L?).
Here,yield(L?)
= {yield(t) | t ?
L?}
denotes the set ofall yields of trees in L?, the yield yield(t) of a treet being the string obtained by reading its leavesfrom left to right.5 Millstream SystemsThroughout the rest of this paper, let ?
denote anytype of predicate logic that allows us to make useof n-ary predicates symbols.
We indicate the ar-ity of predicate symbols in the same way as therank of symbols in ranked alphabets, i.e., by writ-ing P (n) if P is a predicate symbol of arity n. Theset of all well-formed formulas in ?
without freevariables (i.e., the set of sentences of ?)
is denotedby F?.
If S is a set, we say that a predicate symbolP (n) is S-typed if it comes with an associated type(s1, .
.
.
, sn) ?
Sn.
We write P : s1 ?
?
?
?
?
sn tospecify the type of P .
Recall that an n-ary predi-cate ?
on D is a function ?
: Dn ?
{true, false}.Alternatively, ?
can be viewed as a subset of Dn,namely the set of all (d1, .
.
.
, dn) ?
Dn such that?
(d1, .
.
.
, dn) = true.
We use these views in-terchangeably, selecting whichever is more conve-nient.
Given a (finite) set P of predicate symbols,a logical structure ?D; (?P )P?P?
consists of a setD called the domain and, for each P (n) ?
P , apredicate ?P ?
Dn.
If an existing structure Zis enriched with additional predicates (?P )P?P ?
(where P?P ?
= ?
), we denote the resulting struc-ture by ?Z; (?P )P?P ??.
In this paper, we will onlyconsider structures with finite domains.
To repre-sent (tuples of) trees as logical structures, considera ranked alphabet ?, and let r be the maximumrank of symbols in ?.
A tuple T = (t1, .
.
.
, tk) ?Tk?
will be represented by the structure|T | = ?V (T ); (Vi)i?
[k], (labg)g?
?, (?i)i?
[r]?consisting of the domain V (T ) and the predicatesV (1)i (i ?
[k]), lab(1)g (g ?
?)
and ?
(2)i (i ?
[r]).The predicates are given as follows:?
For every i ?
[k], Vi = V (T, i).
Thus, Vi(d)expresses that d is a node in ti (or, to be pre-cise, that d represents a node of ti in the dis-joint union V (T )).?
For every g ?
?, labg = {(i, v) ?
V (T ) |i ?
[k] and ti(v) = g}.
Thus, labg(d) ex-presses that the label of d is g.?
For every j ?
[r], ?j = {((i, v), (i, vj)) |i ?
[k] and v, vj ?
V (ti)}.
Thus, ?j(d, d?
)31expresses that d?
is the jth child of d in oneof the trees t1, .
.
.
, tk.
In the following, wewrite d ?j d?
instead of ?j(d, d?
).Note that, in the definition of |T |, we haveblurred the distinction between predicate symbolsand their interpretation as predicates, because thisinterpretation is fixed.
Especially in intuitive ex-planations, we shall sometimes also identify thelogical structure |T | with the tuple T it represents.To define Millstream systems, we start by for-malising our notion of interfaces.
The idea is thata tuple T = (t1, .
.
.
, tk) of trees, represented bythe structure |T |, is augmented with additional in-terface links that are subject to logical conditions.An interface may contain finitely many differentkinds of interface links.
Formally, the collectionof all interface links of a given kind is viewed asa logical predicate.
The names of the predicatesare called interface symbols.
Each interface sym-bol is given a type that indicates which trees it isintended to link with each other.For example, if we want to make use of ternarylinks called TIE, each linking a node of t1 witha node of t3 and a node of t4, we use the in-terface symbol TIE : 1 ?
3 ?
4.
This interfacesymbol would then be interpreted as a predicate?TIE ?
V (T, 1)?
V (T, 3)?
V (T, 4).
Each triplein ?TIE would thus be an interface link of type TIEthat links a node in V (t1) with a node in V (t3) anda node in V (t4).Definition 2 (interface).
Let ?
be a ranked al-phabet.
An interface on Tk?
(k ?
N) is a pairINT = (I,?
), such that?
I is a finite set of [k]-typed predicate symbolscalled interface symbols, and?
?
is a finite set of formulas in F?
that may,in addition to the fixed vocabulary of ?, con-tain the predicate symbols in I and those ofthe structures |T | (where T ?
Tk?).
Theseformulas are called interface conditions.A configuration (w.r.t.
INT ) is a structure C =?|T |; (?I)I?I?, such that?
T ?
Tk?,?
?I ?
V (T, i1)?
?
?
?
?
V (T, il) for every in-terface symbol I : i1 ?
?
?
?
?
il in I, and?
C satisfies the interface conditions in ?
(ifeach symbol I ?
I is interpreted as ?I ).Note that several interfaces can always be com-bined into one by just taking the union of their setsof interface symbols and interface conditions.Definition 3 (Millstream system).
Let ?
be aranked alphabet and k ?
N. A Millstream sys-tem (MS, for short) is a system of the form MS =(M1, .
.
.
,Mk; INT ) consisting of ?-tree genera-tors M1, .
.
.
,Mk, called the modules of MS , andan interface INT on Tk?.
The language L(MS )generated by MS is the set of all configurations?|T |; (?I)I?I?
such that T ?
L(M1) ?
?
?
?
?L(Mk).Sometimes we consider only some of the treesin these tuples.
For this, if MS is as above and1 ?
i1 < ?
?
?
< il ?
k, we define the notationLMi1????
?Mil (MS ) = {(ti1 , .
.
.
, til) |?|(t1, .
.
.
, tk); (?I)I?I |?
?
L(MS )}.The reader should note that, intentionally, Mill-stream systems are not a priori ?generative?.
Evenless so, they are ?derivational?
by nature.
This isbecause there is no predefined notion of derivationthat allows us to create configurations by meansof a stepwise (though typically nondeterministic)procedure.
In fact, there cannot be one, unless wemake specific assumptions regarding the way inwhich the modules work, but also regarding thelogic ?
and the form of the interface conditionsthat may be used.
Similarly, as mentioned in theintroduction, there is no predefined order of im-portance or priority among the modules.6 Examples and Remarks Related toFormal Language TheoryThe purpose of this section is to indicate, bymeans of examples and easy observations, thatMillstream systems are not only linguistically wellmotivated, but also worth studying from the pointof view of computer science, most notably regard-ing their algorithmic and language-theoretic prop-erties.
While this kind of study is beyond the scopeof the current article, part of our future research onMillstream systems will be devoted to such ques-tions.Example 1.
Let ?
be ordinary first-order logicwith equality, and consider the Millstream systemMS over ?
= {?
(2), a(0), b(0), c(0), d(0)} whichconsists of two identical modules M1 = M2 thatsimply generate T?
(e.g., using the regular treegrammar with the single nonterminal S and the32rules3 S ?
?
[S, S] | a | b | c | d) and a sin-gle interface symbol BIJ : 1 ?
2 with the interfaceconditions?x : lab{a,b,c,d}(x)?
?y : BIJ(x, y) ?
BIJ(y, x),?x, y, z : (BIJ(x, y) ?
BIJ(x, z)?BIJ(y, x) ?
BIJ(z, x))?
y = z,?x, y : BIJ(x, y)??z?
{a,b,c,d}(labz(x) ?
labz(y)).The first interface condition expresses that alland only the leaves of both trees are linked.
Thesecond expresses that no leaf is linked with two ormore leaves.
In effect, this amounts to saying thatBIJ is a bijection between the leaves of the twotrees.
The third interface condition expresses thatthis bijection is label preserving.
Altogether, thisamounts to saying that the yields of the two treesare permutations of each other; see Figure 2.?
?b ?c d?a c?d ?
?c b?c abijbijbijbijbijFigure 2: An element of L(MS ) in Example 1.Now, let us replace the modules by slightlymore interesting ones.
For a string w over {A,B,a, b, c, d}, let w denote any tree over {?
(2), A(0),B(0), a(0), b(0), c(0), d(0)} with yield(w) = w.(For example, we may choose w to be the leftcomb whose leaf symbols are given by w.) Let theMillstream system MS ?
be defined as MS , but us-ing the modules M ?1 = ({A,B,C,D},?, R1, A)and M ?2 = ({A,B},?, R2, A) with the followingrules:R?1 = {A?
aA | aB, B ?
bB | bC,C ?
cC | cD, D ?
dD | d},R?2 = {A?
acA | acB, B ?
bdB | bd}.Thus, M ?1 and M ?2 are the ?standard?
grammars(written as regular tree grammars) that generatethe regular languages {akblcmdn | k, l,m, n ?3As usual, A ?
r | r?
stands for A ?
r, A ?
r?.1} and {(ac)m(bd)n | m,n ?
1}.
The inter-face makes sure that LM ?1?M ?2(MS ?)
contains onlythose pairs of trees t1, t2 in which yield(t1) is apermutation of yield(t2).
As a consequence, itfollows that yield(LM ?1(MS )) = {ambncmdn |m,n ?
1}.The next example discusses how top-down treetransductions can be implemented as Millstreamsystems.Example 2 (top-down tree transduction).
Recallthat a tree transduction is a binary relation ?
?T?
?
T??
, where ?
and ??
are ranked alpha-bets.
The set of trees that a tree t ?
T?
is trans-formed into is given by ?
(t) = {t?
?
T??
|(t, t?)
?
?}.
Obviously, every Millstream systemof the form MS = (M1,M2; INT ) defines a treetransduction, namely LM1?M2(MS ).
Let us con-sider a very simple instance of a deterministic top-down tree transduction ?
(see, e.g., (Ge?cseg andSteinby, 1997; Fu?lo?p and Vogler, 1998; Comon etal., 2007) for definitions and references regardingtop-down tree transductions), where ?
= ??
={f (2), g(2), a(0)}.
We transform a tree t ?
T?
intothe tree obtained from t by interchanging the sub-trees of all top-most fs (i.e., of all nodes that arelabelled with f and do not have an ancestor thatis labelled with f as well) and turning the f athand into a g. To accomplish this, a top-downtree transducer would use two states, say SWAPand COPY, to traverse the input tree from the topdown, starting in state SWAP.
Whenever an f isreached in this state, its subtrees are interchangedand the traversal continues in parallel on each ofthe subtrees in state COPY.
The only purpose ofthis state is to copy the input to the output withoutchanging it.
Formally, this would be expressed bythe following term rewrite rules, viewing the statesas symbols of rank 1:SWAP[f [x1, x2]] ?
g[COPY[x2], COPY[x1]],COPY[f [x1, x2]] ?
f [COPY[x1], COPY[x2]],SWAP[g[x1, x2]] ?
g[SWAP[x1], SWAP[x2]],COPY[g[x1, x2]] ?
g[COPY[x1], COPY[x2]],SWAP[a] ?
a,COPY[a] ?
a.
(We hope that these rules are intuitive enough tobe understood even by readers who are unfamiliarwith top-down tree transducers, as giving the for-mal definition of top-down tree transducers wouldbe out of the scope of this article.)
We mimicthe behaviour of the top-down tree transducer us-33ing a Millstream system with interface symbolsSWAP : 1 ?
2 and COPY : 1 ?
2.
Since the mod-ules simply generate T?, they are not explicitlydiscussed.
The idea behind the interface is that aninterface link labelled q ?
{SWAP, COPY} links anode v in the input tree with a node v?
in the outputtree if the simulated computation of the tree trans-ducer reaches v in state q, resulting in node v?
inthe output tree.
First, we specify that the initialstate is SWAP, which simply means that the rootsof the two trees are linked by a SWAP link:?x, y : root1(x) ?
root2(y)?
SWAP(x, y),where root i is defined as root i(x) ?
Vi(x) ?
@y : y ?1 x.
It expresses that x is the root oftree i.
The next interface condition corresponds tothe first rule of the simulated top-down tree trans-ducer:?x, y, x1, x2 : SWAP(x, y)?labf (x)?
x ?1 x1?x ?2 x2 ?
labg(y)?
?y1, y2 : y ?1 y1?y ?2 y2?COPY(x1, y2) ?
COPY(x2, y1).In a similar way, the remaining rules are turnedinto interface conditions, e.g.,?x, y, x1, x2 : COPY(x, y)?labf (x)?
x ?1 x1?x ?2 x2 ?
labf (y)?
?y1, y2 : y ?1 y1?y ?2 y2?COPY(x1, y1) ?
COPY(x2, y2).The reader should easily be able to figure outthe remaining interface conditions required.One of the elements of L(MS ) is shown in Fig-ure 3.
It should not be difficult to see that, indeed,LM1?M2(MS ) = ?
.gfa fa aaggfa aaaswapswapcopycopycopy copyswapFigure 3: An element of L(MS ) in Example 2.Extending the previous example, one can eas-ily see that all top-down and bottom-up tree trans-ductions can be turned into Millstream systemsin a way similar to the construction above.
Asimilar remark holds for many other types of treetransductions known from the literature.
Most no-tably, monadic second-order definable tree trans-ductions (Engelfriet and Maneth, 1999; Engelfrietand Hoogeboom, 2001; Engelfriet and Maneth,2003) can be expressed as Millstream systems.Since the mentioned types of tree transductionsare well studied, and much is known about theiralgorithmic properties, future research on Mill-stream systems should investigate the relation-ship between different types of tree transductionsand Millstream systems in detail.
In particular,it should be tried to formulate requirements onthe interface conditions that can be used to ob-tain characterisations of various classes of treetransductions.
We note here that results of thistype would not only be interesting from a purelymathematical point of view, since tree transduc-ers have turned out to be a valuable tool in, forexample, machine translation (Knight and Graehl,2005; May and Knight, 2006; Graehl et al, 2008).7 Preliminary Results and Future WorkMillstream systems, as introduced in this article,are formal devices that allow to model situationsin which several tree-generating modules are inter-connected by logical interfaces.
In a forthcomingpaper (Bensch et al, 2010), we investigate the the-oretical properties of regular MSO Millstream sys-tems, i.e., Millstream systems in which the mod-ules are regular tree grammars and the logic usedis monadic second-order logic.
In particular, westudy the so-called completion problem.
Givena Millstream system with k modules and l ?
kknown trees ti1 , .
.
.
, til (1 ?
i1 < ?
?
?
< il ?
k),the task is to find a completion, i.e., a configura-tion whose ij th tree is tij for all j ?
[l].
Thus, ifviewed as a pure decision problem, the completionproblem corresponds to the membership problemfor LMi1????
?Mil (MS ).
To be useful in applica-tions, algorithms solving the completion problemshould, of course, be required to explicitly con-struct a completion rather than just answering yes.Let us briefly summarize the results of (Benschet al, 2010).1.
In general, the completion problem is unde-cidable for k ?
l ?
2 even in the case whereonly the use of first-order logic is permitted.This can be shown by reducing Post?s corre-spondence problem (PCP) to the emptinessproblem for a regular FO Millstream systemwith k = 2.
The Millstream system con-structed is somewhat similar to the one in Ex-ample 1, as it establishes bijective correspon-dences between the nodes of two trees (that34represent the two parts of a solution to a PCPinstance).2.
If there are no direct links between unknowntrees (i.e., |{j1, .
.
.
, jm} \ {i1, .
.
.
, il}| ?
1for each interface symbol I : j1 ?
?
?
?
?
jm),then the completion problem is solvable forall regular MSO Millstream systems.3.
Applying some well-known results, the com-pletion problem is solvable for all regularMSO Millstream systems for which L(MS )is of bounded tree width.
Thus, it is of inter-est to establish conditions that guarantee theconfigurations in L(MS ) to be of boundedtree width.
Two such conditions, are givenin (Bensch et al, 2010).
Roughly speaking,they require that the links respect the struc-ture of the trees.
Let us informally describeone of them, called nestedness.
Say that alink I ?
(u1, .
.
.
, um) is directly below a linkI(v1, .
.
.
, vl) if there are i, j such that uj isa descendant of vi and none of the nodes inbetween carries a link.
Now, fix a constanth.
A configuration is nested if the roots arelinked with each other and the following holdfor every link ?
= I(v1, .
.
.
, vl):(a) There are at most h links I ?
(u1, .
.
.
, um)directly below ?.
(b) Each of the nodes uj in (a) is a descen-dant of one of the nodes vi.As mentioned above, L(MS ) is of boundedtree width if its configurations are nested(with respect to the same constant h).Nestedness, and also the second sufficient con-dition for bounded tree width studied in (Benschet al, 2010) restrict the configurations themselves.While such conditions may be appropriate in manypractical cases (where one knows what the config-urations look like), future research should also at-tempt to find out whether it is possible to put someeasily testable requirements on the interface con-ditions in order to force the configurations to beof bounded tree width.
Note that, since the prop-erty of being of tree width at most d is expressiblein monadic second-order logic, one can always ar-tificially force the configurations of a given MSOMillstream system to be of bounded tree width, butthis is not very useful as it would simply excludethose configurations whose tree width is greaterthan the desired constant d, thus changing the se-mantics of the given Millstream system in a usu-ally undesired manner.Future work should also investigate propertiesthat make it possible to obtain or complete config-urations in a generative way.
For example, for reg-ular MSO Millstream systems with interface con-ditions of a suitable type, it should be possible togenerate the configurations in L(MS ) by generat-ing the k trees in a parallel top-down manner, atthe same time establishing the interface links.
Re-sults of this kind could also be used for solvingthe completion problem in an efficient manner.
Ingeneral, it is clear that efficiency must be an im-portant aspect of future theoretical investigationsinto Millstream systems.In addition to theoretical results, a good imple-mentation of Millstream systems is needed in or-der to make it possible to implement nontrivial ex-amples.
While this work should, to the extent pos-sible, be application independent, it will also benecessary to seriously attempt to formalise and im-plement linguistic theories as Millstream systems.This includes exploring various such theories withrespect to their appropriateness.To gain further insight into the usefulness andlimitations of Millstream systems for Computa-tional Linguistics, future work should elaborate ifand how it is possible to translate formalisms suchas HPSG, LFG, CCG, FDG and XDG into Mill-stream systems.AcknowledgmentsWe thank Dot and Danie van der Walt for pro-viding us with a calm and relaxed atmosphere atMillstream Guest House in Stellenbosch (SouthAfrica), where the first ideas around Millstreamsystems were born in April 2009.
Scientifically,we would like to thank Henrik Bjo?rklund, StephenJ.
Hegner, and Brink van der Merwe for discus-sions and constructive input.
Furthermore, wewould like to thank one of the referees for valu-able comments.ReferencesSuna Bensch and Frank Drewes.
2009.
Mill-stream systems.
Report UMINF 09.21,Umea?
University.
Available at http://www8.cs.umu.se/research/uminf/index.cgi?year=2009&number=21.35Suna Bensch, Henrik Bjo?rklund, and Frank Drewes.2010.
Algorithmic properties of Millstream sys-tems.
In Sheng Yu, editor, Proc.
14th Intl.
Conf.on Developments in Language Theory (DLT 2010),Lecture Notes in Computer Science.
To appear.Hubert Comon, Max Dauchet, Re?mi Gilleron, Flo-rent Jacquemard, Christof Lo?ding, Denis Lugiez,Sophie Tison, and Marc Tommasi.
2007.
TreeAutomata Techniques and Applications.
Internetpublication available at http://tata.gforge.inria.fr.
Release October 2007.Mary Dalrymple.
2001.
Lexical Functional Gram-mar, volume 34 of Syntax and Semantics.
AcademicPress.Ralph Debusmann and Gert Smolka.
2006.
Multi-dimensional dependency grammar as multigraph de-scription.
In Proceedings of FLAIRS Conference,pages 740?745.Ralph Debusmann.
2006.
Extensible DependencyGrammar: A Modular Grammar Formalism BasedOn Multigraph Description.
Ph.D. thesis, Univer-sita?t des Saarlandes.
Available at http://www.ps.uni-sb.de/?rade/papers/diss.pdf.Joost Engelfriet and Henrik Jan Hoogeboom.
2001.MSO definable string transductions and two-wayfinite-state transducers.
ACM Transactions on Com-putational Logic, 2:216?254.Joost Engelfriet and Sebastian Maneth.
1999.
Macrotree transducers, attribute grammars, and MSO de-finable tree translations.
Information and Computa-tion, 154:34?91.Joost Engelfriet and Sebastian Maneth.
2003.
Macrotree translations of linear size increase are MSO de-finable.
SIAM Journal on Computing, 32:950?1006.Zolta?n Fu?lo?p and Heiko Vogler.
1998.
Syntax-DirectedSemantics: Formal Models Based on Tree Transduc-ers.
Springer.Ferenc Ge?cseg and Magnus Steinby.
1997.
Tree lan-guages.
In G. Rozenberg and A. Salomaa, editors,Handbook of Formal Languages.
Vol.
3: BeyondWords, chapter 1, pages 1?68.
Springer.Jonathan Graehl, Kevin Knight, and Jonathan May.2008.
Training tree transducers.
ComputationalLinguistics, 34(3):391?427.Ray Jackendoff.
2002.
Foundations of Language:Brain, Meaning, Grammar, Evolution.
Oxford Uni-versity Press, Oxford.Kevin Knight and Jonathan Graehl.
2005.
Anoverview of probabilistic tree transducers for naturallanguage processing.
In Alexander F. Gelbukh, edi-tor, Proc.
6th Intl.
Conf.
on Computational Linguis-tics and Intelligent Text Processing (CICLing 2005),volume 3406 of Lecture Notes in Computer Science,pages 1?24.
Springer.Jonathan May and Kevin Knight.
2006.
Tiburon:A weighted tree automata toolkit.
In Oscar H.Ibarra and Hsu-Chun Yen, editors, Proc.
11th Intl.Conf.
on Implementation and Application of Au-tomata (CIAA 2006), volume 4094 of Lecture Notesin Computer Science, pages 102?113.
Springer.Carl Pollard and Ivan Sag.
1994.
Head-Driven PhraseStructure Grammar.
Chicago University Press.Jerrold Sadock.
1991.
Autolexical Syntax - A Theoryof Parallel Grammatical Representations.
The Uni-versity of Chicago Press, Chicago & London.Petr Sgall, Eva Hajic?ova?, and Jarmila Panevova?.
1986.The meaning of the sentence in its semantic andpragmatic aspects.
Reidel, Dordrecht.Mark Steedman.
2000.
The Syntactic Process (Lan-guage, Speech, and Communication).
MIT Press.36
