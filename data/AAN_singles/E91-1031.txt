Prediction in Chart Parsing Algorithms forCategorial Unification GrammarGosse BoumaComputat iona l  Linguistics Depar tmentUniversity of Groningen, P.O.
box 716NL-9700 AS Groningen, The Nether landse-mail:gosse@let.rug.nlAbstractNatural language systems based on Categorial Unifica-tion Grammar (CUG) have mainly employed bottom-up parsing algorithms for processing.
Conventionalprediction techniques to improve the efficiency of the?
parsing process, appear to fall short when parsing CUG.Nevertheless, prediction seems necessary when parsinggrammars with highly ambiguous lexicons or with non-canonical categorial rules.
In this paper we present alexicalist prediction technique for CUG and show thaithis may lead to considerable gains in efficiency for bothbottom-up and top-down parsing.1 Prel iminariesCATEGORIAL UNIFICATION GRAMMAR.. Unification-based versions of Categorial Grammar, known as CUGor UCG, have attracted considerable attention recently(see, for instance, Uszkoreit, 1986, Karttunen, 1986,Bouma, 1988, Bouma et al, 1988, and Calder et al,1988).
The categories of Categorial Grammar (CG)can be encoded easily as feature-structures, in whichthe attribute < cat > dominates either an atomic value(in case of an atomic category) or a structure with at-tributes < val  >, < dir  > and < arg > (in case ofa complex category).
Morphosyntactic information canbe added by introducing additional labels.
An exampleof such a category represented as attribute-value matrixis presented below.N P \ [+nom\] /N \ [+nom,  +sg\] =val  : case : norad i r  : r ightarg : case : nomhum : sgThe combinatory rules of classical CG, A ~ A /B  B(rightward application) and A ---, B B \A  (leftward ap-plication), can be encoded as highly schematic rewriterules associated with an attribute-value graph:Rightward Appl icat ion Rule :Xo ~ XI X2Xo:< 1> \[-Xl  : \] cat :1.X~ :<2>dir  : r ightarg :< 2 >Lef tward  App l i ca t ion  Ru le  :X0 --* X1 X2X0:< 1>X1 :<2>dir  : l e f targ :< 2 >CUG is a lexicalist theory: language specific in-formation about word order, subcategorization, agree-ment, case-assignment, e c., is stored primarily in thelexicon.
Whereas in classical CG functor-argumentstructure is the only means available for describing ling-uistic phenomena, in CUG additional features may beused to account for phenomena such as agreement andcase-marking (see Bouma 1988).
Also, whereas in clas-sical CG all rules are in principle universal (i.e.
notlanguage-specific), in CUG there is a tendency to sup-plement generic categorial rules with language or con-struction specific rules For instance, a ruleN P ~ N \[+plu\]may be added to account for the occurence of bareplural NPs, and specific rules may be added to ac-count for unbounded ependency constructions (Bouma- 179  -1987).
Finally, instead of fully instantiated category-structures, one may choose to work with polymorphiccategories (Karttunen 1989, Zeevat et al 1987).
Con-sequently, CUG not only shows resemblances with tra-ditional categorial grammar, but also with Head-drivenPhrase Structure Grammar (Pollard &: Sag, 1987), an-other lexicalist and unification-based framework.CHART PARSING OF UNIFICATION GRAMMAR(UG).
Parsing methods for context-free grammar canbe extended to unification-based grammar formalisms(see Shieber, 1985 or Haas, 1989), and therefore theycan in principle be used to parse CUG.
A chart-parserscans a sentence from left to right, while enteringitems, representing (partial) derivations, in a chart.Assume that items are represented as Prolog termsof the form item(Begin, End, LH S, Parsed, ToParse),where LHS is a feature-structure and Parsedand ToParse contain lists of feature-structures.An item(O, 1, \[S\],\[NP\], \[V  NP\] )  represents a partialderivation ranging from position 0 to 1 of a constituentwith feature-structure S, of which a daughter NP hasbeen found and of which daughters V and NP arestill to be parsed.
A word with lexical entry Word :Cat at position Begin, leads to addition of an itemitem(Begin, Begin + 1, Cat, \[Word\], \[ \]).
Next, com-pletion and prediction steps are called until no furtheritems can be added to the chart.Complet ion  step: I For each item(B, ".
E, LHS,Parsed, \[NeztlToParse\]) and item(E, End, Next,Parsed, \[\]), add an item(B, End, LHS,Parsed+Next, ToParse).Bot tom-up Pred ic t ion  step: For each item(B, E,Next, Parsed, \[1), and each rule (LHS--~ \[Next IRHS\]), add item(B, E, LHS, \[Next\], RHS).The prediction step causes the algorithm to workbottom-up.2 The Prob lemIn a bottom-up chart parser, applicable rules are pre-dicted bottom-up, and thus, lexical information is usedto constrain the addition of active items (i.e.
itemsrepresenting partial derivations).
At first sight, thismethod appears to be ideal for CUG, as in CUGthe lexical items contain syntactic information whichis language and grammar specific, whereas the rulesare generic in nature.
Note, however, that although1 In these and following definitions, we assume, unless other-'wise indicated, that feature-structures d noted by identical prologvariables are unified by means of feature-unificatiombottom-up parsing is certainly attractive for CUG,there are also a number of potential inefficiencies:In many cases useless items will be predicted.Consider, for instance, a grammar with a lexi-con containing only the categories NP/N, N, andNP\S, and with application as the only combina-tory rules.
When encountering a determiner, pre-diction of an item(i,i, X, \[np/n\], \[(np/n)\X\]) issuperfluous, ince there is simply no way that thegrammar could ever produce a category (np/n)\X2If the lexicon is highly ambiguous, many useless(partial) derivations may take place.
Consider,for instance, the syntax of NPs in German, wheredeterminers and adjectives are ambiguous withrespect to case, declension pattern, gender andnumber (see Zwicky, 1986, for an analysis in termsof GPSG).
The sentence die junge Frau schldfl hasonly one derivation, but a bottom-up arser has toconsider 11 possible analyses for the word junge,6 for the phrase junge Frau, 4 for die and 2 fordie junge Frau.
This example shows that even irka pure categorial system, there may be situationswhere top-down prediction has its merits.If the grammar contains language or constructionspecific rules, bottom-up prediction may be lessefficient.
Relevant examples are the rule for form.ing bare plurals mentioned irk tile previous ectionand rules which implement a categorial version ofgap-threading (see Pereira & Shieber, 1986 : l l4if).
The rule shemata below allow for the deriva-tion of sentences with a preposed element and forthe extraction of arguments:Gap-elimination: S --* X S\[gap : X\]Gap-introduction: X\[gap : Y\] ~ X /YX\[gap : Y\] ---* Y \XOap-introduction will be used every time a func-for category is encountered.
Again, some form oftop-down prediction could improve this situation.In the following sections, we will consider top-downparsing, as an alternative for the bottom-up approach,and we will consider the possibility of improving thepredictive capabilities of a bottom-up arser.~The example may suggest hat prediction should be elimi-nated Ml  together .
This option is feasible only if the rule set isrestricted to application.- 180  -3 Top-down ParsingTop-down chart parsing differs from the algorithm de-scribed above only in the prediction-step, which pre-dicts applicable rules top-down.
Contrary to bottom-up parsing, however, the adaptation of a top-down al-gorithm for UG requires some special care.
For UGswhich lack a so-called context-free back-bone, such asCUG, the top-down prediction step can only be guar-anteed to terminate if we make use of restriction, asdefined in Shieber (1985).Top-down prediction with a restrictor R (where Ris a (finite) set of paths through a feature-structure)amounts to the following:Rest r i c t ion  The restriction of a feature-structure Frelative to a restrictor R is the most specificfeature-structure F ~ E_ F, such that every pathin F j has either an atomic value or is an elementof R.P red ic tor  S tep  For each item(_ , End, LHS, Parsed,\[Next I ToParse\]) such that Rjve~, is the re-striction of Next relative to R, and each ruleRNe~:t ~ RHS,  add item(i,i, Rge~:t, \[\], RHS).Restriction can be used to develop a top-down chartparser for CUG in which the (top-down) prediction stepterminates.
The result is unsatisfactory, however, forthe following two reasons.
First, as a consequence ofthe generic and language independent nature of cate-gorial rules, the role of top-down prediction as a con-straint on possible derivation steps is lost completely.Second, many useless items will be predicted due tothe fact that the LHS of both rightward and leftwardapplication always match with RJvext in the:predictionstep (note that a bottom-up parser has a similar inef-ficiency for leftward application only).
Therefore, theoverhead which is introduced by top-down predictiondoes not pay-off.
We conclude that, eventhough the in-troduction of restriction make it possible to parse CUGtop-down, in practice, such a method has no advantagesover a bottom-up approach.4 Lexicalist PredictionInstead of customizing existing top-down parsing algo-rithms for CUG, we can also try to take the oppositetrack.
That  is, we will try to represent a CUG in sucha way that non-trivial forms of top-down prediction arepossible.Top-down prediction, as described in the previoussection, relies wholly on the syntactic information en-coded in the syntactic rules.
For CUG, this is an akwardsituation, as most syntactic information which could berelevant for top-down prediction is located in the lexi-con.
tn order to make this information accessible to theparser, we precompile the grammatical rules into a setof instantiated rules.
The instantiated rules are more re-strictive than the generic categorial rules, as they takelexical information into account.The following algorithm computes a set of instanti-ated syntactic rules, given a set of generic rules and alexicon.Compi la t ion  For every category C, where C is eithera lexical category or the LHS of an instantiatedrule, and every (generic) rule GR, if C is utlifiablewith the head-daughter of GR, add GR' (the re-sult of the unification) to the set of instantiatedrules, aWe assume that there is some way of distinguishinghead-daughters from non-head daughters (for instance,by means of a feature).
The head daughter should bethe daughter which has the most ialluellce on the in-stantiation of the rule.
For the application rules, forinstance, the functor is the most natural choice, as thefunctor both determines the instantiation of the resul-tant category and of the argument category.The compilation step is correct and complete forarbitrary UGs, that is, a string is derivable using theinstantiated rules if and only if it is derivable usingthe generic rules.
Note, however, that the compila-tion procedure does not necessarily terminate.
Con-sider for instance a categorial gramrnar with categoryraising (X / (Y \X)  ---, Y).
In such a gramrnar, arbitrar-ily complex instantiations of this rule can be compiled.To avoid the creation of an infinite set of rules, we mayagain employ restriction:Compi la t ion  w i th  res t r i c t ion  Let R be a restrictor.For every category C, where C is either a lexicalcategory or the LHS of art instantiated rule, andevery (generic) rule GR, if the restriction of Crelative to R is unifiable with the head-daughterof GR, add GR ~ (the result of the unification) tothe set of instantiated rules.The compilation step is guaranteed to terminate a.slong as R is finite (cf.
Shieber, 1985).
The compi-lation procedure is not specific to a certain grammarformalism or rule set, and thus can be used to compilearbitrary UGs.
Such a compilation step will give riseto a substantially more instantiated rule set in all cases3Note that for classical CG, an algorithm of this kind canbe used to compute the phrase-structure eqtfivalent of the inputgranunax.181 -where schematic grammar ules are used in combinationwith highly structured lexical items.For the compiled grammar, a standard top-down al-gorithm (such as the one in section 3) can be used.
Pre-diction for CUG is now significant, as only rules whichhave a functor category that is actually derivable by thegrammar will be predicted.
So, starting from a categoryS, we will not predict leftmost categories such as S/NP,(S/NP)/NP, if no such categories can be derived fromthe lexical categories.
Also, a leftmost argument cate-gory A will only be predicted if the grammar containsa matching functor category A~S.
Finally, since we areworking with the instantiated rules, morphosyntacticinformation can effectively be predicted top-down.Restriction is not only useful to guarantee termi-nation of the compilation procedure.
The precompi-lation procedure can in principle lead to an instanti-ated grammar that is considerably larger than the inputgrammar.
For instance, given a grammar which distin-guishes between plural and singular and between first,second and third person NPs, six versions of the ruleS --~ NP NP\S  might be derivable.
Such a multipli-cation is unnecessary, however, as it does not provideany information which is useful for the top-down pre-diction step.
Choosing a restrictor which filters out alldistinctions that are irrelevant o top-down prediction,can prevent an explosion of the rule set.5 Bottom-Up Parsing with Pre-dictionThe compilation procedure described in section 4 wasdeveloped to improve the performance of top-downparsing-algorithms for lexicalist grammars of the CUG-variety.
In this section, we argue that replacing ageneric CUG with its instantiated.equivalent also hasadvantages for bottom-up arsing.
There are two rea-sons to believe that this is so: first, predictions based onleftward application will be less frequent and second, toan instantiated grammar non-trivial forms of top-downprediction can be added.In section 2 we pointed out that a bottom-up arserwill predict many useless instances of leftward applica-tion.
This is due to the fact that the leftmost daughterof leftward application is completely general and thus,given an item(B, E, Cat, Parsed, I\]), an item(B,E, X,\[Cat\], \[Cat\X\]) will always be predicted.
The compi-lation procedure presented in the previous section re-places leftward application with instantiated versionsof this rule, in which the leftmost argument of the ruleis instantiated.
Although the instantiated rule set of agrammar is bound to be larger than the original ruleset, which is a potential disadvantage, the chart willgrow less fast if we use theinstantiated grammar.
It istherefore worthwhile to investigate the performance ofa bottom-up arser which uses a compiled grammar asopposed to a bottom-up arser working with a genericrule set.There is a Second reason for considering instan-tiated grammars.
It is possible in bottom-up pars-ing to speed up the parsing process by adding top-down prediction.
Top-down prediction is implementedwith the help of a table containing items of theform left_corner(Ancestor, LeftCorner), which liststhe left-corner elation for the grammar at hand.
Theleft-corner relation is defined as follows:Le f t -corner  Category C1 is a left-corner of an ancestorcategory A if there is a rule A ---* C1 .... C,.
Therelation is,transitive: if A is a left-corner of B andB a left-corner of C, A is a left-corner of C.Top-down filtering is now achieved by modifying theprediction step as follows :Bot tom-up Pred ic t ion  wi th  Top-down F i l ter ing:For each item(B, E, Cat, Parsed, \[\]), and eachrule (Xo "-* \[Cat \[ RHS\]), such that there is anitem(_, B, _, _, \[NeztlToParse\]) with Xo a left-corner of Next, add item(B, E, Xo, \[Cat\], RHS) 4.For CUG it makes little sense to compute a left-corner relation according to this definition, since anycategory X is a left-corner of any category Y (accord-ing to leftward application), and thus the left-cornerrelation can never have any predictive power.For an instantiated grammar, the situation is morepromising.
For instance, given the fact that only nom-irmtive NPs occur as left-corner of S, and that everydeterminer which is the left-corner of NP, has a casefeature which is compatible (unifiable) with that NP, itcan be concluded that only nominative determiners canbe left-corners of S.Computing the left-corner elation mechanichallyfor a UG will not always lead to the most economic-a| representation of the left-corner table.
For exam-pie, in German the left-corner of an NP with case andnumber features X will be a determiner with identi:cal features.
If we compute this, using a sufficiently4The bottom-up arsing algorithm extended with left-cornerprediction is closely related to the BUP-parser of Matsumoto etal.
(1983).
The BUP-parser is based on definite clause grammarand thus, may backtrack.
Minimal use is made of a chart (inwhich successful and failed parse a t tempts  are stored).
Our algo-rithm assigns amore important role to the chart and thus avoidsbacktracking.182 -instantiated grammar, we get 8 versions (i.e.
4 casestimes 2 possible values for number) of this relation.Similar observations can be made for adjectives thatare left-corners of N (where things are even worse, aswe would like to take declension classes into accountas well).
This multiplication may lead to a needlesslylarge left-corner table, which, if used in the predictionstep, may in fact lead to sharp decreases in parsing per-formanee (see also Haas, 1989, who encountered sim-ilar problems).
Note that checking a left-corner tablecontaining feature-structures is in general expensive, asunification, rather than identity-tests, have to be car-ried out.To avoid tMs problem we have found it necessary toconstruct he left-corner table by hand, using linguisticmeta.knowledge about what is relevant, given a particu-lar left-corner elation, to top-down prediction to com-press the table to an absolute minimum.
It turns out tobe the case that only in this way the effect of top-downfiltering will pay-off against the increased overhead ofhaving to check the left-corner table.6 Some ResultsThe performance of the parsing algorithms discussedin the preceding sections (a bottom-up parser for UG(BU), a top-down parser for UG (of Shieber, 1985)(TD), a top-down parser operating on an instantiatedgrammar (TD/1), and a bottom-up parser with top-down filtering operating on an instantiated grammar(BU/LC)) were tested on two experimental CUGs, oneimplementing the morphosyntactic features of GermanN Ps, and one implementing the syntax of WH-questionsin Dutch by means of a gap-threading mechanism.Some illustrative results are listed in Tables 1 and 2.Sentencel Sentence2items sees items seesTD: 93 5.9 160 10.5TD/ I :  45 2.0 68 2.5BU:  68 2.0 120 3.0Bu/ c: 12 o.6 53 o .9Table1:  GermanFor German, an ideal restrictor R was {< l* > II =cat,val, arg, or dir}.
This restrictor effectively filtersout all morphosyntactic information, in as far as it is notrepeated in the categorial rules.
The resulting precom-piled grammar is much smaller than in the case whereno restriction was used or where morphosyntactic in-formation was not completely filtered out.
A categoriallexicon for German, for instance, containing only deter-miners, adjectives, nouns, and transitive and intransi-tive verbs, will give rise to more than 60 instantiatedrules if precompiled without restriction, whereas onlyfour rules are computed if R is used (i.e.
only two morethan in the uncompiled (categorial) grammar).
Theimprovement in efficiency of TD/ I  over TD is due tothe fact that no useless instances of leftward applica-tion are predicted and to the fact that no restriction isneeded during parsing with an instantiated grammar.Thus, prediction based on already processed materialcan be maximal.
As soon as we have parsed a cate-gory N P/N\[+sg, +wk, +dat, +fern\], for instance, top-down prediction will add only those items that haveN\[+sg, +wk, +dat, +fern\] as LHS.BU is almost, as efficient as TD/ I ,  eventhough itworks with a generic grammar, and thus produces(significantly) more chart-items.
Once we replace thegeneric grammar by an instantiated grammar, and addleft-corner relationships (BU/LC), the predictive capac-ities of the parser are maximal, and a sharp decrease inthe number of chart items and parse times occurs.Senteneel Sentence2 Sentence3items sees items sees items seesTD: 255 32.2 225 27.9 358 47.2TD/I :  48 3.2 71 6.0 \]29 11.9BU : 78 1.8 74  1.7 131 3.6BU/LC: 40 1.7 45 2.1 ~i9 3.9Tab le l :  Gap- thread ingFor the grammar with gap-threading (table 2),we used a restrictor R = {< 1 ?
> II =eat,val, arg,dir, gap, in or out}.
The TD parser en-counters erious difficulties in this case, whereas TD/ Iperforms significantly better, but still is rather ineffi-cient.
There is a distinct difference between BU andBU/LC if we look at the number of chart items, al-though the difference is less marked than in the case ofGerman.
In terms of parse times the two algorithmsare almost equivalent.Comparing our results with those of Shieber (1985)and Haas (1989), we see that in all cases top-down fil-tering may reduce the size of the chart significantly.Whereas Haas (1989) found that top-down filteringnever helps to actually decrease parse times in abottom-up arser, we have found at least one example(German) where top-down filtering is useful.- 183  -7 ConclusionsThere is a trend in modern linguistics to replace gram-mars that are completely anguage specific by grammarswhich combine universal rules and principles with lan-guage specific parameter settings, lexicons, etc.
Thistrend can be observed in such diverse frameworksas Lexical Functional Grammar, Government-BindingTheory, Head-driven Phrase Structure Grammar andCategorial Grammar.
In parsing with such formalisms,especially those formalisms that are unification-based,we find that traditional parsing-techniques, eventhoughthey may be applicable to UG, are no longer satisfac-tory.
In particular, prediction techniques which maybe efficient for phrase structure grammar do not alwayscarry over easily to UG.
The present paper shows that ifa grammar uses only schematic combinatory principlesinstead of phrase-structure rules, prediction is only pos-sible if we replace the generic rules by grammar-specificinstances of these rules.8 LiteratureBourns, G. 1987.
A Unification-based Analysis of Un-bounded Dependencies in Categorial Grammar, in J.Groenendijk, M. Stokhof, & F. Veltman (eds.)
Proceed-ings of the sixth Amsterdam Colloquium, University ofAmsterdam, Amsterdam, 1-19.Bourns, G., 1988, Modifiers and Specifiers in CategorialUnification Grammar, Linguistics, vol 26, 21-46.Bourns, G., E. KSnig, & H. Uszkoreit, 1988.
A Flexi-ble Graph-Unification Formalism and its Application toNatural Language Processing, IBM Journal of Researchand Development, 32, 170-184.Calder, J., E. Klein, & H. Zeevat 1988.
UnificationCategoriai Grammar: a concise, extendable grammarfor natural anguage processing.
Proceedings of Coling1988, Hungarian Academy of Sciences, Budapest, 83-86.Haas, A.
1989.
A Parsing Algorithm for UnificationGrammar.
Computational Linguistics 15-4, 219-232.Karttunen, L. 1989.
Radical Lexicalism.
In M. Baltin& A. Kroch (eds.
), Alternative Conceptions of PhraseStructure, Chicago University Press, Chicago, 43-66.Matsumoto, Y., H. Tanaka, H. Hirakawa, II.
Miyoshi,& H. Yasukawa, 1983, BUP : A Bottom-Up Parser em-bedded in Prolog.
New Generation Computing, vol 1,145-158.Pereira, F., & S. Shieber (1986).
Proiog and NaturalLanguage Analysis.
CSLI Lecture Notes 10, Universityof Chicago Press, Chicago.Pollard, C.  I.
Sag, 1987, Information-Based Syntaxand Semantics, vol 1 : Fundamentals, CSLI LectureNotes 13, University of Chicago Press, Chicago.Shieber, S. 1985.
Using Restriction to Extend Pars-ing Algorithms for Complex-Feature-Based Algorithms.Proceedings of the g2nd Annual Meeting of the As-sociation for Computational Linguistics, University ofChicago, Chicago, 145-152.Uszkoreit, H. 1986.
Categorial Unification Grammars.Proceedings of COLING 1985.
Institut fiir angewandteKommunikations- und Sprachforschung, Bonn, 187-194.Zeevat, H., E. Klein, & J. Calder, 1987.
An Introduc-tion to Unification Categorial Grammar.
In N. Had-dock, E. Klein, & G. Morill (eds.
), Categorial Grammar,Unification grammar, and Parsing, Edinburgh WorkingPapers in Cognitive Science, Vol.
1.Zwicky, A.
1986.
German Adjective Agreement inGPSG.
Linguistics, vol 24,957-990.- 184  :
