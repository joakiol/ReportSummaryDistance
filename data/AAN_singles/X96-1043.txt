TIPSTER Text Phase II Architecture DesignVersion 2.1p 19 June 1996Ralph GrishmanNew York Universitygfishman@cs.nyu.eduand theTIPSTER Phase H Contractors' Architecture Working Group (CA WG):Bill Caid, Jamie Callan, Jim Conley, Harold Corbin, Jim Cowie, Kathy DiBella,Ted Dunning, Joe Dzikiewicz, Louise Guthrie, Jerry Hobbs, Clint Hyde, Mark llgen,Paul Jacobs, Matt Mettler, Bill Ogden, Peggy Otsubo, Bev Schwartz, Ira Sider,Ralph Weischedel, and Remi Zajac1.0 GOALSThe TIPSTER Program aims to push the technology for access to information in large (multi-GB) text collections, inparticular for the analysts in Government agencies.
Technology is being developed for document detection("information retrieval") and for data extraction from free text.The primary mission of the TIPSTER Common Architecture is to provide a vehicle for efficiently delivering thisdetection and extraction technology to the Government agencies.
The Architecture also has a secondary mission ofproviding aconvenient and efficient environment for research in document detection and data extraction.To accomplish this mission, the TIPSTER Architecture is being designed to:?
provide APIs for document detection, data extraction, and the associated document management functions?
support monolingual and multilingual applications?
allow the interchange of modules from different suppliers ("plug and play")?
apply to a wide range of software and hardware nvironments?
scale to a wide range of volumes of document archives and of document flow?
support appropriate application response time?
support incorporation of multi-level security?
enhance detection and extraction through the exchange of information, and through easier access to linguisticannotations2492.0 CONCEPTSThe architecture is described by a set of object classes and a set of functions associated with these objects.
Inaddition, there is a "functional" section which indicates how data typically flows between these functions.2.1 Object ClassesAn object class is characterized by a class name, a set of named properties, and a set of operations.
Unless explicitlynoted otherwise, there is an operation (the property accessor function) associated with each property for reading thatproperty's value.
If the property is followed by (R, W), operations are provided both for reading and for writing thatproperty.
If the property is followed by (g), no functions are provided for reading or writing the property.Each property has a value, which may be?
an object (of one or several classes)?
a sequence of objects (ordered), denoted by "sequence of..."?
a string (of characters)?
an integer?
a byte?
a Boolean value (true or false)?
a member of an enumerated type, denoted by "one of { ... }"?
nilThe operations will include both procedures (which do not return a value) and functions (which do).
The notation isprocedure (type of argl, type of arg2 .... )function (type of argl, type of arg2 .... ): type of resultTo indicate the significance of particular arguments, an argument position may containargument name: argument typeIf a class C 1 is a subclass of another class C2 (indicated by the notation Type of C2 in the definition of C 1) then C 1inherits all the properties and operations of C2.The designation of a class as an Abstract Class indicates that the class is not intended to be instantiated but isintended to serve as a superclass for other classes (which will be instantiated).A class C can include operations whose name has the form "class.C".
If D is a type of C (i.e., class D includes thespecification Type of C), then the operation as inherited by D has the name "class.D".
This facility is provided toallow for the specialization of operations which create new instances of a class.2.20ptionalitySome objects and functions will be required: they must be implemented by any system conforming to thearchitecture.
Some objects and functions will be optional: they need not be included, but if they are, they mustconform to the standard.
This allows us to define standards, for example, for some linguistic annotations, withoutrequiring all systems to generate such annotations.2.3 Correspondence toInterface SpecificationsThis document provides an abstract definition of the architecture in terms of classes and operations.
Thisarchitecture will be implemented in a number of programming languages; currently implementations are being251developed in C, Tcl, and Common Lisp.
This section describes the correspondence b tween the set of operationsdescribed in this document and the APIs for implementations of this architecture in these programming languages.Common Lisp: The classes, properties, and operations defined herein correspond to those of a Common Lispimplementation f the TIPSTER Architecture as follows:1.
(because Lisp is normally not case sensitive) each capital letter in the name of a class, property, oroperation, except for the first letter in a name, will be preceded by a "-" in Lisp2.
each class, property, and operation corresponds to a Lisp class, property, and function3.
each argument of the form "class" becomes a positional argument; each argument of the form "name:class" becomes a keyword argument with the keyword name4.
sequences are represented as listsIn Lisp, the name of the property accessor function is formed from the class name, a hyphen, and the property name(e.g., attr ibute-name and attribute-value).
If the property is writable, the property accessor function acts as a"generalized variable" which can be set by serf; e.g., (serf (collection-owner collectionl) "Mitchell").C: Each operation defined herein corresponds to a C function, with the same name as in the abstract architecture.
Allarguments in the C implementation are positional; the argument names ("keywords") in the abstract architecture arenot used.
If property Comp of a class is readable, it is accessed by the function Get Comp; if it is also writeable, it isset by the function Set Comp.Note that the abstract architecture occasionally "overloads" operations: the same operation name may apply todifferent classes of arguments.
To support such overloading, the C implementations of the various classes, as well assets and sequences, hould employ a generic container structure which will allow a C function to determine the classof an actual argument.
1The C-language typing, including the overloading of various functions, is spelled out in Appendix C.Tci: Operation ames and argument lists in Tcl shall be the same as in the C implementation.2.3.1 Opt iona l  ArgumentsIn addition to the arguments which are specified for each operation in this document and which are required, animplementation f the Architecture may provide optional keyword or positional arguments for any of the operations.The operation must be able to complete and to perform the specified function even if only the required arguments aregiven, but use of the optional arguments may provide enhanced performance or a greater ange of functionality.2 .3.2 Imp lementat ion  of SequencesThe architecture includes the notion 'sequence of X', where X is a type, as one of the possible values of an argumentto an operation or the value of a property.
In describing an implementation of the Architecture (an API), it isnecessary to specify the representation r set of operations for such sequences.1 The overloading does not extend to basic C data types (char, int, float), since these could not be differentiated from structures by a calledprocedure.252The C language interface (Appendix C) defines types AttributeSet, AttributeValueSet, DocumentCollectionlndexSet,QueryCollectionlndex, SpanSet, and stringSet, corresponding to "sequence of Attribute', "sequence ofAttributeValue', "sequence of DocumentCollectionlndex', "sequence of QueryCollectionlndex', "sequence of Span',and "sequence of string' in the Architecture 2.
These are referred to collectively as XSets, where X may be Attribute,Span, etc.
An empty XSet is created by the operationCreateXSet 0: XSet(i.e., by one of the operations CreateAttributeSet, CreateSpanSet, c.).
The following operations apply to XSets:Nth (XSet, n: integer): Xreturns the nth element of XSet (where the first element of sequence has index 0)Push (XSet, X)adds X to the end of sequence XSetPop (XSet): Xremoves and returns the last element of XSetLength (XSet): integerreturns the length of XSetIn addition, the operation Free, described just below, applies to all types of objects, including XSets.2.4 Storage ManagementA free operation must be provided for every class of object o release the memory associated with that object as wellas to perform any necessary implementation specific leanup operations.2.5 Error HandlingA number of operations in the architecture describe rror conditions (generally with the phrase "it is an error if...").Such errors should be implemented by signaling an error rather than by returning an error value (this could beperformed in C by using the longjrnp function and in Common Lisp by the error function).The C implementation provides utility routines which simplify the use of longjmp for this purpose.2 Annotation sets are treated as a separately defined class in the Architecture, but its Nth and Length operations are designed to parallel those ofthe other sets.2533.0 BASIC CLASSES3.1 AttributesA number of classes will have "attributes".
This is a list of feature-value pairs, where the feature names are arbitrarystrings and the values can be any of a number of types:Class AttributePropertiesName: stringValue: AttributeValueOperationsCreateAttribute (name: string, value: AttributeValue): AttributeClass AttributeValuePropertiesValue: string OR ObjectReference OR sequence of AttributeValueOperationsCreateAttributeValue(string OR ObjectReference OR sequence of AttributeValue): AttributeValue 3TypeOf (AttributeValue): one of {string, sequence, CollectionReference, DocumentReference,AnnolationReference, AttributeReference }returns a member of the enumerated type, indicating the type of AttributeValueNote: AttributeValue is made a separate class, with an explicit TypeOf operator, out of deference to languages uchas C without dynamic type identification.
Because AttributeValue can take on multiple types, including types such asstrings which would not use a generic container structure, implementations in such languages must provide anexplicit ype discriminator here, accessible through the TypeOf operator.The value of an attribute may be (inter alia) a reference to a collection, document, annotation, or attribute:Abstract Class ObjectReferenceClass CollectionReferenceType of ObjectReferencePropertiesCollectionNarne: stringOperationsCreateCollectionReference (Collection): CollectionReference3 For implementation n languages which cannot determine the type of the argument at run time, such as C, this operation requires twoarguments.
The additional rgument ( he first of the two arguments) i  of enumerated type "'one of {string, sequence, CollectionReference,DocumentReference, AnnotationReference, AttributeReference}" and specifies the type of the second argument, which is the value itself.255Class Document ReferenceType of ObjectReferencePropertiesCollectionName: stringDocumentld: swingOperationsCreateDocumentReference (Document): DocumentReferenceClass AttributeReferenceType of ObjectReferencePropertiesCollectionName: stringDocumentld: stringAttributeName: stringOperationsCreateAttributeReference (Document, AttributeName: string): AttributeReferenceClass AnnotationReferenceType of ObjectReferencePropertiesCollectionName: stringDocumentld: stringAnnotationld: stringOperationsCreateAnnotationReference (Document, Annotation): AnnotationReferenceObjectReferences are references to(names of) persistent collections, documents, etc., and not to the object instancescreated by opening a collection, etc.
It is therefore possible to have ObjectReferences to documents in collectionswhich are not currently open; it is even possible to have references to documents which have been deleted from acollection.
Because of the variety of objects which can be referenced, the Architecture does not provide a singledereferencing operator.
Dereferencing must be done explicitly by the Application using the property accessors - -opening the collection, accessing the document, accessing the annotation i the document, etc.An abstract class for objects which have attributes i defined as:Abstract Class AttributedObjectPropertiesAttributes: sequence of AttributeOperationsPutAttribute (AttributedObject, name: string, value: AttributeValue)256assign value as the current value of attribute name of object, overwriting any prior assignment of avalue to that attributeGetAttribute (AttributedObject, name: string): AttributeValue OR nilif attribute name of object has been assigned a value by a prior PutAttribute operation, return that value,else return nilRemoveAttribute(AttributedObject, name: string)if AttributedObject has an Attribute whose Name property is name, remove that attribute fromAttributedObject (otherwise do nothing)3.2 Persistent ObjectsThe TIPSTER Architecture assumes a name space of persistent objects; each persistent object is assigned a uniquename (a string).
If the Architecture is operating in a networked environment, his name will presumably consist of ahost name and a unique name on that host.The (abstract) class Persistent Object is introduced, which is a superclass of any class of persistent objects.Abstract Class PersistentObjectPropertiesName: stringOperationsCreate.PersistentObject (name: string): PersistentObjectcreates a new object of a specified class, and returns that object (it is an error if name is the name ofan existing persistent object)Open.PersistentObject (name: string): PersistentObjectname should be the name of an object of class PersistentObject, created by a priorCreate.PersistentObject operation; the object with that name is returnedClose (object: PersistentObject)saves any changes made to object in persistent storage and frees any local memory associated withthis object the Architecture assumes that all Persistent Objects will be automatically closed onsystem terminationSync (object: PersistentObject)saves any changes made to object in persistent storageDestroy (name: string)erases the persistent instance of the object (it is an error if name is not the name of a persistentobject)The architecture does not require us to identify persistent object names with file names, but this may be the simplestway to manage initial implementations.
In the present architecture DocumentCollectionlndexes andQueryCollectionlndexes are persistent; Collections are optionally persistent (Documents are not persistent objectsthemselves but have persistence as a part of a Collection).3.3 Byte SequencesThe decision about the representation f a sequence of bytes, which constitutes the contents of a document, should behidden from most applications.
To do so, the class ByteSequence is introduced.
The minimal requirement for an257implementation f the Architecture is to be able to obtain the length of a ByteSequence, and to convert between aByteSequence and a string:Class ByteSequenceOperationsLength (ByteSequence): integerreturns the number of bytes in ByteSequenceConvertToString (ByteSequence): stringCreateByteSequence (string): ByteSequence(In fact, the simplest implementation f a ByteSequence will probably be as a string, so the conversion will be anidentity operation.)
Implementations may choose to supplement these with additional operations for creating andaccessing ByteSequences, for two reasons:1.
For applications involving large documents, the implementation may wish to provide the ability todirectly access portions of the document.
This may be done through operations which retrieve substrings ofa ByteSequence, or through operations which allow a ByteSequence to be opened to a stream (forsubsequent read and write operations).2.
A collection of documents needs to be converted into a TIPSTER Collection prior to processing withinthe Architecture.
For large collections which are already in place on some data store, such as a file systemor a data base, it may be highly desirable to create the TIPSTER Collection without copying the documenttext.
A TIPSTER implementation can support his capability by allowing a ByteSequence tobe created as areference to a portion of this data store.
For example, the implementation could define a "file segment" as aportion of a file (with start and end positions), and support operations for creating a ByteSequence from afile segment.
Alternatively, an application based on a data base could define an operation for creating aByteSequence from a data base field.2584.0 DOCUMENTS AND COLLECTIONS4.1 DocumentsThe document is the central object class in the TIPSTER architecture.
As a unit of information, it serves severalbasic functions within the architecture:?
it is the repository of information about a text, in the form of attributes and annotations (althoughannotations will in general refer to portions of documents)?
it is the atomic unit in building collections?
it is the atomic unit of retrieval in detection operationsEach Document is part of one or more Collections (see Section 4.2).
A Document has persistence by virtue of beinga member of a Collection, and can be accessed only as a member of a Collection.
Each document is given a uniqueidentity by its ld property, which is copied by the CopyDocument and CopyBareDocument operations, and is alsocopied when a new collection is created by document retrieval operations.Class DocumentType of AttributedObjectPropertiesParent: Collectionthe Collection of which this Document is a member;Id: stringan internal document identifier, assigned automatically when a new Document is created, which isunique within an entire TIPSTER system (to insure uniqueness in a distributed system, animplementation may choose to include a host name as part of the Id)Externalld: string (R, W)a document identifier assigned by the applicationRawData: ByteSequencethe contents of the document prior to any TIPSTER processing.
The byte-sequence may includesubsequences representing text in multiple languages, as well as non-text material such as pictures,audio, and tablesAnnotations: AnnotationSetinformation about portions of the document (information about he document as a whole is stored inAttributes; aDocument inherits an Attributes property by virtue of being a type of Attributed Object)OperationsCreateDocument (Parent: Collection, Externalld: string, RawData: ByteSequence, annotations:AnnotationSet, attributes: equence of Attribute): Documentcreates anew document within the Collection Parent and assigns the document a new unique IdCopyBareDocument (NewParent: Collection, Document): Documentmakes a copy of Document, including only its internal Id, Externalld, and RawData, and places thecopy in collection NewParent.
The attributes and annotations of the original document are notcopied by this operation.259CopyDocument (NewParent: Collection, Document): Documentmakes a copy of Document, including its internal Id, Externalld, RawData, attributes, andannotations, and places the copy in collection NewParent.Annotate (Document, AnnotatorName: string)invokes annotation procedure AnnotatorName on the Document; see Section 5.6.WriteSGML (Document, AnnotationSet, AnnotationPrecedence: sequence of string): stringConverts a document together with a set of Annotations into SGML format.
AnnotationPrecedence,which is a list of annotation types, is used to resolve conflicts when two annotations cover the samespan: the tag corresponding to the annotation type which appears first in the list is written out first.The resulting document is in a "normalized" SGML, with all attributes and end tags explicit.
4ReadSGML (string, Parent: Collection, Externalld: string): DocumentReads a string marked up with "normalized" SGML, with all attributes and end tags explicit, andgenerates a Document with the specified Externalld, no attributes, and an AnnotationSet containingone annotation for each SGML text element marked in the input text.
If the input violates theseconstraints (e.g., unmatched start tags) or violates SGML syntax (e.g., unmatched quotation markswithin tags), an error will be signaled.
5As noted earlier, new sources of data will need to be converted by the application into Collections of Documentsbefore they can be processed within the TIPSTER Architecture.
The functions which perform these conversions willnecessarily be specific to the type of data source, and hence a TIPSTER application will be required to provide theseconversion operations when a new type of data source is to be used.4.2 Co l lec t ionsDocuments are gathered into Collections, which may have attributes on the collection level as well as on theindividual documents.
Collections provide a permanent repository for documents within the TIPSTER Architecture.Collections in general are persistent and hence have names; however, the Architecture also provides for volatile,unnamed Collections.C lass  Co l lec t ionType of PersistentObject, AttributedObjectPropertiesOwner: string (R, W)Contents: sequence of Document (t~)OperationsCreateCollection ( ame: string, attributes: equence of Attribute): Collectioncreates anamed, persistent collectionCreateVolatileCollection (attributes: equence of Attribute): Collectioncreates an unnamed, volatile collection4 The specification of this operation is subject o revision based on the experience of implementors in using these SGML representations iapplications.5 The specification of this operation is subject o revision based on the experience of implementors in using these SGML representations iapplications.260Length (Collection): integerreturns the number of documents in a collectionRemoveDocument (Collection, Id: string)removes the Document with Id Id from the Collection; if no such Document is present, the Collectionis unchangedGetDocument (Collection, Id: string): Document OR nilreturns the Document in the Collection with the given Id, or nil if no such Document existsFirstDocument (Collection): Document OR nilreturns the "first' document within a collection and initializes data structures internal to the collectionso that NextDocument can be used to iterate through the documents in a collection.
Returns nil if nodocuments are found in the collection.NextDocument (Collection): Document OR nilreturns the "next' document within a collection.
Normally used to iterate through all documents in acollection.
Returns nil if no more documents are found in the collection.
FirstDocument andNextDocument must be well behaved in the presence of calls to CreateDocument andRemoveDocument.
This means that a loop using FirstDocument and NextDocument must visit alldocuments which were in the collection when FirstDocument was called if and only if the documentsare not deleted before the loop reaches them.
Documents added after FirstDocument is called may ormay not be encountered during the loop.GetByExternalld (Collection, Externalld: string): Document OR nilreturns the Document in the Collection with the given Externalld; if several Documents have the sameExternalld, returns one of them; if none have this Externalld, returns nil.AnnotateCollection (which: Collection, destination: Collection, AnnotatorName: string)invokes annotation procedure AnnotatorName on a subset of Collection destination; see Section 5.6for further information.2615.0 DOCUMENT ANNOTATIONS: GENERAL STRUCTUREAnnotations, along with attributes, provide the primary means by which information about a document is recordedand transmitted from module to module within a system.
This chapter elaborates the general structure of annotations,noting some of the issues which arise at each stage.5.1 What Is Annotated?An annotation provides information about a portion of the document (including, possibly, the entire document).
Theportion of the document is specified by a set of spans.
Each span consists in turn of a pair of integers pecifying thestarting and ending byte positions in the RawData of the document (with the first byte of the document counting asbyte 0).Class SpanPropertiesStart: integerEnd: integerOperationsCreateSpan (start: integer, end: integer): SpanThe current span design is intended for character-based text documents which may contain additional types ofinformation such as graphical images, audio, or video, which needs to be retained and displayed, but which wouldnot be further processed by components of the TIPSTER Architecture.
For documents which do not contain text inthe form of a sequence of characters, the meaning of a span will not necessarily be compatible with this startbyte/end byte convention.
For instance, in compressed video, the information contained in a sequence of framescannot be located using starting and ending byte.
Similarly, in a graphical image of a document, such as a fax, themost natural definition of a primitive subimage is likely to be a rectangle.
Note that the data in a fax is not even bytealigned.
All of these considerations indicate that eventually an opaque type for spans with a subclass beingTextSpan will be neededMost annotations will be associated with a single contiguous portion of the text, and hence with a single span.However, a set of spans is provided for in order to be able to refer to non-contiguous portions of the text.
Forexample, an event might be described at the beginning of an article and again later in the article, but not in theintervening text; using a set of spans allows us to have an annotation for the event refer to these two passages.
Itwould also allow for discontinuous linguistic elements, uch as verb plus particle pairs ("I gave my gun up.
").5.1.1 Code Sets and Character PositionsPositions in the RawData re represented internally in terms of byte offsets, rather than characters.
This is necessarybecause the RawData may contain non-text data, such as graphics or sounds, for which character addressing wouldnot be meaningful.
However, once a text has been segmented into text and non-text portions, and the text portioninto segments involving different character codes, it should be possible to provide operations at the character level(i.e., operations which are sensitive to the different sizes of characters in different codes).
This segmentation i toregions using different character code sets is to be recorded in the TIPSTER Architecture as Annotations on thedocument (see Section 6.1).
By accessing these Annotations, an application can determine the code set employed at aspecific position in a document, and hence the size of the character at that position.
This information can be used toimplement operations to extract asingle character or advance to the next character position.More work is required on the multi-lingual design of the Architecture before such operations can be incorporatedinto the Architecture itself.2635.1.2 Mod i f i ca t ion  o f  the TextTo allow annotations to modify the text (and, in particular, to insert characters) in such a way that subsequentaccesses to the text see the modified text in place of the original text, it is necessary to require a representation fpositions in a document which allows for insertions (e.g., by using integers above the length of the original string torefer to inserted elements).
The current architecture does not allow for such changes; corrections to the text must berecorded as attributes on text elements which are explicitly accessed by subsequent processes.
Alternatively, theapplication can create a new Document with a new RawText property which incorporates these modifications.5.2 Information Associated With an AnnotationAn annotation associates a type with a span of the document.
Examples of possible types are token, sentence,paragraph, and dateline.
In addition, one or more attributes may be assigned to each annotation.Class AnnotationType of AttributedObjectPropertiesId: stringthe identifier of an Annotation, which is nil when the Annotation is created and which is set when theAnnotation is added to a Document; the value assigned is unique among the Annotations on thatDocument.Type: stringSpans: sequence of SpanOperationsCreateAnnotation (Type: string, Spans: sequence of Span, attributes: sequence of Attribute): AnnotationExamples of simple attributes on annotations (attributes whose values are single strings) include a type-of-nameattribute on name annotations, which might take on such values as "person, country", "company", etc.
; a pos (part ofspeech) attribute on token annotations, which might take on the Penn Tree Bank values, such as "NNS" and "VBG",and a root attribute on token annotations, which would record the root (uninflected) form of a token.An example of an attribute whose value is another annotation would be a coreference pointer.
An even morecomplex attribute value would be a template object, which may in turn contain pointers to several other annotations(for the text elements filling various slots in the template object).5.3 Accessing AnnotationsBecause annotations are central to the TIPSTER architecture, it is expected that applications will have frequent needto access, search, and select annotations on a document.
To meet this need, the Architecture defines a classAnnotationSet and a number of operations operating on such sets of annotations.
In particular, operations areprovided to support the sequential scanning of a document (AnnotationsAt, NextAnnotations) and to support thcextraction of annotations meeting certain criteria (SclcctAnnotations).Although AnnotationSets are logically just sets of annotations, and could be implemented like other sets (e.g., aslists), a special class is provided in the expectation that implementations may wish to choose a more elaborateimplementation (such as a sorted list or tree with one or more indexes) in order to implement the operations moreefficiently.Each Document includes as one property an AnnotationSet, holding the annotations on that Document.
Most of theoperations on AnnotationSets can also be applied to Documents, and in that case apply the same operation to theAnnotationSet property of the Document.264Class AnnotationSetPropertiesMembers: sequence of Annotation ()the individual annotations in the setOperationsCreateAnnotationSet (): AnnotationSetcreates an empty AnnotationSetAddAnnotation (Document, Annotation): stringadds an annotation to a document.
If the Id slot of Annotation is nil, this operation creates a newannotation Id (unique for this document) and assigns it to the id field of Annotation.
If the ld field ofAnnotation is filled (not nil), and there is an existing annotation on the document with the same Id,the new annotation replaces the existing annotation.
The Id field of the annotation is returned.RemoveAnnotation (Document OR AnnotationSet, Id: string)removes the annotation with the specified Id from the Document or AnnotationSet.
It is an error ifthe document does not have an annotation with that Id.GetAnnotation (Document OR AnnotationSct, Id: string): Annotationreturns the annotation whose id slot is equal to the desired value.
It is an error if no annotation hasthe specified identifier.Length (AnnotationSet): integerreturns a count of the number of annotations inAnnotationSetNth (AnnotationSet, n: integer): Annotationreturns the Nth annotation in AnnotationSct, where the first annotation has index 0.SclectAnnotations (Document OR AnnotationSet, ype: swing OR nil, constraint: sequence of Attribute):AnnotationSetreturns the (possibly empty) set of annotations from the Document or AnnotationSet which are oftype type and which satisfy constraint, constraint is a sequence of attributes, where the ith attributehas name a i and value vi.
An annotation satisfies the constraint if (for each i), attribute ai of theannotation has value v i.
If constraint is the empty sequence, no constraint is placed on the attributes:all annotations of the given type are selected.
If type is nil, annotations of all types satisfying theattribute constraints are included.DeleteAnnotations (Document OR AnnotationSct, ype: string OR nil, constraint: sequence of Attribute)removes from the Document or AnnotationSet al annotations which are of type type and whichsatisfy constraint.
These arguments have the same significance as for SelectAnnotations, above.AnnotationsAt (Document OR AnnotationSet, Position: integer): AnnotationSetreturns the set of annotations from Document or AnnotationSet which start at the specified position.NextAnnotations (Document OR AnnotationSet, Position: integer): AnnotationSctReturns the set of annotations from Document or AnnotationSet which have the smallest startingpoint that is greater than or equal to Position.MergeAnnotations (AnnotationSet, AnnotationSet): AnnotationSetreturns the union of the Annotations in the two AnnotationSets.2655.4 Annotation Type Declarations5.4.1 IntroductionA central goal in creating the TIPSTER architecture is for different modules to be able to share information about adocument through the use of annotations.
Such information sharing will be workable only if there are precise, formaldescriptions of the structure of these annotations, and if the modules which create annotations adhere to thesedescriptions.Therefore, annotation type declarations are introduce here which serve to document the information associated withdifferent ypes of annotations.
In the present architecture these declarations only serve as documentation; futuregenerations of the architecture may seek to do type checking based on these declarations ( ee Appendix A.
1).Type declarations are organized into packages.
A package will typically include a set of related annotation types.
Forexample, a package may declare all the types of annotations used to represent the document structure for onemessage format (header, dateline, author, etc.).
Another package, associated with an extraction system, wouldrepresent the annotation types corresponding to the template objects created by that system.The declaration of a package of annotation types would consist of a package name declaration followed by one ormore annotation type declarations.
The package name declaration has the formtype package identifierAn annotation type declaration defines an annotation type; it specifies the attributes which such annotationsmay have and the type of value of each attribute.
The declaration has the formannotation type identifier ( attribute-spec l attribute-spec2 .
.
.
.
};where each attribute specification, attribute-spec,., has the formattribute-name: type-specThe type-spec specifies the type of allowable values of the attribute.
The type spec may specify a basic type:Booleanstringintegerrealdocumentcollectionannotation (a reference to an annotation of any type)it may specify an enumerated type by giving its alternative values:( value 1, value2 ...)it may specify a union of types by listing the alternative types:( type I or type 2 or ...)to indicate that the value may be of any one of the types listed; it may specify a compound type, eithersequence of typewhich allows for a sequence of zero or more instances of type type, oroptional typewhose value may be either of type or be nil.
Finally, type-spec may be a previously defined annotation type,specifying areference to an annotation of that type.266One or more white-space characters (blanks, tabs, or newlines) are required between successive identifiers andalphabetic names; zero or more white-space characters are allowed before and after the separator characters ": ; ()".Any text between a left bracket and a right bracket (\[...\]) is considered a comment.Here is a simple example based on the mini-MUC organization template (more elaborate template xamples aregiven in Section 8):type package organizations;annotation type organization { org_name:org_aliases:org_type:org_location:annotation type typed_location {location:type:5.5 Examples of Annotationsstring,sequence of string,{ government, company, other },sequence of typed_location }:string;{country city landregion provincewaterregion address oth-unk }} ;This section shows some simple examples of annotated documents.
Each example is shown in the form of a table, Atthe top of the table is the document being annotated; immediately below the line with the document is a rulershowing the position (byte offset) of each character.
Underneath this appear the annotations, one annotation per line.For each annotation is shown its Id, Type, Span, and Attributes.
Integers are used as the annotation Ids.
Also, forsimplicity only a single Span for each Annotation is shown.
The attributes are shown in the form name = value.At the end of this section the type declaration packages which would be used to describe these annotations i shown.The first example shows a single sentence and the result of three annotation procedures: tokenization with part-of-speech assignment, name recognition, and sentence boundary recognition.
Each token has a single attribute, its partof speech (pos), using the tag set from the University of Pennsylvania Tree Bank; each name also has a singleattribute, indicating the type of name: person, company, etc.Id Type1 token2 token3 token4 token5 token6 name7 sentenceTextCyndi savored the soup.10...
I ls.. 120Annotat ionsSpan Start0614182200Span End51317222323Attributes~ pos=NPpos=VBDI pos=DTpos=NNname_type=personAnnotations will typically be organized to describe a hierarchical decomposition of a text.
A simple illustrationwould be the decomposition of a sentence into tokens.
A more complex case would be a full syntactic analysis, inwhich a sentence is decomposed into a noun phrase and a verb phrase, a verb phrase into a verb and its complement,etc.
down to the level of individual tokens.
Such decompositions can be represented by annotations on nested sets ofspans.
Both of these are illustrated in our second example, which is an elaboration of our first example to includeparse information.
Each non-terminal node in the parse tree is represented by an annotation of type parse.267TextCyndi savored the soup.10... Is.
.
.
li0.. l ls.
.
120AnnotationsSpan Start Span End Attributes Id Type1 token2 token3 token4 token5 token6 name7 sentence8 parse9 parse10 parse11 parse0614182201460513172223235222222pos=NPpos=VBDpos=DTpos=NNname_type=personconstituents= \[1\],\[2\],\[3\].\[4\],\[5\]symbol="NP",constituents= \[ 1 \]symbol="NP",constituents=\[3\],\[4\]symbol="VP",constituents=\[2\],\[9\]symbol="S",constituents=\[8\],\[ 10\]In most cases, the hierarchical structure could be recovered from the spans.
However, it may be desirable to recordthis structure directly through a constituents attribute whose value is a sequence of annotations representing theimmediate constituents of the initial annotation.
For the annotations of type parse, the constituents are either non-terminals (other annotations in the parse group) or tokens.
For the sentence annotation, the constituents attributepoints to the constituent tokens.
A reference to another annotation is represented in the table as "\[Annotation hi\]";for example, "\[3\]" represents a reference to annotation 3.
Where the value of an attribute is a sequence of items,these items are separated by commas.
No special operations are provided in the current architecture for manipulatingconstituents.At a less esoteric level, annotations can be used to record the overall structure of documents, including in particulardocuments which have structured headers, as is shown in our third example6:6 lncounting characters, count one character for the newline between li es268TextTo: All Barnyard AnimalsIo...15...11o..11s..12o..From: Chicken Little125.
.13o .
.13s .
.14o .
.145 .
.Date: November i0, 1194. .
.
.
I so .
.155 .
.16o .
.165 .
.Subject: Descending Firmament17o..17s..18o..18s..19o..19s..Priority : Urgent.lloO.llO5.11zo.lzls.The sky is falling.
The sky is falling.. .
.
.
112o.l125.t13o.113s.l14o.l145.tlSO.AnnotationsId Type Span Start Span End Attributes1 Addressee2 Source3 Date4 Subject5 Priority6 Bod~?7 Sentence8 Sentence43153178109111611613624456998115155135155ddmmyy=101194If the Addressee, Source .... annotations are recorded when the document is indexed for retrieval, it will be possibleto perform retrieval selectively on information i  particular fields.Our final example involves an annotation which effectively modifies the document.
The current architecture does notmake any specific provision for the modification of the original text.
However, some allowance must be made forprocesses uch as spelling correction.
This information will be recorded as a correction attribute on tokenannotations and possibly on name annotations:269TextTopster tackles 2 terrorbytes.10.
.
.
IS .
.
.
l i 0 .
.
\ [15 .
.
120. .
125.
.AnnotationsId Type Span Start Span End Attributes1 token 0 7 pos=NP correction=TIPSTER2 token 8 15 pos=VBZ3 token 16 17 pos=CD4 token 18 29 pos=NNS correction=terabytes5 token 29 : 30The sample annotations shown here would rectype package basic;annotation type token:annotation type name:annotation type sentence:type package parse;annotation type parse:type package message;annotation type addressee;annotation type source;annotation type date: {ddmmyy: string};annotation type subject;annotation type priority;annotation type body;uire the following type declarations:{pos: string, correction: optional string};{ name_type: { person, organization, other } } ;{ constituents: optional sequence of token };{ symbol: string, constituents: equence of (parse or token or name)};5.6 Invoking AnnotatorsEach TIPSTER system will be provided with a number of "annotators" procedures for generating annotations.
Therewill be annotators for different ypes of annotations; for example, for tokenization, for sentence segmentation, forname recognition, etc.
In addition, there may be multiple annotators of a single type; e.g., multiple tokenizers.Each annotator is assigned aname (a string).
It is invoked byAnnotate (Document, AnnotatorName: string)orAnnotateCollection (which: Collection, destination: Collection, AnnotatorName: swing)The first form annotates a single Document.
The second form annotates a Collection or a subset hereof.
This usesCollection which to determine which documents o process, and Collection destination to record the annotations.
Foreach document in collection which, if the same document (a document with the same Id) appears in destination,annotate that document in collection destination.
This calling sequence allows us to selectively apply annotators tosubsets of a collection, but to keep all the annotations together in the "original" collection.
If which and destinationare identical, the entire collection is annotated.Note: Future versions of the architecture will include operations for managing the set of annotators: for adding anannotator to the set of annotators, for recording the types of annotations produced by an annotator, and forsearching the set of annotators.2705.7 External Representation of AnnotationsThe TIPSTER architecture provides an external, character-based representation f annotated ocuments, o that suchdocuments can be interchanged among modules (possibly as part of different TIPSTER systems on differentmachines) without regard to the internal representation used on particular machines.
A representation based onSGML has been selected in order to be able to make use of the large number of existing applications which canoperate on SGML documents.In this representation, if the document consists of the text "aaaa bbbb cccc", and the span corresponding to "bbbb"has been assigned an annotation of type atype with id ident, and this annotation has attributes attribute1, attribute2,... with values value1, value2 .... then the external representation f the annotated ocument will beaaaa <atype id=ident attributel=valuel attribute2=value2... >bbbb</atype> ccccThis representation is produced by the WriteSGML operation, which takes as arguments a document, anAnnotationSet, and a precedence list among annotation types.
This precedence list is used to determine the nesting ofSGML tags if two annotations involve the same span.
A complementary operation, ReadSGML, reads a SGMLdocument which conforms to this format (with all attributes and end tags explicit) and creates a document withannotations.The specification of these operations is subject o revision based on the experience of implementors in using theseSGML representations in applications.It may be desirable to have a second external representation which much more closely parallels the internalproperty structure of the annotations, particularly if annotations are to be exchanged over a network.5.8 Annotation Schemata nd Style SheetsDifferent groups of annotations normally exist in some fixed structural relationships to one another.
Thus, a textbody may consist of paragraphs, a paragraph of sentences, a sentence of tokens, etc.
For an SGML document, heserelationships are provided by a DTD.
At present, the Architecture includes a very limited amount of such informationin the form of the PrecedenceList argument to WriteSGML; it may be desirable to include in later versions of thearchitecture an AnnotationSchema ore analogous to a DTD.When an SGML form is generated from an annotated ocument, rules must be applied to realize each type ofannotation as a sequence of characters.
In the present version, these rules are assumed to be built in to theWriteSGML operation, but in later versions it may be desirable to provide these rules explicitly as a StyleSheet.
ATIPSTER System would have a default StyleSheet, but it may be necessary to extend the WriteSGML operation touse a different, explicitly specified style sheet.2716.0 TYPES OF DOCUMENT ANNOTATIONSThe TIPSTER Architecture defines a number of standard annotations; these are divided into structural and linguisticannotations.
If these particular annotation type names are used, they must be used for the purpose designated.However, a TIPSTER system is free to create and use any other annotation types that it wishes.These annotations all have to be described in further detail.6.1 Structural Annotations1.
The raw document may contain several types of information, including text, tables, and graphics.
TheTIPSTER Architecture needs to preserve all this information in the document, but for the present will onlyprocess the text information (at a subsequent s age other structures with embedded text information, such astables, may also be processed).To delimit these different types of information, the TIPSTER Architecture will use annotations of typeTextSegment, each subsuming a maximal contiguous equence of text (and possibly other annotations, uch asGraphicsSegment, which would be ignored in subsequent processing).2.
A text segment may consist of text in one or more languages and character codes.
This information would berecorded by annotations of type MonolingualTextSegment which each have Language and CharacterSetattributes.3.
A document may be divided into a header and a body.
The body would be annotated with a body annotation.The header may include a document identifier (to be annotated with a docid annotation) and such otherproperties as a title or headline, adateline, etc.4.
A body may be divided into paragraphs; the p annotation type will be used to identify paragraphs.5.
A paragraph may be divided into sentences; the s annotation type will be used to identify sentences.6.
A sentence may be divided into tokens.
The rules for tokenization for English will follow those used by thePenn Tree Bank.
Tokens will be denoted by the token annotation.The capability to annotate sentences and tokens will be obligatory for a TIPSTER System, since so many otherproperties may be expected to assume their existence.
Other levels of annotation will be optional.6.2 Linguistic Annotations1.
Names, as defined for MUC-6.
This includes company names, people's names, locations, currencies, anddates.2.
Part of speech labels, using the Penn TreeBank set as a standard for English.3, Coreference tagging, as is being defined for MUC-6.
Standards for other linguistic annotations, uch asphrase structure, word senses, and predicate-argument structure, may be added as more progress is made indefining these annotations for MUC evaluation.All of these linguistic annotations would be optional: the architecture would be used to establish standards wherebypeople who want to generate or use these annotations could communicate, but (except possibly for name recognition)this would not obligate anyone to produce these annotations.2737.0 DETECTION7.1 Object Classes7.1.1 Detection Needs and QueriesThe user's request for documents i initially prepared in the form of a DetectionNeed: a document with a variety ofSGML-delimited fields.
A DetectionNeed is a type of Document, and so partakes of all the operations which can beapplied to Documents.
As a specialization of Collections, the Architecture includes DetectionNeedCollections; theseare required primarily for routing operations, which typically involve sets of DetectionNeeds.The DetectionNeed is transformed in two stages: it is first transformed into a DetectionQuery, and thence into eithera RetrievalQuery or a RoutingQuery.
DetectionNeeds are independent of the specific retrieval engine employed,while DetectionQueries, RetrievalQueries, and RoutingQueries are specific to a particular etrieval engine.
TheDetectionQuery is specific to the retrieval engine but independent of the collection over which retrieval is to beperformed, and the operation (retrieval or routing) to be performed; the RetrievalQuery and RoutingQuery arespecific to the retrieval engine, to the operation, and to a collection (they may incorporate, for example, term weightsbased on the Inverse Document Frequencies in a collection).
The transformation process is divided into these twostages because aretrieval system may provide specialized tools for modifying the DetectionQuery.7.1.2 Detection NeedsClass DetectionNeedType of DocumentDescriptionA system-independent description of the contents of the documents that the user would like to retrieve.The description may be in natural anguage, expressed with query language operators (described below),or a combination of natural language and query language operators.OperationsQueryGenerator (DetectionNeed): DetectionQueryGenerate a system-specific DetectionQuery from an analysis of the DetectionNeed; theDetectionQuery has the same Externalld as the DetectionNeed.Query language operators are represented within the DetectionNeed using SGML-style tags.
Each query languageoperator has the following syntax.<OPERATOR> argument +</OPERATOR>That is, an operator consists of an operator field marker (e.g.
<OPERATOR>), one or more arguments, and anending field marker (e.g.
</OPERATOR>).
Operators may be nested arbitrarily.
Operator characteristics an bealtered as shown.
When alternatives are given (e.g.
EXACT or FUZZY), the first one listed is the default.
Thedefault value for numeric arguments i 1.It is not necessary for a system to implement each operator exactly as described below.
A compliant system is onethat can translate any valid DetectionNeed into its own query language, and that documents how each operator ishandled.
A system may ignore operators that it does not implement, or it may map them to the nearest reasonablealternative in that system's query language.Any text not explicitly encapsulated in a query language operator is assumed to be implicitly encapsulated by the<SUM> operator (described below).When it is necessary to distinguish among two or more DetectionNeeds, for example when they are stored in anASCII file, the <DETECTION-NEED> SGML tag indicates the beginning of a DetectionNeed, and the275</DETECTION-NEED> SGML tag indicates the end of the DetectionNeed.
Text that is not enclosed between thesetags is handled in a system-dependent (i.e.
not defined by the TIPSTER architecture) manner.The operators are listed below, in alphabetic order.<AND MATCH=\[EXACT I FUZZY\]>Document should contain all arguments.
EXACT match means that each document must contain all of thearguments.
FUZZY match means that a document may be returned if it lacks one or more arguments, but thedocument is presumably ranked lower than documents that match all arguments.<AND-NOT MATCH=\[EXACT I FUZZY\]>Document should contain the first argument but not the second.
Only two arguments can be specified for thisoperator.<COMMENT>All tokens until </COMMENT> are comments, to be ignored when creating DetectionQuery objects.<DOC-ANNOTATION=name>The arguments are to be matched against hat portion of the document annotated with the annotation of type"name".
Note that annotations may denote document structure, so that this operator may be used to restrict hematch to within a single phrase, sentence, paragraph, section, etc.<DOC-ATTRIBUTE=name>The arguments are to be matched against he value of attribute "name".<NL>The arguments are a natural anguage description of part of the information eed.
No other query operator canoccur in the <NL> description of the information eed.
(Any operators encountered are to be treated as text.
)</NL> ends the field, unless it is escaped (see below).<ESCAPE>All tokens until </ESCAPE> are query terms, not operators.
If the next token is </ESCAPE> then it is a queryterm, and not the end of the <ESCAPE>.<NONRELEVANT>The arguments are the Ids of documents that the user has judged to be not relevant o the information eed.<OR MATCH=\[EXACT I FUZZY\]>Document should contain at least one argument.<PARAGRAPH MATCH=\[EXACT I FUZZY\],  DISTANCE=n, \ [UNORDERED I ORDERED\]>Document should contain all arguments within n paragraphs.<PHRASE MATCH=\[EXACT I FUZZY\],  DISTANCE=n, \ [UNORDERED I ORDERED\]>Document should contain all arguments within n phrases.<RELEVANT>The arguments are the Ids of documents that the user has judged to be relevant o the information eed.<SENTENCE MATCH=\[EXACT I FUZZY\], DISTANCE=n, \ [UNORDERED I ORDERED\]>Document should contain all arguments within n sentences.<SUM>Functionally, this operator is like an <OR> operator: The document must contain one or more arguments.However, the user may assume that documents that match more arguments are generally ranked higher thandocuments that match fewer arguments.
(Typically used with vector-space or probabilistic systems.
)<SYNONYM>The arguments are considered synonyms.<WEIGHT n>Applies a weight of n to its argument.
May affect a document's score, depending upon the retrieval algorithmused.276<WORDS MATCH=\[EXACT I FUZZY\], DISTANCE=n, \[UNORDERED I ORDERED\]>Document should contain all arguments within n words.An SGML-like syntax was chosen because it is expressive, relatively easy to read, and system neutral.
It allows theoperator characteristics to be tailored without introducing a large number of special-purpose operators.Class DetectionNeedCollectionType of CollectionDescriptionA Collection of Documents, all of which are DetectionNeeds.7.1.3 QueriesClass DetectionQueryType of DocumentDescriptionthe system-specific (but collection-independent) translation of a DetectionNeed.P roper t iesDetectionNeed: DocumentReferencea reference to the DetectionNeed from which this query is derivedOperationsFormRetrievalQuery (DetectionQuery, sequence of DocumentCollectionlndex): RetrievalQuerytranslate the DetectionQuery into an RetrievalQuery by using the information (e.g., documentfrequencies of terms, similarities between terms) in the set of DocumentCollectionlndexes; theRetrievalQuery has the same Externalld as the DetectionQueryFormRoutingQuery (DetectionQuery, sequence of DocumentCollectionlndex): RoutingQuerytranslate the DetectionQuery into a RoutingQuery by using the information (e.g., documentfrequencies of terms, similarities between terms) in the set of DocumentCollectionlndex; theRetrievalQuery has the same Externalld as the DetectionQueryEditQuery (DetectionQuery)optional: this system-specific operation allows the user to modify the query, providing informationwhich cannot be provided through the (system-independent) DetectionNeedClass Ret r ieva lQueryDescriptionthe translation of a DetectionQuery which is based on a particular DocumentCollectionlndex and intendedfor use in retrospective retrievalPropertiesDetectionNeed: DocumentReferencea reference to the DetectionNeed from which this query is derivedOperat ionsScoreDocuments (Collection, RetrievalQuery)277assign to each Document in Collection an attribute relevance whose value indicates the relevance ofthe document to the queryUpdateUsingRelevanceFeedback (RetrievalQuery, relevant_docs: Collection, sequence ofDocumentCollectionlndex): RetrievalQuerythis operation updates the RetrievalQuery using relevance feedback, and returns the updated (ornew) Query.
The relevance feedback is provided through the relevant_docs argument.
Eachdocument in this collection should have an Attribute relevant with the value "true" or "false".Furthermore, if that value is "true", the entry may also have one or more Annotations of typerelevant-section whose Spans indicate the relevant sections of the document.RetrievalQueryFromRelevanceJudgements (relevant_docs: Collection, sequence ofDocumentCollectionlndex, DetectionNeed): RetrievalQuerythis operation is similar to Update UsingRelevanceFeedback, but creates a new RetrievalQuery fromscratch based on the relevance judgments recorded in relevant_docs.
The DetectionNeed parameteris required since each query must point to the original DetectionNeed; this DetectionNeed maycontain a narrative characterization of the query being created, but no information from theDetectionNeed is used in creating the queryClass RoutingQueryDescriptionthe translation of a DetectionQuery which is based on a particular DocumentCollectionlndex andintendedfor use in routing.PropertiesDetectionNeed: DocumentReferencea reference to the DetectionNeed from which this query is derivedOperationsUpdateUsingRelevanceFeedback (RoutingQuery, relevant_docs: Collection, sequence ofDocumentCollectionlndex): RoutingQueryRoutingQueryFromRelevanceJudgments (r levant_docs: Collection, sequence ofDocumentCollectionlndex, DetectionNeed): RoutingQuerythese operations are exact analogs of the operations with the same names which apply toRetrievalQuefies.7.1.4 Document and Query IndexesThe TIPSTER Architecture provides for two types of document detection operations: retrieval and routing.
Inessence, retrieval involves the comparison of a single query against a large number of documents, while routinginvolves the comparison of a single document against a large number of queries (or "user profiles").As a preliminary step for retrieval, generally, the set of documents must be pre-processed.
Typically, this involvesthe creation of a term index, but it may also involve the gathering of various statistics about the set of documents(such as term document frequencies, term co-occurrence frequencies, and even term similarities based on co-occurrence).
The result of all this preprocessing is a DocumentCollectionlndex.
Retrieval is then performed bysending a query (in the form of an RetrievalQuery) to the DocumentCollectionlndex; the DocumentCollectionlndexreturns a list of relevant documents.278Class DocumentCollectionIndexType of PersistentObjectDescriptiona form of a Collection which is capable of responding to DetectionQuery.
For most systems, this involvesthe annotation of the documents in the collection with approach-specific annotations, and then the creationof an inverted index involving these annotations.
For some systems, however, an "index" might just be anormalized copy of the original text in a form which can be scanned by high speed search software.OperationsAugment (DocumentCollectionIndex, Collection)adds all the documents in Collection to the DocumentCollectionIndexRetrieveDocuments (sequence of DocumentCollectionlndex, RetrievalQuery, NumberToRetrieve: integer,Monitor or nil): Collectionreturns a collection of Documents (of maximal ength NumberToRetrieve) which are most closelyrelated to the DetectionNeed from which the Retrieval Query is derived.
TheDocumentCollectionIndex will provide progress updates as requested by the Monitor.
A nilargument means that no progress monitoring is required.
A retrieval operation canceled by theMonitor object's MonitorProgress operation returns a Collection of accumulated documentsIn routing, a set of queries or user profiles (in the form of RoutingQueries) are pre-processed to create aQueryCollectionIndex.
Routing is then performed by sending a Document o a QueryCollectionIndex; what isreturned is a set of relevant profiles (in the form of a DetectionNeedcollection).Class QueryCollectionIndexType of PersistentObjectDescriptionthe translation of a collection of RoutingQueries into a format which is efficient for performing documentroutingOperationsAddQuery (QueryCollectionlndex, RoutingQuery)adds a single query (in the form of an RoutingQuery) to a QueryCollectionlndex; if an existing queryin the QueryCollectionlndex is based on the same DetectionNeed as RoutingQuery, the existingquery is replaced by RoutingQueryRemoveQuery (QueryCollectionlndex, RoutingQuery)if QueryCollectionlndex includes a query based on the same DetectionNeed asRoutingQuery, thatquery is removed from the IndexRetrieveQueries (sequence of QueryCollectionlndex, Document, NumberToRetrieve: integer):DetectionNeedCollectionreturns the collection of DetectionNeeds (of maximal ength NumberToRetrieve) which are mostclosely related to Document7.1.5 Query MonitoringThe Monitor object is intended as an advisory object in the Architecture.
If no Monitor object is provided, nomonitoring or interruption of the RetrieveDocuments operation is possible.
The RetrieveDocuments operation willnot fail due solely to the absence of a nil Monitor argument.279Class MonitorDescriptionTracks the progress of requests to a Detection component.
Some programmatic control is provided viaStatusType and IntervalTypePropertiesStatusType: one of {NumDocs (number of documents processed), Time (estimated time to complete -seconds), Percent (% of documents processed)}IntervalType: one of {NumDocs (number of documents processed), Time (interval in seconds betweenstatus reports), Percent (% of documents processed)}Interval: IntegerClientData: set of stringOperationsCreateMonitor (StatusType: one of {NumDocs, Time, Percent}, IntervalType: one of {NumDocs, Time,Percent}, Interval: integer, ClientData: set of string): MonitorStatusType is the type of report requested.
If the type is not supported a reasonable default shall beprovided with the type indicated.
IntervalType indicates the desires type of interval which may differfrom StatusType.
Interval indicates the frequency of status information.
The Interval value behavesaccording to the IntervalType.
If IntervalType is Percent hen Interval = 5 means provide status wheneach 5% of the documents are processed.
ClientData is optional user data for the MonitorProgressoperationMonitorProgress (Monitor, DCIName: string, Status: integer, MaxStatus: integer, Type: one of{NumDocs,Time, Percent}): BooleanDCIName is the name of the DocumentCollectionlndex which is being monitored.
Status is thecurrent status consistent with type.
MaxStatus indicates the maximum value Status may have forDCIName.
Type is the type of progress update provided to the functionReturns FALSE to terminate the search, returns TRUE to continue the search7.2 Functional ModelThe following functional model diagrams are based on the notation used by Rumbaugh et al Ovals representprocesses (operations); boxes with only a top and bottom represent "data stores" - -  persistent repositories of data;fully enclosed boxes represent "actors" - -  active sources of data.7.2.1 Retrospective RetrievalThe system begins by converting the DocumentCollection(s) into DocumentCollectionlndex(es), as shown on the leftside.
To retrieve information from this collection, the User produces a DetectionNeed.
This DetectionNeed isconverted in two stages, first to a DetectionQuery and then to an RetrievalQuery, as shown in the right column (thelatter step may use information, for example, on term weights, from the DocumentCollectionIndex).
Finally, theRetrievalQuery is run against he DocumentCollectionlndex to retrieve the documents; this produces a Collection ofrelevant documents, with a relevance attribute for each document.280Collection11DocumentCollectionIndexI User I NeedDetectionQuery~t r ieva lQuery~... y ocumen s >lCollectionRetrievalQuery7.2.2 RoutingRouting requires a DocumentCollectionIndex which is used to determine weights for the translation of aDetectionQuery into an RoutingQuery.
Typically an application will be able to use a pre-existing index (for aCollection of content comparable tothe documents o be routed).Each DetectionNeed (user profile) in the DetectionNeedCollection s translated in two stages: first to aDetectionQuery, and then into a RoutingQuery.
These RoutingQueries are then stored and indexed in aQueryCollectionlndex.
Finally, this QueryCollectionlndex can be run against a Document o produce a set ofrelevant queries (profiles), in the form of a DetectionNeedCollection.281DocumentCollectionIndexIDataSource \[DocumentDetectionNeedCollectionDetectionNeednQueryutingQueryQueryCollectionIndex~gtTieval~,4DetectectionNeedCollection7.2.3 Relevance FeedbackRelevance feedback begins with an initial RetrievalQuery, which is used to retrieve a set of documents.
Thisoperation is shown as "Retrieve Documents \[1\]" in the figure below (the DocumentCollectionlndex input is notshown), and produces a Collection.
A human judge (or possibly an alternative source of relevance judgments, suchas an extraction system) then reviews the retrieved ocuments and records relevance judgments on the Collectionusing the relevant Attribute.
This is done using a Relevance Recorder, which is not part of the Architecture butwould be part of any application system which wished to support relevance feedback.
The Collection is then fed,along with the original query, to an UpdateUsingRelevanceFeedback operation, producing an updated query.
Finally,the updated query can be used to retrieve a new set of documents ( hown as "Retrieve Documents \[2\]" at the bottomof the figure).282\[initial\] Retrieval Queryl~ievalDocumeots~,~ >lCollection ~ ~vance  Recorderl, ~ a~UsingFeedback~I \[updated\] Retrieval Query~trievalDocuments \[2\]User2838.0 EXTRACTIONInformation extraction the extraction from a document of information concerning particular classes of events is aform of document annotation.
An extraction engine adds annotations describing the events and their participants.Extraction therefore does not require any operations and classes beyond those already presented.
However, becauseextraction will be a major component of many systems built using the Architecture, this section describes howextraction fits into the current Architecture.At present the development of extraction engines from a description of a class of events (a "scenario") is a black artpracticed by a cadre of information extraction specialists.
It is expected that in the future it will be possible forexperienced users to customize xtraction systems to new scenarios; this would be an interactive process whichwould draw upon a library of predefined template objects.
Appendix A.2 presents the additional object classes whichwould be needed to support such customization.8.1 Representing Templates as AnnotationsIn the terminology developed by the Message Understanding Conferences, the information extracted from adocument is stored in a (filled) template, which in turn consists of a set of template objects.
A template object maycontain information about a real-world object (such as a person, product, or organization), a relationship, or an event.Each such template object provides information about a portion of a document and is therefore represented in theTIPSTER Architecture by an annotation.
A particular extraction task will involve several kinds of template objects,for events, people, organizations, etc.
Each kind of template object corresponds to a type of annotation.
Thus theformal specification of a set of template objects corresponds to a set of annotation type declarations.
This formalspecification is supplemented by a large amount of narrative (the "fill rules") describing the circumstances underwhich a template object is to be created and the information to be placed in each slot.Each slot/value pair in the template object is represented as an attribute/value pair on the annotation.
Note that thevalues of attributes can be lists (thus allowing for slots with multiple values) and can be references to otherannotations (thus allowing for a hierarchy of filled objects, and allowing for references to other annotations, uch asnames which have been identified by a prior annotation process).
Furthermore, ach annotation has a span which canlink the object o the text from which it has been derived.Some applications may want to link an individual slot in the template object to text in the document.
This can bedone by introducing additional annotations.
Instead of having the value of the attribute corresponding to that slot bea string, it would be a reference to an annotation of type string-annotation.
That annotation would (like allannotations) have a set of spans referencing the text; it would also have a value attribute holding the value of thetemplate slot (the "slot filler").
This has been done for one of the slots in the example below, the role slot ofpersonnel, but could have done it for others.If an application system involves extractions for multiple scenarios (multiple classes of events),it will be necessary todistinguish the annotations corresponding to different extraction scenarios (so that, for example, one can display allthe annotations for one scenario).
This can be done by adding a scenario attribute to each annotation.
In similarfashion, in an application environment integrating annotation modules from different suppliers, it would be desirableto record the source of particular annotations using an annotator attribute.
These additional attributes are not shownin the example below.8.2 An ExampleAs an illustration of this approach, consider the result of annotating a document consisting of the sentenceThe KGB kidnapped ARPA program manager Umay B. Funded.285with an information extraction system covering terrorist events.look like 7<EVENT-l> :=EVENT_TYPE: KIDNAPPINGPERPETRATOR: <ORG- 1>TARGET: <PERSONNEL-l><ORG-I> :=ORQNAME:  "KGB"ORG_NATIONALITY: USSR<PERSONNEL- 1> :=PERSON: <PERSON-l>ORGANIZATION: <ORG-2>ROLE: "PROGRAM MANAGER"<ORG-2> :=ORG_NAME: ARPAORG_NATIONALITY: USA<PERSON-l> :=PER_NAME: "Umay B.
Funded"These might be encoded as a set of annotations a follows:The MUC-style template for such an event might7 The templates shown here are loosely based on those for the MUC-6 information extraction task.286TextThe KGB k idnapped ARPA program manager Umay B. Funded.Io...15...11o..115..12o..125..13o..135..14o..145..15o..AnnotationsId12345678Type Span Start Span End AttributesNameName!NameEventOrgPersonnelString-annotationOrgPerson4183918231839722535353382253The type declaration package for these annotations i as follows:type package terrorist_event;annotation type event:annotation type org:annotation type personnel:annotation type person:annotation type name:annotation type string-annotation:name_type=organizationname_type=organizationname_type=organizationevent_type=kidnapping,perp=\[5\], target=\[6\]org_name=\[ 1 \],org_nationality=USSRperson=J9\],organization=\[8\], role=\[7\]value="program manager"org_name=\[2\],org_nationality=USAper_name=\[3\]{ event_type: { kidnapping, murder .... },perp: org,target: personnel };{ org_name: name,org_nationality: string};{ person: person,organization: org,role: string-annotation } ;{ per_name: name };{name_type: {person, organization, other} ;{ value: string };287APPENDIX A POSSIBLE EXTENSIONS TO THE ARCHITECTUREA.1 Enforcing Type DeclarationsIn the current Architecture, annotation type declarations serve only as documentation; they are not processed by anycomponent of the Architecture.
It may be desirable in future versions of the Architecture to perform type checkingbased on such declarations.
This could involve:1. creation of a new class of document, TypeDeclarationDocument, containing apackage of type declarations2.
associating a set of declaration packages with a Collection3.
requiring that any annotation added to a document in a collection conform to the associated type declarationA number of issues would need to be resolved to implement such a scheme, including the name scoping ofannotation types, and the implications of modifying a type declaration after annotations of that type have beencreated.
The overall type checking mechanism would be fairly complex and so has not been included in the currentArchitecture.A.2 Customizable Extraction SystemsThe present Architecture treats extraction engines as modules which have been hand-coded for specific tasks(extraction scenarios).
In the future, it is expected that there will be more general extraction engines which can becustomized by users to specific needs.
This section considers the additional object classes and data flow whichwould be entailed,A.2.1 Object ClassesThe user would prepare an ExtractionNeed, using a combination of formal specification and narrative descriptioncomparable to the "fill rules" for MUC-5.
This would then be "translated" to produce aCustomizedExtractionSystem.
This translation would be performed by a component which will guide an analyst inproducing aCustomizedExtractionSystem; his interactive translation component is labeled Customize below.
Once aCustomizedExtractionSystem is created, it can be applied to documents in a collection (like other, pre-existingannotators) and will produce templates for the documents.The Extraction Need would include annotation type declarations for the annotations to be produced.
These typedefinitions will be supplemented byfill rules in the form of comments.
As the process of translating ExtractionNeedsbecomes more formalized, the fill rules will accordingly also become more formalized.
For example, thespecifications may include the semantic lass of particular slot fills.
For the present, however, an ExtractionNeed is akind of TypeDeclarationDocument:Class ExtractionNeedType of TypeDeclarationDocumentClass CustomizedExtractionSystemDescriptiona system-specific structure, containing patterns, rules, etc.OperationsCustomize (ExtractionNeed): CustomizedExtractionSysteman interactive process which will guide the user in converting an ExtractionNeedCustomizedExtractionSystemExtract (which: Collection, destination: Collection, CustomizedExtractionSystem)into a289the operation which generates templates from documents.
Extraction is a special type of annotation,and accordingly the Extract operation is a variant of the Annotate operation (Section 5.6).
For eachdocument in collection which, if the same document (a document with the same Id) appears indestination, annotate that document in collection destination with the information extractiontemplates generated for that document.Class Template Object LibraryDescriptiona set of system-specific rules for extracting various classes of objects, such as persons or organizations;this library could bc used in customizing an extraction system to a particular taskA.2.2 Functional ModelThe analyst begins by preparing an ExtractionNeed.
The ExtractionNeed would serve as the starting point forcustomization, which would be performed by the analyst using an interactive customization tool and drawing uponthe Template Object Library.
The result of this process would be a CustomizedExtractionSystem.Once a CustomizedExtractionSystem has been created, it can bc given a Collection specifying the documents to beannotated (the "which" argument) and a Collection where the annotations hall be placed (the "destination"argument); it will add to each document of the destination Collection the appropriate templates (in the form ofannotations).I User I  tractionNeedCustomizedExtractionSystemCollection Collection with filledtemplates290APPENDIX B CLASSES AND THEIR OPERATIONSThis appendix lists all the classes and their operations in an "expanded" form.
Instead of showing the propertiesassociated with a class, this appendix explicitly lists the operations to access (and, in some cases, to write) theseproperties.
If property Comp of a class is readable, it is accessed by the operation GetComp; if it is also writeable, itis set by the operation SetComp.
In addition, the inheritance of operations from abstract classes has been madeexplicit: the abstract classes themselves have been removed, and the operations are shown explicitly as part of eachclass which directly inherited them from the abstract class.Class AnnotationOperationsCreateAnnotation (Type: string, Spans: sequence of Span, attributes: sequence of Attribute): AnnotationGetAttribute (Annotation, ame: string): AttfibuteValue OR nilGetAttributes (Annotation): sequence of AttributeGetId (Annotation): stringGetSpans (Annotation): sequence of SpanGetType (Annotation): stringPutAttribute (Annotation, ame: string, value: AttributeValue)RemoveAttribute (Annotation, ame: string)Class AnnotationReferenceOperationsCreateAnnotationReference (Document, Annotation): AnnotationReferenceGetAnnotationId (AnnotationReference): stringGetCollectionName (AnnotationReference): stringGetDocumentId (AnnotationReference): stringClass AnnotationSetOperationsAddAnnotation (Document, Annotation): stringAnnotationsAt (Document OR AnnotationSet, Position: integer): AnnotationSetCreateAnnotationSet 0: AnnotationSetDeleteAnnotations (Document OR AnnotationSet, type: string OR nil, constraint: sequence ofAttribute)GetAnnotation (Document OR AnnotationSet, Id: string): AnnotationLength (AnnotationSet): integerMergeAnnotations (AnnotationSet, AnnotationSet): AnnotationSetNextAnnotations (Document OR AnnotationSet, Position: integer): AnnotationSetNth (AnnotationSet, n: integer): AnnotationRemoveAnnotation (Document OR AnnotationSet, Id: string)SelectAnnotations (Document OR AnnotationSet, type: swing OR nil, constraint: sequence of Attribute):AnnotationSetClass AttributeOperationsCreateAttribute (name: string, value: AttributeValue): AttributeCreateAttributeValue (string OR ObjectReference OR sequence of AttributeValue): AttributeValucGetName (Attribute): string291GetValue (Attribute): AttributeValueClass AttributeReferenceOperationsCreateAttributeReference (Document, AttributeName: string):GetAttributeName (AttributeReference): stringGetCollectionName (AttributeReference): stringGetDocumentld (AttributeReference): stringAttributeReferenceClass AttributeValueOperationsGetValue (AttributeValue): string OR CollectionReference OR DocumentReference ORAttributeReference OR AnnotationReference OR sequence of AttributeValueTypeOf (AttributeValue): one of (string, sequence, CollectionReference,DocumentReference, AnnotationReference, AttributeReference)Class ByteSequenceOperationsConvertToStrring (ByteSequence): stringCreateByteSequence (string): ByteSequenceLength (ByteSequence): integerClass CollectionOperationsAnnotateCollection (which: Collection, destination: Collection, AnnotatorName:Close (object: Collection)CreateCollection ( ame: string, attributes: equence of Attribute): CollectionCreateVolatileCollection (attributes: equence of Attribute): CollectionDestroy (name: string)FirstDocument (Collection): Document OR nilGetAttribute (Collection, name: string): AttributeValue OR nilGetAttributes (Collection): sequence of AttributeGetByExternalId (Collection, ExternalId: string): Document OR nilGetDocument (Collection, Id: string): Document OR nilGetName (Collection): stringGetOwner (Collection): stringLength (Collection): integerNextDocument (Collection): Document OR nilOpenCollection ( ame: string): CollectionPutAttribute (Collection, name: string, value: AttributeValue)RemoveDocument (Collection, Id: string)SetOwner (Collection, string )Sync (object: Collection)RemoveAttribute (Collection, name: string)string)292Class CollectionReferenceOperationsCreateCollectionReference (Collection): CollectionReferenceGetCollectionName (CollectionReference): stringClass DetectionNeedType of DocumentOperationsQueryGenerator (DetectionNeed): DetectionQueryClass DetectionNeedCollectionType of CollectionClass DetectionQueryType of DocumentOperationsEditQuery (DetectionQuery)FormRetrievalQuery (DetectionQuery, sequence of DocumentCollectionlndex): RetrievalQueryFormRoutingQuery (DetectionQuery, sequence of DocumentCollectionlndex): RoutingQueryGetDetectionNeed (DetectionQuery): DocumentReferenceClass DocumentOperationsAnnotate (Document, AnnotatorName: string)CopyBareDocument (NewParent: Collection, Document): DocumentCopyDocument (NewParent: Collection, Document): DocumentCreateDocument (Parent: Collection, ExternalId: string, RawData:ByteSequence, annotations: AnnotationSet, attributes: equence of Attribute): DocumentGetAnnotations (Document): AnnotationSetGetAttribute (Document, name: string): AttributeValue OR nilGetAttributes (Document): sequence of AttributeGetExternalId (Document): stringGetId (Document): stringGetParent (Document): CollectionGetRawData (Document): ByteSequencePutAttribute (Document, name: string, value: AttributeValue)ReadSGML (string, Parent: Collection, ExternalId: string): DocumentSetExternalId (Document, string )WriteSGML (Document, AnnotationSet, AnnotationPrecedence: sequence ofRemoveAttribute (Document, name: string)string): stringClass DocumentCollectionIndexOperationsAugment (DocumentCollectionlndex, Collection)Close (object: DocumentCollectionlndex)CreateDocumentCollectionlndex (name: string): DocumentCollectionlndex293Destroy (name: string)GetName (DocumentCollectionlndex): stringOpenDocumentCollectionlndex (name: string): DocumentCollectionlndexRetrieveDocuments (sequence ofDocumentCollectionlndex, R trievalQuery,integer): CollectionSync (object: DocumentCollectionlndex)NumberToRetrieve:Class Document ReferenceOperationsCreateDocumentReference (Document): DocumentReferenceGetCollectionName (DocumentReference): stringGetDocumentlD(DocumentReference):stringClass MonitorOperationsCreateMonitor (StatusType :one of { NumDocs, Time, Percent }, IntervalType one of{ NumDocs,Percent}, Interval :integer, ClientData :string) :MonitorMonitorProgress (Monitor, DCIName :string, Status: integer, MaxStatus :integer, Type :oneof(numDocs, Time, Percent}) :BooleanClass QueryCollectionIndexOperationsAddQuery (QueryCollectionIndex, RoutingQuery)Close (object: QueryCollectionlndex)CreateQueryCollectionlndex (name: string): QueryCollectionlndexDestroy (name: string)GetName (QueryCollectionlndex): stringOpenQueryCollectionlndex (name: string): QueryCollectionlndexRemoveQuery (QueryCollectionlndex, RoutingQuery)RetrieveQueries (sequence ofQueryCollectionlndex, Document, NumberToRetrieve: integer):DetectionNeedcollectionSync (object: QueryCollectionlndex)Class RetrievalQueryOperationsUpdateUsingRelevanceFeedback(RetrievalQuery, relevant_docs: Collection, sequence ofGetDetectionNeed (RetrievalQuery): DocumentReferenceRetrievalQueryFromRelevanceJudgements (rel vant docs: Collection, sequence ofDocumentCollectionIndex, D tectionNeed): RetrievalQueryScoreDocuments (Collection, RetrievalQuery)UpdateUsingRelevanceFeedback (RetrievalQuery, elevant_does: Collection, sequence ofDocumentCollectionIndex): RetrievalQueryClass RoutingQueryOperationsGetDetectionNeed (RoutingQuery): DocumentReferenceRoutingQueryFromRelevanceJudgments (relevant docs: Collection, sequence ofDocumentCollectionIndex, D tectionNeed): RoutingQueryTime,294UpdateUsingRelevanceFeedback (RoutingQuery, relevant_docs: Collection,DocumentCollectionlndex): RoutingQueryClass SpanOperationsCreateSpan (start: integer, end: integer): SpanGetEnd (Span): integerGetStart (Span): integersequence of295APPENDIX C C LANGUAGE HEADER FILEThis appendix shows the C language header file corresponding to the classes defined in the TIPSTER Architecture.Each concrete TIPSTER class has been mapped into a C language type of the same name.
However, classes.DetectionNeed, DetectionQuery, and DetectionNeedCollection, are not realized as separate C language types.
Thefirst two are subtypes of Document in the Architecture, and are treated as instances of the Document type; the last isa subtype of Collection, and is treated as a Collection in the C language specifications.Any functional argument which can be of more than one TIPSTER class is declared of type void* in the C-languagedeclarations (however, arguments which can either point to an object of class X or be NULL are declared as being ofclass X).Instances of such overloading, and instances where a specific TIPSTER class is represented by a more general Ctype (e.g., DetectionNeed byDocument) are noted in comments immediately preceding the function type declaration./* Tipster Architecture header file (tipster.h) */typedef char* tip_string;typedef int tip_integer;typedef int tip_Booleanenum tip_AttributeValueType { STRING, SEQUENCE, COLLECTION_REFERENCE,DOCUMENT_REFERENCE, ANNOTATION_REFERENCE, ATTRIBUTE_REFERENCE} ;typedef void* tip_Annotation;typedef void* tip_AnnotationReference;typedef void* tip_AnnotationSet;typedef void* tip_Attribute;typedef void* tip_AttributeReference;typedef void* tip_AttributeSet;typedef void* tip AttributeValue;void* tip_AttributeValueSet;void* tip_ByteSequence;void* tip_Collection;void* tip_CollectionReference;void* tip_Document;void* tip_DocumentCollectionlndex;void* tip_DocumentCollectionlndexSet;typedeftypedeftypedeftypedeftypedeftypedeftypedeftypedef void*typedef void*typedef void*typedef void*typedef void*typedef void*typedef void*tip_DocumentReference;tip_Monitor;tip_QueryCollectionlndex;tip_QueryCollectionlndexSet;tip_RetrievalQuery;tip_RoutingQuery;tip_Span;297typedef void* tip_SpanSet;typedef void* tip_stringSet;void tip_Free(void*);tip_string tip_AddAnnotation(tip_Document, tip_Annotation);void tip_AddQuery(tip_QueryCollectionIndex, tip_RoutingQuery);void tip_Annotate(tip_Document, tip_string);void tip_AnnotateCollection(tip_Collection, tip_Collection,tip_string);/* Type of argument 1 of AnnotationsAt can be tip_Document ortip_AnnotationSet */tip_AnnotationSet tip_AnnotationsAt(void*, tip_integer);void tip_Augment(tip_DocumentCollectionlndex, tip_Collection);/* Type of argument 1 of Close can be tip_QueryCollectionlndex ortip_Collection or tip_DocumentCollectionlndex */void tip_Close(void*);tip_string tip_ConvertToString(tip_ByteSequence);tip_Document tip_CopyBareDocument(tip_Collection, tip_Document);tip_Document tip_CopyDocument(tip_Collection, tip_Document);tip_Annotation tip_CreateAnnotation(tip_string, ip_SpanSet,tip_AttributeSet);tip_AnnotationReference tip_CreateAnnotationReference(tip_Document,tip_Annotation);tip_AnnotationSet tip_CreateAnnotationSet(void);tip_Attribute tip_CreateAttribute(tip_stfing, tip_AttributeValue);298/* Type of argument 2 of CreateAttributeValue canbe tipstring or tip_CollectionReference ortip DocumentReference or tip_AttributeReference or tip_AnnotationReference or tip_AttributeValueSettip AttributeValue tip_CreateAttributeValue (enum tip_AttributeValueType, void*)tip AttributeReference tip_CreateAttributeReference(tip_Document,tip_string);*/tip_AttributeSet tip_CreateAttributeSet(void);tip AttributeValueSet tip_CreateAttributeValueSet(void);tip ByteSequence tip_CreateByteSequence(tip_string);tipCollection tip_CreateCollection(tip_string, tip_AttributeSet);tip_CollectionReference tip_CreateCollectionReference(tip_Collection);tipDocument tip_CreateDocument(tip_Collection, tip_string,tip_ByteSequence, tip_AnnotationSet, tip_AttributeSet);tip_DocumentCollectionlndextip_CreateDocumentCollectionlndex(tip_string);tip DocumentCollectionlndexSettip_CreateDocumentCollectionlndexSet(void);tip_DocumentReference tip_CreateDocumentReference(tip_Document);tip_QueryCollectionlndex tip_CreateQueryCollectionlndex(tip string);tip_QueryCollectionlndexSet tip_CreateQueryCollectionIndexSet(void);tip_Span tip_CreateSpan(tip_integer, tip_integer);tip_SpanSet tip_CreateSpanSet(void);tipCollection tip_CreateVolatileCollection(tip_AttributeSet);299tip_stringSet tip_CreatestringSet(void);/* Type of argument 1 of DeleteAnnotations can be tip_Document ortip_AnnotationSet *//* Type of argument 2 of DeleteAnnotations can be tip_string or NULL */void tip_DeleteAnnotations(void*, t p_string, tip_AttributeSet);void tip_Destroy(tip_string);/* tip_Document as argument 1 represents Tipster class DetectionQuery*/void tip_EditQuery(tip_Document);/* Result of FirstDocument can be tip_Document orNULL */tip_Document tip_FirstDocument(tip_Collection);/* tip_Document as argument 1 represents Tipster class DetectionQuery */tip_RetrievalQuery tip_FormRetrievalQuery(tip_Document,tip_DocumentCollectionlndexSet);/* tip_Document as argument 1 represents Tipster class DetectionQuery */tip_RoutingQuery tip_FormRoutingQuery(tip_Document,tip_DocumentCollectionlndexSet);/* Type of argument 1 of GetAnnotation can be tip_Document ortip_AnnotationSet */tip_Annotation tip_GetAnnotation(void*, tip_string);tip_string tip_GetAnnotationld(tip_AnnotationReference);tip_AnnotationSet tip_GetAnnotations(tip_Document);/* Result of GetAttribute can be NULL or tip_AttributeValue *//* Type of argument 1 of GetAttribute can be tip_Annotation ortip_Collection or tipDocument */tip_AttributeValue tip_GetAttribute(void*, tip_string);tip_string tip_GetAttributeName(tip_AttributeReference);/* Type of argument 1 of GetAttributes can be tip_Annotation or300tip_Collection or tip_Document */tip_AttributeSet tip_GetAttributes(void*);/* Result of GetByExternalld can be tip_Document orNULL */tip_Document tip_GetByExternalld(tip_Collection, tip_string);/* Type of argument 1 of GetCollectionName can betip_AnnotationReference or tip_AttributeReference ortip_DocumentReference or tip_CollectionReference */tip_string tip_GetCollectionName(void*);/* tip_Document as argument 1 represents Tipster class DetectionQuery *//* Type of argument 1 of GetDetectionNeed can be tip_RoutingQuery ortip_RetrievalQuery or tip_Document*/tip_DocumentReference tip_GetDetectionNeed(void*);/* Result of GetDocument can be tip_Document orNULL */tip_Document tip_GetDocument(tip Collection, tip_string);/* Type of argument 1 of GetDocumentld can be tip_DocumentReference ortip_AnnotationReference or tip_AttributeReference */tip_string tip_GetDocumentld(void*);tip integer tip_GetEnd(tip Span);tipstring tip_GetExternalId(tip_Document);/* Type of argument 1 of GetId can be tip_Annotation ortip_Document */tipstring tip_Getld(void*);/* Type of argument 1 of GetName can be tip_Collection ortip DocumentCollectionlndex or tip_QueryCollectionlndex ortipAttribute */tip_string tip_GetName(void*);tipstring tip GetOwner(tip Collection);tipCollection tip_GetParent(tip Document);tip ByteSequence tip_GetRawData(tip_Document);301tip_SpanSet tip_GetSpans(tip_Annotation);tip_integer tip GetStart(tip_Span);tip_string tip_GetType(tip_Annotation);/* Result of GetValue can be tip_AttributeReference ortip_AnnotationReference or tip_AttributeValueSet or ip_AttributeValueor tip_string or tip_CollectionReference or tip_DocumentReference *//* Type of argument 1of GetValue can be tip_AttributeValue ortip_Attribute */void* tip_GetValue(void*);/* Type of argument 1of Length can be tip_Collection or tip SpanSetor tip_DocumentCollectionlndexSet or tip_AttributeSet ortip_ByteSequence or tip_AnnotationSet or tip_stringSet ortip_AttributeValueSet or ip_QueryCollectionlndexSet */tip_integer tip_Length(void*);tip_AnnotationSet tip_MergeAnnotations(tip_AnnotationSet,tip_AnnotationSet);/* Type of argument 1 of NextAnnotations can be tip_Document ortip_AnnotationSet */tip_AnnotationSet tip_NextAnnotations(void*, tip_integer);/* Result of NextDocument can be tip_Document orNULL */tip_Document tip NextDocument(tip_Collection);/* Result of Nth can be tip_DocumentCollectionlndex or tip_Attributeor tip_Annotation or tip_string or tip_AttributeValue ortip_QueryCollectionlndex or tipSpan *//* Type of argument 1of Nth can be tip_DocumentCollectionlndexSet ortip_AttributeSet or tip_AnnotationSet or tip_stringSet ortip_AttributeValueSet or ip_QueryCollectionlndexSet or tip_SpanSet */void* tip_Nth(void*, tip_integer);tip_Collection tip_OpenCollection(tip_string);tip_DocumentCollectionlndextip_OpenDocumentCollectionlndex(tip_string);tip_QueryCollectionlndex tip_OpenQueryCollectionlndex(tip_string);302/* Result of Pop can be tip_Attribute or tip_string ortip_AttrributeValue ortip_QueryCollectionlndex or tip_Span ortip_DocumentCollectionlndex *//* Type of argument 1 of Pop can be tip_AttributeSet or tip_stringSetor tip_AttributeValueSet or ip_QueryCollectionlndexSet or tip_SpanSetor tip_DocumentCollectionlndexSet */void* tip_Pop(void*);/* Type of argument 1 of Push can be tip AttributeSet or tip stringSetor tip_AttributeValueSet or ip_QueryCollectionlndexSet or tip SpanSetor tip_DocumentCollectionlndexSet *//* Type of argument 2 of Push can be tipAttribute or tip_string ortip_AttributeValue or tip_QueryCollectionlndex or tip_Span ortip_DocumentCollectionlndex */void tipPush(void*, void*);/* Type of argument 1 of PutAttfibute can be tip_Annotation ortip_Collection or tip_Document */void tip PutAttribute(void*, tip_string, tip_AttributeValue);/* tip_Document as result represents Tipster class DetectionQuery *//* tip_Document as argument 1 represents Tipster class DetectionNeed */tip_Document tip_QueryGenerator(tip_Document);tip_Document tip_ReadSGML(tip_string, tip_Collection, tip_string);/*Type of argument 1 of RemoveAttribute can be tipCollection OR tip_Document OR tip_Annotation */void tip_RemoveAttribute (void*, tip_string)/* Type of argument 1 of RemoveAnnotation can be tip_Document ortip AnnotationSet */void tip_RemoveAnnotation(void*, t p_string);void tip RemoveDocument(tip_Collection, tipstring);void tip RemoveQuery(tip_QueryCollectionlndex, tip_RoutingQuery);/* tip_Document as argument 3 represents Tipster class DetectionNeed */tip_RetrievalQuerytip RetrievalQueryFromRelevanceJudgements(tip_Collection,tip DocumentCollectionlndexSet, tip_Document);tip_Collection tip_RetrieveDocuments(tip_DocumentCollectionlndexSet,303tip_RetrievalQuery, tip_integer);/* tip_Collection as result represents Tipster classDetectionNeedCollection */tip_Collection tip_RetrieveQueries(tip_QueryCollectionlndexSet,tip_Document, tip_integer);/* tip_Document as argument 3 represents Tipster class DetectionNeed */tip_RoutingQuerytip_RoutingQueryFromRelevanceJudgements(tip_Collection,tip_DocumentCollectionlndexSet, tip_Document);void tip_ScoreDocuments(tip_Collection, tip_RetrievalQuery);/* Type of argument 1 of SelectAnnotations can be tip_Document ortip_AnnotationSet *//* Type of argument 2 of SelectAnnotations can be tip_string or NULL*/tip_AnnotationSet tip_SelectAnnotations(void*, t p_string,tip_AttributeSet);void tip_SetExternalId(tip_Document, tip_string);void tip_SetOwner(tip_Collection, tip_string);/* Type of argument 1 of Sync can be tip_QueryCollectionlndex ortip_Collection or tip_DocumentCollectionlndex */void tip_Sync(void*);enum tip_AttributeValueType tip_TypeOf(tip_AttributeValue);/* Result of UpdateUsingRelevanceFeedback can be tip_RoutingQuery ortip_RetrievalQuery *//* Type of argument 1 of UpdateUsingRelevanceFeedback can betip_RoutingQuery or tip_RetrievalQuery */void* tip_UpdateUsingRelevanceFeedback(void*, tip_Collection,tip_DocumentCollectionlndexSet);tip_string tip_WriteSGML(tip_Document, tip_AnnotationSet,tip_stringSet);/*Arguments 1 & 2 of CreateMonitor can be number of documents, econds, percent*/tip_Monitor tip_CreateMonitor(tip integer, tip_integer, tip_integer, tip_string);304/*Argument 4 of MonitorProgress can be number of documents, econds, percent*/tip_Boolean MonitorProgress(tip_Monitor, tip_string, tip_integer, tip_integer);305
