INV ITED TALKHead Automata and Bilingual Tiling:Translation with Minimal RepresentationsHiyan  AlshawiAT&T Research600 Mounta in  Avenue, Murray Hill, NJ  07974, USAhiyan@research.att .comAbst rac tWe present a language model consisting ofa collection of costed bidirectional finitestate automata ssociated with the headwords of phrases.
The model is suitablefor incremental pplication of lexical asso-ciations in a dynamic programming searchfor optimal dependency tree derivations.We also present a model and algorithmfor machine translation involving optimal"tiling" of a dependency tree with entriesof a costed bilingual exicon.
Experimen-tal results are reported comparing methodsfor assigning cost functions to these mod-els.
We conclude with a discussion of theadequacy of annotated linguistic strings asrepresentations formachine translation.1 I n t roduct ionUntil the advent of statistical methods in the main-stream of natural language processing, syntacticand semantic representations were becoming pro-gressively more complex.
This trend is now revers-ing itself, in part because statistical methods re-duce the burden of detailed modeling required byconstraint-based grammars, and in part because sta-tistical models for converting natural anguage intocomplex syntactic or semantic representations is notwell understood at present.
At the same time, lex-ically centered views of language have continued toincrease in popularity.
We can see this in lexical-ized grammatical theories, head-driven parsing andgeneration, and statistical disambiguation based onlexical associations.These themes - -  simple representations, statisti-cal modeling, and lexicalism - -  form the basis forthe models and algorithms described in the bulk ofthis paper.
The primary purpose is to build effec-tive mechanisms for machine translation, the oldestand still the most commonplace application of non-superficial natural language processing.
A secondarymotivation is to test the extent o which a non-triviallanguage processing task can be carried out withoutcomplex semantic representations.In Section 2 we present reversible mono-lingualmodels consisting of collections of simple automataassociated with the heads of phrases.
These headautomata re applied by an algorithm with admissi-ble incremental pruning based on semantic associa-tion costs, providing apractical solution to the prob-lem of combinatoric disambiguation (Church andPatil 1982).
The model is intended to combine thelexical sensitivity of N-gram models (Jelinek et al1992) and the structural properties of statistical con-text free grammars (Booth 1969) without he com-putational overhead of statistical lexicalized tree-adjoining rammars (Schabes 1992, Resnik 1992).For translation, we use a model for mapping de-pendency graphs written by the source languagehead automata.
This model is coded entirely asa bilingual exicon, with associated cost parame-ters.
The transfer algorithm described in Section 4searches for the lowest cost 'tiling' of the targetdependency graph with entries from the bilinguallexicon.
Dynamic programming is again used tomake exhaustive search tractable, avoiding the com-binatoric explosion of shake-and-bake translation(Whitelock 1992, Brew 1992).In Section 5 we present ageneral framework for as-sociating costs with the solutions of search processes,pointing out some benefits of cost functions otherthan log likelihood, including an error-minimizationcost function for unsupervised training of the pa-rameters in our translation application.
Section 6briefly describes an English-Chinese translator em-ploying the models and algorithms.
We also presentexperimental results comparing the performance ofdifferent cost assignment methods.Finally, we return to the more general discussionof representations formachine translation and othernatural anguage processing tasks, arguing the casefor simple representations close to natural languageitself.2 Head Automata  Language Mode ls2.1 Lexieal and Dependency ParametersHead automata mono-lingual language models con-sist of a lexicon, in which each entry is a pair (w, m)of a word w from a vocabulary V and a head au-tomaton m (defined below), and a parameter tablegiving an assignment of costs to events in a genera-tive process involving the automata.167We first describe the model in terms of the familiarparadigm of a generative statistical model, present-ing the parameters as conditional probabilities.
Thisgives us a stochastic version of dependency grammar(Hudson 1984).Each derivation in the generative statistical modelproduces an ordered dependency tree, that is, a treein which nodes dominate ordered sequences of leftand right subtrees and in which the nodes have la-bels taken from the vocabulary V and the arcs havelabels taken from a set R of relation symbols.
Whena node with label w immediately dominates a nodewith label w' via an arc with label r, we say thatw' is an r-dependent of the head w. The interpre-tation of this directed arc is that relation r holdsbetween particular instances of w and w'.
(A wordmay have several or no r-dependents for a particularrelation r.) A recursive left-parent-right traversal ofthe nodes of an ordered dependency tree for a deriva-tion yields the word string for the derivation.A head automaton m of a lexical entry (w, m) de-fines possible ordered local trees immediately dom-inated by w in derivations.
Model parameters forhead automata,  together with dependency parame-ters and lexical parameters, give a probability dis-tribution for derivations.A dependency parameterP( L w'lw, r')is the probability, given a head w with a dependentarc with label r ' ,  that w' is the r'-dependent for thisarc.A lexical parameterP(m, qlr, t, w)is the probability that a local tree immediately dom-inated by an r-dependent w is derived by startingin state q of some automaton m in a lexieal entry(w, m).
The model also includes lexieal parametersP(w,m, qlt>)for the probability that w is the head word for anentire derivation initiated from state q of automatonm.2.2 Head AutomataA head automaton is a weighted finite state machinethat writes (or accepts) a pair of sequences of rela-tion symbols from R:((rl... r,)).These correspond to the relations between a headword and the sequences of dependent phrases to itsleft and right (see Figure 1).
The machine consistsof a finite set q0, ?
?
", qs of states and an action ta-ble specifying the finite cost (non-zero probability)actions the automaton can undergo.There are three types of action for an automatonm: left transitions, right transitions, and stop ac-tions.
These actions, together with associated prob-abilistic model parameters, are as follows.WWl " " " Wk Wk+l  " " " WnFigure h Head automaton m scans left and rightsequences of relations ri for dependents wi of w.?
Left transition: if in state qi-1, m can writea symbol r onto the right end of the currentleft sequence and enter state qi with probabil ityP(~,  qi, rlqi-1, m).?
Right transition: if in state qi-1, m can writea symbol r onto the left end of the currentright sequence and enter state qi with proba-bility P(--* , qi, rlqi-1, m).?
Stop: if in state q, m can stop with probabil-ity P(t31q ,m), at which point the sequences areconsidered complete.For a consistent probabilistic model, the probabili-ties of all transitions and stop actions from a state qmust sum to unity.
Any state of a head automatoncan be an initial state, the probability of a partic-ular initial state in a derivation being specified bylexical parameters.
A derivation of a pair of sym-bol sequence thus corresponds to the selection of aninitial state, a sequence of zero or more transitions(writing the symbols) and a stop action.
The prob-ability, given an initial state q, that automaton mwill a generate a pair of sequences, i.e.P(( r l ' .
.
rk), ( rk+l " ' '  rn)Ira, q)is the product of the probabilities of the actionstaken to generate the sequences.
The case of zerotransitions will yield empty sequences, correspond-ing to a leaf node of the dependency tree.From a linguistic perspective, head automata l-low for a compact, graded, notion of lexical subcate-gorization (Gazdar et al 1985) and the linear orderof a head and its dependent phrases.
Lexical param-eters can control the saturation of a lexical item (forexample a verb that is both transitive and intran-sitive) by starting the same automaton in differentstates.
Head automata can also be used to code agrammar in which states of an automaton for wordw corresponds to X-bar levels (Jaekendoff 1977) forphrases headed by w.Head automata re formally more powerful thanfinite state automata that accept regular languagesin the following sense.
Each head automaton definesa formal anguage with alphabet R whose strings arethe concatenation of the left and right sequence pairs168written by the automaton.
The class of languagesdefined in this way clearly includes all regular lan-guages, since strings of a regular language can begenerated, for example, by a head automaton thatonly writes a left sequence.
Head automata can alsoaccept some non-regular languages requiring coordi-nation of the left and right sequences, for examplethe language anb ~ (requiring two states), and thelanguage of palindromes over a finite alphabet.2.3 Der ivat ion  P robab i l i tyLet the probability of generating an ordered depen-dency subtree D headed by an r-dependent word wbe P(D\]w, r).
The recursive process of generatingthis subtree proceeds as follows:1.
Select an initial state q of an automaton m forw with lexical probability P(m, q\[r, ~, w).2.
Run the automaton m0 with initial state q togenerate a pair of relation sequences with prob-ability P( ( r l .
.
.
rk), (rk+l-"" r,,)lm, q).3.
For each relation ri in these sequences, elect adependent word wi with dependency probabil-ity P(l ,  wi\[w, ri).4.
For each dependent wi, recursively generate asubtree with probability P(D~ Iwi, ri).We can now express the probability P(Do) for anentire ordered ependency tree derivation Do headedby a word w0 asP(Do) =P(wo, too, q0\[ 1>)P( (rl .
.
.
rl,), (rk+l " .
.
rnl Imo, qo)YIl <i<n P( l ,  wilwo, ri)P( Di Iwi, ri).In the translation application we search for the high-est probability derivation (or more generally, the N-highest probability derivations).
For other purposes,the probability of strings may be of more interest.The probability of a string according to the model isthe sum of the probabilities of derivations of ordereddependency trees yielding the string.In practice, the number of parameters in a headautomaton language model is dominated by the de-pendency parameters, that is, O(\]V\]2\]RI) parame-ters.
This puts the size of the model somewhere inbetween 2-gram and 3-gram model.
The similarlymotivated link grammar model (Lafferty, Sleatorand Temperley 1992) has O(\[VI 3) parameters.
Un-like simple N-gram models, head automata modelsyield an interesting distribution of sentence lengths.For example, the average sentence length for Monte-Carlo generation with our probabilistic head au-tomata model for ATIS was 10.6 words (the averagewas 9.7 words for the corpus it was trained on).3 Analysis and Generation3.1 AnalysisHead automaton models admit efficient lexicallydriven analysis (parsing) algorithms in which par-tial analyses are costed incrementally as they areconstructed.
Put in terms of the traditional parsingissues in natural anguage understanding, "seman-tic" associations coded as dependency parametersare applied at each parsing step allowing semanti-cally suboptimal analyses to be eliminated, so theanalysis with the best semantic score can be identi-fied without scoring an exponential number of syn-tactic parses.
Since the model is lexical, linguisticconstructions headed by lexical items not present inthe input are not involved in the search the waythey are with typical top-down or predictive parsingstrategies.We will sketch an algorithm for finding the lowestcost ordered ependency tree derivation for an inputstring in polynomial time in the length of the string.In our experimental system we use a more generalversion of the algorithm to allow input in the formof word lattices.The algorithm is a bottom-up tabular parser(Younger 1967, Early 1970) in which constituentsare constructed "head-outwards" (Kay 1989, Sataand Stock 1989).
Since we are analyzing bottom-up with generative model automata, the algorithm'runs' the automata backwards.
Edges in the parsinglattice (or "chart") are tuples representing partial orcomplete phrases headed by a word w from positioni to position j in the string:(w,t , i , j ,m,q,c) .Here m is the head automaton for w in this deriva-tion; the automaton is in state q; t is the dependencytree constructed so far, and c is the cost of the par-tial derivation.
We will use the notation C(zly ) forthe cost of a model event with probability P(zIy);the assignment of costs to events is discussed in Sec-tion 5.Initialization: For each word w in the input be-tween positions i and j, the lattice is initialized withphrases{w,{}, i , j ,m,q$,c$)for any lexical entry (w, m) and any final state q!
ofthe automaton m in the entry.
A final state is onefor which the stop action cost c!
= C(DJq!, m) isfinite.Transitions: Phrases are combined bottom-up toform progressively larger phrases.
There are twotypes of combination corresponding to left and righttransitions of the automaton for the word acting asthe head in the combination.
We will specify leftcombination; right combination is the mirror im-age of left combination.
If the lattice contains twophrases abutting at position k in the string:169(Wl, tl, i, k, ml, ql, Cl)(W2, t2, k, j, ra2, q2, c2),and the parameter table contains the following finitecosts parameters (a left v-transition of m2, a lexicalparameter for wl, and an r-dependency parameter):c3 = C(~---, q2, rlq~, m2)c4 = C(ml, qiir, ~, Wx)c5 = C(l, wllw2, r),then build a new phrase headed by w2 with a tree t~formed by adding tl to t~ as an r-dependent of w2:(w2, t~, i, j, m2, q~, cl + c2 + c3 + c4 -4- cs).When no more combinations are possible, for eachphrase spanning the entire input we add the appro-priate start of derivation cost to these phrases andselect the one with the lowest total cost.Pruning: The dynamic programming condition forpruning suboptimal partial analyses is as follows.Whenever there are two phrasesp:  (w,t, i , j ,m,q,c)p' = (w, t', i, j, m, q, c'),and c ~ is greater than c, then we can remove p~ be-cause for any derivation involving p~ that spans theentire string, there will be a lower cost derivationinvolving p. This pruning condition is effective atcurbing a combinatorial explosion arising from, forexample, prepositional phrase attachment ambigui-ties (coded in the alternative trees t and t').The worst case asymptotic time complexity of theanalysis algorithm is O(min(n 2, IY12)n3), where n isthe length of an input string and IVI is the size ofthe vocabulary.
This limit can be derived in a simi-lar way to cubic time tabular ecognition algorithmsfor context free grammars (Younger 1967) with thegrammar elated term being replaced by the termmin(n 2, IVI 2) since the words of the input sentencealso act as categories in the head automata model.In this context "recognition" refers to checking thatthe input string can be generated from the grammar.Note that our algorithm is for analysis (in the senseof finding the best derivation) which, in general, isa higher time complexity problem than recognition.3.2 Generat ionBy generation here we mean determining the low-est cost linear surface ordering for the dependents ofeach word in an unordered ependency structure re-sulting from the transfer mapping described in Sec-tion 4.
In general, the output of transfer is a de-pendency graph and the task of the generator in-volves a search for a backbone dependency tree forthe graph, if necessary by adding dependency edgesto join up unconnected components of the graph.For each graph component, the main steps of thesearch process, described non-deterministically, are1.
Select a node with word label w having a finitestart of derivation cost C(w, m, ql t>).2.
Execute a path through the head automaton mstarting at state q and ending at state q' with afinite stop action cost C(Olq' , m).
When mak-ing a transition with relation ri in the path, se-lect a graph edge with label ri from w to somepreviously unvisited node wi with finite depen-dency cost C(~,wilw, ri).
Include the cost ofthe transition (e.g.
C(---% ql, rilqi-1, m)) in therunning total for this derivation.3.
For each dependent node wi, select a lexical en-try with cost C(mi, qilri, J., wi), and recursivelyapply the machine rni from state ql as in step2.4.
Perform a left-parent-right traversal of thenodes of the resulting dependency tree, yield-ing a target string.The target string resulting from the lowest cost treethat includes all nodes in the graph is selected as thetranslation target string.
The independence assump-tions implicit in head automata models mean thatwe can select lowest cost orderings of local depen-dency trees, below a given relation r, independentlyin the search for the lowest cost derivation.When the generator is used as part of the trans-lation system, the dependency parameter costs arenot, in fact, applied by the generator.
Instead, be-cause these parameters are independent of surfaceorder, they are applied earlier by the transfer com-ponent, influencing the choice of structure passed tothe generator.4 T rans fer  Maps4.1 Trans fer  Mode l  B i l ingual  Lex iconThe transfer model defines possible mappings, withassociated costs, of dependency trees with source-language word node labels into ones with target-language word labels.
Unlike the head automatamonolingual models, the transfer model operateswith unordered ependency trees, that is, it treatsthe dependents of a word as an unordered bag.
Themodel is general enough to cover the common trans-lation problems discussed in the literature (e.g.
Lin-dop and Tsujii 1991 and Dorr 1994) including many-to-many word mapping, argument switching, andhead switching.A transfer model consists of a bilingual lexiconand a transfer parameter table.
The model uses de-pendency tree fragments, which are the same as un-ordered dependency trees except that some nodesmay not have word labels.
In the bilingual lexicon,an entry for a source word wi (see top portion ofFigure 2) has the form(wi, Hi, hi, Gi, fi)where Hi is a source language tree fragment, ni (theprimary node) is a distinguished node of Hi withlabel wi, Gi is a target tree fragment, and fi is a170mapping function, i.e.
a (possibly partial) functionfrom the nodes of Hi to the nodes of Gi.The transfer parameter table specifies costs forthe application of transfer entries.
In a context-independent model, each entry has a single cost pa-rameter.
In context-dependent transfer models, thecost function takes into account he identities of thelabels of the arcs and nodes dominating wi in thesource graph.
(Context dependence is discussed fur-ther in Section 5.)
The set of transfer parametersmay also include costs for the null transfer entriesfor wi, for use in derivations in which wi is trans-lated by the entry for another word v. For example,the entry for v might be for translating an idiominvolving wi as a modifier.Each entry in the bilingual lexicon specifies away of mapping part of a dependency tree, specifi-cally that part "matching" (as explained below) thesource fragment of the entry, into part of a targetgraph, as indicated by the target fragment.
Entrymapping functions pecify how the set of target frag-ments for deriving a translation are to be combined:whenever an entry is applied, a global node-mappingfunction is extended to include the entry mappingfunction.4.2 Matching, Tiling, and DerivationTransfer mapping takes a source dependency tree Sfrom analysis and produces a minimum cost deriva-tion of a target graph T and a (possibly partial)function f from source nodes to target nodes.
Infact, the transfer model is applicable to certain typesof source dependency graphs that are more generalthan trees, although the version of the head au-tomata model described here only produces trees.We will say that a tree fragment H matches anunordered ependency tree S if there is a functiong (a matching function) from the nodes of H to thenodes of S such that?
g is a total one-one function;?
if a node n of H has a label, and that label isword w, then the word label for g(n) is also w;?
for every arc in H with label r from node nl tonode n2, there is an arc with label r from g(nz)to g(n2).Unlike first order unification, this definition ofmatching is not commutative and is not determinis-tic in that there may be multiple matching functionsfor applying a bilingual entry to an input source tree.A particular match of an entry against a dependencytree can be represented by the matching function g,a set of arcs A in S, and the (possibly context de-pendent) cost c of applying the entry.A tiling of a source graph with respect o a transfermodel is a set of entry matches{(El, gz, A1, cl), ?
?
", (E~, gk, At, ck)}which is such thatgiFigure 2: Transfer matching and mapping functions?
k is the number of nodes in the source tree S.?
Each Ei, 1 < i ~ k, is a bilingual entry(wi, Hi, hi, Gi, fil matching S with function gi(see Figure 2) and arcs Ai.?
For primary nodes nl and nj of two distinctentries Ei and Ej, gi(ni) and gi(nj) are distinct.?
The sets of edges Ai form a partition of theedges of S.?
The images gi(Li) form a partition of the nodesof S, where Li is the set of labeled source nodesin the source fragment Hi of Ei.?
ci is the cost of the match specified by the pa-rameter table.A tiling of S yields a costed derivation of a targetdependency graph T as follows:?
The cost of the derivation is the sum of the costsci for each match in the tiling.?
The nodes and arcs of T are composed of thenodes and arcs of the target fragments Gi forthe entries Ei.?
Let fi and fj be the mapping functions for en-tries Ei and Ej.
For any node n of S for whichtarget nodes fi(g\[l(n)) and fj(g~l(n)) are de-fined, these two nodes are identified as a singlenode f(n) in T.The merging of target fragment nodes in the lastcondition has the effect of joining the target frag-ments in a consistent fashion.
The node mappingfunction f for the entire tree thus has a differentrole from the alignment function in the IBM statis-tical translation model (Brown et al 1990, 1993);the role of the latter includes the linear ordering ofwords in the target string.
In our approach, tar-get word order is handled exclusively by the targetmonolingual model.4.3 Trans fer  A lgor i thmThe main transfer search is preceded by a bilinguallexicon matching phase.
This leads to greater ef-ficiency as it avoids repeating matching operations171during the search phase, and it allows a static analy-sis of the matching entries and source tree to identifysubtrees for which the search phase can safely pruneout suboptimal partial translations.T rans fer  Conf igurat ions  In order to apply tar-get language model relation costs incrementally, weneed to distinguish between complete and incom-plete arcs: an arc is complete if both its nodes havelabels, otherwise it is incomplete.
The output of thelexicon matching phrase, and the partial derivationsmanipulated by the search phase are both in theform of transfer configurations(S ,R ,T ,P , f , c , I )where S is the set of source nodes and arcs con-sumed so far in the derivation, R the remainingsource nodes and arcs, f the mapping function builtso far, T the set of nodes and complete arcs of thetarget graph, P the set of incomplete target arcs,c the partial derivation cost, and I a set of sourcenodes for which entries have yet to be applied.Lexical  match ing  phase  The algorithm for lexi-cal matching has a similar control structure to stan-dard unification algorithms, except hat it can resultin multiple matches.
We omit the details.
The lex-icon matching phase returns, for each source nodei, a set of runtime entries.
There is one runtimeentry for each successful match and possibly a nullentry for the node if the word label for i is includedin successful matches for other entries.
Runtime en-tries are transfer configurations of the form(Hi, ?, Gi, Pi, fi, ci, {i})in which Hi is the source fragment for the entry witheach node replaced by its image under the applica-ble matching function; Gi the target fragment forthe entry, except for the incomplete arcs Pi of thisfragment; fi the composition of mapping functionfor the entry with the inverse of the matching func-tion; ci the cost of applying the entry in the contextof its match with the source graph plus the cost inthe target model of the arcs in Gi.Trans fer  Search  Before the transfer searchproper, the resulting runtime entries together withthe source graph are analyzed to determine decom-position nodes.
A decomposition node n is a sourcetree node for which it is safe to prune suboptimaltranslations of the subtree dominated by n. Specifi-cally, it is checked that n is the root node of all sourcefragments Hn of runtime ntries in which both n andits node label are included, and that fn(n) is notdominated by (i.e.
not reachable via directed arcsfrom) another node in the target graph Gn of suchentries.Transfer search maintains a set M of active run-time entries.
InitiMly, this is the set of runtimeentries resulting from the lexicon matching phase.Overall search control is as follows:1.
Determine the set of decomposition nodes.2.
Sort the decomposition nodes into a list D suchthat if nl dominates n2 in S then n2 precedesnl in D.3.
If D is empty, apply the subtree transfer search(given below) to S, return the lowest cost solu-tion, and stop.4.
Remove the first decomposition node n from Dand apply the subtree transfer search to the sub-tree S ~ dominated by n, to yield solutions(s', ?, T', ?, f', c', ?).5.
Partition these solutions into subsets with thesame word label for the node f l(n), and selectthe solution with lowest cost c' from each sub-set.6.
Remove from M the set of runtime entries fornodes in S ~.7.
For each selected subtree solution, add to M anew runtime entry (S', ?, T', f ' ,  c', {n}).8.
Repeat from step 3.The subtree transfer search maintains a queueQ of configurations corresponding to partial deriva-tions for translating the subtree.
Control follows astandard non-deterministic search paradigm:1.
Initialize Q to contain a single configuration(?, R0, ?, ?, ?, 0, I0) with the input subtree R0and the set of nodes I0 in R0.2.
If Q is empty, return the lowest cost solutionfound and stop.3.
Remove a configuration iS, R, T, P, f,  c, I) fromthe queue.4.
If R is empty, add the configuration to the setof subtree solutions.5.
Select a node i from I.6.
For each runtime entry (Hi, ?, Gi, Pi, fi, cl, {i})for i, if Hi is a subgraph of R, add to Q a con-figuration iS 0 Hi, R - Hi, T O Gi 0 G', P U Pi -G', fO fi, c +ci +cv, , I - -{ i} ), where G' is the setof newly completed arcs (those in P t3 Pi withboth node labels in T U Gi O P 0 Pi) and cg,is the cost of the arcs G' in the target languagemodel.7.
For any source node n for which f (n)  and fi(n)are both defined, merge these two target nodes.8.
Repeat from step 2.Keeping the arcs P separate in the configuration al-lows efficient incremental application of target de-pendency costs cv, during the search, so these costsare taken into account in the pruning step of theoverall search control.
This way we can keep thebenefits of monolingual/bilingual modularity (Is-abelle and Macklovitch 1986) without the compu-tationM overhead of transfer-and-filter (Alshawi etal.
1992).172It is possible to apply the subtree search directlyto the whole graph starting with the initial runtimeentries from lexical matching.
However, this wouldresult in an exponential search, specifically a searchtree with a branching factor of the order of the num-ber of matching entries per input word.
Fortunately,long sentences typically have several decompositionnodes, such as the heads of noun phrases, so thesearch as described is factored into manageable com-ponents.5 Cost  Funct ions5.1 Costed  Search  ProcessesThe head automata model and transfer model wereoriginally conceived as probabilistic models.
In orderto take advantage of more of the information avail-able in our training data, we experimented with costfunctions that make use of incorrect ranslations asnegative xamples and also to treat the correctnessof a translation hypothesis as a matter of degree.To experiment with different models, we imple-mented a general mechanism for associating costs tosolutions of a search process.
Here, a search processis conceptualized as a non-deterministic computa-tion that takes a single input string, undergoes asequence of state transitions in a non-deterministicfashion, then outputs a solution string.
Processstates are distinct from, but may include, head au-tomaton states.A cost function for a search process is a real val-ued function defined on a pair of equivalence classesof process states.
The first element of the pair, acontext c, is an equivalence class of states beforetransitions.
The second element, an event e, is anequivalence class of states after transitions.
(Theequivalence relations for contexts and events maybe different.)
We refer to an event-context pair as achoice, for which we use the notation(efc)borrowed from the special case of conditional prob-abilities.
The cost of a derivation of a solution bythe process is taken to be the sum of costs of choicesinvolved in the derivation.We represent events and contexts by finite se-quences of symbols (typically words or relation sym-bols in the translation application).
We writeC(a l ' "an lb l ' "bk)for the cost of the event represented by (al ..-a,~) inthe context represented by(b1 ..-bk).
"Backed off" costs can be computed by averag-ing over larger equivalence classes (represented byshorter sequences in which positions are eliminatedsystematically).
A similar smoothing technique hasbeen applied to the specific case of prepositionalphrase attachment by Collins and Brooks (1995).We have used backed off costs in the translation ap-plication for the various cost functions described be-low.
Although this resulted in some improvement intesting, so far the improvement has not been statis-tically significant.5.2 Mode l  Cost  Funct ionsTaken together, the events, contexts, and cost func-tion constitute a process cost model, or simply amodel.
The cost function specifies the model param-eters; the other components are the model structure.We have experimented with a number of modeltypes, including the following.Probabilistic model: In this model we assume aprobability distribution on the possible events for acontext, that is,E~ P(elc) = 1.The cost parameters of the model are defined as:C(elc) = - ln(P(elc)).Given a set of solutions from executions of a process,let n+(e\]e) be the number of times choice (e\[c) wastaken leading to acceptable solutions (e.g.
correcttranslations) and n+(c) be the number of times con-text c was encountered for these solutions.
We canthen estimate the probabilistic model costs withC(elc ) ~ ln(n+(c)) - ln(n+(elc)) .Discriminative model: The costs in this model arelikelihood ratios comparing positive and negativesolutions, for example correct and incorrect rans-lations.
(See Dunning 1993 on the application oflikelihood ratios in computational linguistics.)
Letn-(elc ) be the count for choice (e\]c) leading to neg-ative solutions.
The cost function for the discrimi-native model is estimated asC(elc) ~ In(n- (elc)) - ln(n+(ele)) .Mean distance model: In the mean distance model,we make use of some measure of goodness of a solu-tion ts for some input s by comparing it against anideal solution is for s with a distance metric h:h(t , , i , )  ~ din which d is a non-negative r al number.
A param-eter for choice (e\]c) in the distance modelC(elc) = Eh(elc)is the mean value of h(t~,t~) for solutions t, pro-duced by derivations including the choice (eIc).Normalized distance model: The mean distancemodel does not use the constraint hat a particularchoice faced by a process is always a choice betweenevents with the same context.
It is also somewhatsensitive to peculiarities of the distance function h.With the same assumptions we made for the meandistance model, letEh(c)be the average of h(t~, ts) for solutions derived fromsequences of choices including the context c. Thecost parameter for (elc) in the normalized istancemodel is173C(e lc)  = Bh(c) 'that is, the ratio of the expected istance for deriva-tions involving the choice and the expected istancefor all derivations involving the context for thatchoice.Ref lex ive Tra in ing  If we have a manually trans-lated corpus, we can apply the mean and normal-ized distance models to translation by taking theideal solution t~ for translating a source string s tobe the manual translation for s. In the absence ofgood metrics for comparing translations, we employa heuristic string distance metric to compare wordselection and word order in t~ and ~s.In order to train the model parameters withouta manually translated corpus, we use a "reflexive"training method (similar in spirit to the "wake-sleep" algorithm, Hinton et al 1995).
In thismethod, our search process translates a source sen-tence s to ts in the target language and then trans-lates t~ back to a source language sentence #.
Theoriginal sentence s can then act as the ideal solu-tion of the overall process.
For this training methodto be effective, we need a reasonably good initialmodel, i.e.
one for which the distance h(s, #) is in-versely correlated with the probability that t~ is agood translation of s.6 Exper imenta l  Sys temWe have built an experimental translation systemusing the monolingual and translation models de-scribed in this paper.
The system translates en-tences in the ATIS domain (Hirschman et al 1993)between English and Mandarin Chinese.
The trans-lator is in fact a subsystem of a speech translationprototype, though the experiments we describe hereare for transcribed spoken utterances.
(We infor-mally refer to the transcribed utterances as sen-tences.)
The average time taken for translation ofsentences (of unrestricted length) from the ATIS cor-pus was around 1.7 seconds with approximately 0.4seconds being taken by the analysis algorithm and0.7 seconds by the transfer algorithm.English and Chinese lexicons of around 1200 and1000 words respectively were constructed.
Alto-gether, the entries in these lexicons made referenceto around 200 structurally distinct head automata.The transfer lexicon contained around 3500 pairedgraph fragments, most of which were used in bothtransfer directions.
With this model structure, wetried a number of methods for assigning cost func-tions.
The nature of the training methods and theircorresponding cost functions meant that differentamounts of training data could be used, as discussedfurther below.The methods make use of a supervised trainingset and an unsupervised training set, both sets be-ing chosen at random from the 20,000 or so ATISsentences available to us.
The supervised trainingset comprised around 1950 sentences.
A subcollec-tion of 1150 of these sentences were translated by thesystem, and the resulting translations manually clas-sified as 'good' (800 translations) or 'bad' (350 trans-lations).
The remaining 800 supervised training setsentences were hand-tagged for prepositional ttach-ment points.
(Prepositional phrase attachment is amajor cause of ambiguity in the ATIS corpus, andmoreover can affect English-Chinese translation, seeChen and Chen 1992.)
The attachment informa-tion was used to generate additional negative andpositive counts for dependency choices.
The un-supervised training set consisted of approximately13,000 sentences; it was used for automatic training(as described under 'Reflexive Training' above) bytranslating the sentences into Chinese and back toEnglish.A.
Qualitative Baseline: In this model, all choiceswere assigned the same cost except for irregularevents (such as unknown words or partial analy-ses) which were all assigned a high penalty cost.This model gives an indication of performance basedsolely on model structure.B.
Probabilistic: Counts for choices leading to goodtranslations for sentences of the supervised train-ing corpus, together with counts from the manuallyassigned attachment points, were used to computenegated log probability costs.C.
Discriminative: The positive counts as in theprobabilistic method, together with correspondingnegative counts from bad translations or incorrectattachment choices, were used to compute log likeli-hood ratio costs.D.
Normalized Distance: In this fully automaticmethod, normalized istance costs were computedfrom reflexive translation of the sentences in the un-supervised training corpus.
The translation runswere carried out with parameters from method A.E.
Bootstrapped Normalized Distance: The same asmethod D except hat the system used to carry outthe reflexive translation was running with parame-ters from method C.Table 1 shows the results of evaluating the per-formance of these models for translating 200 unre-stricted length ATIS sentences into Chinese.
Thiswas a previously unseen test set not included inany of the training sets.
Two measures of transla-tion acceptability are shown, as judged by a Chinesespeaker.
(In separate xperiments, we verified thatthe judgments of this speaker were near the averageof five Chinese speakers).
The first measure, "mean-ing and grammar", gives the percentage of sentencetranslations judged to preserve meaning without theintroduction of grammatical errors.
For the secondmeasure, "meaning preservation", grammatical er-rors were allowed if they did not interfere with mean-ing (in the sense of misleading the hearer).
In the ta-ble, we have grouped together methods A and D for174Table 1: Translation performance of different costassignment methodsMethod Meaning andGrammar (%)A '  29 71D 37 71B 46 82C 52 83E 54 83MeaningPreservation (%)which the parameters were derived without humansupervision effort, and methods B, C, and E whichdepended on the same amount of human supervisioneffort.
This means that side by side comparison ofthese methods has practical relevance, ven thoughthe methods exploited ifferent amounts of data.
Inthe case of E, the supervision effort was used onlyas an oracle during training, not directly in the costcomputations.We can see from Table 1 that the choice of methodaffected translation quality (meaning and grammar)more than it affected preservation of meaning.
Apossible xplanation is that the model structure wasadequate for most lexical choice decisions because ofthe relatively low degree of polysemy in the ATIScorpus.
For the stricter measure, the differenceswere statistically significant, according to the signtest at the 5% significance l vel, for the followingcomparisons: C and E each outperformed B and D,and B and D each outperformed A.7 Language Process ing  andSemant ic  Representat ionsThe translation system we have described employsonly simple representations of entences and phrases.Apart from the words themselves, the only sym-bols used are the dependency relations R. In ourexperimental system, these relation symbols arethemselves natural anguage words, although thisis not a necessary property of our models.
Infor-mation coded explicitly in sentence representationsby word senses and feature constraints in our pre-vious work (Alshawi 1992) is implicit in the mod-els used to derive the dependency trees and trans-lations.
In particular, dependency parameters andcontext-dependent transfer parameters give rise toan implicit, graded notion of word sense.For language-centered applications like transla-tion or summarization, for which we have a largebody of examples of the desired behavior, we canthink of the task in terms of the formal problem ofmodeling a relation between strings based on exam-pies of that relation.
By taking this viewpoint, weseem to be ignoring the intuition that most interest-ing natural anguage processing tasks (translation,summarization, i terfaces) are semantic in nature.It is therefore tempting to conclude that an adequatetreatment of these tasks requires the manipulationof artificial semantic representation languages withwell-understood formal denotations.
While the in-tuition seems reasonable, the conclusion might betoo strong in that it rules out the possibility thatnatural language itself is adequate for manipulatingsemantic denotations.
After all, this is the primaryfunction of natural anguage.The main justification for artificial semantic rep-resentation languages i that they are unambiguousby design.
This may not be as critical, or useful,as it might first appear.
While it is true that nat-ural language is ambiguous and under-specified outof context, this uncertainty is greatly reduced bycontext o the point where further resolution (e.g.full scoping) is irrelevant o the task, or even theintended meaning.
The fact that translation is in-sensitive to many ambiguities motivated the use ofunresolved quasi-logical form for transfer (Alshawiet al 1992).To the extent hat contextual resolution is neces-sary, context may be provided by the state of the lan-guage processor ather than complex semantic rep-resentations.
Local context may include the state oflocal processing components ( uch as our head au-tomata) for capturing rammatical constraints, orthe identity of other words in a phrase for capturingsense distinctions.
For larger scale context, I haveargued elsewhere (Alshawi 1987) that memory ac-tivation patterns resulting from the process of car-rying out an understanding task can act as globalcontext without explicit representations of discourse.Under this view, the challenge is how to exploit con-text in performing a task rather than how to mapnatural language phrases to expressions of a formal-ism for coding meaning independently of context orintended use.There is now greater understanding of the formalsemantics of under-specified and ambiguous repre-sentations.
In Alshawi 1996, I provide a denota-tional semantics for a simple under-specified lan-guage and argue for extending this treatment to aformal semantics of natural anguage strings as ex-pressions of an under-specified representation.
Inthis paradigm, ordered dependency trees can beviewed as natural language strings annotated so thatsome of the implicit relations are more explicit.
Amilder form of this kind of annotation is a bracketednatural anguage string.
We are not advocating anapproach in which linguistic structure is ignored (asit is in the IBM translator described by Brown etal.
1990), but rather one in which the syntactic andsemantic structure of a string is implicit in the wayit is processed by an interpreter.One important advantage ofusing representationsthat are close to natural language itself is that it re-duces the degrees of freedom in specifying languageand task models, making these models easier to ac-175quire automatically.
With these considerations inmind, we have started to experiment with a versionof the translator described here with even simplerrepresentations and for which the model structure,not just the parameters, can be acquired automati-cally.AcknowledgmentsThe work on cost functions and training methodswas carried out jointly with Adam Buchsbaum whoalso customized the English model to ATIS and in-tegrated the translator into our speech translationprototype.
Jishen He constructed the Chinese ATISlanguage model and bilingual lexicon and identifiedmany problems with early versions of the transfercomponent.
I am also grateful for advice and helpfrom Don Hindle, Fernando Pereira, Chi-Lin Shih,Richard Sproat, and Bin Wu.ReferencesAlshawi, H. 1987.
Memory and Context for LanguageInterpretation.
Cambridge University Press, Cambridge,England.Alshawi, H. 1996.
"Underspecified First Order Log-ics".
In Semantic Ambiguity and Underspecification,edited by K. van Deemter and S. Peters, CSLI Publi-cations, Stanford, California.Alshawi, H. 1992.
The Core Language Engine.
MITPress, Cambridge, Massachusetts.Alshawi, H., D. Carter, B. Gamback and M. Rayner.1992.
"Swedish-English QLF Translation".
In H. A1-shawi (ed.)
The Core Language Engine.
MIT Press,Cambridge, Massachusetts.Booth, T. 1969.
"Probabilistic Representation f For-real Languages".
Tenth Annual IEEE Symposium onSwitching and Automata Theory.Brew, C. 1992.
"Letting the Cat out of the Bag: Gen-eration for Shake-and-Bake MT'.
Proceedings of COL-ING92, the International Conference on ComputationalLinguistics, Nantes, France.Brown, P., J. Cocks, S. Della Pietra, V. Della Pietra,F.
Jelinek, J. Lafferty, R. Mercer and P. Rossin.
1990.
"A Statistical Approach to Machine Translation".
Com-putational Linguistics 16:79-85.Brown, P.F., S.A. Della Pietra, V.J.
Della Pietra, andR.L.
Mercer.
1993.
"The Mathematics of StatisticalMachine Translation: Parameter Estimation".
Compu-tational Linguistics 19:263-312.Chen, K.H.
and H. H. Chen.
1992.
"Attachment andTransfer of Prepositional Phrases with Constraint Prop-agation".
Computer Processing of Chinese and OrientalLanguages, Vol.
6, No.
2, 123-142.Church K. and R. PatH.
1982.
"Coping with SyntacticAmbiguity or How to Put the Block in the Box on theTable".
Computational Linguistics 8:139-149.Collins, M. and J. Brooks.
1995.
"PrepositionalPhrase Attachment through a Backed-Off Model."
Pro-ceedings of the Third Workshop on Very Large Corpora,Cambridge, Massachusetts, ACL, 27-38.Dorr, B.J.
1994.
"Machine Translation Divergences:A Formal Description and Proposed Solution".
Compu-tational Linguistics 20:597-634.Dunning, T. 1993.
"Accurate Methods for Statistics ofSurprise and Coincidence."
Computational Linguistics.19:61-74.Early, J.
1970.
"An Efficient Context-Free ParsingAlgorithm".
Communications of the ACM 14: 453-60.Gazdar, G., E. Klein, G.K. Pullum, and I.A.Sag.1985.
Generalised Phrase Structure Grammar.
Black-well, Oxford.Hinton, G.E., P. Dayan, B.J.
Frey and R.M.
Neal.1995.
"The 'Wake-Sleep' Algorithm for UnsupervisedNeural Networks".
Science 268:1158-1161.Hudson, R.A. 1984.
Word Grammar.
Blackwell, Ox-ford.Hirschman, L., M. Bates, D. Dahl, W. Fisher, J. Garo-folo, D. Pallett, K. Hunicke-Smith, P. Price, A. Rud-nicky, and E. Tzoukermann.
1993.
"Multi-Site DataCollection and Evaluation in Spoken Language Under-standing".
In Proceedings of the Human Language Tech-nology Workshop, Morgan Kaufmann, San Francisco,19-24.Isabelle, P. and E. Macklovitch.
1986.
"Transfer andMT Modularity", Eleventh International Conference onComputational Linguistics, Bonn, Germany, 115-117.Jackendoff, R.S.
1977.
X-bar Syntax: A Studyof Phrase Structure.
MIT Press, Cambridge, Mas-sachusetts.Jelinek, F., R.L.
Mercer and S. Roukos.
1992.
"Prin-ciples of Lexical Language Modeling for Speech Recog-nition".
In S. Furui and M.M.
Sondhi (eds.
), Advancesin Speech Signal Processing, Marcel Dekker, New York.Lafferty, J., D. Sleator and D. Temperley.
1992.
"Grammatical Trigrams: A Probabilistic Model of LinkGrammar".
In Proceedings of the 199P AAAI  Fall Sym-posium on Probabilistic Approaches to Natural Language,89-97.Kay, M. 1989.
"Head Driven Parsing".
In Proceed-ings of the Workshop on Parsing Technologies, Pitts-burg, 1989.Lindop, J. and 3.
Tsujii.
1991.
"Complex Transferin MT: A Survey of Examples".
Technical Report 91/5,Centre for Computational Linguistics, UMIST, Manch-ester, UK.Resnik, P. 1992.
"Probabilistic Tree-Adjoining Gram-mar as a Framework for Statistical Natural LanguageProcessing".
In Proceedings of COLING-9P, Nantes,France, 418-424.Sata, G. and O.
Stock.
1989.
"Head-Driven Bidi-rectional Parsing".
In Proceedings of the Workshop onParsing Technologies, Pittsburg, 1989.Schabes, Y.
1992.
"Stochastic Lexicalized Tree-Adjoining Grammars".
In Proceedings of COLING-9P,Nantes, France, 426-432.Whitelock, P.J.
1992.
"Shake-and-Bake Translation".Proceedings of COLING92, the International Conferenceon Computational Linguistics, Nantes, France.Younger, D. 1967.
Recognition and Parsing ofContext-Free Languages in Time n 3.
Information andControl, 10, 189-208.176
