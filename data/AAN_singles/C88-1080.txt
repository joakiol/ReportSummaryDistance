A PROCEss-AcTIVATION \]8~SF, D PARS~gl ~kL, GOR~'I-la~I~ORTIlE DEVELOPMENT OF \]NATURAL LANGIIAGIg G k ~Massimo MARINODepartment of lAnguisties -,University of \]~51saVia S. Maria 36 - 56100 Plsa -- ITALYElectronic Mall: MASSIMOM@ICNUCEVM.BITNETABST~CTA running system, named SAIL, for the developmentof Natural Language Grammars is described.
Stress Is puton the particular grammar ule model adopted, namedComplex Grammar Units, and on the parsing algorithmthat runs rules written In according to this model.Moreover, the parser is like a processor and sees grammarrules as processes which cart be activated or Inactivated,and eaxi handle exchange of information, structured as:messages, among rules for long distance analysis.
A briefdescription of the frmnework of SAIL a user can interactwith, neaned SiS, is also given.
Finally, an example showsthat different greanmar formalisms can be implementedinto the frame of SAIL.X o INTRODUCTIONMost recent research in the field of grammarIbrmalisms and parsers for natural language has seen thef lour ish ing of var ious  theoret ica l  as well ascoralmtational accounts, which, however, bring intoconsideration the same lacts.
The most relevant ones~,mem the following:-~ whatever representation is adopted for the structure ofthe parsed sentence (basically f-structures or trees), it isagreed that {complex) sets of features must describe thelinguistic units.
It is, therefore, necessary to providefeature handling mechanisms;long distance dependency, or, more generMly,dependency, requires a specific treatment, which Is to benaturally embedded in the theoretical or computationalmodel of syntax, and must  be subject to languagedependent constraints.
In aaly case, the treatment ofdependencies takes the form of a differently constrainedsearch Ibr a referent;- a certaln amount of context-sensitiveness is to beallowed in natural anguage parsing.As an additional feature of recent research, thel~mlinatlon towards the one-to-one correspondencebetween semantic and syntactic rules has to bementioned.SAIL Is the parsing algorithm of a developmentenvironment, called SAIL Interfacing System, wheredifferent grammars  corresponding to differentgrammatical theories can be hnplemented (/Marlno1988/ I .
Its basic features,  which allow fullimplementation f grmnmars and their debugging are aslbllows:a ,teh lmlguage for the handling of features;grammar ules are seen as processes which can beactivated or Inactivated, and can exchange messages;this mechanism allows a natural  treatment ofdependencies and the running of context-sensitive rules;the format of the rules Is such as to allow semanticprocessing in parallel with syntactic processing;the traditional structure of the parser, a bottomoupall-paths algorithm, allows relative efficiency mid the590ca W integration of a diagnostic omponent fi~w debugging;the development envirotJrnent is based on dllterentlayers of rules, which are processed by the same parserand can handle the external interface, the particularapplication, and the debugger.
This enables the user tomodify also the front-end of SAIL, by modifying tilecorresponding grammar.2.
TItN G ~ A R  RI\[1LN FONISNThe grammar rules are expres,~md ix-, a tbrmallsmcalled Complex Grammm Units g','.G.Uos) having thetbllowing BNF:CGD" ::=<Syntact ic-Rule> ::::<ProducUo~ ::=<LHS> ;;=<I~-IS> ::=<Synerests> ::=<S~\]n-ActIo~> ::=<Syn-Recovery-Actiorr~> ::=<Semantie~Rule> ::=<Sere:rests> ::=<Sem-Recov(,, y Actions> ::A<Syntactic-Rule> <Semantic-Rule><Prrnluetlon> <8yn-.Tests><Syn-Actlons><8yn-Recovery-Actions><LHS> <RHS>A non-ternmaal symbol of theg~mrim~'A pat*era st~lng of terminalarid/or non..termUral uymbolsBorne teats  on  the appl icabi l i ty ofttte syntactic aetimmArbitrary syntactic actionsSyntactic actions for the recoveryIn case of rmatch-ihfl or test-f-.dl<Sere-Tests> <Sere.Actions><SemoRecovery-Actions>Some te~t.~ on the applicability ofthe semantic rule/U'blhary semantic actiorLs"Semantic aetloIlg for the recoveryin case of match4all or test-fallIn.
each grmimlar rule the syntactic intexpretation isdirectly connected with the corresponding semanticinterpretation: hL this way the pea'ser processes in parallelboth interpretations.Inside the augmentations we can do several things:- the tests arc evaluated before the application of a ruleand through *hera we can check its applicability;- every node of the parsing structure contains tructuralinfbrmation about the part of sentence it covers; thisinformation is local to each node and is stored as afeature structure tree.
"l~e features are classicallystored as attribute-value pairs, with the possibili .ty thata value la itseff an attribute-value pair; several featurehandling functions are defined inside the system, so wecea~ use them with the augmentations to create, delete.test, get, copy and raise features;the semantic rule acts on the semantic part of thesystem, which can be, for example, a t~ handled by aknowledge representation language; tkfls side isdependent on the system application;- the  semantic actions are a sequence of semanticoperations, includkng the possibility of assigning :,tsemmatic value to the new node built by the ~:ule; Thesemant ;e  value ass igned to a node represents ,  Ingeneral, the mean ing  of tb.c" t)mt of the sentence thenode covers, accordh~g i(~ the chosen fonrmlism;?
the eye, tact ic and  se_manti.e recovery aet imm allowtdte~ rmt ive act ions ff the rule fails dur ing  the matehi~ gphase  or the test  checking,  so the rules need not  bem-udely rejected Mten  they fail;-- soirie bLdlt.4n system funct ions  are available: thesetools handle,  for example, the part icu lar  execut ion of arule, o, ,.nodlly tile pars ing  processing,  etc.
; these~ilecha:~iJ.sllks are discrtssed below.The product ion  in each n i le  Is classical ly represented asa Cmfi;c~_rt -lq:ee producttm,:  A- ~ w, w= _. w , ,  where A 1,.; ano~ ~ 4:~:~_utJn~d syt~llool al id  w~ wa ... w,, i s  a si~:lng of terminala tu l /o r  :ta~m.
te~miual symbols.The ~ ole,'~ of the grammm are  appl ied by the parser  hi  abot to ln - l t  i) 'w~ly: it ,';tin t,'~ f iom the sentence  and  build,~over  it the pars ing  sh  t lctnre as a graph.In our  system we Mso have a dh; t tonmy D. Each i temin the dict ionary is (:::filed a .~.
'ox',t.< We dlsLing~fish betweeuah~gle ?ox~ta l~d ~aut?itAe i'ox~as.
The first matehes  thege,mral concept  of ~, word; the second defines a nmlt l -word expxession of the language,  typically an  idiom.One or more in terpretat ions  are associated with eachtb~at and  they cons ist  of the syntact ic  categmy, these.mantie value and  a \[(~ature s t ructure .A sentence  is a con lpoL l l ld  of fonus.
For every set~temm f,fa...~ SUCh ttrat every tbrm i~ D, and a grammar  G definedin our  model we say that  f~ f,...f, is pa laab le  If we car~bui ld a sU'uc.tu,e lh rough a finite sequence of ruleapplleatirms, where at  least  one node covers the ent i reaentenee and its; category Is the root synibol of thegl~mnlna, ~Rule appllcation,~3 are performed by tt}.e pro'set in abottom-hi)  ,';tratep~ whez~eve~::a. at  leae;i: one sequence of nodes exists in the sh-ucturethe l)a>'scr has  been bui lding, match ing  the <RtIS>par t  of the rule;b. if' the above condit ion holds tile parser  verifies thetests  of the rule; if they ate veiif ied the n i le  is applied;c. if the match  fails, or the tests  are not  verified, then theparser  eKe.cures recovexy actions?~lt~e core appl icat ion o f t  CGU cons ists  in:d. bnl ld ing a new node cot.responding to the <I,I-IS> par tof the ~ ule;e. ass ign ing lcature,~.
; to the new trade by execut ing the~'~y~ffacl:ic action'.
; of the rule;f. exeent;h~g the semant ic  act ions of rile ni le,  andpossibl~, ass ign ing the semant le  value to the newnude.In the ibllowing we always rep~et;ent the product ion  In tiles tandard  way as above; the feature s t ruc tures  assoc iatedwl~:h a no0e of category w~ are represented  as \[\[~,1 and tilesemmtt lc  vahm as \[Iw,\]i,We.'
carl Sl),~cii ) tile complete process  of a rule appl icat ionby means  of a PASCAL-lithe s ta tement  as follows.Ne~4~eeover3ro.Aetlonst~dhq~J~~y~x-Ite c ovety -Aet lo~;~ ~e ,'~-lleeovea-~-Acllom~"llm ru les  are grouped in such  a way that  the parseraccesses to a restr icted number  of them,  i.e.
only thecurrent ly  appl icable ones, when it t~tes to apply SOlne.This is accompl i shed by part i t ion ing the ru les into~-meket~ d iscr iminated by the last: category in fire r ight-band side.
If a g rammar  is part i t ioned as t'~ ..... Pk then  forevery ld:,l ..... k, i:~l, we must  have tlmi.
I., r~ P~ ::: {}.
So whenthe parser  acee.s.~;es a packet  th rough the category of anode, thc rrdes In that  packet  are the tufty ones  al~l)lleableat that  momeut .Now let us  int roduce the coneepl  of Not  Operat ive/~:oflttet, tiOnu.In gene, ral such  product ions  do not  bui ld  a new node If oneof the three special  categories <NOP>,  <NOP-ASE>,<NOP-.SE> is the le f t -hand side.
A Not Operat iveProduct ion is one of the following:{ <NOP> I <NOP--ASE> I <NOP-SE> } - > v% % ... wRules ?with such  product ions  are ealled NOt- Rules.l )epend ing  on the NOP-eategoly used,  tile ruleappl iealton is performed i,~ a special was.A NOP rule wi th  <NOP> as lett-.hand side Is appl ied asfollows Jf lhe syrltaette tests  succeed: 1) no new node isl)uJlt; 2) only ihe syntact ic  rule is iakci~ into accoml t  bythe parser;  3) the semant ic  rule is never  considered.Therefore the appl icat ion of such  a rule iy.pc ia pe~ lbnnedas in the following PASCAL-like statemc~.l :iJ_' i~tch  ( w~ ..... wu, graph )Iben LfNyn-Test,a (\[it~l .
.
.
.
.
I!~,J )gloat Sy~t,,Recovery-Aetton~'.?
!f~Jt S y~141ec ore  ~-y.,Ae, t Ions;This k ind of NOP rule is usefu l  when we are interested ir~per forming modlf leat lons or par t i cu la r  consh-uct ions orana lyses  on features Inside a eet ia in  contexi  wi thoutbui ld ing a new node.
Such  a k ind  of NOr' rule is purelysyntact ic.in a producl~on with <NOP-ASE> a s le f t -hand side, ff bothsyutaet le  and  semant ic  tests  succeed:  1) no new node isbui lt;  2) the rule appl icat ion is preformed in the s tandm'dway?
irmlndiug feature hmadl lng if it does not  iovolve thenon--existent parent  node.In a product ion  with <NOP-.SE> as le f t -hand side, if oMyitic semant ic  tests succeed:  1) no new node is t)uilt', 2) onlythe semant ic  rule is taken  Into account  by the parser;  3)file syntac l le  rule is never  considered.
From thereonappl icat ion is the dua l  of that  defined for tim <NOP>category..!
( lVlal;ch ( v, l ..... w. graph )/* ~;c:.~:~'~q~ one o~ mo~c ,~clt; ~1" ~mdcs matching the <I:tIIS> */~;em.-'r~ata ( \[1%11 ..... \[\[wJl, SEM )/* :~;EM ie, presetllt; {he s;elnain'lc itlode\] */~'~a~td (A,,.% ..... %, J;/* build a **eve node A ovm the matched nodes */f~ls~q .i)eghL& R'( JLE~ AS  PROCESSESThe rtfles defined ill our  sys iem ~re viewed asproeesses  to be executed by the proset  which has  the roieo f i~e processor?
Aa a consequence,  a state is ass igned toeach rifle which is determined at the  moment  of g rammardel ln i | ion.
Rules can  assume two dif ferent ~tates: aet tveor i~xaefive state.
A rule is aettw.~ when the parsernormal ly  takes it into account  for appl icat ion;  ru les areacLivc when thei r  names  are in the i r  co l respond ingpackets.
A rule is inae, t tve  when the parser  does notnormal ly  take it into cons iderat ion  for appl icat ion;  rulesare inact ive when thei r  names  are not  in any  packet.It is possible to modify the state of a rule by memm of two39\]tunetions within the augmentations dining a ruleapplication.A rule R, changes its state from active to Inactive if somerule Rj calls within its augmentations the function i le-dtsable for R,, performing a disabling operation; on thetermination of the disabling rule R j, the disabled nilename R, is removed from the corresponding packet, andthe parser does not take into account R,, Conversely, arule l~ ehaazges its state from Inactive to active If some rulecalls the function ru le-enable for Ph within itsaugmentations, perlbrming an enabling operation.
Onthe termination of tlm enabling rule R r the enabled rulename R, becomes present into the corresponding packet.It Is possible to change the state of one or more rules ata time through these functions and the rules can performself-enabling and self:disabling operations.
Changes ofstate effected uring the parsing are not penuanent.
Atthe end of each parse the rules are reconfigured asindicated in their original definition.In addition we cruz invoke an inactive rule for just oneapplication from another ule.
We say that an inactiverule R~ is act ivated to be applied Just once, when a call tothe function r i f le-activation is in some augmentation ofanother ule R r The activation of an inactive rule R, allowsjust one application of it by the parser, immediately afterthe termination of the activating rule R r The state of theactivated rule Is not modified.
The activation of more thanone rule at a time Is possible, and once a rule ls activatedit can activate other rules,4o CONTEXTUAL RULESRule activation bymeans  of the rule-act lvat ionfunction, together with NOP rules can be used to handlecontext sensitive languages, However, rials is entirelydone by means  of CF product ions  and theaugmentations.A typical CS production is: ~h A p~ --~ p, 1~ ~h where p,,p~, 13 are strings Of symbols, and A is a non-terminalsymbol.
A bottom-up applieation of such a production ispossible lfit happens in two steps: 1) indlviduation of thecontext p~ I~ P~; the right-hand side must match asequence of sub-trees that covers 1~13 1~; 2} Inside thiscontext we can perform the api~lleaflon of the CFproduction A .-~ \[~ building the node A over the sequenceof nodes characterized by ~l.
So the complete applicationfor a CS production is made in two steps: the tlrst oneconcerns context determination, the context beingrepresented by the right-hand side of the CS production;the second step is just the application of a CF productionif and only if the first step has determined the contextwhere the CF production is applicable.
Theseconsiderations allow us to say that: step 1 can beperformed by the application ofa NOP rule using the NOP-special categories; in fact this kind of rule Is useful indetet~ining the context by defining a NOP rule withproduction:{ <NOP> I <NOP.-SE> I <NOP-ASE> } --> ~t, ~ bt2Step 2 can be performed by the application of an activatedrule; in fact, wizen the rule at step 1 determines thecontext it cart activate an inactive rule with a productionA--~13, indicating in the cMI to rule-act ivat ion the lastnode In the sequence ~.Now we can give the definition of contextual  nile.We say that a rule is contextual if it is a NOP rule withproduction:{<NOP> I <NOP-SE> \[ <NOP-ASE> } -~ w z ... wand inside the augmentations there is a rule activation of,gJ~g_~t one inactive rule which has a production:A --> w k wk.~ ... w~, 1 <_k.<_m~nAe VNu{<NOI~>,<NOP-SE>,<NOP-/LSE>}392where VN is the set of the non--terminal symbols of thegrammar.This definition allows a nesting of contextual xnules: In thctan activated rule can be a contextual rule itself, Inaddition, we can activate more than one rule at a time; inthis way we can access several contexts Inside a maincontext.We suggest a method to make possible asynchronousoperations, i.e., how two independent rules can interactwith each other in order to perform long distanceoperations.
All this is based on the fact that we must besure that a certain rule will be applied after mlother andthe earlier ule wants to communicate some informationto the other one, To this end we have adopted acommunication meeharflsm, that we call messagepa~alug, which Is not based on nmtehing as all thepreviously explained opexations, but on executing twobasic tasks: sending and receiving, The sending task isfirstly performed by the sending rule that sends amessage to a receiving rule; afterwards the receiving rulemust perlbrm the receiving task to receive the message,These two tasks are executed by the two rules at twoindependent thnes, i.e., when the rules are applied, In thefollowing we denote the sending rule as Rs and thereceiving rule as Rr, and we assume they are standardrules: so we denote with SN the node built by Rs mad withRN the node built by Pa ?.We state two different approaches for what a ~ i s :1) the rules access a global feature structure where theystore global features.
Each role can access this structureand whatever feature value In It; 2) a Message-Box existswhere a rule can send a message to another specified rule.
"l~e Message-Box is accessible from every rule but themessages are accessible only by receiving rules.
Amessage iscomposed as follows: a reference to the teaturestructure of SN: Rs makes avafiable its feature structureto Rr; a sequence of operations, possibly empty, that Rr~-o.ust execute.It Is not necessm3r that both these Items m'e present inamessage,In the case of the global feature structure all the ruleshave access to It.
We recall that all the feature structuresIncluded Ill the nodes of the graph are local to their ownnode, Each rule earl store in or get from the globalstructure features that are global for the sentence: thenthe messages are feature structures and the same type ofoIJerations allowed on the feature structures of the nodesof the graph Is possible on this sta~aetureoThe Message-Box Is a structure referred to by all rulesthat want to send or receive messages.
A rule Rs, buildingthe node 8N.
sends a message which is automaticallyinserted In the Message-Box specifying: Its name Rs, thereceiving rule Rr, a reference to the feature structure of SNwhich is made available to Rr, a list of operations, possiblyempty, to be perlbrmed by Rr.
Until the messages are sent,they are the exclusive property of Rs.
Wizen they are sentRs loses Its property, rights, and only the rule Rr specifiedIn the messages i authorized to get them.
In addition, Rrfinds In the message a reference to a feature structure ~mdthis structure is available only to It and always local to itsown node.Message passing, In either of the two realizations, is away to facilitate the tndlviduation and treatment ofexisting relations among phrases or parts of them.
It iscertainly flexible and not expensive because It avoidssearches, i e., matches, Inside the graph, and it can be avalid alternative to NOP rules that require a certainnumber of matches to find particular nodes In the graph.In fact, if there was not  over lapping of the  sub--trees rootedIn SN and  RN, thenwe can  solve re lat ions between SN andRN by apply ing a proper  NOP rule, but ,  more efficiently,message  pass ing  al lows us  to avoid a cer ta incomputat iona l  overhead per ibnn ing  proper  operat ionsdirectly in Iks and  Rx.When NOP rules are appl ied they act  upon  a s t ruc turea l ready built .
It Is also possible to act ivate i~ales thatpertbl-m fur ther  bu i ld ing (contextual  rules) and/orteatur ing operat ions with in  a context.
This  process  ofact ivat ion can  be nested  many t imes ins ide a certa ins t ructure ,  This  analys is  per /orms a k ind  of operat ion thatis virtual ly directed toward the bottom,  in depth.
If therewas a part ia l  or total  over lapping between the sub- t reesrooted In SN and  RN, then  - In th is  case .- when iLs sendsa message;, assuraes  that  Rr will be appl ied above its nodeSN; in thkl way it Is poss ib le  to eva luate  the consequencesof certa in  operat ions on a s t ruc ture  wh ich  Is not  yet butIt could be but t .
In th is  case we act  toward the top of thepars ing  s lxueture,  th rough as many levels as we want,  Incontrast ,  us ing  NOP rules,  we only act  on an  exist ings t ructure  represent ing  deeper  levels.So we can  d is t ingu ish  two ways of operat ion for longd is tance analys is  araong phrases  or par ts  of them:breadth  ;malysls, us ing  both  NOP ru les  or messagepass ing;  depth  analys is  wh ich  can  be top-down with NOPru les  or bot tom-up wi th  message pass ing.The mechan ism of the  messages  so descr ibed isperformed through funct ions  that  can  be used  with in  theaugmentat ions .6?
T I -~ P,,~RSEROur  parser  is a CF-based one, derived from the ICA(inmledia~:e Const i tuent  Analysis) a lgor i thm descr ibed in/Gx ishman 1976/ ,  designed to run  CGU rules,  carry ingout  the syntact ic  and  semant ic  ana lys is  In parallel.
It isa bot tom-up algorithm, a~nd it per forms left-toorlghtscann ing  and  reduct ion in an  Immediate  const i tuentanalysis .
The data  s t ruc ture  It works  on is a graph  whereall possible parse  trees are connected.
The complete parseh'ee(s) is (are) extracted from the graph  in a subsequentstep, Therefore, the parser  Is also able to create s t ruc turefragment,~ for i l l -formed sentences,  thus  return ing ,  evenin ti l ls ca;~e, part ia l  analyses.
This  Is part icu lar ly  usefulfor diagnosis and  debugghlg.Pars ing te.rmination occurs  In a natura l  way, when nomore rule can  be appl ied and  the input  str ing iscompletely scanned,Before enter ing the parser  a preprocessor  scans  thesentence  fi'om left to ~ght,  performs the d ict ionary look-up  tbr each form in the Input  str ing, and  re turns  as t ructure ,  tile preprocessed sentence,  wi th  the  syntact icand  semant ic  In format ion taken  from the dict ionary.The graph  Is composed of nodes:  the nodes  can beei ther  termina ls  or non- termln~s .
Termina l  nodes  arebui l t  in co:a'espondence to a scanned form, whereas  non-termina l  ones arc bui l t  whenever  a rule is applied,obviously the rule must  not  be a NOP rule.As s tated above the parser  is seen as a processor  aridIt sees the ru les as  processes,  It hand les  a queue ofw~t ing  processes / ru les  to be executed.
When the parsertakes  a packet,  for every rule it bu i lds  a process  descr iptorand  Insexts it in the queue.
We call such  a processdescr iptor  an  app l i ca t ion  spec i f i ca t ion  (AS), while thequeue is c~dlcd the app l i ca t ion  spec i f i ca t ions  Hst  (ASL),ASs are composed of:a node identif ier, th rough th is  node the parser  s tar tsfl'ie ntatching;the nmne of the rule that  the parser  will apply;- only in the case of an  AS of an  act ivated rule th is  I temis the  context  where  the nmned act ivated rule will beapplied, l.e.
the  nodes  that  matched the r ight -hand sideof the  act ivat ing rule, otherwise th is  i tem is left empty.ASs in ASL are ordered depend ing  upon the ruleinvolved in an  AS.
In general ,  ff stm~dard active rules haveto be executed,  ASL is hand led  wi th  a LIFO policy.
If wecons ider  the case of NOP rules?
then  these ru les must  beordered before the others,  s ince featm'e modif icat ionsthey may produce can  ser~e as input  to other  ru les of thesame packet,  wh ich  are appl ied after  them..4.n Inactiverule can  be act ivated Jus t  ibr  one appl icat ion by means  ofru le -ac t ivat ion  t rac t ion :  the  act ivated rules must  beappl ied immediate ly  a l ter  the  end  of the  act ivat ing rule.
Soth is  k ind of ru les  has  the h ighest  pr ior ity of execut ion withrespect  o NOP ru les  and  s "tandard active rules.
Then  xalle-ac t ivat ion  inser ts  an  ac t ivat ion  ~pect / tea~lo~ on thetop of/KSL for the  act ivated rule.
Sunamarlz lng, the ro leshave the tbllowing decreas ing  prior ity order of execution:1) act ivated rules;  2) active NOP rules;  3) s tandard  activerules,Once a node  is created,  be it te rmina l  (incor respondence  to a scar ined tbrm) or non~terminal  (ineon 'espondence  to a reduct ion),  the parser  inser ts  In theASL an  AS for every rule in the packet  corresponding tothe categoxy of the new created node: i.e.
the new node Istile one specif ied In every inser ted  AS, The parserper forms all poss ib le reduct ions  bu i ld ing more than  onenode if possible, extract ing one AS at  a t ime beforeanalyz ing the next  one.
After ml AS ls extracted tom theASL, the parser  gets file specif ied rule: the first step is tomatch  the r ight -hand side on  the graph.
The nodesmatch ing  a r ight -hand side are searched by the matcher :It re turns  one or more sets  of these  nodes,  calledreduct ion  sets .
For every reduct ion  set, the appl icat ionof the  cur rent  rule is h-led.
In th is  way we can  connecttogether  all poss ib le parses  for a sentence  in a un iques t ructure .
Terminat ion  occurs  when the ASL is e~.npty andthe  preprocessed  s t r ing  is complete ly  scanned.Afterwards the parser  re turns  the graph,  kom which  ~1parse  trees sat is i~ing the tbllowing condi t ions  areextracted: a node covers the ent i re sentence  and  Itscategory Is the root symbol  of the grmnmar .
Here is thecomplete a lgor i thm of the  parser :* Until the end of tile sentence ts not reached:, Scan atorm:* Ill,lid a new ternmml xmde for the scanned tbxm;~ interpretation f the node:o g.~ the packet corresponding to Its categoi T and for everyrule In the packet ~ tile AS In the ASL ;F_Qr~ AS in the ASL:* gt?
the first AS from the top of the ASL;* ggi the specified rule kl tile AS, it Is the current rule, andaccess to the node specified in the AS, it is tim emxent node;* starting from the cun~nt node perform tile match on thegraph using tile production of the current rule;i_f at least one reduction set is found hlh.c_r_l:?
F r_~K._C~YC,~t reduction set:- Apply the current rule;o If a new non-terminal node is butt  ~ gtk thecorresponding packet to its category and for every rulein it ~ the AS in the ASL;.
?g.~: o Apply recovery actions of the current rule;In th is  a lgor i thm by match  we mean the operat ion ofsearch ing  the reduct ion  sets  and  by  'apply  the cur rentrule'  we mean the s tandard  rule appl icat ion s tar t ing  fromtile test  check ing as  s ta ted  for the  CGU model;  part icu larways of appl icat ion,  e,g, NOP rules,  depend on thepar t icu lar  ule definit ion.7.
AN EXAMPLEThe example concerns a simple fragment of a LFGwritten in SAIL according to the CGU model, Our exampleis taken f rom/Kap lan  1982/and/Winograd  1983/.The lexical entries for this grammar in SAIL are thefollowing:a {(Determiner NIL (Definiteness) (Indefinite){Number) (singular)))baby ((Noun NIL (Number) (Singular)(Predicate) {Baby)}}girl {(Noun NIL {Number} (Singular}(Predicate) {Girl)l}handed ((Verb NIL (Tense) (Past)(Predicate) (Hand)))the ((Determiner NIL (Definiteness) {Definite)))toys ((Noun NIL (Number) (Plural}(Predicate) (Toys)))Rules in SAIL are written using a def~ttle format whereall the fields appearing in the CGUs can be defined; inaddit ion two fields are devoted to the state definition(STATUS field) and the rule type definition, that  is ff therule is a standard rule or a contextual  or a NOP rule(CNTXTLORNOPR field).
The rules are the following:(defrule NPRule ; NP --> Determiner Noun(STATUS active)(CNTXTLORNOPR NIL)(PRODUCTION (NP (Determiner Noun)))(SYN-TESTS T)(SEM-TESTS T)(SYN-ACTIONS(ralsef "(* DefiniteneSS Determiner);raise the values of the specified features from the;son node into the parent node"(* * Noun)l}}; second *means all features of the son node;first * means the storing of the features as they are;in the son node into the parent node(defrule VPRule ; VP --> Verb NP NP(STATUS active)(CNTXTLORN OPR NIL)(PRODUCTION (Via (Verb NP NP)))(SYN-TESTS T)(SEM-TESTS T)(SYN-ACTIONS{raiser "(* * Verb) ;all features of the Verb node are;copied in the parent node((Object Definiteness) Definiteness NP) ;lst NP"((Object Number) Number NP)"((Object Predicate} Predicate NP)"((Object-2 Definiteness) Definiteness NP 2} ;2nd NP"((Object-2 Number} Number NP 2)"((Object-2 Predicate) Predicate NP 2)}))(defrule TOPRule ; S --->NP VP(STATUS active}(CNTXTLORNOPR NIL)(PRODUCTION (S (NP VP)))(SYN-TESTS T)(SEM-TESTS T)(SYN-ACTIONS{ralaef "({Subject Definiteness) Definiteness NP)"({Subject Number) Number NP)"{(Subject Predicate} Predicate NP)"{* * vP}})\[SEM-ACTIONS{put-sem-val ;stores the EVALuation of the following;expression as the semantic value of the;parent node S39g(append (getf-pn "Predicate){getf-pn "{Subject Predicatel}(getl-pn "(Object Predicate))(getf-pn "(Object-2 Predicate)))))); getf-pn gets feature values from the parent nodeThe graph bui lt  by the parser  applying these rules to thesentence 'a gir l  handed the  baby  the  toys '  is equivalentto the e-structure bui l t  by the corresponding LFG asshown in /Wlnograd  1983/ .
The top node S contains thefollowing feature structure:" -Definiteness : Indefiniteq-Subject : Nmnber Singular |Predicate Girl ._!Object : \[ DefiniteneSSpredicateNUmber ::: BabySlngularDeftnite\]Object-2 : |F NumberDefiniteness : PluralDefinite \]L P~edicate ToysTerme : PastPredicate : Handwith the semantic  value: (Hand Girl Baby Toys),Compar ing the  solution of the LFG version with thefeature structure and the semant ic  value of the SAILversion we have that  the LFG solution is equivalent to theabove feature structure p lus  the semant ic  value.8.
THE SAIL INTERFACING SYSTEMThe SAIL Interfacing System (S.I.S.)
is the f rameworkwhere a user  can interact with SAIL in developing NLapplications.
In fact SIS is organized in Interface Levels(I.L.s): in SIS we commonly  speak of Interface LevelApplications (I.L.A.s) which are the associat ion of an ILwith a grammar.If IL-Name is the name of an IL, and G-Name is the nameof a g rammar  which defines a part icular  languagethrough a dict ionary and a set of CGU rules, then the pair<IL-Name, G-Name> defines an 1LA inside the SIS: thisapplication is a task performed by that  part icular  IL.In this way the development envi ronment  is based ondifferent layers of rules, which are processed by the sameparser and can handle the external Interface, thepart icular application, and any request  issued by theuser.
In fact, the grammar  of an ILA defines a languagewhich can be used by the user  for sending to the systemhis requests o that  are caught  by the pars ing system andimmediately satisfied.SIS is s t ructured in 2 main ILs: the Kenael InterfaceLevel (K.I.L.)
and the Natural  Language IL (N.L.I.L).When the system runs  only two ILAs are active andavailable to the user: the KIL, associated to the KernelGrammar  (K.G.)
and the Current  Running Interface Level(C.R.I.L.).
The KIL is always aetive because it is the coreILA of SIS and Its purpose Is to handle the overall system,so when the system Is started the user  is introduced to theKernel Interface Level.
The Kernel Grammar  is a semant icg rammar  associated with the KIL and defines a kernellanguage of commands  and through them the user  canuse all the functional ity of the system such as grammarbuilding, parse checking, running other lI.As.When SAIL starts up, the KIL is also the CRIL, but  whenthe user  wants  to load as CRIL another  ILA defined In thesystem, for example a NLIL application, then a KILcommand allows this and NLIL becomes the CRIL byloading a grammar associated to the NLIL: in this way theCRIL is updated to the new application and the loadedgrammal becomes the current rumllng grammar.A subset of KIL commands defines a language throughwhich the user can e ~ e  the parsing structuresgenerated by the parser for all the sentences input untilthat moment.
This tool, named ANAPAR (ANAlysis ofPARsing), is useful for the grammar and parse checkingin deveh)ping NL applications,Finally, we want to point out that the particular structuregiven to ~IS enables the user to modify the front-end toSAIL by n mdifying the corresponding grammar of the KIL;in fact, all the files involved in their definition areaccessible to the user who can modify those files as hewishes, or extend the language by introducing newgramma~ rules.CONCLUSIONSThe example has  shown the possibi l i ty ofimplementing different grammar formalisms into theframe of SAIL and also the searching of standardprocedures for building grammars in the CGU modelstarting feom Categorial Grammars is planned,An exper imental  component  has also beenimplemented, which performs some diagnosis of ill-formed input, and confirmed that the chosen parsingalgorithm easily supports uch a component.A fuU evaluation of some of the described mechanisms(such as message passing) has not been carried yet, asapplication to real linguistic ases has not been designed,but theoretically.However, a whole view of the system, and thedescribed example show that SAIL is a valuable tool forthe development of concrete grammars, even of largecoverage.The whole system described in this paper is currentlyimplemented in Common Lisp and runs on Sun andOrion wockstations.
"ITils work has been carried out within the frameworkof the ESPRIT Project P527 CFID (ConmmnlcationFailure in Dialogue: Techniques for Detection andRepair).ACKNOWLEDGMENTSThe author is thankful to Giaeomo Ferrari and IrlnaProdanof or their helpful support.
The author is alsograteful to Ronan Reilly who read the draft of the paper.~FERENCES/Aho 1972/Aho, A. E. and UIlman, J.  D. (1972).
Thetheory of parsing, translation andcompi l ing.
Vol I :  Parsing.
Prentice-HallInc./Gr ishman 1976/Grishman, R. (1976).
A survey ofsyntactic analysis procedures for naturallanguage.
AJCL, Microfiches 47, pp.
2-96./Kaplan 1982/ Kaplan, R. and Bresnan, J.
(1982).Lexical-Functional Grannnar: A FormalSystem for Grammatical Representation.
InThe Mental  Representat ion  ofGrammatical Relations, Bresnan, J, Ed.Cambridge, MA: MIT Press, pp.173-281./Marino 1987a/ Marino, M., Spiezio, A., Ferrari, G. andProdanof, I. SAIL: a natural  languageinterface for the building of and interactingwith knowledge bases.
In Proceedings ofthe 2nd International Conference onArtificial Intelligence: Methodology,Systems and Application9 (AIMSA '86)?Varna, Bulgaria, 1986, Jon'and, P. toldSgurev, V., Eds.
North-Holland, 1987, pp.349-356./Marlno 1987b/ Marino, M., Splezlo, A., Ferrari, G. andProdanof, I.
An efficient context-free parserfor augmented phrase-structure grammars.In Proceedings of 1987 ACL EuropeConference, Copenhagen, Denmark, 1987./Marino 1988/ Mar ino,  M. {1988).
The SAILInterfacing System: a Framework for theDeve lopment  of Natura l  LanguageGrannnars and Applications.
TechnicalReport DL-NLP-1988-1, Department ofLinguistics, University of Pisa, Italy./Robinson 1980/Robinson,  J., J, (1980).
Interpretingnatural- language utterances in dialoguesabout tasks.
Teehn.
Note 210, SRIInternational, Menlo Park, CA,/Robinson 1982/Robinson,  J., J .
(1982).
DIAGRAIVI: Agrammar for dialogues.
CACM, 25, 1, pp.
27-47./Winograd 1983/Winograd, T. (1983).
Lauguage as aCognit ive Process.
Vol.
l: Syx~tax.Addison-Wesley.395
