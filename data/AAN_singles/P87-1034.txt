REVISED GENERAL IZED PHRASE STRUCTURE GRAMMAREr ic  Sven  R ls tad  1M.I.T.
Artificial Intelligence Lab545 Technology Square, 805Cambridge, MA 02139Thinking Machines Corporat ion245 First StreetCambridge, MA 02142ABSTRACTIn this paper, I revise generalized phrase structure grammar(GPSG) linguistic theory so that  it is more tractable and linguis-tically constrained.
Revised GPSG is also easier to understand,use, and implement.
I provide an account of topicalization, ex-plicative pronouns, and parasitic gaps in the revised system andconclude with suggestions for efficient parser design.1 Introduction and MotivationA linguistic theory specifies a computational process that assignsstructural descriptions to utterances.
This process requires cer-tain computational resources, such as time or space.
In a descrip-tively adequate linguistic theory, the computational resourcesavailable to the theory match those used by the ideal speaker-hearer.
The goal of this paper is to revise generalized phrasestructure grammar (GPSG) so that its computational power cor-responds to the ability of the speaker-hearer.The bulk of this paper is devoted to identifying what com-putational resources are used by GPSG theory, and decidingwhether they are linguistically necessary.
GPSG contains fiveformal devices, each of which provides the theory with the re-sources to model some linguistic phenomenon or ability.
I iden-tify those aspects of each device that cause intractability and thenrestrict the computational power of each device to more closelymatch the (inherent) complexity of the phenomenon or abilityit models.
The remainder of the paper presents the new formalsystem and exercises it in the domain of topicalization, explica-tive pronouns, and parasitic gaps.
I conclude with suggestionsfor efficient parser design and future research.In my opinion, the primary value of this work lies in the re-sult (revised GPSG,  or RGPSG)  as well as in the methodologyof using complexity analysis to improve linguistic theories.
Themethodology explicates how a tool of modern computer sciencecan help us understand and improve theories of linguistic compe-tence.
More than that, complexity analysis forms the foundationof informed parser design.
I feel RGPSG is of value both to lin-guists and computational linguists because it is more tractableand easier to understand, use, and implement.
It can be effi-ciently implemented and appears to have better empirical cover-age than its GPSG ancestor.tThe author is eupported by a graduate f llowship from the IBM Corpora-tion.
This research was supported in part by Thinking Machines Corporationand by NSF Grant DCR-85552543, under a Presidential Young InvestigatorAward to Profeuor Robert C. Berwick.
I wish to thank Ed Barton forstylistic improvements and helpful discussion; Robert Berwick for support,critickm, and suggesting I pursue thk research; and Geoff Pullum for hispatient help with GPSG theory.2 El iminat ing Intractabi l i ty in GPSGRistad (1986a) examines the computational complexity of twocomponents of the GPSG formal system (metarules and the fea-ture system) and shows how each of these systems can lead tocomputational intractability.
Rlstad also proves that the uni-versal recognition problem for GPSGs  is EXP-POLY  hard, andintractable.
2 In another words, the fastest recognition algorithmfor GPSGs  can take more than exponential time.These results may appear surprising, given GPSG's  weakcontext-fres generative power.
They also raise some importantcomputational and linguistic questions: why GPSG-Recognitionis so difficult, what aspects of the GPSG formalisms cause in-tractability, and whether they are linguistically necessary.
I be-gin with an outline of the GPSG formal system, as presented inGazdar, Klein, Pullum, and Sag (1985), GKPS hereafter.
Sub-sequently, I identify and remove the excess computational powerprovided by each formal device.2.1  Overv iew o f  GPSG Formal i smsFrom the perspective of classic formal language theory, a GPSGmay be thought  of as a g rammar  for generating a context-freegrammar.
The generation process begins with immediate dom-inance (ID) rules, which are context-free productions with un-ordered r ight-hand sides.
An important  feature of ID rules is thatnonterminals in the rules are not atomic symbols (for example,NP).
Rather,  GPSG nonterminals are sets of \[.feature, feature-value\]pairs.
For example, IN +\] is a \[feature, feature-value\] pair, andthe set { IN ?\], IV - \ ] ,  \[BAR 2\] } is the GPSG representation ofa noun phrase.
Next, metarules apply to the ID rules, resultingin an enlarged set of ID rules.
Metarules have fixed input andoutput  patterns containing a dist inguished mult iset variable Win addition to constants.
If an ID rule matches the input patternunder some specialization of the variable W, then the metarulegenerates an ID rule corresponding to the metarule's output  pat-tern under the same specialization of W. For example, the passivemetaruleVP ~ W, NP?
~.
(1)VPIPAs\] ---* W, (PP Iby \ ] )says that "for every ID rule in the grammar  which permits a VPto dominate an NP and some other material, there is also a rule2The universal recognition problem most accurately reflectg the difficultyof processing a grammatical formalism because it incorporates the gr-4m-mar in the problem statement, as explained in Barton, Berwick, and Ristad(x987).243in the grammar which permits the passive category VP \[PAS\] todominate just the other material from the original rule, together(optionally) with a PP\[by\] ~ (GKPS:59).
In Ristad (1986a), thefinite closure problem is used to determine the cost of metaruleapplication.
Principles of universal feature instantiation (UFI)apply to the resulting enlarged set of ID rules, defining a set ofphrase structure trees of depth one (local trees).
One principle ofUFI is the head feature convention, which ensures that phrasesare projected from lexical heads.
Informally, the head featureconvention is GPSG's  ~-theory.
Ristad (1986a) uses the eatego~jmem~ersA~p problem to determine, in part, the cost of mappingI'D rules to local trees.
Finally, linear precedence statements areapplied to the inst~ntiated local trees.
LP statements order theunordered aughters in the instantiated local trees.
The ulti-mate result, therefore, is a set of ordered local trees, and theseare equivalent to the context-free productions in a context-freegrammar.
The resulting context-fres grammar derives the lan-guage of the GPSG.The process of assigning structural descriptions toutterancesconsists of two steps in GPSG: the projection of ID rules to localtrees and the derivation of utterances from nonterminals, usingthe local trees.
Accordingly, formal devices may supply resourcesto either process.2.2 Theory  of Syntact ic  FeaturesIn current GPSG theory, syntactic ategories (nonterminals) en-code linguistic relations as feature-value pairs.
If a relation istrue of two categories in a phrase structure tree, then the rela-tion will be encoded in every category on the unique path be-tween the two categories.
The primary computational resourceprovided by the theory of syntactic features is polynomial space,primarily due to the large number of possible syntactic categoriesarising from finite feature closure.
Ristad (1986a) observes thatfinite feature closure admits a surprisingly large number of pos-sible categories: 9(36"bT) where a is the number of atomic-valuedfeatures and b the number of category-valued features.
In fact,there are more that 107:~ categories in the GKPS system.Fortunately, the full power of embedded categories does notappear to be linguistically necessary because no category-valuedfeature need ever contain another, s In GPSG,  there are threecategory-valued features: SLASH, which marks the path betweena gap and its filler with the category of the filler; AGR, whichmarks the path between an argument and the functor that syn-tactically agrees with it (between the subject and matrix verb, forexample); and WH, which marks the path between a ~#h-word andthe minimal clause that contains it with the morphological typeof the ~h-word.
AGR will never contain SLASH because a functor(verb or predicate) will never select a gap or a constituent con-taining a gap as it's argument.
Conversely, SLASH will never berequired to contain AGR because such a category corresponds to%he following imaginary (and rather weird) case: Suppose wefound a language in which finite verb phrases could be frontedover an unbounded domain provided that they were in the agree-ment form associated with third-person-singular NP  controllers"(PuUum, personal communication).
Similarly, because the valueof ~ is the category of a wh- noun phrase, and because ~#~- nom-sLet f and g be any distinct category-valued f atures.
I am arguing thatalthough f may ~ppear inside g in some L~nguage, f will never be reqm'regtoappear inside g.inals never contain gaps, WH can never contain SLASH or AGR.
Inpoint of fact, no category embeddings appear in the GKPS gram-mar for English, and it is difficult to see how they would appearin a GPSG for any other natural language.The obvious revision, then, is unit feature closure: to limitcategory-valued features to containing only O-level categories.
(0-level categories do not contain any category-valued features).
Iadopt this strongly falsifiable constraint in RGPSG.
The depthof category-embedding is purely an empirical issue, and henceunit closure is not ad hoe.
The other revision is primarily no-tational: any RGPSG feature f may assume the distinguishedvalues noBind or unbound in addition to those values determinedby p(f).
A noBSnd value indicates that the feature may not re-ceive a value in an extension of the given category, while unboundindicates that the feature does not currently have a value, andmay receive one in extension.2.3 Immediate  Dominance/L inear  P recedenceGPSG's  ID/LP format models certain word order phenomena,such as the head parameter and some free word order facts.
AnID rule is a context-free productionCo -'* CI,C2 .... ,C~whose left-hand side (LHS) is the mother category and whoseright-hand side (RHS) is an unordered multlset of daughter cate-gories, some of which may be designated as head daughters.
TheLHS immediately dominates the unordered RHS in a tree of depthone (a local tree).2.3.1 Complex i ty  in ID /LPID rules significantly increase the time resources available to theGPSG derivation process in four related ways.
First, a deriva-tion step is nondeterm/nistlc because a category may immediatelydominate more than one RHS.
Second, the derivation processmay alternate between a derivation step involving the ID rulesC --~ Ct \[ ...
I C~ that corresponds to an OR-transition (onlyone of k possible successors must yield a terminal string) anda derivation step involving an ID rule C ~ CI,C2,... ,Ce thatcorresponds to an AND-transition (all k successors must yieldterminal strings).
These two devices introduce lexical and struc-tural ambiguity.
As is well-known, ambiguity is a central prop-erty of natural languages.
Therefore, I consider this aspect of IDrules linguistically essential, and it will be retained in RGPSG.Third, unrestricted null transitions in ID rules are a source ofintractability because they allow GPSGs  to generate enormousphrase structure trees whose yield is the empty string (see Ristad,1986a).
Thus, a parser that used such a grammar must nonde-terministically postulate elaborate phrase structure in betweenits input tokens.
The indisputable unnaturalness of this abilitymotivates me to greatly restrict null transitions in RGPSG.Fourth, the multiset RHS of an ID rule contributes to a largespace of local phrase structure trees: an ID rule with s a RHS ofcardinality b can, if unconstrained by LP statements, correspondto b!
ordered productions.
In parsing practice, this can causea combinatorial explosion in a context-free parser's state space(see Barton, 1985).
In addition to causing nondeterrninism in244any GPSG-based parser, the multiset RHS confers on GPSG theability to count nonterminals.
The apparent artificiality of thisdevice, as discussed in Barton, Berwick, and Ristad (1987:260-261), will motivate me to adopt a substantive constraint of shortID rules in RGPSG (binary branching, for example).
42.3.2 Rev ised  ID /LPRGPSG ID rules have exactly one mother and at least one headdaughter.
The heads are separated notationally from the non-heads by a colon, and appear to the left of the colon.
The motherand all head daughters are implicitly specified for \[NULL - \ ] .
Forexample, the RGPSG headed ID rule 2 corresponds to the GPSGID rule 3.ve  -- ,  \[SUBCAT 2\] : 5'e (2)Ve\[NULL -\] --* H\[SUBCAT 2.NULL -\],N,q (3)There is only one lexical element for the null string, and it isuniversal across all grammars:X2 \[SLASH X,~I, NULL +\] l ""*Co-subscripting indicates that the two X,~ categories must beidentical in any legal projection of the rule, with the exception ofthe \[NULL ?\] and SLASH specifications.
This restricted ID ruleformat, when coupled with a restriction on metarules that pre-vents them from affecting head daughters, prevents head daugh-ters from ever being erased in a RGPSG derivation.
Thus, nulltransitions are effectively eliminated from RGPSG.An ordered production is an ID rule whose daughters are com-pletely linearly ordered, that is, a string of daughter categoriesrather than multisets of head and nonhead daughters.
An  or-dered production is LP-occeptable if all LP  statements in theRGPSG are true of it.The RGPSG ID/LP formalism does not contain formal con-straints sufficient to guarantee polynomial-time recognition, al-though the linguistically justified use of short ID rules can renderID rules tractable, because ID/LP grammars with bounded rulescan be parsed in time polynomial in the grammar si~.e, s2.4 Metaru lesMetarules are lexical redundancy rules.
Formally, they are func-tions that take le=ical ID rules--ID rules with a lexical head--to'The binary branching constraint is independently motivated by the lln-guistic arguments of Kayne (1981) und others.
In that work, Kayne arguesthat the pnth from a governed category to its governor (for example, froman anaphor to its antecedent) must be unamblguou~--informally put, "anunambiguous path is a path such that, in tracing it out, one is never forcedto m~.ke a choice between two (or more) unused branches, both pointing inthe same direction" (Kayne 1981:146).
The unambiguous path requirementsharply constrains fan-out in phra~ structure trees because n-ary branching,for n > 2, is only possible when none of the rt sister nodes must govern anyother nodes in the phrase structure tree.s~ the length bound for natural language graznmars is the constant b, thenany \]I)/LP grammar G cffin be converted into a strongly-equivalent CFG G ~,of sise 0(IG I .
b!)
= $(IGI) by simply expanding out the constant number oflinear precedence po~ibilitlee.
In the GKP$ and RGPSG grammars for En-glish, b = 3 becau~ double object constrnctions (\[g/us NP NP\], for example)are atmigued a fiat, ternary branching structure.
(I ignore the iterating coor-dination schema, which licenses rules with unbounded right-hand sides.)
Itis important, however, that the short rules reflect a genuine constraint andthat the grammar does not use some other mechanism to get the effect oflonger ules (feature instantiation, for example).sets of lexical ID rules.
See the GKPS passive metarule above.The GKPS grammar for English also includes metarules for subject-aux inversion, extrapusition, and transitivity alternations.
Thecomplete set of ID rules in a GPSG is the maximal set that canbe arrived at by taking each metarule and applying it to the setof rules that did not themselves arise from the application of thatmetarule.
This maximal set is called the finite closure FC(M, R)of a set R of lexical ID rules under a set At f of metarules.2.4.1 Complex i ty  of  Metaru lesMetarules can increase the time and space resources available tothe derivation process by introducing null transitions and ambi-guity in ID rules and by increasing the space of ID rules morethan exponentially.
They can also increase the cost of the projec-tion process itself: finite closure is nondeterministic (NP-hard, infact) because metsrules are applied to ID rules nondeterministi-cally.2.4.2 Rev ised  Metaru lesUnrestricted null transitions are both linguistically and computa-tionally undesirable.
Moreover, the ability of metarules to affectlexicai head daughters is in direct conflict with their linguisticpurpose: ato express generalizations about the subcategorizationpossibilities of lexical heads, n (GKPS:59) Unrestricted metarulescan destroy the relation between a phrase and its lexicai head,and thereby violate ~-theory.
The first step in revising recta-rules is to restrict hem to on/y affect nonhead aughters in lexicalID rules.
Because of this change, metarules cannot alter the im-plicit \[NULL o\] specification on the head daughters.
Therefore,once a category is expanded in a derivation, it must be lexlcal\]yrealized in the derived string.
This formal constraint ensuresthat the empty string does not have elaborate phrase structurein RGPSG.Metarule finite closure generates many linguistically incorrectID rules that must be excluded by other GPSG devices (FCRs,for example).
The GKPS grammar for English contains ix meta-rules; out of approximately 1944 possible metarule interactionsin principle, only two such interactions appear to be productive(passive followed by subject-aux inversion or slash terminationmetarule 1).6 Therefore, the second metarule restriction adoptedby RGPSG is biclosure, instead of  finite closure, rSGiven a set of ,~ metarules, the number of possible metarule interactionsis the number of ways to pick n or less metarules from the set, where ordermatters and repetitions are not allowed.
That number is given by the totalnumber of possible koeslections from the a metarules, where k v-4ries from 0(no metarnles apply) to ~ (any combination of all metaruies apply).
Thus,the number  of possible interact ions j'(n) is: ~-~:o  (b--,)l ~ b!-e).
This k notthe size of metarule finite closure, because it does not consider the pouib i l l tyof a metarnle matching an I'D rule in more than one wuy.TMetarule biclosure does not overgenerate asbadly as finite closure, andthereby promotes descriptive adequacy at the expense of some explanatorypower.
Biclosure has an edge in descriptive conomy (explanatory power)over unit closure because simpler (and less) metarules are needed with biclo-sure.
Thus, the length of metarnle derivations i not totally ad hoc becauseit is subject o scientific riterion.2452.5 P r inc ip les  o f  Un iversa l  Feature  Ins tant ia t ionThe ID rules obtained by taking the finite closure of the mete-rules on the ID rules are proiected to local phrase structure trees.Abstractly, this process establishes the connection between thoserelations encoded in ID rules (for example, domination, subcate-gorization, case, modification, and predication) and the nonlocallinguistic relations.
Local trees are projected from ID rules bymapping the categories in a rule into legal extensions of thosecategories in the projected local tree.Principles of aniverea/feature instantiation (UFI) constrainthis projection by requiring categories in a local tree to agree incertain feature specifications when it is possible for them to doso.
For example, the head feature convention (HFC) requires themother to agree with all head features that the head daughtersagree on, if agreement is possible.
The HFC expresses ~-theoryin part, requiring a phrase to be the projection of its head.
Italso plays a central role in the GPSG account of coordinationphenomena, requiring the conjuncts in a coordinate structure toall participate in the same linguistic relations with the rest ofthe sentence.
The two other principles of UFI are the controlagreement pr/nc/ple and the foot feature principle.
The controlagreement principle represenm the GPSG theory of predicate-argument relations; informally, it requires predicates to agreewith their arguments (for example, verb phrases must agree withtheir subject NPs in English).
The foot feature principle pro-rides a partial account of gap-filler elations in the GPSG sys-tem, including parasitic gaps and the binding facts of reflexiveand reciprocal pronouns; it plays a role strikingly similar to thatof Pesetsky's (1982) path theory and Chomsky's (1986) bindingand chain theories,  Informally, the foot feature principle nsuresthat certain syntactic information is not lost.
~Exceptional ~ fea-ture specifications are those feature specifications in an ID rulethat should agree by virtue of a principle of UFI, but are unableto without changing a feature specification i herited from the IDrule.2.5.1 Complex i ty  of U'FIThe three principles of UFI all cause intractability because theyprovide the derivation process with reusable space resources.First, each principle of UFI can enforce nonlocal feature agree-ment in phrase structure.
Ristad (1986b) shows how this causesNP-hardnees, when coupled with lexical ambiguity or null tran-sitions.
A related source of intractability is that the projectionof ID rules to local trees can create an astronomical space oflocal trees, which in turn increases parser search space.
Thesetwo sources of intractability cannot be eliminated because theyare essential to GPSG's account of linguistic agreement amongaThe possibility ofexpreuing the control agreement and foot feature prin-ciples as local constI-sints on nonlocal relations ~llm out from the centralrole of c-command, orequivalently unambiguous paths, in binding theory.C-command k a local relation, in fact the primary source of locality inphrase structure (see Berwick and Wexler 1982).
Similarly, the possibilityof encoding multiple g-sp-filler relations in one feature specification f onecategory corresponds to the "no crossing ~ constraint of path theory.
Peeet-sky (1982:556) compares the predictions of path theory and principles ofUFIwhen the two diverge in cases of double xtraction (for example, a probls~r~thaf~ \] know ~vho i to \[~ talk to s i about ell) from coordinate structures.
Heconcludes that ithe apparent simplicity of the slash category solution fadeswhen more complex cases are considered.
"conjuncts and between predicates and their arguments, gaps andtheir fillers, and phrases and their lexical heads.The use of exceptional feature specifications in these princi-ples allows a derivation to reuse the space resources provided bythe ID rules and theory of syntactic features.
In the reductionof Ristad (1986a), head features encode an alternating Turingmachine tape.
The HFC is used to transfer the tape contentsfor an ATM configuration Co (represented by the mother) to itsimmediate successors C1, C2,.. .
,Ck (the head daughters).
Theconfigurations Co, C1 .
.
.
.
,Ct have identical tapes, with the crit-ical exception of one tape square.
If the HFC enforced absoluteagreement between the head features of the mother and headdaughters, the polynomial space ATM computation could not besimulated in this manner.2.5.2 Universal Feature  Ins tant ia t ion  in RGPSGPrinciples of universal feature instantiation in RGPSG all pre-serve a simple invariant across all ID rules.
They are mono-tonic; that is, they never delete or alter existing feature spec-ifications.
The head feature convention, for example, ensuresthat the mother agrees exactly with all head feature specifica-tions that the head daughters agree on, regardless of where thespecifications come from.Principles of UFI  are first applied to the ID rule output ofmetarule unit closure.
After this initial application, each princi-ple always applies, governing the well-formedness of the ID ruleextension relation.
The resulting ID rules derive utterances inthe language generated by the RGPSG.Head feature  convent ion.
The head feature convention en-forces the invariant hat the mother is in absolute agreementwith all head features on which the head daughters agree.
Italso requires the BAR value on a head daughter to be less than orequal to the BAR value on the mother.
HEAD contains exactlythose features that must be equivalent on the mother and headdaughters of every ID rule.
9HEAD = {AGR, ADV, AUX, INV, LOC, N, N'FORM, PAS, PAST,PER, PFORM, PLU, PRD, V, VFORM}Contro l  agreement  pr inciple.
The control agreement princi-ple (CAP)differs from the HFC in that it establishes equivalences(//nks) between the categories in an ID rule: when two categoriesare linked in an ID rule, the two categories must be identical inany legal extension of that rule.
Links are calculated immedi-ately after the HFC has applied to the ID rules for the first time;once a link is established in an ID rule, it cannot be changed orundone.
I?
The first part of the CAP calculates control relationsbetween categories, while the second part of the CAP establishs?In order to properly account for feature inetantiation in the binary andRerating coordination schemata, the binary head (BHEAD) features BAR,SUB J, SUBCAT, and SLASH are considered to be head features for the purposesof the HFC in all nonlexlcal, multiply-headed ID rules.loin GI~s, only head feature specifications and inherited foot featurespecificationJ determine the semantic types relewant to the definition of con-trol.
RGPSG simplifies this by considering inherited feature specificationsand only some head feature specifications.
Alternatively, control relationscould be calculated every time the HFC instantiates a feature specification.246links using the control relations.
In all cases, linking is indicatedby co-subscripting.RGPSG control relations are calculated as follows.
A predi-cate is a VP or an instantiation of XP\[?PRD\] such as a predicatenominal or adjective phrase.
The control feature of a category C~,where C~(BAR) 7 & 0, is SLASH if C~ is specified for SLASH; other-wise, it is AGR.
Control is calculated once and for all immediatelyafter the HFC has applied to the ID rules resulting from metaruleunit closure.Let f be the control feature of a category C,.
Then 6', iscontrolled by C~ in a rule if and only if CI(f)  = C2, 6'2 ~_ X2,and either the rule is Co -* C, : 6'2 (recall that 6'1 is the headdaughter), or the rule is Co -'* Cs : CI,C2, and C0,CI _~ VP.The RGPSG control agreement principle states: In an ID ruler = Co - .
e l , .
.
.
,  Ci : C#+~ .
.
.
.
.
C .?
If C~ controls Ck and fk is the control feature of C~, thenCk(f~) and C~ are linked.?
If there is a nonhead predicate C~ with no controller, thenlink C~(f~) and Co(fo), where f~ and f0 are the controlfeatures of C~ and Co, respectively.In the theory of GKPS,  the control agreement principle per-forms subject-verb agreement by enforcing a control relation be-tween the two daughters of the rule5' --, H\[-SUBJ\], X~In RGPSG, this rule must be stated asS --* X~ \[-SUBJ,AGR X~\] : X~if we wish to enforce the control relation between the two daugh-ters.
Because control relations in RGPSG are static (never re-calculated), this control relation exists even if Xg ~ NP.
Fortu-nately, no verb will ever be specified for \[AGR AP\] in the lexicon,and therefore any "questionable" control relations involving anXg  other than NP  are ignored at the lexical insertion level.Foot feature principle.
The foot feature principle (FFP) re-quires any foot feature specification instantiated on a daughtercategory to also be instantiated on the mother.
The specifica-tion is identical to any instantiation of the same feature on otherdaughter categories.
The FFP  ensures that (1) the existenceof inherited foot features on any category of an ID rule blocksinstantiation of those foot features on any other component cat-egory of the rule, and (2) inherited foot features are equivalentacross all component categories of the rule.
This second condi-tion may be too strong.Because the empty string can be dominated only by a cate-gory of the form <*\[NULL ?, SLASH a\] in RGPSG, the FFP triesto ensure that every gap will have a unique filler.
Unfortunately,it is impossible to truly guarantee recoverability of deletions inRGPSG, because the FFP can only locally constrain the rule-to-tree projection, and not the ID rules themselves.
This sit-uation is unavoidable in the GPSG framework, simply becauseSLASH does not always mark the complete path between a gapand its filler in accepted GPSG analyses.
The classic exampleis the GPSG analysis of subject dependencies, where an S/NPis reanalyzed as a I/P, effectively deleting an NP gap in subjectposition.
In GKPS,  this operation is performed by slash termi-nation metarule 2 (GKPS:160-2): \[SLASH NP\] only marks thepath from the filler to the mother of the reanalyzed I/P.
Anotherexample is the GKPS (pp.
150-152) analysis of missing-objectconstructions such as John is e~y to please.
In missing-objectconstructions, \[SLASH NP\]  only marks the path from the NPgap to the V~\[ INF\ ] /NP dominating to please, failing to continuethrough the AP easlt to please to the filler Job,.
Many sweep-ing changes would be necessary before the FFP would be able tostrictly enforce recoverability ofdeletions in RGPSG.2.6 Mark ing  Convent ionsFeature co-occurrence restrictions (FCRs) and feature specifica-tion defaults (FSDs) are explicit marking conventions used in theGPSG system both to express language-particular facts and torestrict the overgeneration of other formal devices (both metaruleand feature closure}.
FCRs  and FSDs are restrictive predicateson categories, constructed by Boolean combination of featurespecifications.
All legal categories must unconditionally satisfyall FCRs.
All categories must also satisfy all FSDs, if it is possi-ble to do so without violating an FCR or a principle of universalfeature instantiation.
For example,FCR i: \[INV ?\] D {\[AOX +\] A \[VFORM FIN\])requires any category that bears the \[INV ?\] feature specifica-tion to also bear the specifications \[AUX ?\] and \[VFORM FIN\].2.6.1 Complex i ty  of Mark ing  ConventionsFCRs  and FSDs both provide significant resources to the GPSGprojection process.
First, they allow the projection process toreuse the polynomial space provided by the theory of syntacticfeatures, because they can establish equivalences between the fea-tures in a category C and the features in a category containedin C. This ability to apply across embedded categories vastlyincreases the complexity of the rule-to-tree projection.
To seewhy it is linguistically unnecessary, consider the role of embed-ded categories.
A category-valued feature f expresses a nonlocallinguistic relation between a category C and the one or more cat-egories that bear the feature specification \[f C\].
Thus, in thelinguistically relevant cases, every embedded category eventually~surfaces" in phrase structure, where the marking conventionsare free to apply.
The one exception to this argument is FCR13 in the GKPS grammar for English, which applies 'across' anembedded category.FCR 13: \[FIN, AGR NP\] O \[AGR NP\[NOM\]\]In RGPSG,  marking conventions may not apply to or across em-bedded categories.
The effect of FCR 13 is achieved in RGPSGby a combination of the simple default SD 2 in section 3.2.2 belowand carefully written ID rules.Second, FCRs  and FSDs of the "disjunctive consequence"form \[f ~\] D \[fl vl\] V .
.
.V  \[fn ~,\] compute the direct ana-log of the NP-complete satisfiability problem: when several such247FCRs  are used together, the GPSG must nondeterministicallytry all n featurs-value combinations.Third, the process of applying FSDs to local trees is verycomplex, in part because it is not informationally encapsulated.Rather than simply considering the (existing) feature specifica-tions in each target category separately, FSD application is af-fected by the other categories in the ID rule, all principles ofuniversal feature instantiation, and even FCRs.2.6.2 Simple  Defau l ts  in RGPSGThere is no reason to believe that marking conventions need beso powerful and unconstrained.
The approach RGPSG takes is tovirtually eliminate marking conventions.
Rather than stating theinternal constraints on categories explicitly (and redundantly),as FCRs do, RGPSG eliminates FCRs altogether.
Instead, theconstraints FCRs express are implicitly stated in the rest of thegrammar - -  in the way ID rules and metarules are written, forexample.
The sole explicit marking convention in RGPSG is thesimple defauh (SD).
Unlike FCRs and FSDs, SDs are construc-tive, easy to understand and computationally tractable.
Each$D is applied (and may be understood) to each category inde-pendent of all other categories and RGPSG formal devices, in-cluding other SDs.
$Ds are applied to ID rules immediately afterthe initial application of principles of UFI.An SD contains a predicate and a consequent.
The conse-quent is a list of feature specifications.
The predicate is a Booleancombination of truth-values and feature specifications such thatif a category C bears or extends a given feature specification, thatfeature specification is true of C, else false.
If the predicate istrue of a given category C in a rule and the consequent includesonly unbound and unlinked features, then the feature specifica-tions listed in the consequent are instantiated on C. Each SD isapplied simultaneously to every top-level category in every ruleexactly once, in the order specified by the grammar.
Considerthe following SD:SD I: if \[SUBCAT\] then \[BAR 0\]If the target category C in a ID rule is specified for the SUBCATfeature, but unspecified for the BAR feature, then the SD wi|\]force the feature specification \[BAR 0\] on C.3 The  Rev ised  TheoryIn this section, I explain how the formal subsystems describedabove fit together.
I begin by formally specifying the class ofRGPSGs and the languages they generate.
I conclude by trans-lating the GKPS analysis of topicalization, explicative pronouns,and parastic gaps to the RGPSG formal system.Figure 1 shows the internal organization of RGPSG.
The setof ID rules R' defined by metarule unit closure, UFI, and SDapplication generates the language of the RGPSG as follows.
IfR' contains a rule A --.
~' with an extension A' --..1, that satisfiesall principles of UFI and is an LP-acceptable ordered production,then for any string of terminals a and nonterminals ~, we writeaA'~ =~ a'Tt~.
This is a derivation step.
The language of anRGPSG contains all terminal strings that can be derived, usingro s,~es R o( IRI)I Metarule UCvc(M,a) O(iRi2.1Mi)v-.d r~ R~.
I O(IR?
'IMI'ISl)I SDe and UFIm , ,~.
~ O(IGt')Figure I: This diagram shows internal organization of an RGPSGG with ID rules R, metarules M, and simple defaults S. TheO-bounds show the effect of various formal devices on derivedgrammar symbol size.the ID rules, from any extension of the distinguished start cate-gory.
Let =~ be the reflexive transitive closure of =~.
Then thelanguage L(G) generated by G isL(G) = { z I z e V~ and 3C ?
K\[(C ~_ Star t )  ^  C =~ zl}Ristad (1986b) proves that universal recognition problem forRGPSG is NP-complete, a significant decrease in complexityfrom the EXP-POLY time hardness of GPSG-Recognition.
xl Infact, of the more than ten sources of intractability lurking inGPSG, only two remain in RGPSG - -  lexical ambiguity andnonlocal feature agreement.
Critically, these two sources of in-tractability in RGPSG appear to be linguistically essential.3.1 E f f i c ient  RGPSG Pars ingIntractability in RGPSG arises from a particularly deadly com-bination of feature agreement and lexical ambiguity.
Underspec-ification of categories in ID rules and metarules can be costly.This suggests that limiting the number of head features or thescope of their agreement will mitigate the intractability.
An ef-ficient recognition algorithm might approximate grammaticalityby failing to transfer all head features through coordinate struc-tures (for example, letting them assume default values instead),or by aborting a parse in the face of excessive lexical or struc-tural ambiguity.
Ef~cient parsing techniques based on partialenforcement of UFI are also possible.
One such implementation,which propagates feature specifications bottom up using Earley'salgorithm, is in progress at Thinking Machines Corporation.~This decrease incomplexity iesignificant from both theoretical nd prac-tical perspectives.
First, N'P-complete problems typically have good averagetime algorithms, while EXP-POLY problems do not.
Next, the fastest rec-ognizer known for GPSGs can require double-exponential me in the worstcase, while RGPSG has a simple exponential time recognizer.
Finally, NP-complete problems have efficient witneeBes, while EXP-POLY hard problemsdo not.
Thk means that RGPSG parses can always be verified efficiently,while GPSG parsee cannot, in gener~h248Barton (1986) proposes a constraint-based computational so-lution to intractability in the two-level Kinuno morphologicalanalyzer.
Intractability arises from unbounded agreement pro-cesses in that system, and similar techniques based on constraintpropagation may be adapted to create an e/~cient approz~mateparsing algorithm for RGPSG.
Tuples of features would corre-spond to constraint-propagation nodes, while tuples of sets offcature-values would correspond to node labels; features couldreceive multiple values in this implementation.
Nodes would beconnected by both RGPSG ID rules and principles of universalfeature instantiation.3.2 L ingu is t i c  Ana lys i s  o f  Eng l i shThis section reproduces three of the more intricate linguistic anal-yses of GKPS in order to illustrate RGPSG's  formalisms.
Toreproduce their comprehensive analysis of English in toto wouldbe a disservice to that work and is beyond the scope of thispaper.
Instead, Ristad (1986b) provides an RGPSG roughlyequivalent to their GPSG for English; the reader should consultGKPS for the accompanying linguistic exposition.
In all cases,co-subscripting indicates linking.3.2.1 Top ica l l za t ionThe rule 4a expands clauses and rule 4b introduces unboundeddependency constructions (UDCs) in English.a.S- -*XS\ [sUBJ  -.AGR X2\] :X~b.
S --.
X8  \[SUBJ *,SLASH X2\] : X~ (4)In both cases the X2  nonhead daughter controls the head daugh-ter, and the control agreement principle links the value of thehead daughter's control feature with the 3(2 daughter, creatingthe ID rules in 5.a.
S --* VP\ [AGR X~x\] : X~Ib.
S \[SLASH noBind\] .~ S \[SLASH X~\ ]  :X~ \[SLASH noBind\]t(s)In the following discussion, \[3s\] and \[3p\] abbreviate \[PER 3, -PLU\]and \[PER 3.+PLU\], respectively.
Note that it is impossible toextract any constituent out of the X~ daughter in 5b becausethe foot feature principle has forced \[SLASH noBind\] on the X~daughter and its mother.
This explains the unacceptabihty of 6in RGPSG,  which is permissible in the theory of GKPS.
* New York \[\[ the girl from - - \ ]  \[ we want __  to succeed \]\](s)3.2.2 Exp l i ca t ive  pronounsNow I account for the distribution of the explicative pronouns itand there in infinitival constructions on the basis of postulated IDrules and principles of universal feature instantiation (see GKPS,pp.115-121).
The feature specification \[AGR NP\[NFORM all isabbreviated as +a below, where a is it, there, or NORM.The RGPSG for English includes the ID rules 7,a.
S --~ X2 \[-SUBJ,AGR X~ : X2b.
VP --, \[13\] : VP\[INF\]c. VP  -.
\[1?,\] : (PP\[to\]), VP\[INF\] (7)d. VP -.
\[17\] : NP, VP\[INF\]e. VP  \[AGR 5"\] --.
\[20\] : NPthe simple defaults 8,a.
SD I: if \[SUBCAT\] then \[BAR 0\]b. SD 8: ;f \[+V,-N,-SUBJ\] then \[+NORM\] (8)the extraposition metarule g,X~ \[AGR S\] -., W(9)X~\[+it;\]  - .
W,Sand the lexical entries 10.
All other nouns are specified for\[NFORM NflRM\] by their lexical entries.
(it, NP  \[PRO.
-PLU.
NFORM it;\] )(there, NP \[PRO, NFORM t;here\] ) (I0)From the ID rules in 7, RGPSG generates the following IDrules.a.
VP  \[AGRI\] --~ VO \[13.AGRI\] : VP \[INF,AGRI\]b. VP\[AGRI\] -~ VO\[16,AGRI\] : (PP\[to\]), VP\[INF,AGRI\](11)The absence of a controlling category allows the CAP to link theAGR values of the mother and VP\[INF\] predicate daughter.
TheHFC then links the AGR values of the mother and lexical headdaughter.
SD 1 specifies the head daughter for \[BAR 0\], whileSD 2 cannot affect the linked AGR values.VP\[AGRI NP\[HORM\]\] --~ V0114.AGR, NP\[HORM\]\] :V~\[INF, AGR, NP\[NORM\]\]The CAP and HFC operate identically as in 11, except that the\[+NORM\] specification is inherited from the ID rule 7b and prop-agated through the rule by the CAP and HFC.VP\[AGR~ NP\[NORM\]\] --.
V0117,AGR2 NP\[HORM\]\] :NPI, VP\[INF, AGRt NP\](12)The NP  daughter controls its VP\[INF\] sister, and the CAP linksthe AGR value of the VP  to its sister NP.
SD 2 specifies the motherfor \[+NORM\], and the HFC forces this specification on the headdaughter.The rules 13 introduce \[+it\] and \[+there\] specifications.Note that 13a is the result of the extraposition metarule on theID rule 7e.a.
VP\ [+ i t \ ]  -* \[20\] :NP,  Sb.
VP \ [+ i t \ ]  -~ \[21\] : (PP \ [ to \ ] ) ,S \ [F IN \ ]  (13)c. VP  \[AGR NP\[*there.PLU ,~\] } --* \[22\] : NP \[PLU c~\]The rules in 13 may only expand the VP daughters of theID rules 11 and 12 in a derivation (compare their AGR values).Thus, the grammar claims that explicative pronouns only occurin utterances generated using the rules in 13, in combination withthe "extending" rules 11 and 12.
This describes the followingfacts from GKPS,  p. 120.
I~{It}*There \[continues \[ to bother \[ Lou \]\[ that Robin was chosen \]!!
*Kim(14)*21n order to better understand these examples, associate each constituentwith the ID rule that generated it.
To help with this task, the mainverbs and their SUBCAT values are: (continue, 18), (appear, 16), (believe, 17),(bother, 2.0), {be, f.P.
).249*It }There \[ appeared (to us) \[ to be \[ nothing in the park Ill*Kim(is) { } Leslie \[ believed *there \[ to bother \[ u= \] \[ that Lee lied Ill*Kim(16) {'} We \[ believed there \[ to be \[ no flaws in the argument HI*Kim(17)3.2.3 Paras i t ic  gapsSimple parasitic gaps, that is, those introduced in verb phrasesby lexical rules, present no problem for RGPSG because the FFPdemands all instantiations of SLASH on daughters to be equal toeach other and equal to the SLASH instantiation on the mother.VP/NPvo \[13\]NP/NP (18)PP \['to\] /NPKim wondered which models{ \[ had sent \[ pictures of __  \] \[ to __  \]\] }Sandy \[ had sent \[ pictures of __  \] \[ to Bill \]\]\[ had sent \[ pictures of Bill \] \[ to E II(19)The FFP  insists nonlexical heads be instantiated for SLASH ifany nonhead daughter is, thereby explaining the unacceptabilityof 20 and the acceptability of 21.a.
* S/NPNP/NPvP  (20)b.
* K im wondered which authors\[\[ reviewers of E \] \[ always detested sushi \]\]a. S/NPNP/NPVP/NP (21)b. K im wondered which authors\[\[ reviewers of ~ \] \[ always detested ~\]\]This analysis of parasitic gaps exactly follows the one presentedin GKPS on matters of fact.
These facts may be questionable,however.
Some sentences considered acceptable in GKPS (forexample, Kim wondered which models Sandy had sent pictures ofto Bill and Kim wondered which authors reviewers of always de-tested) axe marginal for some native English speakers.
Note thatboth sentences axe marked unacceptable in the GB frameworkbecause of subjacency violations.It would be instructional to identify a~nd restrict the computa-tional resources provided by the formal devices in other linguistictheories (for example, lexical-functional grammar, government-binding theory, or morphological theory).
Barton, Berwick, andRistad (1987) explores the utility of complexity analysis in otherlinguistic domains, although the research strategy reported hereis not the focus of that work.5 ReferencesBarton, E., 1985.
On  the complexity of ID/LP parsing.
Compu-tational Linguistics 11(4):205-218.Barton, E., 1986.
Constraint propagation in Kimrno systems.Proceedings of the ~4th Annual Meeting of the Associationfor Computational Linguistics.
Columbia University, NewYork: Association for Computational LinguisticsBarton, E., R. Berwick, and E. Ristad, 1987.
ComputationalComplczity and Natural Language.
Cambridge, MA: MITPress.Berwick, R. and K. Wexler, 1982.
Parsing efficiency and c-command.
Proceedings of the First West Coast Conferenceon Formal Linguistics.
Los Angeles, CA: University of Cali-fornia at Los Angeles, pp.
29-34.Chomsky, N., 1986.
Knowledge of Language: Its Origins, Nature,and Use.
New York: Praeger Publishers.Gazdar, G., E. Klein, G. Putlum, and I.
Sag, 1985.
GeneralizedPhrase Structure Grammar.
Oxford, England: Basil Black-well.Kayne, R., 1981.
Unaznbiguous paths.
In Levels of SyntacticRepresentation, R. May  and J. Koster, eds.
Dordrecht: ForisPublications, pp.
143-183.Pesetsky, D., 1982.
Paths and categories.
Ph.D. dissertation,M IT  Department of Linguistics and Philosophy, Cambridge,MA.Ristad, E.S., 1986a.
Computational complexity of current GPSGtheory.
Proceedings of the 2~th Annual Meeting of the As-sociation for Computational Linguistics.
Columbia Univer-sity, N. ew York: Association for Computational Linguistics,pp.
30-39.Ristad, E.S., 1986b.
Complexity of linguistic models: a com-putational analysis and reconstruction of generalized phrasestructure grammar.
S.M.
Thesis, MIT Department of Elec-trical Engineering and Computer Science, Cambridge, MA.Shieber, S., 1986.
A simple reconstruction of GPSG.
Proceed-ings of the 11th International Conference on ComputationalLinguistics.
Bonn, West Germany, 20-22 August, 1986.4 Conc lus ionThis work is similar to that of Shieber (1986) in its attempt toreconstruct GPSG theory.
Shieber, however, is concerned solelywith creating a more easily implementable description of GPSGtheory, rather than with changing the theory in a linguisticallyor computationally significant way.250
