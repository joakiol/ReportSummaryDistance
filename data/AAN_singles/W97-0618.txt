A Programmable Multi-Blackboard Architecture for DialogueProcessing SystemsMatth ias  DeneckeInteractive Systems Laborator iesCarnegie Mellon UniversityP i t tsburgh,  PA 15217denecke@cs.cmu.eduAbst rac tIn current Natural Language ProcessingSystems, different components for differentprocessing tasks and input\] output modali-ties have to be integrated.
Once integrated,the interactions between the componentshave to be specified.
Interactions in dia-logue systems can be complex due in partto the many states the system can be in.When porting the system to another do-main, parts of the integration process haveto be repeated.
To overcome these difficul-ties, we propose a multi-blackboard archi-tecture that is controlled by a set of expert-system like rules.
These rules may containtyped variables.
Variables can be substi-tuted by representations with an appropri-ate type stored in the blackboards.
Fur-thermore, the representations i  the black-boards allow to represent partial informa-tion and to leave disjunctions unresolved.Moreover, the conditions of the rule maydepend on the specificity of the represen-tations with which the variables are instan-tiated.
For this reason, the interaction isinformation-driven.
The described systemhas been implemented and has been inte-grated with the speech recognizer JANUS.1 In t roduct ionWhen building an NLP application, several buildingblocks have to be integrated to form a working inter-active system.
Since, in the most cases, the compo-nents have been developed separately from one amother, each of them has its own representations forinput and output data and are optimized to achievethe task for which they have been designed, but "notnecessarily to optimize integrated behavior.Partly for this reason, several blackboard andmulti-agent systems have been proposed for spokenlanguage processing in the past, one of the first be-ing the HEARSAY system (Erman and Lesser1980).In some of these architectures, fine grained agent in-teraction may take place.
Due to the inherent mod-ularity, these architectures are easily extendible andreconfigurable.
However, to our knowledge, littlework has been focused on how the specification ofthis interaction may easily be adapted and extendedto new tasks.We adopt the hypothesis that a dialogue systemis supposed to perform a limited set of parametrizedactions and that the communicative goal of the useris to make the system perform one of these actions.Thus, we not only assume the dialogue to be task-oriented, we also assume that the behavior of the sys-tem is limited to determine which action, includingits parameters, is compatible with the informationconveyed by the users request and which is not.
Todo so, we propose to use typed representations thatexclude the use of inappropriate information for anunintended action.
Together with a type inferenceprocedure, partially specified requests can be incre-mentally made more specific by using clarificationdialogues.Contrary to most multi-agent and blackboard sys-tems in spoken language processing, we propose tocontrol the interaction of the modules by a set ofrules.
The rules contain typed variables that canbe instantiated with the representations stored ina discourse blackboard.
The discourse blackboardstores four different levels of linguistic represen-tations.
These are orthographic representations (nbest and word n best lists), syntactic/lexical seman-tic representations (parse trees generated by a se-mantic parser), the semantic representations of theutterances, and representations of the objects refer-ring expressions may refer to.
The different modulesmay make use of each level of representation to per-form the action they implement.
The advantage ofrepresenting the interaction between the modules ina set of rules are twofold.
First, the rules are justanother parameter that may easily be changed oradapted if the system is supposed to be ported toanother domain.
Second, since the variables in therules are substituted with representations stored inthe discourse history, the approach is information-driven and may take fully into account the specificityof the information entered by the user.The system has been implemented for a map-based application in which it is possible to ask forlocations and path descriptions and to make ho-98tel and restaurant reservations.
The system hasbeen integrated with the speech recognizer JANUS(Waibel1996).
To illustrate the portability, the sys-tem has been ported to a new and independent do-main, a system with which fast food can be ordered.2 In fo rmat ion-centeredRepresentat ions2.1 The  Type  H ierarchyWe use typed feature structures as defined in (Car-penter1992) throughout the entire system as repre-sentation formalism.
The notion of a type in a fea-ture structure refers to the fact that every featurestructure is assigned a type from a type hierarchy.Moreover, for every type, a set of appropriate fea-tures is specified so that type inference is possible.In our applications, we primarily encode the domainknowledge in the type hierarchy.According to Carpenter (Carpenter1992), thetype hierarchy of the respective domain is given by aset Type of types and the ordering relation betweentypes E, the subsumption relation.
Additionally,we describe which features from a set Feat a typemay consist of by so-called appropriateness condi-tions (Carpenter1992).
The type hierarchy allows usto express the IS-A relations (in the following notedin cursive letters) and IS-PART-OF relations (notedin capital etters) that hold between objects.
Figure1 shows a part of the domain that we use in our mapapplication.
: : , .
:~..~.
NAT =nat iona =ty .
:~:~',,~,.~ .
.
:.-,~.~;~ SRC~.
;ob I .~concrete-:,~Figure 1: A part of the type hierarchy and its appro-priateness conditions used in the map application.The least specific type is at the bottom of the tree.The information in the type hierarchy not onlyprovides the types for the feature structures and de-fines the relations between them but serves also torestrict variable Substitutions in the rules describedbelow.2.2 The  Semant ic  Representat ionsOftentimes, requests formulated in natural anguageencode only partial information or are ambiguous.The representations of a natural anguage processingsystem have to account for this fact.
Naturally, fea-ture structures are well-suited for representing pax-tial information.
However, they do not adequatelyrepresent ambiguity.
For this reason, underspecified.feature structures have been developed.
As featurestructures, underspecified feature structures can en-code partial information.
In addition to featurestructures, they are able to leave disjunctions unre-solved.
Figure 2 shows examples for a typed featurestructure and an underspecified feature structure.obj_museum \]TOWN pittsburgh J(a)" obj .......... { \[ obj ....... (2) HREF ht tp : / /  .
.
.
.
.
.
.
ho|.org/warbol/warhol.htm| \] }{"c  gi .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
f natural history "(I) }NAME string* andy warhol museum "(2)fort pitt museum "(3)ADDRaddress" forbes ave" (1,3) string* STREETNAME I sandusky st" (2) f{4400(1)}STREETNUMBER int* 117(2) z00(3)TOWN pittsburgh(b)Figure 2: Examples of a typed feature structure(a) representing the semantics of the noun phrasemuseums in pittsburgh and an underspecified fea-ture structure (b) representing objects that are com-patible with (a).In the attribute-value-matrix notation that we useto display underspecified feature structures, the typemarked with an asterisk is the most specific lowerbound of the types in its scope.
The scope is indi-cated by curly brackets.
The alternatives are rep-resented inside curly brackets.
Indices behind typesidentify the typed feature structure to which thisinformation belongs.
If there are no indices, the in-formation belongs to all feature structures.
Featuresthat are common to only a subset of all representedfeature structures are in the scope of the most spe-cific type that is in common to that subset.Underspecified feature structures represent sets offeature structures efficiently in that they expressboth the information that is common to and theinformation that differs between the feature struc-tures in question.
The fact that underspecified fea-ture structures represent informational differences iused when generating clarification questions to ge-nerate uniquely referring NPs.2.3 Generat ing  Noun Phrases  andClar i f icat ion Quest ionsNoun phrases containing descriptions of objects aregenerated by traversing the feature structure repre-senting the object in depth-first order and mappingthe features and types to strings.
Since underspeci-fled feature structures represent unresolved isjunc-tions, they are an adequate point of departure forgenerating clarification questions.
Underspecifiedfeature structures exPlicitly represent the differences99between feature structures.
To generate a clarifi-cation question to disambiguate an underspecifiedfeature structure, a noun phrase for every disjunctis generated.
The information in the noun phrasemust be specific enough to reduce ambiguity in theunderspecified structure.
The noun phrases are thenfilled into a template of the form0o you mean <npl) ..... <nP~_1> or <~Pn>?The following example shows the information usedfor generating two clarification questions to disam-biguate the structure shown in figure 2.Example 1 Example 2Disjunct 1 \[NAME\] I ADDR I STI:tEETNAME \]tADOR I STRZETNUM \]Disjunct 2 \[NAMEJ IADDR \[ STREETNAME \]Disjunct 3 \[NAME\] ~ADDK I STREETNAME \]tADOR I STREETNUM \](a)(1) Do you mean carnegie museum of natura lh is tory ,  andy warhol museum or fo r tp i t t  museum?
(2) Do you mean the one at 4400 forbes ave,the one at sandusky  st or the one at 100forbes ave?
(b)Figure 3: Generating clarification questions.
Thepaths shown in (a) single out the information thatis sufficient to completely disambiguate the under-specified feature structure shown in figure 2 for anyof the three disjuncts.
The paths and their valuesare mapped to strings that are filled into a templateto produce the questions shown in (b)3 The  B lackboard  SystemThe dialogue system is implemented as a blackboardsystem.
The system consists of multiple blackboardseach of which stores a separate database.
More-over, a certain number of agents is linked to thesystem.
The agents implement operations on the re-presentations stored in the discourse blackboard ina modular way.
The operations are used to formu-late rules that control the interaction between black-boards and agents.
The rules are evaluated by acentral processing unit, the general manager, thatpasses control to the agents to evaluate their localoperations.3.1 The  AgentsThe task of agents is to perform operations on repre-sentations tored in blackboards.
To this end, eachagent disposes of a set of procedures that execute theactions.
To specify the interface with the dialoguesystem, each agent exports a set of signatures con-taining information about the number and form ofthe procedures' parameters to the general manager.When the procedure assigned to a given signatureis evaluated, the general manager passes the param-eters on to the agent.
After having executed theprocedure, the agent returns status information andpossible return values, if any, to the general managerwhich, in turn, uses this information to decide uponthe control strategy.3.2 The  B lackboardsAmong the blackboards, there is one distinguishedblackboard, called the discourse blackboard thatstores different levels of representations of the dis-course history.
Database blackboards are hooked upto the discourse blackboard to make the represen-tations more specific.3.2.1 The  Database  B lackboardsThe database blackboards tore a set of featurestructures.
The functionality of a database black-board is to provide procedures to insert, remove, andlookup feature structures.
Any database lookup willreturn an underspecified feature structure represen-ting all feature structures that are compatible withthe feature structure passed to the lookup proce-dure.3.2.2 The  Representat ion  of  D iscourseAside from the database blackboards, there is onedistinguished blackboard, the discourse blackboardrepresenting the discourse history.
For the time be-ing, the discourse structure is a list of the generatedrepresentations.
In order to access all levels of repre-sentations, this list is maintained for orthographic,syntactic and semantic representations a  well as re-presentations of referred objects which allow the dis-course blackboard to be seen as four database black-boards in parallel.
Moreover, links exist between theobjects to access the different levels.
This organiza-tion is similar to the discourse pegs (LuperFoy1995),with the main difference being that discourse pegscompile the different representations i  one discourseunit while in our approach the different levels areseparated and only accessible via links.Ortllographic Syn/Sem Semant ic  ObjectsJ '~ Qu~T?~L .
.
.
.
.
.
.
.ATIONALITYallchinese relllauran~ dot ad~, nal N obLrestall NAME"  kiku ex~eu ?chin... L "p,,ki~ g~a..'\]Figure 4: The four different levels of representation.Links exist between the representations in order toaccess the representation across the levels.In the remainder of the paper, the level of re-presentation may also be referred to by a numberranging from 0 (object level) to three (orthographiclevel).
Typed feature structures in the semantic levelrepresenting noun phrases can be seen as partial de-scriptions of objects, each of which is compatiblewith the description.
This allows us to determinethe objects by compatibility check.
In figure 2 (b),the underspecified feature structure might be the re-sult of a database request completing the descriptionshown in 2 (a).
This is the reason why the database100blackboards are attached to only one of the four lev-els.
Every time a feature structure is added to oneof the four levels, the appropriate database proce-dures, if any, provided by the database blackboardsare executed to complete the feature structure.
Forinstance, the object level of the discourse blackboardcan be seen as database for anaphora resolution:when the representation f an anaphor is added tothe semantic level of the discourse blackboard, theobject level of the discourse blackboard is consid-ered to be a standard atabase blackboard, and theantecedents are determined.The natural language input is analyzed by thePHOENIX parser developed by Ward (Ward1994).The parser generates a set of parse trees each ofwhich covers a part of the input sentence.
The rootsof the parse trees are specified by top-level frames.Top-level frames can be changed uring dialogue in-teraction to check if the input is or is not conform towhat has been expected.
Words not covered by theparse trees rootes at the top-level slots are ignored.The partial semantic parse trees are converted to asemantic representation by traversing the parse treeand applying construction rules to the nodes.
Theconstruction rules operate mostly on the semanticslots in the parse trees so that synonymy and para-phrases of expressions can be handled.
The seman-tics of an utterance is given by a set of possibly par-tially specified feature structures that are stored ina discourse history.
Each structure represents thesemantics of a phrase of one of the main syntacticcategories NP, VP, or PP.
Examples of how the se-mantic representations of a request might look likeare given in figure 6 and 7.4 The  Form of Ru lesThe interaction of the agents and the blackboardsis governed by a set of expert system style rules.The rules are composed of constants, typed vari-ables, functions and predicates.
The predicates andfunctions can tal~e variables over either possibly un-derspecified feature structures over Type and Feat,feature paths over Feat, or events that enable thecommunication with the speech recognizer and otherexternal processing modules.4.1 ConstantsA constant is given by any type from the type hierar-chy.
Moreover, integers and strings are considered tobe subtypes of the types string and int respectivelyand are also treated as constants.
Constants tandfor atomic feature structures whose type is given bythe constant name.4.2 Var iab lesVariables range over feature structures and under-specified feature structures.
Variables are typed inthe sense that they impose an informational lowerbound on the type of the feature structures withwhich they will be substituted.
Names of variablesranging over feature structures have to start with thename of their type, with a capital letter to distin-guish variables from constants.
Feature structuressubstituting variables have to be stored in the dis-course blackboard.
Variables are indexed with thelevel of representation, as inObj : OMoreover, parts of the feature structures can beaccessed by specifying a feature path such asObj : 0Q\[eOSITION I X\]The feature path has to obey the well-typed condi-tions as imposed by the type hierarchy.Variables ranging over underspecified featurestructures are indicated by curly brackets as in{Obj_path} :0.Here, too, feature path application{Obj_path} : 0@\[DST\].is possible, the path value of an underspecified fea-ture structure being the underspecified structure ofall values of the path when applied to the featurestructures represented by the underspecified featurestructure.The variables in the rules may be instantiatedwith representations on each of the four levels.
Con-sequently, there is, contrary to systems that processdata sequentially, no restriction that predeterminesthe point at which some future agent has to performan action simly because it relies on a specific levelof representation.
This fact makes the architecturewell-suited for repair and rescore mechanisms thatintegrate scores from the speech recognizer and se-mantic domain knowledge.4.3 Funct ionsFunctions as well as predicates have to be introducedby signatures that define informational lower boundson the arguments (if present) and the return 'value.The signature for the function pkturename that re-turns a string for any given type that is as least asspecific as obj_zoncrete is given bypicturename : obj_concrete+ ~ stringwhere a following '+' or '-' sign indicates whether ornot the argument has to be defined when evaluatingthe function.4.4 P red icatesAs is the case with functions, predicates are intro-duced by signatures.
Examples areuni fy  : bot + xbot+subsumes : bot + xbot+for the unification operation and the subsumptionrelation on feature structures.
An example for anapplication-specific predicate isdraw : string + xstring + xint + xint+whose purpose it is to draw the icon given by thesecond argument into the window given by the firstargument at the position that is identified by thethird and the fourth arguments.1014.5 Ru lesRules are formed using constants, variables, func-tions and predicates together with conjunction andimplication connectors.
They have the general formpl (t1,1,... ,tl,n~) , .
.
.
,  pk (tk,1 .
.
.
.
,t~,~)( tk+, .1  .
.
.
.
, .
.
.
,  p, ( t , .
, , .
.
.
, t , .
, , )where the Pi are predicates, and the ti/ are termsconstructed over constants, variables and functions.For example, the rule displaying every object is givenbydraw( "map",picturename(Obj_concrete : 0),Obj_concrete : OR\[POSITION \] X\],Obj_concrete 0?~\[POSlTION I Y\]).5 In teract ion  and  Cont ro lThe rules are the only means to specify the interac-tion between agents and blackboards and betweenblackboards and user.
Consequently, only the ruleshave to be modified if the system should behave dif-ferently.5.1 Var iab le  subst i tu t ionsIf a rule contains variables, variable substitutionshave to be calculated before evaluating the rule.This is done in the following manner.
Let v be a vari-able of the form 0 : l@Tr.
All possibly underspecifiedfeature structures of type 0' with 0 E O' that havebeen added or non-monotonically modified since thelast stop of the inference procedure are looked upin the discourse blackboard.
If the signature of thefunction or the predicate requires the argument to bedefined, all feature structures for which the path 7ris not defined are removed.
From the remaining fea-ture structures, an underspecified feature structureis generated.
In the same way, the other variablesin the rule are looked up.
All possible combinationsof instantiations form the set of substitutions.
Theonly way to look up the data stored in the discourseblackboard is to generate variable substitutions.5.2 Eva luat ing  a ru leFor each rule to be evaluated, the set of variablesubstitutions is calculated.
For each substitution,the variables of the rules are instantiated and eachpredicate of the condition is evaluated until eitherone predicate fails or the condition yields true.
Eval-uation of a predicate or function means to pass thevariable values to the procedure implementing thepredicate or function and to leave control to theagent associated with the procedure.
If the predi-cates that form the condition of the rule are verified,the remaining predicates are evaluated.
If the eval-uation of one of these predicates fails, the name ofthe failing predicate and the variable instantiationscan be passed on to an error handling procedure.
:IThe functionality is foreseen to allow interactive r-ror recovery.
If, for example, the answer to a clarification5.3 Eva luat ing  a Set  of  Ru lesThe rules are evaluated using a forward chaining in-ference procedure.
The evaluation of the programconsists of the subsequent evaluation of the rules, inthe order in which they are specified.
After termi-nation, all feature structures in the blackboard aremarked so as to prevent re-execution of an alreadyapplied rule.The forward-chaining inference procedure allowsthe system to react information-driven which meansthat, in essence, the information entered into thesystem determines which rules are evaluated.
Con-sequently, there is no predetermined dialogue modelthat predicts the type or the information of the nextutterance.The set of rules forms the program that directsthe interaction of the different components given theusers' input.
Modifying the system's behavior re-quires modification of the program rather than hard-coding and recompiling.
This allows for rapid pro-totyping.
To provide output functionality that caneasily be adapted to new domains, the predicatesalso offer the possibility to call Tcl scripts.5.4 ExamplesOur first example is taken from the map applica-tion.
The task of the rule shown in figure 5.4 is tocompletely disambiguate the representation of thedestination of a path.--).DISAMBIGUATE :isambiguous({Obj_path} : O@\[DST\])settclvar("textl"," Do you mean")settclvar( "text2",translatedifferences({Obj.path} : 0~\[DST\])),tcleval(" DisplayQuestion $textl $text2"),setnewtoplevelslots(gettranstoplevelslots0),waitforevent (EVENT_TEXTIN PUT),tcleval(" UndisplayQuestion" ),setoldtoplevelslots0,add(3, %eti_tezt ),iscompatible( { Obj_path } : 0@\[DST\], parse(%eti_text) ),unify( { Obj_path } : 0~\[DST\], parse(%etiAext ) ),reevaluate().Figure 5: The rule serving to disambiguate com-pletely an underspecified feature structure.The condition of the rule yields true if the seman-tic representation of the destination describes morethan one object.
If so, the remaining predicatesare evaluated.
In this particular case, a clarifica-tion question is generated.
The predicate translate-differences() determines the relevant feature pathsquestion is incompatible with the expected value, an ap-propriate message should be communicated to the user,along with the possibility to provide complementary in-formation as well as to cancel the dialogue.
However,in the current implementation, only the message is dis-played on the screen.102and types for generating a clarification question andmaps them to strings as shown in section 2.3.
2 Italso determines the top level slots corresponding tothe expected answers which are accessed with thepredicate gettranstoplevelslots0.
The question is dis-played on the screen and the execution halts untilsome text has been entered (either via keyboard orvia speech recognizer).
The variable %eti_text isassigned to the event EVENT_TEXTINPUT and con-tains the entered text.
The text is then added tothe orthographic level of the discourse blackboard.If the semantic representation f the text is compat-?
ible with the underspecified feature structure, therepresentations are unified to reduce ambiguity.
Ifthe iscompatible0 predicate fails, the evaluation ofthis rule is aborted, and other rules apply to pro-cess the text entered on the orthographic level.
Thisallows the processing of answers that do not con-vey the expected information.
Finally, the predicatereevaluate() forces the rule to be re-evaluated withthe same substitution until the destination is dis-ambiguated completely or an incompatible answeris given.Note that the formulation of this rule does notmake any domain-specific assumptions except thatthere is a type obj_path that carries a feature \[DST\].In another application that provides functionalityto order items, the same rule may apply to disam-biguate the items.
In order to adapt the rule, onewould only have to replace {Obj_path} : 0@\[DST\]with {Speechact.orderobject} : 0@\[OBJECT\] wherethe request o order an item is represented in a fea-ture structure subsumed byspeechacLorderobject\]OBJECT obj JOur next example is also taken from the map ap-plication.
It demonstrates how database access andrule application interact.
Suppose the user uttersshow me how I;o get to the museum.
We assumefor the sake of example that zoom in was recognizedinstead of the museum, and that the semantic parserskips zoom in .
The  representations that are storedon the semantic level after the input has been parsedand processed are shown in figure 6.We consider the rules shown in figure 5.4.
In thisexample, the second part of the first rule will beevaluated in the case of a missing the destination ofthe path.
The rule is repeated until the feature \[DST\]carries a value or the user enters information thatcauses the unification to fail (well-typed unification).After unification, another procedure nsures that thenew information is inserted correctly in the discourseblackboard.
If, e.g., the user entered the museum,2At this time, a very restricted language model isgenerated on the fly.
Basically, it consists of all expectedanswers and some standard words that are always active.The next speech input is rescored using this languagemodel.
However, at the time being, there is no possibilityto determine if the input corresponds to the languagemodel or not.speechact_showpath \]OBJECT \[\]obj_pathJ\[\] obj_pathFigure 6: The representation  the semantic levelafter having processed the utterance show me howto get  to  the museum with a misrecognition onthe museum.\[ speeehact_showpath \] OBJECT E\]obj_pathJobj_path \]DST \[\]obj_muse~mJ\] obj_muse~mFigure 7: The semantic representation f the requestafter the first question has been answeredthe semantic level looks like the one shown in figure7.Now, since a new object has been entered onthe semantic level and since there is a blackboardthat provides a database access procedure for all ob-jects that are subsumed by obj_concrete (the objectdatabase), a database lookup is executed.
The nounphrase the museum does not refer uniquely to oneobject, as shown in figure 2, thus, an underspecifiedfeature structure is generated on the object level.Now, the disambiguation rule explained above willinitiate a clarification dialogue to disambiguate theobject.
Once this is achieved, the index of the inter-section of the destination is stored in the path ob-ject by the following rule.
The following rule copiesthe index of the intersection of the current positioninto the path object, if the source of the path isnot specified.
If the source of the path is specified,the index of the source intersection is calculated us-ing rules similar to those calculating the destinationindex (not shown in this example for brevity).
Fi-nally, the shortest path is calculated and the result isstored in the path object as a list of line segments.Depending on the speech act type the path is anobject of, there may be subsequent rules that mayperform complementary operations on the data suchas calculating the path length or travel time, gener-ating a path description, or highlighting the streetsegments belonging to the path.To illustrate the behavior of the rules, we showthe complete dialogue:103-+ADD_PATH_DST :isundefined(Obj_path : 0~\[DST\])settclvar("textl","Where do you want to go today?
"),tcleval(" DisplayQuestionStextl" 1,setnewtoplevelslots( bj_concrete ),waitforevent (EVENT_TEXTINP UT),tcleval(" UndisplayQuestion" ),setoldtoplevelslots0,set( { Obj_path } : I~\[DST\], parse(%eti..text ) ),reevaluate().D ISAMBIGUATE : as aboveADD_PATH_SRC :isundefined({Obj.path} : 0~\[SRC\])set( Obj_path } : OH\[SaC\], Current..position~INDEX),CALC_PATH :isunique({Obj_path} : 0~\[DST I ADDFt J STI~EETNAME\]),isunique({Obj_path} 0~\[DST \] ADDI:t I STREETNUMBER\])set( Obj_path : 0~\[INDEX_DST\],gedntersection(l Obj_path} : 0~\[DST J ADDR I STREETNAME\] Obj_path} 0mIDST J ADDRI STREETNAME\])), calcpath(Obj_path : 0~\[PATHLST\], Obj_path : 0~\[INDEX..SRC\], Obj_path : 0~\[INDEX_DST\]).Figure 8: The rules used to calculate the shortest pathU: Show me how to get to the museumS: Where do you want to go?U: To the museum.S: Do you mean carnegie museum of naturalhistory, andy wartiol museum or fortpitt museum?U: the andy warhol museum.S: displays path to and icon of the museumIn our next example, we consider an informationsystem in which the user can query prices and char-acteristics of items, place orders, and obtain a billfor the the ordered items.
We suppose a price re-quest to be represented by a feature structure morespecific than the following :speechact_requestprice\]OBJECT obj JNow, the description of the objects may vary inspecificity which makes it refer to many differentobjects.
The desired behavior of the system is toenumerate the prices if the description refers to few(e.g., three) objects , or to display a price range ifthe description refers to many objects.
The rulesshown in figure 9 calculate the text containing theprice information.Remember that the variableSpeechact_requestprice : IS\[OBJECT\]is instantiated with the semantic representation fthe description as uttered by the user, the variableSpeechact_requestprice : 0R\[OBJECT\]104is instantiated with one object that is adequatelydescribed by the description and{Speechact_requestprice} : 0R\[OBJECT\]is instantiated with the underspecified represen-tation of all objects fitting the description.
The rulesare shown in figure 9.The condition of the first rule yields true if thedescription refers to more than three objects.
Forthis reason, the system paraphrased the noun phraseconveyed by the user to refer to the objects and theminimum and maximum prices are filled in a tem-plate.
If there are less than four objects, the secondrule will be evaluated.
Since the rule will be instanti-ated for each item represented in the underspecifiedfeature structure, the prices of all objects will beappended to the text variable.It is important to note that the system para-phrases the noun phrase it understood, using thetranslate predicate.
In this manner, feedback canbe conveyed to the user without explicitly asking aquestions.6 D iscuss ionWe proposed a multi blackboard architecture com-munication mechanism between different processingmodules in a dialogue system.
The agents formingpart of the processing modules implement a set ofprocedures.
We proposed that a set of expert systemlike rules can be used to mediate the communicationbetween different modules.
The rules are formed us-ing predicates and functions that are linked to pro-.-+PRICE_INFO_RANGE :isgreaterthan(num( { Speechact_requestprice }@OBJECT), 3)appendtclvar( "text"," The prices of"),appendtclvar("text", translate(Speechact_requestprice : I@\[OBJECT\])),appendtclvar( "text"," vary from"),appendtclvar("text", min( { Speechact_requestprice}@\[OBJECW \[ PRICE\]),appendtclvar( "text"," to"),appendtclvar("text", max( { Speechact_requestprice}@\[OBJECW \[ PRICE\]).PRICE_INFO_DETAILED :isgreaterthan(4, num( { Speechact_requestprice }@OBJECT) )appendtclvar("text", The price of"),appendtclvar( "text", transIate( SPEECHACT_REQUESTPKICE:i ~\[OBJECT\]) ),appendtclvar( "text", "is"),appendtclvar("text", Speechact_requestprice@\[OBJECW \[ PRICE\]),a ppendtclvar ( "text"," dollars").Figure 9: Therules generatingthetextto convey the prices ofitems.
Possible values ofthe variable texta~erhaving processed the rulesin the fast ~od application are The pr ices of our pizzas range from 3.995to 10.995 and The price of the large tomato salad is 4.505.
The price of the small tomatosalad is 3.505.cedures formulated in imperative programming lan-guage.
The purpose of the rules is twofold.
One,they provide a uniform access mechanism to pro-cedures that are implemented in a traditional im-perative programming language and that are linkedto the predicates.
Two, they control the human-computer interaction based on the specificity of theavailable information in discourse and databases.This causes the human-computer interaction to beinformation driven rather than controlled by a dia-logue model.Our approach as several advantages.
First, thereis a well-defined uniform access functionality be-tween representations i  the discourse and the pro-cedures operating on the representations.
The in-formation flow from the linguistic representations tothe procedures i governed by the rules and is nothard-coded.
This allows future extension of func-tionality.
Moreover, the dialogue program can pro-ceed dependent on the success of the operationsperformed.
Second, the dialogue is controlled by(i) the data stored in the different levels of thediscourse blackboard (including resolved databaserequests), (ii) the rules and (iii) the users input.No interaction is hard coded.
This makes the ap-proach information-driven.
Third, since the human-computer interaction is controlled by rules, rapidprototyping of different dialogue strategies i pos-sible by providing a different set of rules.
Sinceagents can also function as "wrappers" around exist-ing modules, providing uniform access to the func-tionality of the modules, existing modules can easilybe integrated.AcknowledgementsI would like to thank Alex Waibel, Wayne Ward andBernhard Suhm for discussions, advice and sugges-tions concerning the topics discussed in the paper.Furthermore, I would like to thank Minh Tue Vo andMarkus Baur for help by the implementation.
Also,I would like to thank the three anonymous reviewersfor their helpful comments.Re ferencesBob Carpenter.
The Logic of Typed Feature Struc-tures.
Cambridge University Press, 1992.L.D.
Erman and V.R.
Lesser.
The Hearsay-II SpeechUnderstanding System: A Tutorial In: Trendsin Speech Recognition, A.Waibel, K.F.Lee, (eds),pages 361-381, Prentice-Hall, 1980.Susann LuperFoy.
Implementing File Change Se-mantics for Spoken Language Dialogue ManagersESCA Workshop on Spoken Dialogue Systems,pages 181 - 184, Vigso, Denmark, 1995.Alex Waibel.
Interactive Translation of Conversa-tional Speech.
Computer, 29(7), July 1996.Wayne H. Ward.
Extracting Information in Spon-taneous Speech.
Proceedings off the InternationalConference on Speech and Language Processing,1994, Yokohama, Japan.105
