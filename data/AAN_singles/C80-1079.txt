AN EXPERIMENTAL APPLICATIVE PROGRAMMING LANGUAGEFOR LINGUISTICS AND STRING PROCESSINGP.A.C.
Bailes and L.H.
ReekerDeparTment of Computer Science, University of Queensland,St.
Lucia, Queensland, Auslralia 4067Summar~ been retained, and in fact,The Post-X language is designed toprovide facilities for pattern-directedprocessing of strings, sequences and trees inan integrated applicative format.improved.
In anapplicative framework, the pattern matchmust return a value that can be acted uponby other functions.
The pattern itself hasbeen generalized to a much more powerfuldata object, called the FORM.Post-X is an experimental languagedesigned for string processing, and for theother types of operations that one oftenundertakes in computational linguistics andlanguage data processing.In the design of Post-X, the followingfour goals have been foremost:(I) To modernize the Markov algorithm basedpattern matching paradigm, as embodied insuch languages as COMIT 13 and SNOBOL 8 ;(2) To provide a language useful incomputational linguistics and language dataprocessing, in particular, but hopefully withwider applicability;(3) To provide a vehicle for the study ofapplicative programming, as advocated byBackus , among others;(4) To provide a vehicle to study the applic-ation of natural language devices inprogramming languages, as advocated by Hsu 9and Reekerl~A FORM consists of a series ofalternative PATTERNS and related ACTIONS.Each pattern is very much like a pattern inSNOBOL4 (with some slight variations).
FORMSmay be passed parameters (by value), whichare then used in the pattern or action portion.A PATTERN determines the structure of thestring to which it is matched.
The patterncontains a sequence of concatenated elements,which are themselves PATTERNS, PRIMITIVEPATTERNS (utilizing most of the SNOBOL4primitives) or STRINGS.
The value returned bythe pattern is either FALSE (if it fails tomatch) or a "parse tree" designating thestructure of the string that corresponds toportions of the pattern.
As an example, supposethat a pattern is P:=p1^P2^...^pn"It may be matched to a string S=SoSl...s n bythe use of the operator '~in", and if each ofthe Pi match a successive letter s j, one canconceptualize the "tree" returned ass O s I ?
.. s n Sn+ IThe "X" in "Post-X" stands for"experimental", and is a warning that featuresof the language and its implementation maychange from one day to the next.
The eventualgoal is to produce a language designed forwide use, to be called "Post" (after thelogician Emil Post).
In this paper, we shallpresent some of the language's facilities forstring and tree processing.
A more detailedstatement of th~ rationale behind the languagecan be found in , and more~details of thelanguage are to be found in- .Pattern MatchingThe basic idea of using pattern matchingto direct a computation is found in the normalalgorithms of Markov, and was embodied in theearly string processing language COMIT.
Theseries of SNOBOL languages developed at BellLaboratories, culminating in SNOBOL4,improved a number of awkward features ofCOMIT and added some features of their own.Among these latter was the idea of patternsas data objects.Post-X incorporates patterns into anapplicative framework, which will be illus-tFated below.
In doing so, the powerfulpattern matching features of SNOBOL4 havewhere s O represents the unmatched portion tothe left of the matched portion and Sn+.
theportion to the right of the matched portion.The numbers I ..... n and the characters< and > in the example are SELECTORS, usedin the ACTION portion to refer to theappropriate substring.
The tree returned isdenoted by $$, and !
is used for selection,but $$!
can be condensed to $ in thiscontext, so the expression $ < returns s O inthe example above, while $ 2 returns s 2.
Theselectors give the effect of the shortpersistence variables that were found in COMIT,where they were denoted by numerals.
Thesevariables had the advantage of having theirscope limited to a single line of the program,thus minimizing the number of variablesdefined at any one time.
In Post-X, theselectors are local to a particular FORM.Each of the s may be a subtree, ratherthan a string.
In the example above, if Pl^P ^ .^Pin, then in were defined as P11be12the subtreeplace of s I wouldSll s12 Sln- -520- -where is the portion matched by P11 etc.Then s11Sllwould be referenced by $ I .
I.Composition of functions is often necess-ary.
For the composition of F and G, we writeF:G. For examplehead:sortwhere "head" gives the first element of asequence and "sort" sorts a sequence of stringsinto alphabetical order, defines a functionwhich operates on a sequence of strings andgives the first in alphabetical order.Certain natural variations in the syntaxare permitted.
For exampleexpression Iop expression 2is defined to be the same as(op):\[expression I, expression2\].The existence of a conditional functioncond \[a,b,c\]producing "b v' or "c" depending on "a" isvital; Post-X allows for a multi-way branch ofthe formifcondition I then expression Ielifcond i t ion  2 then express ion 2elifelse expressionfi nthe formdo sequence of namesexpressionodis an expression whose value is the functionwhich may be applied to a sequence ofepxressions, the value of each of which isgiven in the expression (in the d_o_o ... o d)by the corresponding name (i.e.
call-by-value).The value of the application is the value ofthe expression (with "substituted" parameters).User-defined functions are named by declarations,examples of which are given later, and definedI n  ?We have already discussed the bas,icpattern matching operation and the definitionof the FORMS used in that operation.
As maybe apparent from that discussion, contextfree parsing creates no difficulties.Thus we may defineE:=E^"+"^T I TT:=T^"*"^F I FF:=,,(,,^ E ,^,),, I ,,x,,Then the pattern matchE = "x+x*x"will return the tree(E)(E) + ~ T(E) + (T)(T) (T) * (~)(F) (F) xX XThe default action is to produce an unlabelledtree "compressed" by the elimination of singleoffspring nodes.
The example above is given bythe tree (pictorially).XX ~ Xor the sequence\[ \["x","+",E"x","x","x"7 \],"+","x"\]If a labelled phrase marker is desired, thenappropriate actions need to be attached.
Forinstance, if a parenthesized representationof the tree above with node labels added isdesired, the forms would be"E :=E ,^,+,,^  T {,,E\[,,^$ i^ ,,, +, ,,^  $3^,, \],, }1 T {"E\["^$ I^"\]"};T: =T ,^,.,, ^F {,,T\[,,^$ i^ ,,, *, ,, ^$3^,, \],, }I F {"T\["^$1 ^ "\]"};F:=,, (,, ^E^, ) ,, {,,F\[ (,,^ $2 ,^,) \],,}I "x"  {"FEM\ ] "} ;In the example above, the application of Ewould return"E\[E\[E\[T\[ F\[x\] \] \],+,T\[T\[ F\[x\] \], *, FEx\] \]\],+,T\[x\] \]"--521--Translation to a prefix representation ofthe arithmetic expression could, incidentally,be accomplished by a slight change in theactions:E:=E^"+"^T {"+"^$I ^$3}r T;T:=T^"*"^F {"*"^$I ^$3}I F;F:=" (" ^E^") ' {$2}"x";This time, E="x+x*x" would yield++X*XXX.Context sensitive - and even more complex- parsing can be effected by building programsinto the actions to give the effect ofaugmented transition networks.It should also be noted that the actionsneed not merely pass back a single value.Several values may be associated with a node,as in attribute grammars I0.
For exampleE'.--E^"+ ''^ T{value := $1.value + $3.value;code := $1.code^$3.code ^" add"}I T;T: =T ^ ''*'' ^Fava lue  := $1 .va lue  + $3 .va lue ;code := $1 .code^$3.code  ^" t imes"}I F;F:=,,("^E ,,),,{value := $2.value;code := $2.code}I span ("0'~.."9 ''){value := $I;code := " "^$I};(As In SNOBOL4, a numerical string in anumerical context is treated as a number.
)Reference to the attributes of a nodemay be made in several ways.
For example, inthe last grammar given, (E = "1+2*3").valuewould have the value 7, as would value(E="I+2"3") or (E="1+2*3")~"value"; and(E+"1+2*3").code would be evaluated as"I 2 3 times add".If it were considered desirableimmediately to evaluate the expression(returning 7 as the value of the match inthe example above) we can write this in theaction portion:E:=E^"+"^T {$I + $3}IT;T:=T^"*"^F {$I * $3}rF;F:='('^E^') f {$2}r span (0..9) {$I};Certain predefined patterns and pattern-returningfunctions are available, being closely modelledon those of SNOBOL4 e.g.
3any stringarbbreak stringspan stringarbno stringetc...I.Two ExamplesRandom Generation of SentencesGiven a context-free grammar as asequence of rules in BNF notation (i.e.
leftand right hand sides separated by "::=",nonterminals surrounded by angle brackets),we wish to randomly generate sentences fromthe grammar.
We shall assume for simplicitythat a pseudo-random number generator RANDOMis available which generates a number in anappropriate range each time that it is called.We assume also that the grammar is a stringof productions, separated by ";" and is calledGRAM.The program will utilize a form LHS_FINDto find a production with a particular lefthand side and return its right hand side.LHS FIND LHS := LHS^"::="^BREAK";"^";"{$3};The alternatives on the right hand sideare then converted to a sequence by thepattern ALT_LIST:ALT_LIST := BREAK "I ''^ 'ir'' {\[$1\]^(ALT_ LIST <$)>}I REM {\[$I\]};The particular alternative on the righthand side is chosen by the procedureSELECT RHS LIST := LIST !
((RANDOM MODSIZE(LIST))+I);The replacement in the evolving sententialform is accomplished byREPLACE GRAM := "<"^BREAK">"^"> '{$<^((REPLACE GRAM)<SELECT RHS(ALT LTST<(LHS--FIND $2 <GRAM)))%>}INULL{$$};--522--This form finds an occurrence of a nonterminal(it will find the leftmost as it is appliedbelow).
It uses this nonterminal as aparameter to LHS_FIND, which is applied tothe grammar GRAM to return the right handalternatives.
Then SELECT RHS selects analternative, which is plac~d in the contextof the nonterminal matched by the patternportion of the form.
Finally, REPLACE ismatched (recursively) to the result.
Ifthe first alternative fails, it means thatthere is no nonterminal.
In that case, thesecond alternative will be matched, and willreturn the entire string, which will be astring in the language generated by GRAM.The entire program will be invoked asRAND STRING GRAM := (REPLACE GRAM) <"<S>".This assumes that the root symbol is <S>.It should be noted that the parenthesescan be reduced by using the transformationavailable in Post-X into postfix notation,with the postfix composition operator ".
".Using this, one version of REPLACEGRAMwould be:REPLACE GRAM := "<"^BREAK">"^"> '{$<^GRAM.
(<(LHS FIND $2).
(<)ALT LIST.SELECT RHS.
(<)REPLACE GRAM^$>}INULL{$$};The freedom that this alternative notationprovides is one of the refreshing aspectsof Post-X.
(The particular transformationapplied here to REPLACE_GRAM is, incidentally,analogous to extraposition in English.)2.
A KWIC Index of TitlesIt is assumed that the input consistsof a sequence of titles.
It is desired toprovide a primitive alphabetized KWIC index.An input of \["An analysis of the Englishpresent perfect" "The role of the word inphonological development"\] will produce\["<An> analysis ..." "An <analysis> ...""... in phonological <development>" ... etc.\]The top-level program to do this is(I) KWIC :=(2) UNION ALPHA \[(<)\[PARTITION\]\].
(3) ALPHA \[(in) TAGFRONT\]\].
(4) SORT.
(5) ALPHA \[(<)\[REMOVETAG\]\];Line (2) applies the form PARTITIONto each string in the sequence.
PARTITIONwill "tag" each word in each string, byproducing a copy of the string with anglebrackets around the word, creating\[" An <analysis>...", "An <analysis> ...""An analysis <of> ..." ... etc.\] A sequenceis produced for each string in the originalsequence, and these are merged to form a singlesequence by the UNION function.Line (3) adds an occurrence of the "tagged"word to the beginning of each string.
Line (4)sorts the sequence obtained (SORT is a built-infunction), and Line (5) removes the word addedto the beginning of the string in line (3).The forms PARTITION, TAGFRONT, andREMOVE are defined as follows:PARTITION :=SPAN(,A,..,Z,) ^, ,{E'<'^$I^'>'^$2^$>\] ^ ,ALPHA:CAT\[S1\] (PARTITION<S>)}ISPAN('A'..'Z') {'<'^$1^'> '}The SPAN matches the first word, and the actionpar t  of the form places that word ($I) betweenangle brackets.
The PARTITION<$ portion of theaction returns a sequence of PARTITIONS ofthe rest of the string, and the first word isconcatenated onto the beginning of each ofthese.
When only one word remains, the secondalternative is used.TAG FRONT:='<'^BREAK'>'{$2 ^ , ,^@$$}The @$$ is the whole string (the "flattening"of tree $$ to a string), the $2 is the portionin angle brackets.
A copy of this is moved tothe beginning of the string.REMOVE TAG:=~PAN('A'..'Z') ' '{$>}This merely removes the string added at thebeginning of the sentence by removing thefirst word.Tree Processin 9 in Post-XTree processing facilities are pattern-directed and similar to string processingfacilities.
As pointed out earlier, labelledtrees may be represented as strings containingbrackets.
The pattern BAL, carried over fromSNOBOL4, is used to match a full, well-formedsubtree, but is extended to allow aspecification of the value of that tree.
Sometree functions are added for use in forms.The function FUSE fuses a sequence of subtreestogether at their top node, leaving the labelunchanged.
In a tree form, as illustrated--523--below, the use of a text string refers to asubtree with that label, but the function LABELwill return the label itself.
The functionRELABEL (tree, name) changes the label on asubtree to that named.Post-X tree processing facilities arecurrently undergoing a careful study, and may bechanged, but their present capabilities canbe illustrated by the specification of forms fortwo linguistic transformations in English,EQUI NP DELETION and THERE INSERTION:EQUI NP DELETION:=TREE("NP"^BAL^"S"^BAL("NP ''^BAL){If $I=$4~I then$I^$2^$3^$412}THERE INSERTION:=TREE("S"^BAL("NP"^BAL^"V ''^BAL^ARB){$1^FUSE("there"^$2~3 ^$2!2^$2~4))These can be compared to a "conventional"formulation :EQUI NP DELETION: X NP y \[NP Y\] ZS SStructural Index I, 2, 3, 4, 5, 6Structural Change I, 2, 3, 0, 5, 6where 2=4THERE INSERTION: X \[NP V 4\] Z2 SStructural Index I, 2, 3, 4, 5Structural Change I, THERE+3, 2, 4, 5Illustrating the application of these,THERE INSERTION in \[S\[NP\[Det\[A\]N\[boy\]\]VP\[V\[is\]PP\[Prep\[in\]NP\[Det\[the\]N\[garden\]\]\]\]\]\[S\[there V\[is\]NP\[Det\[A\]N\[boy\]\]PP\[Prep\[in\]NP\[Det\[the\]N\[garden\]\]\]\]\]\].Tree forms are not as natural as they mightbe, and changes can be expected, with the majorgoal being to make their use as closelyanalogous to that of strings as possible.SequencesPost-X has a number of facilities thatapply generally to sequences of items.
Thesehave been illustrated in the examples by, forinstance, the operator ALPHA, which appliesa function to each element of a sequence, andUNION, which takes a sequence of sequences andcreates a single sequence.Less obvious, perhaps, is the fact thatstrings and unlabelled trees are themselvessequences; in fact, sequences form theunifying notion within Post-X data structures.There remains work to be done to determine howeffectively one can generalize pattern directedprocessing to sequences without adding too muchcomplexity to the language.The LISP programmer will tend to identifysequences with lists, in the sense of thatlanguage.
There are differences, however.
Thefacilities in LISP are oriented toward listsas right-branching binary trees, and thoughone can build LISP functions to overcome this,the programmer generally must manage the listswith their links in mind.
In Post-X, theprogrammer is encouraged to deal with thesequence directly, as one becomes accustomedto dealing with strings directly in a stringprocessing language.DiscussionThe SNOBOL4 language has had few competit-ors over the years as a general string-process-ing language.
Its development and distributionwere undertaken by Bell Laboratories, and thusit has been widely available for more than adecade.
Yet SNOBOL4 has never been as widelyused for large applications, including thosein computational linguistics, as one mightexpect, and in the light of a decade'sexperience, it is possible to identifyvarious difficulties that account for this.The basic string processing operation ofSNOBOL4, pattern matching, is not the sourceof these difficulties.
In fact, SNOBOL4pattern matching provides a high-level-data-directed facility that should be a standardfor other languages.
The major problems werein the fact that the pattern-matching wasnever sufficiently eeneralized, leading to aII l i t  linguistic schism , that the syntacticconventions of SNOBOL4 led to difficultiesand poor structuring 5 , and that thenecessity of constantly assigning values tostring variables was clumsy and tended toobscure the semantics of all but the simplestprogramsRecently, various attempts have beenmade to remedy the problems mentioned above.But to give up pattern matching, as inIcon 7 or to resort to a less rich vocabularyof patterns, as in Poplar11(despite which,the latter language has a good deal of merit),is to "discard the baby with the bathwater".Post-X is the result of attempts to extendpattern matching and to improve it, at thesame time providing a more natural, flexibleand comprehensible linguistic vehicle.--524--ReferencesI.
Backus, John \[78\], Can programming beliberated from the Van Neumann style?.A functional style and its algebra ofprograms, CACM voi.21, no.8, August, 1978,613-641.2.
Bailes, P.A.C., and Reeker, L.H.\[80\], Post-X: An Experiment in Language Design forString Processing, Australian ComputerSciehce Communications.
Vol.2, no.2, March,1980, 252-267.3.
Bailes, P.A.C., and Reeker, L.H.
\[80\], TheRevised Post-X programming language,Technical Report no.17, Computer ScienceDepartment, University of Queensland.4.
Galler, B.A., and Perlis, A.J.
\[70\],A View of Programming Languages, Addison-Wesley, Reading, Massachusetts.5.
Gimpel, J.F.
\[76\], Algorithms in SNOBOL4,John Wiley, New York.6.
Griswold, R.E.
\[79\], the ICON ProgrammingLanguage, Proceedings,ACM NationalConference 1979, 8-13.7.
Griswold, R.E., and Hanson, D.R.\[80\], AnAlternative to the Use of Patterns inString Processing, ACM Transactions onProgramming Languages and Systems,Vol 2,no.2, April, 1980, 153-172.8.
Griswold, R.E., Poage,J.F., and Polonsky,I.P.
\[71\], The SNOBOL4 Programming Language,Prentice-Hall, Englewood'Cliffs, NewJersey.9.
Hsu, R. \[78\]Readability:Proceedingspon Systems.?
Grammatical Function andthe syntax of loop constructs,Hawaii International Conference10.
Knuth, D.E.
\[65\], On the translation ofLanguages from left to right, Informationand Control, vol.8, no.6, 607-639.11.
Morris, J.H., Schmidt, E., and Walker, P.\[80\], Experience with an Applicative StringProcessing Language, P rOc.Sixth ACM Symp.on Principles of Programming Languages.12.
Reeker, L.H.\[79\], Natural language devicesfor programming readability: embedding andidentifier load, Proceedings of the 2ndAustralian Computer Science Conferen'ce,University of Tasmania, 160-167.13.
Yngve, V. \[58\], A programming languagefor mechanical translation, MechanicalTranslation, vol 5, no.l, 25-41., - -525- -
