ON THE DECIDABIL ITY  OF FUNCTIONAL UNCERTAINTY*Rol f  BackofenGerman Research  Center  for Art i f ic ial  Inte l l igence (DFK I )W-6600 Saarbrf icken,  Germanybackofen@dfk i .un i -sb .deAbst rac tWe show that feature logic extended by functionaluncertainty is decidable, even if one admits cyclicdescriptions.
We present an algorithm, whichsolves feature descriptions containing functional un-certainty in two phases, both phases using a set of de-terministic and non-deterministic rewrite rules.
Wethen compare our algorithm with the one of Kaplanand Maxwell, that does not cover cyclic feature de-scriptions.1 In t roduct ionFeature logic is the main device of unification gram-mars, the currently predominant paradigm in com-putational inguistics.
More recently, feature de-scriptions have been proposed as a constraint systemfor logic programming (e.g.
see \[ l l  D .
They providefor partial descriptions of abstract objects by meansof functional attributes called features.Formalizations of feature logic have been proposedin various forms (for more details see \[3\] in this vol-ume).
We will follow the logical approach intro-duced by Smolka \[9, 10\], where feature descriptionsare standard first order formulae interpreted in firstorder structures.
In this formalization features areconsidered as functional relations.
Atomic formulae(which we will call atomic constraints) are of eitherthe form A(x) or z fy ,  where x, y are first order vari-ables, A is some sort predicate and f is a feature(written in infix notation).
The constraints of theform xfy  can be generalized to constraints of theform xwy,  where w = f l - .
.
fn is a finite feature path.This does not affect the computational properties.In this paper we will be concerned with an ex-tension to feature descriptions, which has been in-troduced as "functional uncertainty" by Kaplan andZaenen \[7\] and Kaplan and Maxwell \[5\].
This for-mal device plays an important role in the frameworkof LFG in modelling so-called long distance depen-dencies and constituent coordination.
For a detailedlinguistic motivation see \[7\], \[6\] and \[5\]; a more gen-eral use of functional uncertainty can be found in \[8\].Functional uncertainty consists of constraints of*This work was supported by a research grant,ITW 9002 0, from the German Bundesministerium ffirForschung und Technologic to the DFKI project DISCO.I would like to thank Jochen Dhrre, Joachim Niehren andRalf Treinen for reading draft version of this paper.
Forspace limitations most of the proofs are omitted; theycan be found in the complete paper \[2\]the form xLy,  where L is a finite description ofa regular language of feature paths.
A constraintxLy  holds if there is a path w E L such that zwyholds.
Under this existential interpretation, a con-straint xLy  can be seen as the disjunction= I ,.,, e xLy L}.Certainly, this disjunction may be infinite, thusfunctional uncertainty ields additional expressivity.Note that a constraint zwy is a special case of a func-tional uncertainty constraint.To see some possible application of functional un-certainty we briefly recall an example that is given inKaplan and Maxwell \[5, page 1\].
Consider the top-icalized sentence Mary John telephoned yesterday.Using s as a variable denoting the whole sentence,the LFG-like clause s topic x A s obj x specifies thatin s Mary should be interpreted as the object of therelation telephoned.
The sentence could be extendedby introducing additional complement predicates, ase.g.
in sentences like Mary John claimed thai Billtelephoned; Mary John claimed thai Bill said that.
.
.Henry  telephoned yesterday; .
.
.
.
For this fam-ily of sentences the clauses s topic x A s comp obj x,s topic xAs  comp cornp obj x and so on would be ap-propriate; specifying all possibilities would yield aninfinite disjunction.
This changes if we make use offunctional uncertainty allowing to specify the aboveas the single clause s topic x A s comp* obj x.Kaplan and Maxwell \[5\] have shown that consis-tency of feature descriptions is decidable, providedthat a certain aeyclicity condition is met.
More re-cently, Bander et hi.
\[1\] have proven, that consistencyis not decidable if we add negation.
But it is an openproblem whether consistency of feature descriptionswithout negation and without additional restrictions(such as acyclicity) is decidable.
In the work pre-sented here we show that it indeed is decidable.2 ' \]?he MethodWe will first briefly describe the main part of solvingthe standard feature terms and then turn to theirextension with functional uncertainty.Consider a clause ?
= xply l  A xpzy2 (from now onwe will refer to pure conjunctive formulae as clauses).A standard method for solving feature terms wouldrewrite ?
in order to achieve a solved form.
Thisrewriting depends on the paths Pl and Pz.
If Plequals Pz, we know that yl and Y2 must be equal.This implies that ?
is equivalent to xplyx Ayl -- Yz.
If201p~ is a prefix of p2 and hence P2 = P~P~, we can trans-form ?
equivalently into the formulae xplyi A YlP'Y2.The reverse case is treated in a similar'fashion.
Ifneither prefix or equality holds between the paths,there is nothing to be done.
By and large, clauseswhere this holds for every x and every pair of differ-ent constraints xp~y and xp2z are the solved formsin Smolka \[9\], which are consistent.If we consider a clause of the form ?
= zL~y~ AzL2y~, then we again have to check the relation be-tween ys and y~.
But now there is in general nounique relation determined by ?, since this dependson which paths p~ and P2 we choose out of L~ andL~.
Hence, we have to guess the relation between pland p~ before we can calculate the relation betweenyl and y~.
However, there is a problem with theoriginal syntax, namely that it does not allow one toexpress any relation between the chosen paths (in alater section we will compare our algorithm to theone of Kaplan/Maxwell, thus showing where exactlythe problem occurs in their syntax).
Therefore, weextend the syntax by introducing so-called path vari-ables (written c~, fl, a ' , .
.
. )
,  which are interpreted asfeature paths (we will call the other variables firstorder variables).
Hence, if we use the modified sub-term relation xo~y and a restriction constraint o~ ~ L,a constraint xLy can equivalently be expressed asxay A a ~ L (4 new).
The interpretation of xay isdone in two steps.
Given a valuation V~, of the pathvariables as feature paths, a constraint =c~y in ?
issubstituted by xV~,(cQy.
This constraint is then in-terpreted using the valuation for the first order vari-ables in the way such constraints are usually inter-preted.By using this extended (two-sorted) syntax we arenow able to reason about the relations between dif-ferent path variables.
In doing so, we introduce ad-ditional constraints c~ - fl (equality), o~ ~ fl (prefix)and c~ fl fl (divergence).
Divergence holds if neitherequality nor prefix holds.
Now we can describe a nor-mal form equivalent to the solved clauses in Smolka'swork, which we will call pre-solved clauses.
A clause?
is pre-solved iff for each pair of different constraintxayl and x~y2 in ~b there is a constraint a I\] ~ in ?.We call this clauses pre-solved, since such clauses arenot necessarily consistent.
It may happen, that thedivergence constraints together with the restrictionsof form a ~ L are inconsistent (e.g.
think of the clausea~ f+ A ~ ~ f f+  A (~ fl fl).
But pre-solved clauseshave the property, that if we find a valuation for thepath variables, then the clause is consistent.Our algorithm first transforms a clause into a setof pre-solved clauses, which is (seen as a disjunction)equivalent to the initial clause.
In a second phase thepre-solved clauses are checked for consistency withrespect to the path variables.
In this paper we willconcentrate on the first phase, since it is the moredifficult one.Before looking at the technical part we will illus-trate the first phase.
For the rest of the paper wewill write clauses as sets of atomic constraints.
Nowconsider the clause 7 = {xay, al ~ L1, xflz, fl~ L2}.The first step is to guess the relation between thepath variables c~ and ft.
Therefore, 7 can be ex-pressed equivalently by the set of clauses71 = {4  ,) ~} u 7 73 = {~ ~ ~} u 772 = {,~ - ~} u 7 74 = {~ -~ ,~} u 7The clause 71 is pre-solved.
For the others we haveto evaluate the relation between a and \]Y, which isdone as follows.
For 72 we substitute/~ by ot and zby y, which yields{y "--z, xay, o~E L1, aEL2}.We keep only the equality constraint for the first or-der variables, since we are only interested in their val-uation.
Combining {4 ~ L1, a ~ L2} to {4 ~ (L1 f')L2)}then will give us the equivalent pre~solved clauseFor 73 we know that the variable/3 can be splitinto two parts, one of them covered by 4.
We canuse concatenation of path variables to express this,i.e.
we can replace fl by the term c~.fl', where ~' isnew.
Thus we get the clause7~ - {xc~y, a~ L1, yfl' z, c~.fl'~L2},The only thing that we have to do additionally inorder to achieve a pre-solved clause is to resolve theconstraint a./~ ~ ~ L2.
To do this we have to guess aso-called decomposition P, S of L2 with P.S C_ L2such that a ~ P and \]~' ~ S. In general, there can bean infinite number of decompositions (think of thepossible decompositions of the language f 'g ) .
Butas we use regular languages, there is a finite set ofregular decompositions covering all possibilities.
Fi-nally, reducing {c~ ~ L~, ~ ~ P} to {~ ~ (L1 n P)} willyield a pre-solved clause.Note that the evaluation of the prefix relation in73 has the additional effect of introducing a new con-straint y~z.
This implies that there again may besome path variables the relation of which is unknown.Hence, after reducing the terms of form a --" \]~ or~ fl we may have to repeat the non-deterministicchoice of relations between path variables.
In theend, the only remaining constraints between pathvariables will be of the form a fl ft.We have to consider some additional point, namelythat the rules we present will (naturally) loop in somecases.
Roughly speaking, one can say that this al-ways occurs if a cycle in the graph coincides witha cycle in the regular language.
To see this let usvary the above example and let 7 now be the clause{xax, c~ ~ f, xflz, fl ~ f 'g}.
Then a possible loopingderivation could be1.
adda4\ ]~:{4 4 fl, xax, a~f, xflz, fl~f*g}2. split fl into a-f~':3. decompose c~-/~ I  f 'g:{=~, ~f ,  ~f~'~, a~f*, Z'~f*g}2024. join a-restrictions:{=~z, ~ I ,  ~/~'z, ~'~y*g}However, we will proof that the rule system isquasi-terminating, which means that the rule systemmay cycle, but produces only finitely many differentclauses (see \[4\]).
This means that checking for cyclicderivations will give us an effective algorithm.Quasi-termination is achieved by the followingmeasures: first we will guarantee that the rules donot introduce additional variables; second we restrictconcatenation to length 2; and third we will showthat the rules system produces only finitely manyregular languages.
In order to show that our rewritesystem is complete, we also have to show that everysolution can be found in a pre-solved clause.3 P re l iminar iesOur signature consists of a set of sorts S (A, B , .
.
. )
,first order variables X (z ,y , .
.
. )
,  path variables 7 9(a,/3, .
.
. )
and features Jr (f,  g, .
.
. )
.
We will assumea finite set of features and infinite sets of variablesand sorts.
A path is a finite string of features.
Apath u is a prefix of a path v (written u ~ v) if thereis a non-empty path w such that v = uw.
Note thatis neither symmetric nor reflexive.
Two paths u, vdiverge (written u n v) if there are features f,  g withf ~ g and possibly empty paths w, wl, w2 such thatu = wfw~ A v = wgw2.
Clearly, n is a symmetricrelation.P ropos i t ion  3.1 Given two paths u and v, then ex-actly one of the relations u = v, u .~ v, u ~- v oru II vholds.A path term (p, q .
.
.
.  )
is either a path variable a ora concatenation of path variables a.fl.
We will allowcomplex path terms only in divergence constraintsand not in prefix or equality constraints.
Hence, theset of atomic constraints is given bye ~ Az  sort restrictionz ":- y agreementz f~ .
.
.
.
.
fn  Y subterm agreement 1zo~y subterm agreement 2p~ L path restrictionp fi q divergence~ \[3 prefixc~ - fl path equalityWe exclude empty paths in subterm agreement sincexey is equivalent o x - y.
Therefore, we requiref l " .
.
. '
fn  E ~r+ and L C_ jr+.A clause is a finite set of atomic constraint de-noting their conjunction.
We will say that a pathterm a.fl is contained (or used) in some clause ?
if?
contains either a constraint a-fl ~ L or a constrainta.fl ti q )  Constraints of the form p~ L, p fl q, a :~ fland c~ - fl will be called path constraints.An interpretation Z is a standard first order struc-ture, where every feature f ~ ~ is interpreted as a bi-nary, functional relation F z and where sort symbolsWe will not differentiate between p fl q and q ~ p.are interpreted as unary, disjoint predicates (henceA zOBz= 0 for A 5?
B).
A valuation is a pair(Vx, VT~), where Vx is a standard first order valu-ation of the variables in X and Vv is a functionV~v : P ---+ ~'+.
We define V~,(a.fl) to be VT,(a)V~,(13),The validity of an atomic constraint in an inter-pretation 2" under a valuation (Vx, V~,) is defined asfollows:(Vx, V~,) ~z Ax :?=:~ Vx(x) e A z(Vx, Vr) Pz = - Y :?=~ Vx(=) = Vx(U)(vx,vr)  ~z zpy(vx, vv) ~z =.u(vx, vT~) ~z p e L(Vx, VT~) ~z pbq:?=, vx(~) F?
0. .
.o  F, ~ Vx(y):?
:=~ (Vx, Vv) ~z ?
Vv(a) y:?==~ V~,(p) C L:?
::~ Vp(p) o VT~(q)for aC  {u,k,--" },where p is the path f l " .
.
. '
f ,  and F/z are the inter-pretations of fi in Z.For a set ~ C X we define =?
to be the followingrelation on first order valuation:Vx =~ V/~ iff W e ~ : Vx(~) = V/~(x).Similarly, we define =~ with 7r C 79 for path valua-tions.
Let 0 C_ XU79 be a set of variables.
For a giveninterpretation 7:we say that a valuation (Vx, V~) isa O-solution of a clause ?
in 2" if there is a valuation(V~, V~) in 2" such that Vx =a'ne V~:, Vp =~,no V~and (V~:, V~) ~z  ?.
The set of all 0-solutions of ?
in2: is denoted by \[?\]~.
We will call X-solutions justsolutions and write \ [?\]z instead of \[?\],~.For checking satisfiability we will use transfor-mation rules.
A rule R is O-sound ?
--*n 7\ [?\]z D \[7\]~ z for every interpretation 2".
R is calledO-preserving if ?
"+R 3' :?"
\[?\]Z C \[7\]~.
R is globallyO-preservingif \ [?\]z C_ U \[7\]$-?--*n74 The  F i r s t  Phase4.1 A Set of  RulesRecall that we have switched from the original syntaxto a (two-sorted) syntax by translating constraintszLy  into {zay, ~ ~ L}, where a is new.
The result ofthe translation constitutes a special class of clauses,namely the class of prime clauses, which will be de-fined below.
Hence, it suffices to show decidabilityof consistency of prime clauses.
They are the inputclauses for the first phase.Let ?
be some clause and z, y be different vari-ables.
We say that ?
binds y t0 z if z - y E ?
and yoccurs only once in ?.
Here it is important hat weconsider equations as directed, i.e.
we assume thatz -" y is different from y - x.
We say that ?
elimi-nates y if ?
binds y to some variable x.
A clause iscalled basic if1.
x - y appears in ?
iff ?
eliminates y,2.
For every path variable a used in ?
there is atmost one constraint zc~y E ?.203(Eq) {c~ - /3,  zay, x/3z) U ?
{v - z, ~v}  u ?\[/3.---, ~.--u\](Pre) {'~ "~ /3' z~y, x/3z) U ?
{x~,v} u {v/3z} u ?\[/3.- ~./3\](Join) {a ~ L, ~ ~ L'} U ?
L :/: L'{,~ ~ (L n L')} U ?
(Divl) {a fi/3') U {a./3 fi/3'} U ?
{~ ii y}  u ?
(Div2) {a-/3 fi ~./3'} U ?
{/3fi y} u?J_(DClashl) {a'/3 fi a} U ?_L(DClash2) {o~ fi a} U ?J_(Empty) {a ~ 0) O ?_LFigure 1: Simplification rules.
Note that (Pre) does not introduce a new variable.A basic clause ?
is called prime if ?
does not containan atomic constraint of the form p fl q, c~ -~/3 or ot -/3.
Every clause ?
in the original Kaplan/Maxwellsyntax can be translated into a prime clause 7 suchthat ?
is consistent iff 9' is consistent.Now let's turn to the output clauses of the firststep.
A basic clause is said to be pre-soived if thefollowing holds:1.
Ax 6 ?
and Bz 6 ?5 implies A - B.2.
c~ d L 6 ?
and a d L' 6 ?
implies L = L*.Furthermore, a d O is not in ?.3.
a-/3, c~ - /3  or a ~/3 are not contained in ?.4.
a f l /36?
i f fa~/3 ,  x (~y6?andz /3z6?
.Lemma 4.1 A pre-soived clause ?
is consistent iffthere is a path valuation V~, with VT~ ~ Cp, where Cpis the set of path constraints in ~.Now let's turn to the rule system.
As wehave explained informally, the first rule adds non-deterministiely relational constraints between pathvariables.
In one step we will add the relations be-tween one fixed variable a and all other path vari-ables/3 which are used under the same node x as a.Furthermore, we will consider only the constraints- /3, c~ fl /3 and a ~ /3 and not additionally theconstraint a 9/3.For better readability we will use pseudo-code fordescribing this rule (using the usual don't care/don'tknow distinction for non-determinism):(PathRel)Choose x 6 l)arsx(?)
(don't care)Choose xay 6 ?
(don't know)For each x/3z 6 ?
wi th  c~ #/3 and c~ fl/3 ~ ?add  a 6~/3 with 5Z 6 { - ,  4~, fl} (don't know)"don't care non-determinism" means that one isfree to choose an arbitrary alternative at this choosepoint, whereas "don't know" means that one has toconsider every alternative in parallel (i.e.
for every al-ternative of the don't care non-determinism a clause?
is equivalent to the set of all don't know alterna-tives that can be generated by applying the rule to?).
Note that the order of rule application is anotherexample for don't care non-determinism in our rulesystem.Although we have restricted the relations 6~ to{ - ,  :(, u}, this rule is globally preserving since wehave non-deterministically chosen zay.
To see thislet ?
be a clause, 27 be an interpretation and (Vx, VT~)be a valuation in 27 with (Vx, V~) ~z  ?.
To find aninstance of (PathRel) such that (Vx, V~,) ~z  7 where3' is the result of applying this instance, we choosexay 6 ?
with V~(a) is prefix minimal in{v~@ 1~/3z ~ ?
}.Then for each x/3z 6 ?
with a #/3  and ~ fi /3 ~ ?we add a 6~ /3 where Vp(a) o~ V~(/3) holds.
Notethat 5 0 equals ~ will not occur since we have cho-sen a path variable a whose interpretation is prefixminimal.
Therefore, the restriction 6~ 6 {- ,  k, fi} issatisfied.We have defined (PathRel) in a very special way.The reason for this is that only by using this spe-cial definition we can maintain the condition thatconcatenation of path variables is restricted to bi-nary concatenation.
E g. assume that we would haveadded both /31 "~ O~ and a :?
/32 to a clause 7.
Thenfirst splitting up the variable a into/31 .a' and then132 into a./3~ will result in a substitution of/32 in 7by/31"a"/3~.
By the definition of (PathRel) we haveensured that this does not occur.The second non-deterministic rule is used in thedecomposition of regular languages.
For decomposi-tion we have the following rules:(DecClash) {a./3~L} O ?
{w e L llwl > 1} = g _L(LangDecn) {a.fl ~ L) U ?
P.S C L{o~P} U {/3~S} U?where P, S, L C F + and A is a finite set ofreg.
languages with L, P, S 6 A. L mustcontain a word w with \[w\[ > 1.The clash rule is needed since we require regular lan-guages not to contain the empty path.
The remain-ing rules are listed in Figure 1.We use A in (LangDecA) as a global restriction,i.e.
for every A we get an different rule (LangDecA)(and hence a different rule system 7~A).
This is donebecause the rule system is quasi-terminating.
Byrestricting (LangDeca) we can guarantee that onlyfinitely many regular languages are produced.204For (LangDec^) to be globally preserving we needto find a suitable pair P, S in A for every possiblevaluation of (~ and \]3.
Therefore, we require A tosatisfyVL E A, Vwl, w2 ~ e : \[WlW 2E L =:~BP, S e A : (P.S C_ L A Wl E PAw2 e S)\].We will call A closed under decomposition if it sat-isfies this condition.
Additionally we have to ensurethat L E A for every L that is contained in someclause ?.
We will call such a set A C-closed.
Surely,we will not find a finite A that is closed under de-composition and C-closed for arbitrary ?.
But thenext lemma states some weaker condition that suf-fices.
We say that 7 is a (?,TiA)-derivative if 7 isderivable from C by using only rules from 7~h.
If R^is clear from the context, we will just say that 7 is aC-derivative.Lemma 4.21.
If A is C-closed and closed under intersection,then A is 7-closed for all (C, T~h)-derivaLives 7.2.
For every prime clause C there is a finite A suchthat A is C-closed and closed under intersectionand decomposition.The proof of this lemma (containing the construc-tion of the set A) can be found in the appendix.4.2 Completeness  and  Quas i -Terminat ionThe rule system serves for an algorithm to transforma prime clause into an equivalent set of pre-solvedclauses.
The rules are applied in arbitrary order un-til a pre-solved clause has been derived.
If one of thenon-deterministic rules is applied, a clause is sub-stituted by a whole set of clauses, one for each ofthe don't know alternatives.
Since the rule systemis quasi-terminating, we may encounter cycles dur-ing the application of the rules.
In this case we skipthe corresponding alternative, since every pre-solvedclause that can be produced via a cyclic derivationcan also be produced via a derivation that does notcontain a cycle.Theorem 4.3 Let ?
be a prime clause.
If A is C-closed, closed under intersection and decomposition,then \[\[C\] z = U.y~ \[\[7\] z for every interpretation Z,where ?b is the set of pre-solved (C, T~^)-derivatives.The set (9 is finite and effectively computable.To prove this theorem we have to show that therule system is sound and complete.
Sound means,that we do not add new solutions during the pro-cessing, whereas complete means that we find all so-lutions in the set of pre-solved erivatives.For the completeness it normally suffices to showthat (1) every rule preserves (or globally preserves)the initial solutions and (2) the pre-solved clausesare exactly the T~h-irreducible clause (i.e.
if a clauseis not pre-solved, then one rule applies).
But in ourcase this is not sufficient as the rule system is quasi-terminating.
A prime clause ?
may have a solutionVx which is a solution of all (C, T~A)-derivatives insome cyclic derivation, but can not be found in anypre-solved (?, T~h)-derivative.
We have to show thatthis cannot happen.
Since this part of the proof isunusual, we will explain the main idea (see the ap-pendix for a more detailed outline of the proofs).Let ?
be some (consistent) prime clause and letVx E ~?\]z for some Z.
Then there exists a path val-uation Vp such that (Vx, V~) ~z  ?.
We will find apre-solved C-derivative that has Vx as a solution byimposing an additional control that depends on V~,.This control will guarantee (1) finiteness of deriva-tions, (2) that each derivation ends with a pre-solvedclause, (3) the initial solution is a solution of everyclause that is derivable under this control.
Since the(Pre) rule does not preserve the initial path valua-tion V~, (recall that the variable fl is substituted bythe term a.~), we have to change the path valuationV~, every time (Pre) is applied.
It is important to no-tice that this control is only used for proof purposesand not part of the algorithm.
For the algorithm itsuffices to encounter all pre-solved e-derivatives.To understand this control, we will comparederivations in our syntax to derivations in standardfeature logic.
Recall that we have a two-level inter-pretation.
A constraint xay is valid under Vx andV~ if xV~(c~)y is valid under Vx.
Hence, for eachclause ?
and each valuation Vx, Vp with C valid un-der Vx and Vp there is a clause Cv~ in standardfeature logic syntax (not containing functional un-certainty) such that ?v~ is valid under Vx.
E.g.
forthe clause {xax, a~f,  xflz, fl~f*g} and a path val-uation V~, with VT,(a) = f and V~,(j3) = g the clauseCv~, is {xfx, xgy}.
The control we have mentionedrequires (by and large) that only those rewrite ruleswill be applied, that are compatible to the clauseCv~ and thus preserve Vx.
If one of the rules (Eq)or (Pre) is applied, we also have to rewrite Cv~.
Tak-ing the above example, we are only allowed to adda l i  fl to C (using (PathRel)), since ev~ is already inpre-solved form.Now let's vary the example and let Vp be a pathvaluation with V~,(a) = f and V~,(f~) = Hg.
Thenwe have to add a ~ /3 in the first step, since thisrelation holds between a and ft.
The next step isto apply (Pre) on a :~ /3.
Here we have to rewriteboth ?
and Cv~.
Hence, the new clauses ?1 and evvare {xax, a~f,  x/3z, a./3~ f*g} and {x f x, x fgy}respectively.
Note that the constraint xf fgy  hasbeen reduced to x fg y by the application of (Pre).Since infinite derivations must infinitely often use(Pre), this control guarantees that we find a pre-solved clause that has Vx as a solution.5 The  Second PhaseIn the second phase we have to check consistencyof pre-solved clauses.
As we have mentioned, a pre-solved clause is consistent if we find some appropri-ate path valuation.
This means that we have tocheck the consistency of divergence constraints ofthe form al  fi a2 together with path restrictions205al ~ L1 and a2 ~ L2.
A constraint al  ti a2 isva|id under some valuation V~, if there are (possi-bly empty) words w, wl, w2 and features' f  ~ g suchthat V~,(al) = WfWl and V~,(c~2) = wgw2.
This def-inition could directly be used for a rewrite rule thatsolves a single divergence constraint, which gives us{al fi ct2} U?
f#g,  ~,~1 2newwhere ? '
= ?\ [a l  ~--/?.a~,a2 ~/3.a~\] .
By the ap-plication of this rule we will get constraints of theform j3.a~ ~ L1 and fl.a~ ~ L2.
Decomposing theserestriction constraints and joining the correspond-ing path restrictions for ~ and ~,~ will result in{fl~ (Pl nP2) ,  ~i ~ (S~:*ns , ) ,  ,~ (g~'*MS2)}with PI.S~ C L~ and P2.S2 C_ L~, which completesthe consistency check.Additionally, one has to consider the effects of in-troducing the path terms/~.a~.
The main part of thistask is to resolve constraints of the form fl.tr~ li tr.There are two possibilities: Either a has also f~ asan prefix, in which case we have to add fl ~ a; orfl is not a prefix of c~, which means that we have toadd c~ fl ft. After doing this, the introduced prefixconstraints have to be evaluated using (Pre).
(In theappendix we present a solution which is more appro-priate for proofing termination).6 Kap lan  and  Maxwel l ' s  MethodWe are now able to compare our method with theone used by Kaplan and Maxwell.
In our method,the non-deterministic addition of path relation andthe evaluation of these relations are done at differenttimes.
The evaluation of the introduced constraintsc~ - fl and o~ :?
fl are done after (PathRel) in the firstphase of the algorithm, whereas the evaluation of thedivergence constraints is done in a separate secondphase.In Kaplan and Maxwell's algorithm all thesesteps are combined into one single rule.
Roughly,they substitute a clause {xL~y, xL2z, } O ?
non-deterministicly by one of the following clauses: ~{ x(L~f3L~)y, x -y}U?
{ x(L~f3P)y, ySz  }U?
P.SC_L~{ x(L~NP)z,  zSy  }U?
P.S C L1{ x(P1NP2)u, u(f.S1)y, u(g.S2)z }U?
withPI'f'S~ C_ L~, P2"g'S~ C_ L~, f # g, u newRecall that {XLly, xL2z} is expressed in our syntaxby the clause 3' = {xay, o~ ~ L1, x~z, j~ ~ L2}, whichis the example we have used on page 2.
The firstthree cases correspond exactly to the result of the2This is not the way their algorithm was originallydescribed in \[5\] as they use a slightly different syntax.Furthermore, they don't use non-deterministic rules, butuse a single rule that produces a disjunction.
However,the way we describe their method seems to be more ap-propriate in comparing both approaches.derivations that have been described for 72, 73 and3'4.
By and large, the last case is achieved if we firstadd c~ \[I ~ to 3' and then turn over to the secondphase as described in the last section.The problem with Kaplan/Maxwell 's algorithm isthat one has to introduce a new variable u in the lastcase, since there is no other possibility to express di-vergence.
If their rule system is applied to a cyc!icdescription, it will not terminate as the last part in-troduces new variables.
Hence it cannot be used foran algorithm in case of cyclic descriptions.The delaying of the evaluation of divergence con-straint may not only be useful when applied tocyclic feature descriptions.
As Kaplan and Maxwellpointed out, it is in general useful to postpone theconsistency check for functional uncertainty.
Withthe algorithm we have described it is also possibleto delay single parts of the evaluation of constraintscontaining functional uncertainty.Append ixP roo f  o f  Lemma 4.2.
The first claim is easyto prove.
For the second claim let {L1 , .
.
.
, Ln}  CP (~+)  be the set of regular languages used in ?
andlet .Ai = (Q.4~, i.4~, cr a~, Fin.4~) be finite, determinis-tic automatons such that .A i recognizes Li.
For each.Ai we define dec(.Ai) to be the setdee(A/) = {L~ \]p,q E QJt,},whereL~ = {w E 2 "+ I a~,(p,w) = q}.
It is easyto show that dec(.Ai) is a set of regular languagesthat contains Li and is closed under decomposition.Hence, the set A0 = \[.Jinx dec (Ai) contains each Liand is closed under decomposition.
Let A = fi (A0)be the least set that contains A0 and is closed underintersection.
Then A is finite and e-closed, since itcontains each Li.We will prove that A is also closed under decompo-sition.
Given some L E A and a word w = wlw2 E L,we have to find an appropriate decomposition P, Sin A.
Since each L in A can be written as a finitem L intersection L = Nk=l i~ where Lik is in A0, weknow that w = wlw2 is in Li~ for 1..m. As A0 isclosed under decomposition, there are languages Pi~and Si~ for k = 1..m with wl E Pi~, w2 E Si~ andPik'Sik C Li~.
Let P = M~n=l Pik and S = s,~.Clearly, wl 6 P,  w2 6 S and P.S C L. Furthermore,P, S 6 A as A is closed under intersection.
This im-plies that P, S is an appropriate decomposition forWl W2 .
I"1A.1 Phase I: Soundness, Completeness andQuasi-TerminationPropos i t ion  A.1 The rule (PathRel) is X U 12-sound and globally X U 12-preserving.
If A is closedunder decomposition, then (LangDec^) is X U 12-sound and globally X U IJ-preserving.
The (Pre) ruleis X-sound and X-preserving.
All other rules areX U 13-sound and X U 13-preserving.206Next we will prove some syntactic properties of theclauses derivable by the rule system.
For the rest ofthe paper we will call clauses that are derivable fromprime clauses admissible.Propos i t ion  A.2 Every admissible clause is basic.I ra  -~ 13, o~ -- \[3 or c~ (I 13 is contained in someadmissible clause ?, then there is a variable z suchthat zc~y and zflz is in ?.Note that (by this proposition) (Pre) (resp.
(Eq))can always be applied if a constraint c~ 4 \[3 (resp.- /3 )  is contained in some admissible clause.
Thenext lemma will show that different applications of(Pre) or (Eq) will not interact.
This means theapplication of one of these rule to some prefix orpath equality constraint will not change any otherprefix or path equality constraint contained in thesame clause.
This is a direct consequence of the way(PathP~el) was defined.Lemma A.3 Given two admissible clauses 7, 7'with 7 ---~r 7' and r different from (PathRel).
Thenc~ "- 13 E 7' (resp.
~ 4 13 E 7 I) implies ~ -- 13 E 7(resp.
a :?
\[3 E 7).
Furthermore, if a.13 is containedin 7', then either a.fl or a -~ 13 is contained in 7.Note that this lemma implies that new pathequality or prefix constraints are only introducedby (PathRel).
We can derive from this lemmasome syntactic properties of admissible clauses whichare needed for proving completeness and quasi-termination.Lemma A.4 I f  ?
is an admissible clause, then1.
I f  c~ :< 13 is contained in ?, then there is no otherprefix or equality constraint in ?
involving 13.Furthermore, neither 13.\[3~ nor 13~.\[3 is containedin ?.e.
ira.13 fi 13' is in ?, then either 13' equals a or ?contains a constraint of form a f i  t3', a - 13' or:~ ~'.The first property will guarantee that concatena-tion does not occur in prefix or equality constraintsand that the length of path concatenation is re-stricted to 2.
The second property ensures that aconstraint c~.13 fi 13' is always reducible.Theorem A.5 For every finite A the rule system7~a is quasi-terminating.Proof .
The rule system produces only finitely manydifferent clauses since the rules introduce no addi-tional variables or sort symbols and the set of usedlanguages i  finite.
Additionally, the length of con-catenation is restricted to 2.
\[\]Lemma A.6 There are no infinite derivations usingonly finitely many instances of (Pre).Since the rule system is quasi-terminating, thecompleteness proof consists of two parts.
In the firstpart we will proof that pre-solved clauses are just theirreducible clauses.
In the second part we will showthat one finds for each solution Vx of a prime clause?
a pre-solved e-derivative 7 such that Vx is also asolution of 7.Theorem A.7 (Completeness  I) Given an ad-missible clause ?
~ _1_ such that ?
is not in pre-solvedform.
I f  A is e-closed and closed under decomposi-tion, then ?
is T~A-reducible.Theorem A.8 (Completeness  I I) For ev-ery prime clause ?
and for every A that is e-closed,closed under decomposition and intersection we haveI?\] _c U b\] z7 E pre-solved (?,R^)where pre-solved(?,R^) is the set of pre-solved(?, R A )-derivat ives.Proof  (Sketch) We have to show, that for eachprime clause ?
and each Vx, V~,Z with (Vx, V~) ~z?
there is a pre-solved (?, T~A)-derivative 7 such thatVx E ~7\] z.
We will do this by controlling deriva-tion using the valuation (Vx, VT~).
The control willguarantee finiteness of derivations and will maintainthe first completeness property, namely that the ir-reducible clauses are exactly the pre-solved clauses.We allow only those instances of the non-deterministic rules (PathRel) and (LangDecA),which preserve xactly the valuation (Vx, V~).
Thatmeans if (Vx ,V~)  ~z ?
and ?
--~r 7 for one ofthese rules, then (Va', V~) ~z 7 must hold.
Notethat the control depends only on VT,.
E.g.
for theclause ?
= {xc~y, a ~ L1, x13z, 13~ L2} and arbitray Z,Vx this means that if VT,(a) = f, V~,(13) = g and(Vx, VT,) ~z  ?, the rule (PathRel) can transform ?only into {a h 13} U ?.If V~, satisfies V~, (tr) 7~ V~, (13) for ~ different from flwith zcry E ?
and 213z E ?, we cannot add any prefixconstraint using this control.
Hence, (Pre) cannot beapplied, which implies (by lemma A.6) that in thiscase there is no infinite controlled erivation.
We willcall such path valuations prefix-free with respect o?.If V~, is not prefix-free, then (Pre) will be appliedduring the derivations.
In this case we have to changethe path valuation, since (Pre) is not P-preserving.If (Vx, V~) ~z  ?
= {a k 13} U ?
and we apply (Pre)on cr -~ fl yielding 7, then the valuation V?
withv (13) = and = for #will satisfy (Vx, pz  % We will use forcontrolling the further derivations.If we change the path valuation in this way, therewill again be only finite derivations.
To see this,note that every time (Pre) is applied and the pathvaluation is changed, the valuation of one variable isshortened by a non-empty path.
As the number ofvariables used in clauses does not increase, this short-ening can only be done finitely many times.
Thisimplies, that (Pre) can only finitely often be appliedunder this control.
Hence (by lemma A.6), there areagain only finite controlled erivations.
1:3207A.2  Cons is tency  o f  P re -So lved  C lausesWe will first do a minor redefinition of divergence.We say that two paths u, v are directly diverging(written u u0 v) if there are features f ~ g suchthat u E f / ' *  and v 6 g/ '*.
Then u n v holds ifthere are a possible empty prefix w and paths u', v'such that u = wu' and v = wC and u' n0 v'.We will reformulate the reduction of divergenceconstraints in order to avoid constraints of forma.fl fi fl'.
Handling such constraints would make thetermination proof somewhat complicated.
For thereformulation we use a special property of pre-solvedclauses, namely that a fi fl is in a pre-solved clause?
iff zay and zflz is in ?.
Hence, if a fi/?
and ~ fi dfis in ?, then a Ii df is also in ?.
This implies, thatwe can write ep  as f i (At)  ~ .
.
.~  f l (A , )  t9 ?, wherefl (A) is a syntactic sugar forfi(A) = {a f ia '  I a # a 'Aa ,  a '  6 A},As , .
.
.
,An  are disjoint sets of path variables and?
does not contain divergence constraints.
Notethat for every Ai = {a l , .
.
.
,a ,}  there are vari-ables x, Y t , .
.
.
,yn  such that {xatyt , .
.
.
, x~,y ,}  C_?.
Now given such that a constraint fi (A), we as-sume that a whole set of path variables A1 C A di-verges with the same prefix ft. That  means we canreplace f l (At) C fl(A) byAs = fl.A',O fi0(A~),where fl is new, A~ = {a~, .
.
.
,  a~} is a disjoint copyof A1 = {or1, .
.
.
,an} and A - fi.A~ is an abbre-viation for the clause {al - f l ' a~, .
.
.
,  c~, - fl.a~}.fl 0(A) is defined similar to fl (A).
Assuming addi-tionally that the common prefix fl is maximal  impliesthat fl fl a holds for a E (A -A1) .
If we also considerthe effects of A1 = fl'A'l on the subterm agreementsin ?
that involves variables of At, then we result inthe following rule:.A,  YxU fi(A) u(Red1) {xflz} U zA'IY1 U fi0(A~) U Ii({fl}UA2) U ?
'where ?'
= ?
\ [a l  ~-- f l ' a~, .
.
.
,  a ,  ~ f l .a ' \ ] ,AI~A2 =A,  IAll > 1 and z, fl new.
A~ isa disjoint copy of A1.
xAtY1 is short for{za lm, .
.
.
, za ,y ,} .
?
may not containconstraints of form 6.6 ~ L in ?.Note that we have avoided constraints of the forma-fl fi f it  The rules(Reds) fl (A) U %bfi0(A) U?u?
(so,v) o f~#f~, for a#~'together with the rules (LangDech), (Join) and(Empty) completes the rule system 7~ ?iv.
(Reds)is needed as path variables always denote non-emptypaths.
We will view (Redz) and (Red2) as one singlerule (Reduce).A clause ~ is said to be solved if (1) a.fl ~ L andot~0 is not in ep;  (2) a~L1 in ep  and a~L~ in epimplies Lz = L2; (3) ?
does not contain constraintsof form a f l  fl, a Ii0 fl, oL :< fl, or a -" fl; and (4) forevery {xay, z/~z} _C ~ with a ?
/?
there are featuresf #g with {a~fLs , f l~gL2} _C ?.
It is easy tosee that every solved clause is consistent.
Note thatevery solved clause is also prime.Lemma A.9 The rules (Reduce) = (Redt) +(Reds) and (Solv) are X-sound and globally X-preserving.
Furthermore, 7~ s?lv is terminating.Lemma A.10 Let ?
be a pre-soived clause.
If  A ise-closed, closed under intersection and decomposi-tion, then a (?, TiS?lv)-derivative different from 1 isirreducible if and only if it is solved.Finally we can combine both phases of the algorithm.Theorem A.11 Consistency of prime clauses is de-cidable.References\[1\] F. Baader, H.-J.
Bfirckert, B. Nebel, W. Nutt, andG.
Smolka.
On the expressivity of feature logics withnegation, functional uncertainity, and sort equa-tions.
Research Report RR-91-01, DFKI, 1991.\[2\] R. Backofen.
Regular path expressions in featurelogic.
Research Report RR-93-17, DFKI, 1993.\[3\] R. Backofen and G. Smolka.
A complete and recur-sire feature theory.
In Proc.
of the 31 th ACL, 1993.this volume.\[4\] N. Dershowitz.
Termination of rewriting.
Journalof Symbolic Computation, 3:69-116, 1987.\[5\] R. M. Kaplan and J. T. Maxwell III.
An algorithmfor functional uncertainty.
In Proc.
of the 12th COL-ING, pages 297-302, Budapest, Hungary, 1988.\[6\] R. M. Kaplan and A. Zaenen.
Functional uncer-tainty and functional precedence in continental westgermanic.
In H. Trost, editor, 4- (gsterreichischeArtificial-lnteiligence- Tagung: Wiener Workshop-Wissensbasierte Sprachverarbeitung, pages 114-123.Springer, Berlin, Heidelberg, 1988.\[7\] R. M. Kaplan and A. Zaenen.
Long-distance depen-dencies, constituent structure, and functional uncer-tainty.
In M. Baltin and A. Kroch, editors, Alterna-tive Conceptions of Phrase Structure.
University ofChicago Press, Chicago, 1988.\[8\] B. Keller.
Feature logics, infinitary descriptions andthe logical treatment of grammar.
Cognitive ScienceResearch Report 205, Univerity of Sussex, School ofCognitive and Computing Sciences, 1991.\[9\] G. Smolka.
A feature logic with subsorts.
LILOG-Report 33, IBM Deutschland, Stuttgart, 1988.\[10\] G. Smolka.
Feature constraint logics for unificationgrammars.
Journal of Logic Programming, 12:51-87, 1992.\[11\] G. Smolka and R. Treinen.
Records for logic pro-gramming.
In Proceedings of the 1992 Joint Inter-national Conference and Symposium on Logic Pro-gramming, pages 240-254, Washington, DC, 1992.208
