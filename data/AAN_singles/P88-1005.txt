QUANTIF IER  SCOPINGIN  THE SR I  CORE LANGUAGE ENGINEDouglas B. MoranArtificial Intelligence CenterSKI International333 Ravenswood AvenueMenlo Park, California 94025, USAABSTRACTAn algorithm for generating the possible quanti-fier scopings for a sentence, in order of preference,is outlined.
The scoping assigned to a quantifier isdetermined by its interactions with other quan-tifiers, modals, negation, and certain syntactic-constituent boundaries.
When a potential scopingis logically equivalent to another, the less preferredone is discarded.The relative scoping preferences of the individ-ual quantifiers are not embedded in the algorithm,but are specified by a set of rules.
Many of therules presented here have appeared in the linguis-tics literature and have been used in various natu-ral language processing systems.
However, the co-ordination of these rules and the resulting coveragerepresents a significant contribution.
Because x-perimental data on human quantifier-scoping pref-erences are still fragmentary, we chose to design asystem in which the set of preference rules couldbe easily modified and expanded..The algorithm described has been implementedin Prolog as part of a larger natural anguage pro-cessing system.
Extensions of this algorithm arein progress.INTRODUCTIONOne of the major sources of ambiguity in sen-tences results from the different scopes that can beassigned to the various quantified noun phrases inthe sentence.
Part of the problem in determiningthe preferred scopings of quantifiers i the numberof factors involved.
For example, consider thesethree sentencesJohn visited every house on a street.
(1)John visited every house on a square.
(2)John visited every patient in a private room.
(3)Each of these sentences has two quantifier scop-ings: in one, "every' has wider scope over "a,"and while in the other, "a" has the wider scope.However, the readings that most people obtain forthese sentences are quite different.
In (1), thereading in which "a" has wider scope is highlypreferred; in (3), the reading in which "ever f  haswider scope is highly preferred; in (2), the readingwith wide-scope "ever f  is preferred, but wide-scope "a" is also acceptable.
A plausible expla-nation for the difference between (1) and (2) isthat, since the typical house is located on a streetbut not on a square, the default preference rep-resented by (2) is overridden by a conversationalmaxim of quantity--if "~ streeff has narrow scope,"on a street" would contribute too little informa-tion to justify its presence.
A plausible explana-tion for the difference between (2) and (3) is basedon the relationship among the components.
Thereading of (3) in which "a" is given wider scope isimprobable because the domain of quantificationfor "every" would then be the single patient inthe selected room--an infelicitous use of "every, ~whereas there is no similar problem in (2) becausethere are normally multiple houses on a square.Similarly, inJohn visited a person on every committee.
(4)John visited a house on every street.
(5)the reading in which "a" has wider scope is reason-able for (4) but not for (5)--in a normal domainof discourse, it is conceivable that there could bea person who is on all of the committees, but it ishighly improbable that the geometry of the streetsis such that a single house could be located on allof them.In (1), (3), and (5), discourse criteria and do-main information seem to be the primary factorsin determining the preferred quantifier scopings,whereas in (2) and (4), linguistic criteria seem to33be the determining factors.Our approach presumes that the determinationof a sentence's preferred scoping can be dividedinto two phases, the first of which is the subject ofthe algorithm described here.
In this initial phase,linguistic information isused to generate the possi-ble quantifier scopings in order of preference.
Therelevant linguistic information consists of surfaceposition, syntactic structure, and the relationshipamong the function words (determiners, modals,and negation).
In the second phase (future work),domain and discourse information is applied suc-cessively to these scopings, modifying the scoresproduced by the first phase.
We expect hat themodifications will be only penalties, thus makingit possible to identify the best choice when it is en-countered (cutting off the processing of remainingscopings generated by the first phase).The primary study of quantifier scoping prefer-ences was done by VanLehn (1978).
The experi-mental data reported therein was of limited useful-hess in developing the algorithm described here--it was gathered and evaluated under assumptionsarising from a different linguistic theory.We shall first present the rules that governed thestructure of our design, then outline the algorithm.This scoping algorithm has been implemented asa component of a larger system that is under con-tinuing development.
In this system, called theCore Language Engine or CLE (Alshawi et aL,1987), the semantic interpretation phase producesunscoped logical forms in which quantifier expres-sions are represented by quantifier terms (qterms).For example, the sentence "John saw a studenf'has the uuscoped logical form 1see'(john';qterm(a',X,student'(X)))Since the only permissible scope for this quanti-fier is the whole sentence, the qterm is raised toproduce the scoped logical formquant(3,X,student'(X), see'(john',X))The qterm expression can best be thought of as aquant expression before its scope has been estab-lished.
In the above qterm and quant expressions,student'(X) is the restr ict ion of the quantifiedvariable X; that is, it specifies a set of the pos-sible values of X over which the quantifier ranges.I The logical form's syntax in the implementat ion is ac-tuaJly \[seel~ohnl,qterm(al,X,\[studentl,X\])\],  but  the moreconventional notat ion will he ~ for perspicuity.In the above quant expression, see'(john',X) is re-ferred to as either the body  or the scope of thequantifier.
This treatment of the logical form ofquantifiers follows that employed in many previ-ous systems (e.g., LUNAR (Woods, 1977), Moore(1981), Barwise and Cooper (1981), and Hobbsand Shieber (1987)).RULES AND PREFERENCESMany of the following rules have appeared inwrious forms in multiple places in the literature,and most natural anguage processing systems in-clude some mechanism for selecting a preferredquantifier scoping.
However, the published de-scriptious of many of those systems' capabilitiestend to be cursory, with the scoping rules utilizedin the LUNAR system still among the best de-scribed in the NLP literature.
Because of spacelimitations, it is not possible to cite much of thisdiscussion, nor to compare this system to others.Rule  1 A quantifier A that is not in the restric.tion of quantifier B and that occurs within thescope of B cannot oeLgcope any of the quantifiersin the restriction of B.Rule 2 If a quantifier is raised past an operator,then any quantifier that occurs within its restric-tion must also be raised past that operator.These rules, presented by Hobbs and Shieber(1987), can best be explained with examples.A bishop visits e~er*j chapel by a ri,)er.
(6)has an uuscoped logical form ofvisit'(qterm(a',B,bishop'(B)),qterm(every',C,and(chapel'(C),by'(C,qterm(a',R,river'(R))))))The following is one of the possible permuta-tions of the quemtifiers, but is not a valid scop-ing because the restriction of "every" ("chapel bya river") has been fragmented:*quant(V,C,chapel'(C),quant(=l,B,bishop'(B),quant(=l, R,and(river'(R),by'(C, R)),visit'(B,C))))Similarly, for the sentenceJohn did not visit a chapel by a river.
(7)the quantifier permutation34*quant(3,C,chapel'(C),not(quant(3,R,and(river'(R),by'(C, R)),visit'(john',C))))is not a possible scoping of the unscoped logicalformnot(visit'Ciohn',qterrn(a',C,and(chapel'(C ),by'(C,qterm(a',R,river'(R)))))))Rule  3 For a set of quantijiers, which quantifierreceives wide-scope preference can be determinedby a pairwise comparison of the determiners.
Thiscomparison is based upon a combination of factorsthat include their relative strengths and surface po-sitions, and whether or not either has been raised.In many systems, determiners are assigned nu-merical strengths and these values are compared todetermine what scope should be assigned to eachquantifier.
Such a ranking is implicit in our prefer-ence rules and can be viewed as a first approxima-tion of the relationships represented by our rules.Our algorithm permits a set of properties to beassociated with determiners and for these to beused in ascertaining which determiner has wide-scope preference.
The properties currently em-ployed are surface position (the integer index ofthe determiner) and a Boolean value indicatingwhen a quantifier has already been raised.P re ference  3.1 There is a strong preference for%ach" to outscope other determiners.That "each" is the strongest determiner is acommon feature of most quantifier-scoping treat-ments.
However, the evidence for the relativestrengths of the remaining quantifiers i much lessclear---our current ranking of them is an ad hocblending of those in TEAM (Grosz ef al., 1987)and VanLehn (1978).P re ference  3.2 There is a strong preference forWH.terms to outscope all determiners ezcepf"each," which outscopes WH-terms.In the unscoped logical forms currently pro-duced, WH-words ("which," "who," "what") andphrases are represented as qterms.
Our scoping-preference rules assign wide scope to "each" inWhich ezams did each student pass?
(8)There is a reported ialect in which sentences ofthe above form are judged to be malformed, butthat dialect was not found among our informants.The design of our algorithm makes it easy to re-place the current preferences with these.The definite determiner "the" is currentlytreated as a very strong quantifier, but this ap-proach is not entirely satisfactory.
ConsiderEvery student passed the ezam.
(9)The student in every race celebrated.
(1O)The student in each race celebrated.
(11)Every student in the race celebrated.
(12)Each student in the race celebrated.
(13)In (9)-(12), the preferred scopings are as predictedby the rules.
However in (13), the preferred read-ing selected is the one with wide-scope "each."
Al-though both scopings of this sentence are logicallyequivalent (as are those for (9) and (12)), wide-scope "the" seems to he the preferred reading.Our algorithm does not distinguish between spe-cific and nonspecific use of indefinite articles.
It isdebatable whether this belongs in quantifier scolPing or in another part of the system.Pre ference  3.3 A logically weaker interpretationis preferred.
This preference is strong when itmaintains urface order, weak when it inverts sur-face order.
2The quantifier order V'~ is weaker than ~/, ac-counting for the preferences inA man loves every woman.
(14)Every man loves a woman.
(15)In both sentences, the reading with wide-scope"eeer f  is the preferred one; the reading withwide-scope "a" is possible for (14), but is verystrained for (15).Ru le  4 Raising a quantifier out of certain syntac-tic constituents changes the strength of its deter-miner.VanLehn presents an "embedding hierarchy" ofthe probability of a quantifier in the modifier ofan NP being raised to have wider scope than thequantifier in the NP's head2Vanl.mhn proposes a more general form of thispreference--that,  when comparing two quantifiers withinthe same ge~neral group, the "more numerous" one will havea preference for wider scope.
For example, "many" wouldtake wider scope over "few."
However, for everything ex-cept "ever~' /"a ,"  such preferences appear to he very slight.35PP > Reduced Relative Clause > Relative ClauseA method frequently proposed to account for thisdistinction is to use, as a measure of the cost ofraising, a count of the number of nodes in the syn-tactic structure over which the quantifier is raised.However, such accounts are acknowledged to havevarious deficiencies and to be overly sensitive tothe syntactic representation used.
We have cho-sen to permit rules to associate a cost for raising aquantifier with certain types of nodes (other nodescan be viewed as having zero costs).
This capabil-ity of the system is currently invoked only on anall-or-nothing basis.P re ference  4.1 A quantifier cannot be raisedacross more than one major clause boundary.A common rule in the quantifier-scoping litera-ture is "quantification is generally clause bound.
"While it is possible to generate sentences withacceptable readings when a quantifier has widerscope than the clause in which it occurs, we havebeen unable to find any examples howing that itcan be raised out of two clauses.P re ference  4.2 A quantifier cannot be raised outof a relative clause.This is a common restriction in many quantifier-scoping algorithms.
In our system, this is not aspecial rule, but one of the preferences.
Conse-quently, this could easily be modified from veverbeing permitted to being "highly unpreferred.
"Rule  5 In unscoped logical form, quantifiers canoccur within the scope of an opaque operator.Whether or not to raise such a quantifier outsidethat operator is determined by a pairwise compar-ison between the operator and the determiner inthe quantifier, as well as by their relative surfaceposition.Pre ference  5.1 There is a strong preference for"some" to outscope negation.Pre ference  5.2 There is a preference for nega-tion to outscope %very."
This preference is strongwhen it maintains surface order, weak when itdoesn't.Different scopings of "some" and "every" undernegation produce quivalent readings (3"~ is equiv-alent to --V).
The preferred scopings for the twosentencesJohn did not see someone.
(16)John did not see everyone.
(17)have equivalent logical formsquant(3,P, person'(P),not(see'(john',P)))not(quant(V,e, person'(e),see'(john',e)))Similarly, the preferred scopings of sentencesSomeone did not see John.
(18)Everyone did not see John.
(19)have equivalent logical formsquant(3,P, person'(P),not(see'(P, john')))not(quant(V,e.person'(P),see'(e, john')))The reading of (16), which would assign nar-row scope to "some" is produced by substituting"an~ 's for "some" :John did not see anyone.
(20)This has the following logical form (no other scop-ings exist):not(q ua nt(3, P, person'(P),see'(joh n', P))) ,which is logically equivalent toquant(V,e, per$on '(e),not(see'(john' ,e))) ,which corresponds to the strongly "unpreferred"readings of (16) and (17).
Similarly, the sentenceNo one saw John.
(21)which has a scoped logical form ofquant(V,P, person'(P),not(see' (p,john')))corresponds to the "unpreferred" scoping for (18)and (19).One of LUNAR's scoping rules was that inthe antecedent of "if-then" statements, quantifiers"some" and "anf  should be assigned wide scope,and that "a" and "every" should be given nar-row scope.
If such antecedents were treated as anegative nvironment (or equivalent thereto), theforegoing preferences could produce this effect.SThe CLE system does not currently provide a treat-merit of ",n~."
However, within the qu~ati~er-scopingcompon~t,  "4n~" is treated ~ ~ potenti~dly am-biguotm between the usual universal quantifier, free-choice "any," and a ~cond form, polarity-sensitive "anlt,"which occurs in conjunction with negative-polarlty i ems.Polarity-~mitive "anlh" is treated as & narrow.cope exis-telxtied quantifier (Ladtmaw, 1980).36Pre ference  5.3 There is a strong preference forfree-choice "any" to have wider scope than modals.There is a strong preference for all other determin-ers that occur within the scope of a modal to havenarrower scope than that modal.Did some student ake every testf (22)Does some student ake every test?
(23)Some student ook every test.
(24)Some student akes every test.
(25)Some student is taking every test.
(26)For sentences (23), (25), and (26), there are twoacceptable quantifier scopings.
However, for (22)and (24), the scoping in which "every" is assignednarrower scope seems to be strongly preferred.
Weascribe this to the presence in the logical formof a modal operator corresponding to the pasttense.
This effect is accentuated in (27), which ex-hibits an ambiguity resulting from whether "someteacher" is scoped inside or outside the modal, cor-responding to (28) and (29), respectively:Some teacher took every course.
(27)Last summer, some teacher took every coarse(28)As a student, some teacher took every course~29)The scoping in which "every" outscopes "some ~is possible, although unpreferred, for the reading?
(28); but it is not a possible scoping for (29) inany dialect that we have encountered.Ru le  6 I f  polarity-sensitive "any" occurs within aclause in which its trigger does not occur, it mustbe raised out of that clause.De D ic to /De  Re The mechanism described herecan provide an account for the de dicto/de re dis-tinction.Another ambiguity associated with quantifierterms is whether or not the referent is requiredto exist.
In PTQ (Montagne, 1973), the sentenceJohn seeks a unicorn.
(30)is assigned a de dicto reading (which does not re-quire that any unicorns exist),seek'(~john ',%~(P,q uant(3,X,u nlcorn '(X),'P(X))))and a de re reading (which requires the existenceof some unicorn)quant(3,X,unicorn'(X),seek'Cjohn',^A(P,'P(X))))In PTQ, this distinction is produced by syntacticrules.
Cooper (1975, 1983) demonstrated that amechanism using a store could produce both read-ings from a single logical form.Our mechanism obtains imilar results.
Startingfrom the unscoped logical formseek'Cjohn','A(P,:P(qterm(a',X,unicorn'(X)))))with the intension operator " treated as being op-tionally opaque, both readings are produced bythe quantifier-scoping algorithm described here.Additional (unwarranted) scopings are not pro-duced because these are the only two sites at whichquantifiers can be pulled from the store.Nonru le  There is a strong preference for a nounphrase in a prepositional phrase complement tooutscope the head noun.This criterion is used in many quantifier scopingmechanisms.
It is a good heuristic, but it is not areliable rule.
InJohn visited every house on a street.
(31)John visited every house with a dog.
(32)the heuristic orrectly predicts the preferred stop-ing for (31), but fails for (32).
4 This heuristic isnot part of our scoping algorithm; we believe thatits effects are part of the processing consigned byus to the second phase of quantifier scoping (futurework).BASIC  ALGORITHMThe first level of our scoping algorithm gener-ates the possible scopings, as described by Hobbsand Shieber (1987).
However, we implemented ~this with a different algorithm, partly for reasonsof eff?ciency and partly because it could be easierexpanded to include additional capabilities.
Theperformance of the Hobbs and Shieber algorithmdeteriorates as the number of quantifiers in thesentence increases---our analysis is that it spendsa significant amount of time repeatedly travers-ing the logical form and doing structure copying(their goal was to produce a provably correct algo-rithm, not a highly efficient one).
Our algorithmtraverses the unscoped logical form, collecting theqterms (quantifier terms) into a store; then as thescoping for each qterm is determined, it is pul ledout of the store, producing a scoped logical form.4This was brought o my attention by Richard Crouch.37For a sentence with four qusatifiers, our algorithmis typically an order of magnitude faster than thatpresented by Hobbs sad Shieber.A simple example of the use of the store is pro-vided by the sentence "John saw a student," whichhas an unscoped logical form ofsee'(john',qterm(a',X,student'(X)))After quantifier scoping has placed the qterm inthe store, the logical form issee'(john',X)sad the store is\[ \[ qterm(a',X,student'(X)) \]\]The scope for this quantifier is the whole sentence,so the qterm is puned out of the store to producethe scoped logical formquant(3,X,studeet'(X), see'~iohn',X))The sentence "Few students pass most ezamg' hasthe unscoped logical formpass'(qterm(few',X,student'(X)),qterm(most'.V.exam'(V)))After the qterms have been extracted, the remain-ing logical form sad the store arep ss'(x,v)\[ \[ qterm(few',X,stud ent'(X)) \],\[ qterm(rhost',Y,exam'(Y))) \] \]A qterm can have other qterms in its restric-tion sad our quantifier store is a structured col-lection (unlike the stores of Cooper sad LUNAR).The structure of qterms in the store correspondsto their relative positions in the unscoped logicalform.
For example, the unscoped logical form for"every student in a college attends the lecture' isatten d'(qterrn(every' ,X,and(student'(X),in'(X,qterm(a',Y,college'(Y))))),qterm(the',Z,lecture'(Z)))When such qterms are placed in the store, this re-lationship is maintained by representing the col-lected qterms as trees (called qtrees), with theouter qterm as the root and those in its restric-tion as daughters:\[\[ qterm(every',X,and(student'(X),in'(X,Y))),qterm(a' ,Y,college'(Y)) \],\[ qterm(the',Z,lecture'(Z)) \] \]Consequently, the store is a forest of such qtrees,and the qterms occurring in the restriction of aqterm are themselves a forest of qtrees and aretreated as if they were a store.As qterms are collected, they are inserted intothe store in inverse order of preferencc c.g., theqterm that has narrowest-scope reference appearsat the front of the list representing the forest.
Inimplementing this algorithm in Prolog, we foundthat it was considerably easier to generate thescopings by working from the narrowest o thewidest scope, rather than rice versa.
As the vari-ous permutations of the quantifiers are generated,equivalent scopings are detected, and all but themost preferred one are then filtered out.
In thefollowing, both scopings of each sentence are logi-tally equivalent:Every student akes every test.Every student akes each test.A student takes a test.Some student akes a tes~.Each student akes the test.Eeery student takes the test.The student takes every test.
(33)(34)(35)(36)(37)(38)(39)In (33), (35), (37), sad (39), the preferred order isthe same as the surface order, while in (34), (36),sad (38), the stronger quantifier occurs second insurface order, sad the scoping that correspondsto surface order is discarded.
Filtering of equiva-lent permutations i  achieved simply by compar-ing the qtree currently being pulled from the storewith the preceding one; if the qusatifiers in theirhead qterms are logically equivalent, his quantifierscoping is discarded unless the qtree being pulledhas wide-scope preference over its predecessor (inwhich case the other logically equivalent orderingwill be discarded).Logically equivalent scopings can also be pro-duced when a quantifier is raised out of the restric-tion of another.
However, the quantifier permuta-tions that produce equivalent scopings by raisingare a subset of those produced by permuting sib-lings:Every student in every race celebrated.
(40)A student in a race celebrated.
(41)Some student in a race celebrated.
(42)38Each student in the race celebrated.
(43)Every student in the race celebrated.
(44)The student in every race celebrated.
(45)Note that the scopings for (40) and (45) are notlogically equivalent.
The scopings in the othersaxe logically equivalent, but in (41) and (43), thepreferred scoping is the one corresponding to con-stituent structure, whereas in (42) and (44), thepreferred scoping has the NP from the PP raisedto have wider scope over the head noun.When a qtree is pulled from the store, the algo-rithm tries to produce additional permutations byraising subsets of qterrns (actually of qtrees) out ofthat qtree's restriction.
When a qtree is raised, itis put back into the store---since qtrees are beingassigned scope from narrowest to widest, this en-sures that a raised qtree will receive wider scopethan the qtree out of which it was raised.Because a raised qtrse may have its strength re-duced when it is placed back in the store (an op-tion in our system), a set of logically equivalentscopings could have all instances filtered out bya naive implementation.
The problem arises inthe following manner.
Before the qtree is raised,the algorithm determines that the unraised scop-ing is logically equivalent to a raised one and thatthe latter is preferred, so it discards the former.When the qtree is raised and its strength reduced,it becomes weaker than the qtree out of whichit was raised.
The algorithm detects that theraised scoping is logically equivalent to an unralsedone, and determines--on the" basis of the currentstrengths--that the unraised scoping is preferred,so it now discards the raised one.
This problem isavoided by doing some additional bookkeeping.The current implementation of the above rulesis very coarse-grained.
The "score" indicatingwhether or not a quantifier should be assignedwide scope over another quantifier, logical formoperator (e.g., a modal, negation), or syntacticconstituent is one of four values: always (narrowscope is impossible), never (wide scope is impos-sible), pref (wide scope is preferred, but narrowscope is acceptable), and unpref (narrow scopeis preferred).
In the current implementation ofthe above preferences, a strong preference to takewider scope is treated as an instance of always,and a weak preference is treated as pref.
For ex-ample, Preferences (3.1)-(3.3) are given by the fol-lowing rules, in which Pref is the preference of adeterminer Detl to take wider scope over anotherdeterminer Det2:if Detl and Det2 are both "each":- if Detl precedes Det2 in surface order,Pref = pref,- otherwise, Pref = unpre.f.otherwise, if Detl is "each" (and Det2 isnot), Pref = alwaysotherwise, if Detl is an interrogativedeterminer, Pref--  alwaysotherwise, if the logical forms for Detl andDet2 are V and 3, respectively:- if Detl precedes Det2 in surface order,Pref = always- otherwise, Pref = pref.Overshoot  The method described here results in.some quantifiers' being assigned scopes that arewider than appropriate, relative to other predicates(but not quantifiers) in the logical form.The sentence "John visited every person on acommittee" has an uuscoped logical form ofvisit'(john',qterm(every',P, and(person'(P),on'(P, qterm(a',C,committee'(C))))))and its preferred scoping isquant(V,P, quant(3,C,committee'(C),and(person'(P),on'(P,C))),v is i t 'C john ' .P ) )Note that person'(P) is independent of C; thus itcan be outside the scope of the quantifier for Cquant(V,P, and(person'(P),quant(q,C,committee'(C),on'(P,C))),visit'~iohn', P))Such transformations can have a significant im-pact on the performance of the system, substan-tially reducing the processing time of queries foreven a modest database.
Rather than pass ad-ditional information so that quantifiers could bepulled at the correct point in the traversal of thelogical form, we chose to let the scoping algorithm"overshoot" its mark and then lower the quanti-tiers to the correct position.
This was considerablyeasier to implement, and it does not seem to haveany performance penalty in our system.CONCLUSIONFor lack of a reasonable corpus of human quan-tifier scoping preferences, the testing of'this sys-tem has been limited to checking conformance to39the stated rules, s The semantic omponent oftheCLE does not produce logical forms with mass orcount NPs or collective readings, but that capa-bility is currently being developed.
The foregoingdescription of qterms is a slight simplification; anextended form is now being used to support gen-eralized quantifiers in the new semantic rules.Examples offered by VanLehn (1978) indicatethat dative movement affects quantifier scoping,but the cause may actually be domain or discourseinformation.
Our examples how that passiviza-tion affects quantifier scoping, but we have not yetfound a means of determining whether the effectis due solely to the cost of raising out of the PP.The algorithm does not handle "donkey sen-tences," nor is it intended to.
A scheme for han-dling such sentences i being explored as part ofthe continuing development of the CLE (FernandoPereira, personal communication).
This would bea separate mechanism, rather than an extensionof quantifier scoping.ACKNOWLEDGMENTSThe research on which this paper is based wassupported by the Natural Language ProcessingClub (NATTIE) of the Alvey Directorate programin Intelligent Knowledge-Based Systems (ProjectNo.
ALV/PRJ/IKBS/105).
Most of it was per-formed while I was a member of SRI's CambridgeComputer Science Research Centre.
This workbenefited from extensive discussion with and sug-gestions from Robert C. Moore and Hiyan ANshawi.REFERENCESAlshawi, Hiyan; Moore, Robert C.; Moran, Dou-glas B.; and Pulman, Steven G. 1987.
Re-search Programme in Natural-Language Pro-cessing, Annual Report to the Natural Lan-guage Processing Club (NATTIE) of theAlvey Directorate Program in IntelligentKnowledge-Based Systems, Cambridge Com-puter Science Research Centre, SRI Interna-tional, Cambridge, England.Barwise, 2on and Cooper, Robin 1981.
General-ized Quantifiers and Natural Language.
Lin-guistics and Philosophy 4(2): 159-219.5The range of quantified noun phrases covered in thealgorithm is larger than what is currently produced bythe syntactic and semaantic omponents of the CLE sys-tem.
Such extenalons have been tested by starting fromthe anticipated logical form.Cooper, Robin 1975.
Montague's Semantic The-ory and Transformational Syntaz.
Ph.D. dis-sertation, Department of Linguistics, Uni-versity of Massachusetts at Amherst, Mas-sachusetts.Cooper, Robin 1983.
Quantification and SyntacticTheory, D. Reidel, Dordrecht, Holland.Grosz, Barbara J.; Appelt, Douglas E.; Mar-tin, Paul A.; and Pereira, Fernando C.N.1987.
TEAM: An Experiment in the De-sign of Transportable Natural-Language In-terfaces.
Artificial Intelligence 32(2): 173-243.Hobbs, Jerry R. and Shieber, Stuart M. 1987.
AnAlgorithm for Generating Quantifier Scop*ings.
Computational Linguistics, 13(1-2): 47-63.Ladnsaw, William 1980.
Pblarity Sensitivity asInherent Scope Relations.
Ph.D. disserta-tion, Department ofLinguistics, University ofTexas at Austin; published by Garland Press,New York, New York.Montague, PAchard 1973.
The Proper Treat-ment of Quantification i Ordinary English.In: Hintikka, J.; Moravcsik, J.; and Sup-pea, P.
(eds.)
1973.
Approaches to Natu-ral Language, D. Reidel, Dordrecht, Holland:221-242.
Reprinted in: Montague, Richard1974.
Formal Philosophy: Selected Papers ofRichard MonLague, edited and with an intro-duction by Richmond Thomason, Yale Uni-versity Press, New Haven, Connecticut: 247-270.Moore, Robert C. 1981.
Problems in LogicalForm.
In Proc.
of the 19th Annual Meetingof the AssociaLion for Computational Linguis-tics: 117-124.VanLehn, Kurt A.
1978.
Determining the Scope ofEnglish Quantifiers.
Report AI-TR-483, Arti-ficial Intelligence Laboratory, MassachusettsInstitute of Technology, Cambridge, Mas-sachusetts.Woods, William A.
1977.
Semantics and Quantifi-cation in Natural Language Question Answer-ing.
In: Advances in Computers, Volume 17,Academic Press, New York, New York: 1-87.40
