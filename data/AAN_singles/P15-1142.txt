Proceedings of the 53rd Annual Meeting of the Association for Computational Linguisticsand the 7th International Joint Conference on Natural Language Processing, pages 1470?1480,Beijing, China, July 26-31, 2015.c?2015 Association for Computational LinguisticsCompositional Semantic Parsing on Semi-Structured TablesPanupong PasupatComputer Science DepartmentStanford Universityppasupat@cs.stanford.eduPercy LiangComputer Science DepartmentStanford Universitypliang@cs.stanford.eduAbstractTwo important aspects of semantic pars-ing for question answering are the breadthof the knowledge source and the depth oflogical compositionality.
While existingwork trades off one aspect for another, thispaper simultaneously makes progress onboth fronts through a new task: answeringcomplex questions on semi-structured ta-bles using question-answer pairs as super-vision.
The central challenge arises fromtwo compounding factors: the broader do-main results in an open-ended set of re-lations, and the deeper compositionalityresults in a combinatorial explosion inthe space of logical forms.
We proposea logical-form driven parsing algorithmguided by strong typing constraints andshow that it obtains significant improve-ments over natural baselines.
For evalua-tion, we created a new dataset of 22,033complex questions on Wikipedia tables,which is made publicly available.1 IntroductionIn semantic parsing for question answering, nat-ural language questions are converted into logi-cal forms, which can be executed on a knowl-edge source to obtain answer denotations.
Earlysemantic parsing systems were trained to answerhighly compositional questions, but the knowl-edge sources were limited to small closed-domaindatabases (Zelle and Mooney, 1996; Wong andMooney, 2007; Zettlemoyer and Collins, 2007;Kwiatkowski et al, 2011).
More recent worksacrifices compositionality in favor of using moreopen-ended knowledge bases such as Freebase(Cai and Yates, 2013; Berant et al, 2013; Faderet al, 2014; Reddy et al, 2014).
However, eventhese broader knowledge sources still define aYear City Country Nations1896 Athens Greece 141900 Paris France 241904 St. Louis USA 12. .
.
.
.
.
.
.
.
.
.
.2004 Athens Greece 2012008 Beijing China 2042012 London UK 204x1: ?Greece held its last Summer Olympics in which year?
?y1: {2004}x2: ?In which city?s the first time with at least 20 nations?
?y2: {Paris}x3: ?Which years have the most participating countries?
?y3: {2008, 2012}x4: ?How many events were in Athens, Greece?
?y4: {2}x5: ?How many more participants were there in 1900 thanin the first year?
?y5: {10}Figure 1: Our task is to answer a highly composi-tional question from an HTML table.
We learna semantic parser from question-table-answertriples {(xi, ti, yi)}.rigid schema over entities and relation types, thusrestricting the scope of answerable questions.To simultaneously increase both the breadth ofthe knowledge source and the depth of logicalcompositionality, we propose a new task (with anassociated dataset): answering a question using anHTML table as the knowledge source.
Figure 1shows several question-answer pairs and an ac-companying table, which are typical of those inour dataset.
Note that the questions are logicallyquite complex, involving a variety of operationssuch as comparison (x2), superlatives (x3), aggre-gation (x4), and arithmetic (x5).The HTML tables are semi-structured and notnormalized.
For example, a cell might containmultiple parts (e.g., ?Beijing, China?
or ?200km?).
Additionally, we mandate that the train-ing and test tables are disjoint, so at test time,we will see relations (column headers; e.g., ?Na-tions?)
and entities (table cells; e.g., ?St.
Louis?
)1470that were not observed during training.
This is incontrast to knowledge bases like Freebase, whichhave a global fixed relation schema with normal-ized entities and relations.Our task setting produces two main challenges.Firstly, the increased breadth in the knowledgesource requires us to generate logical forms fromnovel tables with previously unseen relations andentities.
We therefore cannot follow the typicalsemantic parsing strategy of constructing or learn-ing a lexicon that maps phrases to relations aheadof time.
Secondly, the increased depth in com-positionality and additional logical operations ex-acerbate the exponential growth of the number ofpossible logical forms.We trained a semantic parser for this task fromquestion-answer pairs based on the framework il-lustrated in Figure 2.
First, relations and entitiesfrom the semi-structured HTML table are encodedin a graph.
Then, the system parses the questioninto candidate logical forms with a high-coveragegrammar, reranks the candidates with a log-linearmodel, and then executes the highest-scoring logi-cal form to produce the answer denotation.
We usebeam search with pruning strategies based on typeand denotation constraints to control the combina-torial explosion.To evaluate the system, we created a newdataset, WIKITABLEQUESTIONS, consisting of2,108 HTML tables from Wikipedia and 22,033question-answer pairs.
When tested on unseen ta-bles, the system achieves an accuracy of 37.1%,which is significantly higher than the informationretrieval baseline of 12.7% and a simple semanticparsing baseline of 24.3%.2 TaskOur task is as follows: given a table t and a ques-tion x about the table, output a list of values ythat answers the question according to the table.Example inputs and outputs are shown in Fig-ure 1.
The system has access to a training setD = {(xi, ti, yi)}Ni=1of questions, tables, and an-swers, but the tables in test data do not appear dur-ing training.The only restriction on the question x is that aperson must be able to answer it using just the ta-ble t. Other than that, the question can be of anytype, ranging from a simple table lookup questionto a more complicated one that involves variouslogical operations.t(1) Conversionx (2) Parsing wZx(3) Rankingz (4) Execution yxxx xxxx xxxxx xxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...xxxxxxxxxxxxxxxxxxxx...xxxxxxxxxGreece held the lastSummer Olympics inwhich year??
[Year .
.
.
].argmax(.
.
.
Greece, Index) {2004}Figure 2: The prediction framework: (1) the tablet is deterministically converted into a knowledgegraph w as shown in Figure 3; (2) with informa-tion from w, the question x is parsed into candi-date logical forms in Zx; (3) the highest-scoringcandidate z ?
Zxis chosen; and (4) z is executedon w, yielding the answer y.Dataset.
We created a new dataset, WIK-ITABLEQUESTIONS, of question-answer pairs onHTML tables as follows.
We randomly selecteddata tables from Wikipedia with at least 8 rows and5 columns.
We then created two Amazon Mechan-ical Turk tasks.
The first task asks workers to writetrivia questions about the table.
For each question,we put one of the 36 generic prompts such as ?Thequestion should require calculation?
or ?containsthe word ?first?
or its synonym?
to encourage morecomplex utterances.
Next, we submit the result-ing questions to the second task where the work-ers answer each question based on the given table.We only keep the answers that are agreed upon byat least two workers.
After this filtering, approxi-mately 69% of the questions remains.The final dataset contains 22,033 examples on2,108 tables.
We set aside 20% of the tables andtheir associated questions as the test set and de-velop on the remaining examples.
Simple pre-processing was done on the tables: We omit allnon-textual contents of the tables, and if there is amerged cell spanning many rows or columns, weunmerge it and duplicate its content into each un-merged cell.
Section 7.2 analyzes various aspectsof the dataset and compares it to other datasets.3 ApproachWe now describe our semantic parsing frameworkfor answering a given question and for training themodel with question-answer pairs.1471Prediction.
Given a table t and a question x,we predict an answer y using the framework il-lustrated in Figure 2.
We first convert the tablet into a knowledge graph w (?world?)
which en-codes different relations in the table (Section 4).Next, we generate a set of candidate logical formsZxby parsing the question x using the informa-tion from w (Section 6.1).
Each generated logicalform z ?
Zxis a graph query that can be exe-cuted on the knowledge graph w to get a denota-tion JzKw.
We extract a feature vector ?
(x,w, z)for each z ?
Zx(Section 6.2) and define a log-linear distribution over the candidates:p?
(z | x,w) ?
exp{?>?
(x,w, z)}, (1)where ?
is the parameter vector.
Finally, wechoose the logical form z with the highest modelprobability and execute it on w to get the answerdenotation y = JzKw.Training.
Given training examples D ={(xi, ti, yi)}Ni=1, we seek a parameter vector ?that maximizes the regularized log-likelihood ofthe correct denotation yimarginalized over logi-cal forms z.
Formally, we maximize the objectivefunctionJ(?)
=1NN?i=1log p?
(yi| xi, wi)?
?
??
?1, (2)where wiis deterministically generated from ti,andp?
(y | x,w) =?z?Zx;y=JzKwp?
(z | x,w).
(3)We optimize ?
using AdaGrad (Duchi et al,2010), running 3 passes over the data.
We use L1regularization with ?
= 3 ?
10?5obtained fromcross-validation.The following sections explain individual sys-tem components in more detail.4 Knowledge graphInspired by the graph representation of knowledgebases, we preprocess the table t by deterministi-cally converting it into a knowledge graph w asillustrated in Figure 3.
In the most basic form, ta-ble rows become row nodes, strings in table cellsbecome entity nodes,1and table columns becomedirected edges from the row nodes to the entity1Two occurrences of the same string constitute one node.?
?
?0 1896 Athens Greece?
?
?1 1900 Paris France... 1900.0 1900-XX-XXNextNextIndexIndexYear City CountryYear City CountryNumber DateFigure 3: Part of the knowledge graph correspond-ing to the table in Figure 1.
Circular nodes are rownodes.
We augment the graph with different en-tity normalization nodes such as Number and Date(red) and additional row node relations Next andIndex (blue).nodes of that column.
The column headers areused as edge labels for these row-entity relations.The knowledge graph representation is conve-nient for three reasons.
First, we can encode dif-ferent forms of entity normalization in the graph.Some entity strings (e.g., ?1900?)
can be inter-preted as a number, a date, or a proper name de-pending on the context, while some other strings(e.g., ?200 km?)
have multiple parts.
Instead ofcommitting to one normalization scheme, we in-troduce edges corresponding to different normal-ization methods from the entity nodes.
For exam-ple, the node 1900 will have an edge called Dateto another node 1900-XX-XX of type date.
Apartfrom type checking, these normalization nodesalso aid learning by providing signals on the ap-propriate answer type.
For instance, we can definea feature that associates the phrase ?how many?with a logical form that says ?traverse a row-entityedge, then a Number edge?
instead of just ?traversea row-entity edge.
?The second benefit of the graph representationis its ability to handle various logical phenomenavia graph augmentation.
For example, to answerquestions of the form ?What is the next .
.
.
??
or?Who came before .
.
.
?
?, we augment each rownode with an edge labeled Next pointing to thenext row node, after which the questions can beanswered by traversing the Next edge.
In thiswork, we choose to add two special edges on eachrow node: the Next edge mentioned above andan Index edge pointing to the row index number(0, 1, 2, .
.
.
).Finally, with a graph representation, we canquery it directly using a logical formalism forknowledge graphs, which we turn to next.1472Name ExampleJoin City.Athens(row nodes with a City edge to Athens)Union City.
(Athens unionsq Beijing)Intersection City.Athens u Year.Number.<.1990Reverse R[Year].City.Athens(entities where a row in City.Athens has a Year edge to)Aggregation count(City.Athens)(the number of rows with city Athens)Superlative argmax(City.Athens, Index)(the last row with city Athens)Arithmetic sub(204, 201) (= 204?
201)Lambda ?x[Year.Date.x](a binary: composition of two relations)Table 1: The lambda DCS operations we use.5 Logical formsAs our language for logical forms, we uselambda dependency-based compositional seman-tics (Liang, 2013), or lambda DCS, which webriefly describe here.
Each lambda DCS logicalform is either a unary (denoting a list of values) ora binary (denoting a list of pairs).
The most basicunaries are singletons (e.g., China represents anentity node, and 30 represents a single number),while the most basic binaries are relations (e.g.,City maps rows to city entities, Next maps rowsto rows, and >= maps numbers to numbers).
Log-ical forms can be combined into larger ones viavarious operations listed in Table 1.
Each opera-tion produces a unary except lambda abstraction:?x[f(x)] is a binary mapping x to f(x).6 Parsing and rankingGiven the knowledge graph w, we now describehow to parse the utterance x into a set of candidatelogical forms Zx6.1 Parsing algorithmWe propose a new floating parser which is moreflexible than a standard chart parser.
Both parsersrecursively build up derivations and correspondinglogical forms by repeatedly applying deductionrules, but the floating parser allows logical formpredicates to be generated independently from theutterance.Chart parser.
We briefly review the CKY al-gorithm for chart parsing to introduce notation.Given an utterance with tokens x1, .
.
.
, xn, theCKY algorithm applies deduction rules of the fol-Rule Semantics ExampleAnchored to the utteranceTokenSpan?
Entity match(z1) Greece(match(s) = entity with name s) anchored to ?Greece?TokenSpan?
Atomic val(z1) 2012-07-XX(val(s) = interpreted value) anchored to ?July 2012?Unanchored (floating)?
?
Relation r Country(r = row-entity relation)?
?
Relation ?x[r.p.x] ?x[Year.Date.x](p = normalization relation)?
?
Records Type.Row (list of all rows)?
?
RecordFn Index (row?
row index)Table 2: Base deduction rules.
Entities and atomicvalues (e.g., numbers, dates) are anchored to to-ken spans, while other predicates are kept floating.(a?
b represents a binary mapping b to a.
)lowing two kinds:(TokenSpan, i, j)[s]?
(c, i, j)[f(s)], (4)(c1, i, k)[z1] + (c2, k + 1, j)[z2] (5)?
(c, i, j)[f(z1, z2)].The first rule is a lexical rule that matches an utter-ance token span xi?
?
?xj(e.g., s = ?New York?
)and produces a logical form (e.g., f(s) =NewYorkCity) with category c (e.g., Entity).The second rule takes two adjacent spans giv-ing rise to logical forms z1and z2and builds anew logical form f(z1, z2).
Algorithmically, CKYstores derivations of category c covering the spanxi?
?
?xjin a cell (c, i, j).
CKY fills in the cells ofincreasing span lengths, and the logical forms inthe top cell (ROOT, 1, n) are returned.Floating parser.
Chart parsing uses lexicalrules (4) to generate relevant logical predicates,but in our setting of semantic parsing on tables,we do not have the luxury of starting with orinducing a full-fledged lexicon.
Moreover, thereis a mismatch between words in the utteranceand predicates in the logical form.
For in-stance, consider the question ?Greece held itslast Summer Olympics in which year??
on thetable in Figure 1 and the correct logical formR[?x[Year.Date.x]].argmax(Country.Greece, Index).While the entity Greece can be anchored to thetoken ?Greece?, some logical predicates (e.g.,Country) cannot be clearly anchored to a tokenspan.
We could potentially learn to anchor thelogical form Country.Greece to ?Greece?, but ifthe relation Country is not seen during training,such a mapping is impossible to learn from thetraining data.
Similarly, some prominent tokens1473Rule Semantics ExampleJoin + AggregateEntity or Atomic?
Values z1ChinaAtomic?
Values c.z1>=.30 (at least 30)(c ?
{<, >, <=, >=})Relation + Values?
Records z1.z2Country.China (events (rows) where the country is China)Relation + Records?
Values R[z1].z2R[Year].Country.China (years of events in China)Records?
Records Next.z1Next.Country.China (.
.
.
before China)Records?
Records R[Next].z1R[Next].Country.China (.
.
.
after China)Values?
Atomic a(z1) count(Country.China) (How often did China .
.
.
)(a ?
{count, max, min, sum, avg})Values?
ROOT z1SuperlativeRelation?
RecordFn z1?x[Nations.Number.x] (row?
value in Nations column)Records + RecordFn?
Records s(z1, z2) argmax(Type.Row, ?x[Nations.Number.x])(s ?
{argmax, argmin}) (events with the most participating nations)argmin(City.Athens, Index) (first event in Athens)Relation?
ValueFn R[?x[a(z1.x)]] R[?x[count(City.x)]] (city?
num.
of rows with that city)Relation + Relation?
ValueFn ?x[R[z1].z2.x] ?x[R[City].Nations.Number.x](city?
value in Nations column)Values + ValueFn?
Values s(z1, z2) argmax(.
.
.
,R[?x[count(City.x)]]) (most frequent city)Other operationsValueFn + Values + Values?
Values o(R[z1].z2,R[z1].z3) sub(R[Number].R[Nations].City.London, .
.
.
)(o ?
{add, sub, mul, div}) (How many more participants were in London than .
.
.
)Entity + Entity?
Values z1unionsq z2China unionsq France (China or France)Records + Records?
Records z1u z2City.Beijing u Country.China (.
.
.
in Beijing, China)Table 3: Compositional deduction rules.
Each rule c1, .
.
.
, ck?
c takes logical forms z1, .
.
.
, zkcon-structed over categories c1, .
.
.
, ck, respectively, and produces a logical form based on the semantics.
(e.g., ?Olympics?)
are irrelevant and have nopredicates anchored to them.Therefore, instead of anchoring each predicatein the logical form to tokens in the utterance vialexical rules, we propose parsing more freely.
Wereplace the anchored cells (c, i, j) with floatingcells (c, s) of category c and logical form size s.Then we apply rules of the following three kinds:(TokenSpan, i, j)[s]?
(c, 1)[f(s)], (6)?
?
(c, 1)[f()], (7)(c1, s1)[z1] + (c2, s2)[z2] (8)?
(c, s1+ s2+ 1)[f(z1, z2)].Note that rules (6) are similar to (4) in chartparsing except that the floating cell (c, 1) onlykeeps track of the category and its size 1, notthe span (i, j).
Rules (7) allow us to constructpredicates out of thin air.
For example, we canconstruct a logical form representing a table rela-tion Country in cell (Relation, 1) using the rule?
?
Relation [Country] independent of the ut-terance.
Rules (8) perform composition, wherethe induction is on the size s of the logical formrather than the span length.
The algorithm stopswhen the specified maximum size is reached, afterwhich the logical forms in cells (ROOT, s) for anys are included in Zx.
Figure 4 shows an examplederivation generated by our floating parser.
(Values, 8)R[?x[Year.Date.x]].argmax(Country.Greece, Index)(Relation, 1)?x[Year.Date.x] (Records, 6)argmax(Country.Greece, Index)(Records, 4)Country.Greece(Relation, 1)Country (Values, 2)Greece(Entity , 1)Greece(TokenSpan, 1, 1)?Greece?
(RecordFn, 1)IndexFigure 4: A derivation for the utterance ?Greeceheld its last Summer Olympics in which year?
?Only Greece is anchored to a phrase ?Greece?
;Year and other predicates are floating.The floating parser is very flexible: it can skiptokens and combine logical forms in any order.This flexibility might seem too unconstrained, butwe can use strong typing constraints to preventnonsensical derivations from being constructed.Tables 2 and 3 show the full set of deductionrules we use.
We assume that all named entitieswill explicitly appear in the question x, so we an-1474?Greece held its last Summer Olympics in which year?
?z = R[?x[Year.Number.x]].argmax(Type.Row, Index)y = {2012} (type: NUM, column: YEAR)Feature Name Note(?last?, predicate = argmax) lexphrase = predicate unlex (?
?year?
= Year)missing entity unlex (?
missing Greece)denotation type = NUMdenotation column = YEAR(?which year?, type = NUM) lexphrase = column unlex (?
?year?
= YEAR)(Q = ?which?, type = NUM) lex(H = ?year?, type = NUM) lexH = column unlex (?
?year?
= YEAR)Table 4: Example features that fire for the (incor-rect) logical form z.
All features are binary.
(lex =lexicalized)chor all entity predicates (e.g., Greece) to tokenspans (e.g., ?Greece?).
We also anchor all numer-ical values (numbers, dates, percentages, etc.)
de-tected by an NER system.
In contrast, relations(e.g., Country) and operations (e.g., argmax) arekept floating since we want to learn how theyare expressed in language.
Connections betweenphrases in x and the generated relations and op-erations in z are established in the ranking modelthrough features.6.2 FeaturesWe define features ?
(x,w, z) for our log-linearmodel to capture the relationship between thequestion x and the candidate z.
Table 4 showssome example features from each feature type.Most features are of the form (f(x), g(z)) or(f(x), h(y)) where y = JzKwis the denotation,and f , g, and h extract some information (e.g.,identity, POS tags) from x, z, or y, respectively.phrase-predicate: Conjunctions between n-grams f(x) from x and predicates g(z) from z.We use both lexicalized features, where all possi-ble pairs (f(x), g(z)) form distinct features, andbinary unlexicalized features indicating whetherf(x) and g(z) have a string match.missing-predicate: Indicators on whether thereare entities or relations mentioned in x but not inz.
These features are unlexicalized.denotation: Size and type of the denotationy = JxKw.
The type can be either a primitive type(e.g., NUM, DATE, ENTITY) or the name of thecolumn containing the entity in y (e.g., CITY).phrase-denotation: Conjunctions between n-grams from x and the types of y.
Similar to thephrase-predicate features, we use both lexicalizedand unlexicalized features.headword-denotation: Conjunctions betweenthe question word Q (e.g., what, who, how many)or the headword H (the first noun after the ques-tion word) with the types of y.6.3 Generation and pruningDue to their recursive nature, the rules allow usto generate highly compositional logical forms.However, the compositionality comes at the costof generating exponentially many logical forms,most of which are redundant (e.g., logical formswith an argmax operation on a set of size 1).
Weemploy several methods to deal with this combi-natorial explosion:Beam search.
We compute the model proba-bility of each partial logical form based on avail-able features (i.e., features that do not depend onthe final denotation) and keep only the K = 200highest-scoring logical forms in each cell.Pruning.
We prune partial logical forms thatlead to invalid or redundant final logical forms.For example, we eliminate any logical form thatdoes not type check (e.g., Beijing unionsq Greece),executes to an empty list (e.g., Year.Number.24),includes an aggregate or superlative on a singletonset (e.g., argmax(Year.Number.2012, Index)), orjoins two relations that are the reverses of eachother (e.g., R[City].City.Beijing).7 Experiments7.1 Main evaluationWe evaluate the system on the development sets(three random 80:20 splits of the training data) andthe test data.
In both settings, the tables we test ondo not appear during training.Evaluation metrics.
Our main metric is accu-racy, which is the number of examples (x, t, y)on which the system outputs the correct answer y.We also report the oracle score, which counts thenumber of examples where at least one generatedcandidate z ?
Zxexecutes to y.Baselines.
We compare the system to two base-lines.
The first baseline (IR), which simulates in-formation retrieval, selects an answer y among theentities in the table using a log-linear model overentities (table cells) rather than logical forms.
Thefeatures are conjunctions between phrases in x andproperties of the answers y, which cover all fea-tures in our main system that do not involve thelogical form.
As an upper bound of this baseline,1475dev testacc ora acc oraIR baseline 13.4 69.1 12.7 70.6WQ baseline 23.6 34.4 24.3 35.6Our system 37.0 76.7 37.1 76.6Table 5: Accuracy (acc) and oracle scores (ora)on the development sets (3 random splits of thetraining data) and the test data.acc oraOur system 37.0 76.7(a) Rule Ablationjoin only 10.6 15.7join + count (= WQ baseline) 23.6 34.4join + count + superlative 30.7 68.6all ?
{u,unionsq} 34.8 75.1(b) Feature Ablationall ?
features involving predicate 11.8 74.5all ?
phrase-predicate 16.9 74.5all ?
lex phrase-predicate 17.6 75.9all ?
unlex phrase-predicate 34.3 76.7all ?
missing-predicate 35.9 76.7all ?
features involving denotation 33.5 76.8all ?
denotation 34.3 76.6all ?
phrase-denotation 35.7 76.8all ?
headword-denotation 36.0 76.7(c) Anchor operations to trigger words 37.1 59.4Table 6: Average accuracy and oracle scores ondevelopment data in various system settings.69.1% of the development examples have the an-swer appearing as an entity in the table.In the second baseline (WQ), we only allow de-duction rules that produce join and count logicalforms.
This rule subset has the same logical cov-erage as Berant and Liang (2014), which is de-signed to handle the WEBQUESTIONS (Berant etal., 2013) and FREE917 (Cai and Yates, 2013)datasets.Results.
Table 5 shows the results comparedto the baselines.
Our system gets an accuracyof 37.1% on the test data, which is significantlyhigher than both baselines, while the oracle is76.6%.
The next subsections analyze the systemcomponents in more detail.7.2 Dataset statisticsIn this section, we analyze the breadth and depthof the WIKITABLEQUESTIONS dataset, and howthe system handles them.Number of relations.
With 3,929 unique col-umn headers (relations) among 13,396 columns,the tables in the WIKITABLEQUESTIONS datasetcontain many more relations than closed-domaindatasets such as Geoquery (Zelle and Mooney,Operation Amountjoin (table lookup) 13.5%+ join with Next + 5.5%+ aggregate (count, sum, max, .
.
. )
+ 15.0%+ superlative (argmax, argmin) + 24.5%+ arithmetic, u, unionsq + 20.5%+ other phenomena + 21.0%Table 7: The logical operations required to answerthe questions in 200 random examples.1996) and ATIS (Price, 1990).
Additionally, thelogical forms that execute to the correct denota-tions refer to a total of 2,056 unique column head-ers, which is greater than the number of relationsin the FREE917 dataset (635 Freebase relations).Knowledge coverage.
We sampled 50 exam-ples from the dataset and tried to answer themmanually using Freebase.
Even though Free-base contains some information extracted fromWikipedia, we can answer only 20% of the ques-tions, indicating that WIKITABLEQUESTIONScontains a broad set of facts beyond Freebase.Logical operation coverage.
The dataset cov-ers a wide range of question types and logicaloperations.
Table 6(a) shows the drop in oraclescores when different subsets of rules are used togenerate candidates logical forms.
The join onlysubset corresponds to simple table lookup, whilejoin + count is the WQ baseline for Freebase ques-tion answering on the WEBQUESTIONS dataset.Finally, join + count + superlative roughly corre-sponds to the coverage of the Geoquery dataset.To better understand the distribution of log-ical operations in the WIKITABLEQUESTIONSdataset, we manually classified 200 examplesbased on the types of operations required to an-swer the question.
The statistics in Table 7 showsthat while a few questions only require simpleoperations such as table lookup, the majority ofthe questions demands more advanced operations.Additionally, 21% of the examples cannot be an-swered using any logical form generated from thecurrent deduction rules; these examples are dis-cussed in Section 7.4.Compositionality.
From each example, wecompute the logical form size (number of rulesapplied) of the highest-scoring candidate that exe-cutes to the correct denotation.
The histogram inFigure 5 shows that a significant number of logicalforms are non-trivial.Beam size and pruning.
Figure 6 shows theresults with and without pruning on various beam14762 3 4 5 6 7 8 9 10 11formula size05001000150020002500frequencyFigure 5: Sizes of the highest-scoring correct can-didate logical forms in development examples.with pruning without pruning0 25 50 75 100beam size020406080score0 25 50 75 100beam size020406080scoreFigure 6: Accuracy (solid red) and oracle (dashedblue) scores with different beam sizes.sizes.
Apart from saving time, pruning also pre-vents bad logical forms from clogging up the beamwhich hurts both oracle and accuracy metrics.7.3 FeaturesEffect of features.
Table 6(b) shows the accu-racy when some feature types are ablated.
Themost influential features are lexicalized phrase-predicate features, which capture the relationshipbetween phrases and logical operations (e.g., relat-ing ?last?
to argmax) as well as between phrasesand relations (e.g., relating ?before?
to < or Next,and relating ?who?
to the relation Name).Anchoring with trigger words.
In our parsingalgorithm, relations and logical operations are notanchored to the utterance.
We consider an alter-native approach where logical operations are an-chored to ?trigger?
phrases, which are hand-codedbased on co-occurrence statistics (e.g., we triggera count logical form with how, many, and total).Table 6(c) shows that the trigger words do notsignificantly impact the accuracy, suggesting thatthe original system is already able to learn the re-lationship between phrases and operations evenwithout a manual lexicon.
As an aside, the hugedrop in oracle is because fewer ?semantically in-correct?
logical forms are generated; we discussthis phenomenon in the next subsection.7.4 Semantically correct logical formsIn our setting, we face a new challenge that arisesfrom learning with denotations: with deeper com-positionality, a larger number of nonsensical log-ical forms can execute to the correct denotation.For example, if the target answer is a small num-ber (say, 2), it is possible to count the number ofrows with some random properties and arrive atthe correct answer.
However, as the system en-counters more examples, it can potentially learn todisfavor them by recognizing the characteristics ofsemantically correct logical forms.Generating semantically correct logicalforms.
The system can learn the features ofsemantically correct logical forms only if it cangenerate them in the first place.
To see how wellthe system can generate correct logical forms,looking at the oracle score is insufficient sincebad logical forms can execute to the correctdenotations.
Instead, we randomly chose 200 ex-amples and manually annotated them with logicalforms to see if a trained system can produce theannotated logical form as a candidate.Out of 200 examples, we find that 79% canbe manually annotated.
The remaining ones in-clude artifacts such as unhandled question types(e.g., yes-no questions, or questions with phrases?same?
or ?consecutive?
), table cells that requireadvanced normalization methods (e.g., cells withcomma-separated lists), and incorrect annotations.The system generates the annotated logicalform among the candidates in 53.5% of the ex-amples.
The missing examples are mostly causedby anchoring errors due to lexical mismatch (e.g.,?Italian??
Italy, or ?no zip code??
an emptycell in the zip code column) or the need to generatecomplex logical forms from a single phrase (e.g.,?May 2010??
>=.2010-05-01u<=.2010-05-31).7.5 Error analysisThe errors on the development data can be dividedinto four groups.
The first two groups are unhan-dled question types (21%) and the failure to an-chor entities (25%) as described in Section 7.4.The third group is normalization and type errors(29%): although we handle some forms of en-tity normalization, we observe many unhandledstring formats such as times (e.g., 3:45.79) andcity-country pairs (e.g., Beijing, China), as well ascomplex calculation such as computing time peri-ods (e.g., 12pm?1am?
1 hour).
Finally, we haveranking errors (25%) which mostly occur when theutterance phrase and the relation are obliquely re-lated (e.g., ?airplane?
and Model).14778 DiscussionOur work simultaneously increases the breadth ofknowledge source and the depth of compositional-ity in semantic parsing.
This section explores theconnections in both aspects to related work.Logical coverage.
Different semantic parsingsystems are designed to handle different sets oflogical operations and degrees of compositional-ity.
For example, form-filling systems (Wang etal., 2011) usually cover a smaller scope of opera-tions and compositionality, while early statisticalsemantic parsers for question answering (Wongand Mooney, 2007; Zettlemoyer and Collins,2007) and high-accuracy natural language inter-faces for databases (Androutsopoulos et al, 1995;Popescu et al, 2003) target more compositionalutterances with a wide range of logical opera-tions.
This work aims to increase the logicalcoverage even further.
For example, comparedto the Geoquery dataset, the WIKITABLEQUES-TIONS dataset includes a move diverse set of log-ical operations, and while it does not have ex-tremely compositional questions like in Geoquery(e.g., ?What states border states that border statesthat border Florida??
), our dataset contains fairlycompositional questions on average.To parse a compositional utterance, many worksrely on a lexicon that translates phrases to enti-ties, relations, and logical operations.
A lexiconcan be automatically generated (Unger and Cimi-ano, 2011; Unger et al, 2012), learned from data(Zettlemoyer and Collins, 2007; Kwiatkowski etal., 2011), or extracted from external sources (Caiand Yates, 2013; Berant et al, 2013), but requiressome techniques to generalize to unseen data.
Ourwork takes a different approach similar to the log-ical form growing algorithm in Berant and Liang(2014) by not anchoring relations and operationsto the utterance.Knowledge domain.
Recent works on seman-tic parsing for question answering operate on moreopen and diverse data domains.
In particular,large-scale knowledge bases have gained popular-ity in the semantic parsing community (Cai andYates, 2013; Berant et al, 2013; Fader et al,2014).
The increasing number of relations and en-tities motivates new resources and techniques forimproving the accuracy, including the use of ontol-ogy matching models (Kwiatkowski et al, 2013),paraphrase models (Fader et al, 2013; Berant andLiang, 2014), and unlabeled sentences (Krishna-murthy and Kollar, 2013; Reddy et al, 2014).Our work leverages open-ended data from theWeb through semi-structured tables.
There havebeen several studies on analyzing or inferring thetable schemas (Cafarella et al, 2008; Venetis et al,2011; Syed et al, 2010; Limaye et al, 2010) andanswering search queries by joining tables on sim-ilar columns (Cafarella et al, 2008; Gonzalez etal., 2010; Pimplikar and Sarawagi, 2012).
Whilethe latter is similar to question answering, thequeries tend to be keyword lists instead of naturallanguage sentences.
In parallel, open informationextraction (Wu and Weld, 2010; Masaum et al,2012) and knowledge base population (Ji and Gr-ishman, 2011) extract information from web pagesand compile them into structured data.
The result-ing knowledge base is systematically organized,but as a trade-off, some knowledge is inevitablylost during extraction and the information is forcedto conform to a specific schema.
To avoid these is-sues, we choose to work on HTML tables directly.In future work, we wish to draw informa-tion from other semi-structured formats such ascolon-delimited pairs (Wong et al, 2009), bulletedlists (Gupta and Sarawagi, 2009), and top-k lists(Zhang et al, 2013).
Pasupat and Liang (2014)used a framework similar to ours to extract entitiesfrom web pages, where the ?logical forms?
wereXPath expressions.
A natural direction is to com-bine the logical compositionality of this work withthe even broader knowledge source of general webpages.Acknowledgements.
We gratefully acknowl-edge the support of the Google Natural LanguageUnderstanding Focused Program and the DefenseAdvanced Research Projects Agency (DARPA)Deep Exploration and Filtering of Text (DEFT)Program under Air Force Research Laboratory(AFRL) contract no.
FA8750-13-2-0040.Data and reproducibility.
The WIKITABLE-QUESTIONS dataset can be downloaded at http://nlp.stanford.edu/software/sempre/wikitable/.Additionally, code, data, and experiments forthis paper are available on the CodaLab plat-form at https://www.codalab.org/worksheets/0xf26cd79d4d734287868923ad1067cf4c/.ReferencesI.
Androutsopoulos, G. D. Ritchie, and P. Thanisch.1995.
Natural language interfaces to databases ?1478an introduction.
Journal of Natural Language En-gineering, 1:29?81.J.
Berant and P. Liang.
2014.
Semantic parsing viaparaphrasing.
In Association for ComputationalLinguistics (ACL).J.
Berant, A. Chou, R. Frostig, and P. Liang.
2013.Semantic parsing on Freebase from question-answerpairs.
In Empirical Methods in Natural LanguageProcessing (EMNLP).M.
J. Cafarella, A. Halevy, D. Z. Wang, E. Wu, andY.
Zhang.
2008.
WebTables: exploring the powerof tables on the web.
In Very Large Data Bases(VLDB), pages 538?549.Q.
Cai and A. Yates.
2013.
Large-scale semantic pars-ing via schema matching and lexicon extension.
InAssociation for Computational Linguistics (ACL).J.
Duchi, E. Hazan, and Y.
Singer.
2010.
Adaptive sub-gradient methods for online learning and stochasticoptimization.
In Conference on Learning Theory(COLT).A.
Fader, L. Zettlemoyer, and O. Etzioni.
2013.Paraphrase-driven learning for open question an-swering.
In Association for Computational Linguis-tics (ACL).A.
Fader, L. Zettlemoyer, and O. Etzioni.
2014.Open question answering over curated and extractedknowledge bases.
In International Conference onKnowledge Discovery and Data Mining (KDD),pages 1156?1165.H.
Gonzalez, A. Y. Halevy, C. S. Jensen, A. Langen,J.
Madhavan, R. Shapley, W. Shen, and J. Goldberg-Kidon.
2010.
Google fusion tables: web-centereddata management and collaboration.
In Proceedingsof the 2010 ACM SIGMOD International Confer-ence on Management of data, pages 1061?1066.R.
Gupta and S. Sarawagi.
2009.
Answering tableaugmentation queries from unstructured lists on theweb.
In Very Large Data Bases (VLDB), number 1,pages 289?300.H.
Ji and R. Grishman.
2011.
Knowledge base pop-ulation: Successful approaches and challenges.
InAssociation for Computational Linguistics (ACL),pages 1148?1158.J.
Krishnamurthy and T. Kollar.
2013.
Jointly learningto parse and perceive: Connecting natural languageto the physical world.
Transactions of the Associa-tion for Computational Linguistics (TACL), 1:193?206.T.
Kwiatkowski, L. Zettlemoyer, S. Goldwater, andM.
Steedman.
2011.
Lexical generalization inCCG grammar induction for semantic parsing.
InEmpirical Methods in Natural Language Processing(EMNLP), pages 1512?1523.T.
Kwiatkowski, E. Choi, Y. Artzi, and L. Zettlemoyer.2013.
Scaling semantic parsers with on-the-fly on-tology matching.
In Empirical Methods in NaturalLanguage Processing (EMNLP).P.
Liang.
2013.
Lambda dependency-based composi-tional semantics.
arXiv.G.
Limaye, S. Sarawagi, and S. Chakrabarti.
2010.Annotating and searching web tables using entities,types and relationships.
In Very Large Data Bases(VLDB), volume 3, pages 1338?1347.Masaum, M. Schmitz, R. Bart, S. Soderland, and O. Et-zioni.
2012.
Open language learning for informa-tion extraction.
In Empirical Methods in NaturalLanguage Processing and Computational NaturalLanguage Learning (EMNLP/CoNLL), pages 523?534.P.
Pasupat and P. Liang.
2014.
Zero-shot entity extrac-tion from web pages.
In Association for Computa-tional Linguistics (ACL).R.
Pimplikar and S. Sarawagi.
2012.
Answering tablequeries on the web using column keywords.
In VeryLarge Data Bases (VLDB), volume 5, pages 908?919.A.
Popescu, O. Etzioni, and H. Kautz.
2003.
Towardsa theory of natural language interfaces to databases.In International Conference on Intelligent User In-terfaces (IUI), pages 149?157.P.
Price.
1990.
Evaluation of spoken language sys-tems: The ATIS domain.
In Proceedings of theThird DARPA Speech and Natural Language Work-shop, pages 91?95.S.
Reddy, M. Lapata, and M. Steedman.
2014.
Large-scale semantic parsing without question-answerpairs.
Transactions of the Association for Compu-tational Linguistics (TACL), 2(10):377?392.Z.
Syed, T. Finin, V. Mulwad, and A. Joshi.
2010.Exploiting a web of semantic data for interpretingtables.
In Proceedings of the Second Web ScienceConference.C.
Unger and P. Cimiano.
2011.
Pythia: compositionalmeaning construction for ontology-based questionanswering on the semantic web.
In Proceedings ofthe 16th international conference on Natural lan-guage processing and information systems, pages153?160.C.
Unger, L. B?uhmann, J. Lehmann, A. Ngonga,D.
Gerber, and P. Cimiano.
2012.
Template-basedquestion answering over RDF data.
In World WideWeb (WWW), pages 639?648.P.
Venetis, A. Halevy, J. Madhavan, M. Pas?ca, W. Shen,F.
Wu, G. Miao, and C. Wu.
2011.
Recovering se-mantics of tables on the web.
In Very Large DataBases (VLDB), volume 4, pages 528?538.1479Y.
Wang, L. Deng, and A. Acero.
2011.
Semanticframe-based spoken language understanding.
Spo-ken Language Understanding: Systems for Extract-ing Semantic Information from Speech, pages 41?91.Y.
W. Wong and R. J. Mooney.
2007.
Learningsynchronous grammars for semantic parsing withlambda calculus.
In Association for ComputationalLinguistics (ACL), pages 960?967.Y.
W. Wong, D. Widdows, T. Lokovic, and K. Nigam.2009.
Scalable attribute-value extraction from semi-structured text.
In IEEE International Conferenceon Data Mining Workshops, pages 302?307.F.
Wu and D. S. Weld.
2010.
Open information extrac-tion using Wikipedia.
In Association for Computa-tional Linguistics (ACL), pages 118?127.M.
Zelle and R. J. Mooney.
1996.
Learning toparse database queries using inductive logic pro-gramming.
In Association for the Advancement ofArtificial Intelligence (AAAI), pages 1050?1055.L.
S. Zettlemoyer and M. Collins.
2007.
Online learn-ing of relaxed CCG grammars for parsing to log-ical form.
In Empirical Methods in Natural Lan-guage Processing and Computational Natural Lan-guage Learning (EMNLP/CoNLL), pages 678?687.Z.
Zhang, K. Q. Zhu, H. Wang, and H. Li.
2013.
Au-tomatic extraction of top-k lists from the web.
InInternational Conference on Data Engineering.1480
