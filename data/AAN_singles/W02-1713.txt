XtraGen ?A Natural Language Generation SystemUsing XML- and Java-TechnologiesHolger StenzhornXtraMind Technologies GmbHStuhlsatzenhausweg 366123 Saarbru?cken, Germanyholger@xtramind.comAbstractIn this paper we present XtraGen, a XML- and Java-based software system for the flexible, real-timegeneration of natural language that is easily inte-grated and used in real-world applications.
We de-scribe its grammar formalism and implementationin detail, depict the context of how the system wasevaluated and finally provide an outlook on futurework with the system.1 IntroductionIn this paper we present XtraGen, a recently de-veloped software system for the flexible, real-timegeneration of natural language that can be easily in-tegrated into real-world, industrial application en-vironments through its open XML- and Java-basedimplementation and interfaces.Our motivation for developing a completely newgeneration system started when we made the sameobservation as stated in the following quote:There are thousands, if not millions, ofapplication programs in everyday use thatautomatically generate texts; but proba-bly fewer than ten of these programs usethe linguistic and knowledge-based tech-niques that have been studied by the natu-ral language generation community.
(Re-iter, 1995)The goal of our company is to develop state-of-the-art software and hence we wanted to change theportrayed situation at least in our environment forthe applications we create.Therefore we started to experiment with XSL(World Wide Web Consortium, 2001) to generatenatural language as suggested in (Cawsey, 2000)and (Wilcock, 2001).
But we figured out fairly soonthat XSL did not satisfy our needs and desires be-cause with this mechanism?
we were not able to appropriately handle theissue of morphology,?
we could not parameterize the generation pro-cess at the desired level and?
we had no possibility to generate alternativesor recover from dead ends during generationsince XSL is lacking a backtracking mecha-nism.Therefore we decided to develop our own naturallanguage generation system that incorporates on theone hand many ideas found in XSL but on the otherhand tries to give a solution the above describedproblems.2 Generation Grammars2.1 FormalismThe grammar formalism conceived for the XtraGensystem has been developed from an application-oriented point of view.
This means that from ourstandpoint real-world applications hardly ever re-quire a full and complete linguistic coverage whichis striven for by linguistically motivated generationsystems.
Therefore our formalism is based on ex-tended templates that allow the inclusion of pre-defined and dynamically retrieved text, constraint-based inflection and a context-free selection mech-anism.
The development of this formalism wasstrongly influenced by the ideas found in the (Lisp-based) formalism of the TG/2 system (Busemann,1996; Wein, 1996) and the YAG system (Chan-narukul, 1999).A template has the overall form as depicted in theBackus-Naur Form in figure 2.1.
Each part of thetemplate will be elaborated below.2.2 ConditionsConditions describe the exact circumstances underwhich a certain template can be applied and its ac-tions executed.
There are two distinct basic types<template id="String"category="String"><conditions>Condition*</conditions><parameters>Parameter*</parameters><actions>Action+</actions><constraints>Constraint*</constraints></template>Figure 1: Overview of a XtraGen template inBackus-Naur Formof conditions: Simple-Conditions and Complex-Conditions.
They in turn are the supertypes formore specific conditions:Simple-Condition They form the actual tests thatare applied to the input structure.
A set of com-monly used conditions is already predefinedsuch as ones that test for equality or that testwhether certain information is existent in theinput structure.
If there is a need for some veryspecific conditional testing that cannot be re-alized with the existing means a developer isfree to implement and add its own conditionaltypes.Complex-Condition This type of condition makesit possible to combine several conditionsinto a more complex one.
Three prede-fined Complex-Conditions exist: the And-Condition, the Or-Condition and the Not-Condition.
Additional Complex-Conditionscan also be added by providing an implemen-tation for them.2.3 ParameterizationParameterization is an easy and flexible means toguide and control the generation process with re-gard to different linguistic preferences such as mat-ters of style or rhetorical structures.
Parameteriza-tion works by introducing a preference mechanismthat provides the possibility of dynamically sortingthe application of templates according to a given setof parameters.<conditions><or><and><condition type="equal"><get path="/recall"/><value>95</value></condition><condition type="less"><get path="/accuracy"/><value>90</value></condition></and><not><condition type="exist"><get path="/exception"/></condition></not></or></conditions>Figure 2: Example of some complex interleavedconditionsThe way parametrization works in our system isa two-step process:Adding of parameters to templates During thedesign of a generation grammar the writer addsone or more parameters to some templates asin the example in figure 3.Here the upper template is intended to be usedduring the generation of text targeted at expertsand the lower one in case text is to be pro-duced for novices (level is expert in onetemplate and novice in the other).
Both ofthe templates are preferably used when a lowverbosity level is desired (verbosity is lowin both cases).Setting of the parameters at runtime At runtimethe parameters corresponding to the ones de-fined in the grammar are set to the desired val-ues.
To continue our example, we now set thevalue of the parameter level to expert (seefigure 4) and hence the template in the upperbox would be selected.The particularity of our system is that parame-ters can be assigned a weight and thus a priority.
Inour example we might want to give a higher prior-ity to the parameter level than to the parameterverbosity as shown in figure 5 This now sortsthe application of templates in a way that they arefirst sorted according to their level of verbosity andthe result is further sorted according to the level ofexpertise.<template id="explainExpert"category="explain"><parameters><parameter name="level"value="expert"><parameter name="verbosity"value="low"></parameters>...</template><template id="explainNovice"category="explain"><parameters><parameter name="level"value="novice"><parameter name="verbosity"value="low"></parameters>...</template>Figure 3: Example of using parameters on the levelof generation grammarsgenerator.addParameter("level","expert");Figure 4: Example of using parameters on the levelof programming codegenerator.addParameter("level","novice",0.75);generator.addParameter("verbosity","low",0.5);Figure 5: Example of using parameters with aweight specified on the level of programming code2.4 ActionsIn the case that all conditions of a given templatehave been tested successfully (see section 2.2) theactions contained in the actions-part of the templateare executed.There are four different types of actions that canappear: String-Action, Getter-Action, Inflection-Action and Selection-Action.
The actual purpose ofeach of them is quite different but all of them returna result string when executed successfully.String-Action This type of action simply returns astatically specified string as a result ?
a so-called canned text.Getter-Action With a Getter-Action it is possibleto directly access and retrieve data from the en-tered input structure.
The syntax used for spec-ifying the path to the data conforms to the syn-tax of XPath (World Wide Web Consortium,1999).
There is no additional processing doneon the returned data.<get path="/values/startTime"/>Inflection-Action This action inflects a stem ac-cording to the defined morphological con-straints and returns the result.The stem can be stated statically in the gram-mar as in case (a) or can be dynamically re-trieved from the input structure as in case (b).The needed morphological constraints are fur-nished by the constraints-part of the templateto which the given label provides a link (con-fer to section 2.5 below for details).
(a) <inflect stem="bring"label="X0"/>(b) <inflect path="/action"label="X0"/>Selection-Action The Selection-Action can actu-ally be seen as the most important of theactions since it accounts for the context-freebackbone of the system.It allows to select another template directly viaa specified identifier as in case (a) or via agiven category as in case (b).
In the secondcase several templates might have the givencategory and hence backtracking might be in-voked at his point.
(see section 5.1)(a) <select id="top"/>(b) <select category="top"optional="true"/>Selections can also be declared optional as in(b) which means that in case the selection ofthe template fails no backtracking is invokedand simply an empty string is returned.2.5 Constraints and MorphologyThe treatment of morphology is naturally one ofthe major issues in the context of a complete nat-ural language generation especially when workingwith morphologically rich languages such as Ger-man, Russian or Finnish.
Therefore we took greatcare to design and develop a morphological subsys-tem that is powerful and flexible yet easy to under-stand and use.
The actual realization of the compo-nent is based on a constraint-based inheritance algo-rithm that follows the example of PATR-II (Shieberet al, 1989).In the (overly simplified) example in figure 6 onecan get a glimpse on how the morphology works:There are two Selection-Actions, the first one la-belled X0, the second one labelled X1.
The givenconstraint now tells that the attribute number of X0is the same as the attribute number of X1 and setsit dynamically to the value retrieved by the Getter-Action.<template ...><actions><select category="determiner"label="X0"/><select category="noun"label="X1"/></actions><constraint><place label="X0"attribute="number"/><place label="X1"attribute="number"/><get path="/categoryNumber"/></constraint></template>Figure 6: Example of using constraints2.6 CompilationIn order to be able to work with a generation gram-mar the generation engine requires the grammar(and its templates) to exist in the form of a Java ob-ject.
But since the original format of the grammar isplain XML this format must be transformed througha compilation process into the internally needed rep-resentation.
Our system is capable to perform sucha compilation in two different ways:Just-in-time Compilation With this technique therequired templates are compiled from theirXML source into their corresponding Java ob-jects at runtime of the generation engine, i.e.during the actual generation process.
Thistype of compilation is advised only for smallergrammars or during the development and test-ing of a new grammar since the constant in-terleaving of compilation on the one hand andthe actual generation process on the other leadsto some quite noticeable overhead.
This over-head is naturally not acceptable when XtraGenis used in real-time applications.Pre-Compilation This type of compilation allowsto compile the whole grammar before its actualdeployment during the generation process.
Thepre-compilation of grammars can improve theperformance of the generator-engine tremen-dously and is therefore to be preferred in mostsituations.
(The pre-compilation of generationgrammars is very similar to the Translets ap-proach in XSL (Apache XML Project, 2002)where XSL stylesheets are compiled in ad-vance into Java objects.
)3 InputIn contrast to other generation systems that requiretheir input to adhere to some particular (and mostof the time proprietary) encoding format the coreengine of our system only demands its input to be avalid XML structure.The actual restrictions on the input are imposedonly at the level of the generation grammars interms of their access to the input (see section 2.4on Getter-Actions and Inflection-Actions).
This canobviously lead to a severe drawback: In case thateither the generation grammar or the input structurechanges heavily there might emerge a complete mis-match between the XPath specified in the actionsand the actual structure of the input.Under circumstances when it is not feasible tochange either the input structure or the grammar, wepropose to introduce an additional mapping layerbetween input and generator that is based on a XSLstylesheet and that dynamically maps the input inthe way that is needed by the grammar.4 EditorWe have stressed in the sections before that we be-lieve our formalism to be powerful yet very straight-forward to implement and use.
But when develop-ing larger grammars for real-world applications itbecomes quite a demanding, non-trivial task to keeptrack of all the templates and especially of the rela-tions between them (e.g.
relations on the level ofmorphological constraints) Common XML editorsare of no help at this point since they cannot showsuch relations at all.Therefore the development of egram, a Java-based graphical editor for generation grammars ison its way at the site of our cooperation partnerDFKI (German Research Center for Artificial Intel-ligence).
After the completion of its developmentthis tool will allow to comfortably edit all aspects ofgeneration grammars and templates.
Among manyother things the editor will be able to depict thewhole generation grammar and process in a graphi-cal tree format in which dependencies between tem-plates are shown in an intuitive way.5 ImplementationThe realization and implementation of the XtraGensystem is based entirely on the two cornerstonesJava and XML.XML was chosen because it has become the de-facto standard language in many (if not most) sce-narios where information transfer takes place.
Thisin turn is caused by its unique capabilities to encodeinformation in a way that is easy to read, process,and generate (even for human beings as in the caseof our formalism).Java was chosen because it provides many mech-anism to bolster the productivity of a programmerduring the development of new software with suchthings as an extensive programming interface orautomatic memory management for example.
Anadditional advantage of Java is the availability ofmany free and readily usable open-source packagesthat provide a host of diverse functionalities.
Themost important ones in our project were the differ-ent XML packages and in particular the XML parserXerces or the XSLT engine Xalan (Apache XMLProject, 2002).5.1 BacktrackingDuring the generation process it is possible that twodifferent templates are applicable at the same time(i.e.
they have the same category and all of theirconditions are satisfied).
Now if one of the tem-plates is selected this leads to one of two differentresults:?
The application of the template was success-ful which means that all of its actions couldbe successfully executed and a result was re-turned.?
The application of the template failed becausethe execution of one or more of its actions wasnot successful.But the failure of a template described above doesnot mean that there exist no solution at all.
There-fore we backtrack to the point where the unsuccess-ful template was selected and apply another tem-plate.
This procedure is repeated until there are nomore templates at this backtrack point.The underlying implementation of the backtrack-ing mechanism is quite elaborated since it has totake several important issues into account, the mostimportant ones are:Performance issues We implemented several dif-ferent mechanisms that help to tremendouslyenhance the performance during the backtrack-ing phase such as the memorization of partialsolution.Constraint issues We had to take great care of theconstraint inheritance mechanism during thebacktracking implementation so that an invo-cation of backtracking does not lead to a mis-guided percolation of constraints and hence acorrupted morphology.5.2 Programming InterfaceSo far we have talked about the deployment of Xtra-Gen only on the level of generation grammars andtheir XML-based formalism.
Now we turn to thedescription of the tasks that have to be undertakenon the level of programming code to make the sys-tem run.The following shows the individual steps that arebe taken to generate some output with XtraGen:Creating a new generator-engine The very firstthing to do in order to get the whole systemrunning is to create a new Generator objectwhich represents the core generation engine:Generator generator =new Generator();By doing so one implicitly creates objects forthe internal subcomponents such as the alreadymentioned morphological component and putsthem under the control of the generation en-gine.Setting the start-category or -id The generationengine needs to know which template it shouldstart from.
This is done by specifying either astart-category as in case (a) or a start-identifieras in case (b).
(a) generator.setStartCategory(String category);(b) generator.setStartId(String id);Setting the grammar Without a generation gram-mar it would naturally be impossible to gener-ate any output at all.
There are two differentpossibilities to pass a grammar to the genera-tion engine:(a) generator.setGrammarDocument(Document grammar);(b) generator.setGrammar(Grammar grammar);In the first case a Document object (WorldWide Web Consortium, 2000) that contains thegrammar in parsed XML-format is passed, inthe second case a pre-compiled Grammar ob-ject is passed.
(see section 2.6)Setting the input In addition to the grammar thegeneration engine needs an input structure togenerate from.
This can be set as follows:generator.setInputDocument(Document input);Again, the parameter passed is a Documentobject that contains the input in parsed XMLformat.
The input can be reassigned betweentwo calls to the generation engine.Setting parameters In subsection 2.3 we talkedabout the use of parameters to control andguide the generation process.
The way param-eterization works is explained in detail there.To set parameters at runtime one has to add thefollowing methods:(a) generator.addParameter(String name, String value);(b) generator.addParameter(String name, String value,double weight);This step is only needed if parameterization isdesired.
Otherwise these methods can be omit-ted and parameterization is turned automati-cally off.Run the generation process To now actually startthe generation process and get some output,one of the following calls can be used:(a) String result =generator.generate();(b) Document result =generator.generateDocument();The difference between the two calls is that incase (a) a simple String containing the result isreturned whereas in the case (b) a Document ob-ject is passed back.6 EvaluationAt the end of a software development phase anynewly created system must proof in an evaluationphase whether it reaches its predefined goals.
(Mel-lish and Dale, 1998) This is especially true in anindustrial context with commercial applications asin our case.The context for the evaluation of XtraGen wasprovided by X-Booster (Beauregard et al, 2002)which is another project at our site that was con-currently developed with our system.
This systemis an optimized implementation of Slipper (Cohenand Singer, 1999), a binary classifier that inducesrules via boosting and combines a set of those clas-sifiers to solve multi-class problems.
It was the goalto successfully integrate XtraGen into this system.The motivation behind this is based on the factthat common classification systems are quite non-transparent in regard to their inner workings.
There-fore it becomes rather difficult to understand howand why certain classification decisions are made bythose systems.We departed at exactly this point: XtraGen was tobe used to automatically generate texts that explainthe learning phase of the X-Booster and hence makethe classification more transparent.
As an additional?gadget?
we wanted to create the explanations in allthe languages that are spoken at our company site:English, German, French, Italian, Russian, Bulgar-ian and Turkish.6.1 Integration TasksAs the very first task of the integration procedure weneeded to answer the question what to actually out-put to the user and in which exact format this outputshould be.
We decided on producing a descriptionof the complete learning phase with two kinds ofoutput texts: One targeted at experts and one fornovice users.
The format chosen for the final outputwas HTML.Now we needed to adapt the code of X-Boosterslightly to make the meta data about the learningphase accessible from the outside.
To do so wewrote some small methods that simply returned inXML format the meta data which were only storedin internal variables up to this point.The next step was to add to X-Booster?s own codethe code for calling the generation engine and fortransforming the result into the final output-format.This was done as described in section 5.2.Finally (and most importantly) the generationgrammars for the different languages were devel-oped.
This happened in the way that we first set-upa prototypical grammar for English which we testedextensively.
Then in a second step the grammars forthe other languages were modelled according to thisexemplary one.
For this we worked together withdifferent native-speaking colleagues that translatedthe original English grammar into their language.6.2 Sample Template and OutputFigure 7 below shows a small portion of the outputreturned after running X-Booster together with theintegrated XtraGen on a given training set.
This re-sult was produced by using the English generationgrammar and the parameters set for producing textstargeted at novice users.The number of documents is 37, dividedinto 2 different categories.
The results havebeen produced using 3 fold-cross-validationwhich means that the data-set is divided into1/3 test-set and 2/3 training-set.The learner is trained on the training-dataonly and evaluated on the test-set whichhas not been presented before.
We repeatthis process 3 times on non-intersecting test-data.The overall result is then computed finallyas the average of all performed tests.
Theaverage accuracy reaches 100.0% which isachieved by applying 5 rules.Figure 7: Sample output from X-BoosterFigure 8 shows parts of the template that pro-duced the second paragraph of this sample output.The template is complete in the sense that all dif-ferent aspects of a template are exposed and it isonly simplified in the respect that similar parts ofthe template are left out.<template id="foldNumberNovice"category="foldNumber"><conditions><and><condition type="exists"/><get path="/foldNumber"/></condition>...</and></conditions><parameters><parameter name="level"value="novice"/>...</parameters><actions>...We repeat this process<get path="/foldNumber"/><inflect stem="time"label="X0"/>...</actions><constraints><constraint><place label="X0"attribute="number"/><get path="/foldNumber"/></constraint>...</constraints></template>Figure 8: Sample template from X-Booster7 Outlook and Future WorkBecause the above described evaluation proofed tobe quite successful it was decided to further deployXtraGen at our site and to integrate it into new prod-ucts and projects.
One of the first of these projectsis Mietta-II (Multilingual Information Environmentfor Travel and Tourism Applications), an EuropeanCommission funded industrial project with the goalof developing a comprehensive web search and in-formation portal that specializes on the tourism sec-tor.
(Additional application scenarios are alreadyenvisaged for a possible later stage of the project.
)In this environment we will apply natural languagegeneration to produce texts and messages for vari-ous types of media such as dynamically generatedweb pages, paper leaflets, hand-held devices andin particular cellular phones.
For the last of thosemedia we are exploring the possibility of producingvoice-enabled output with a dedicated voice serverthat is based on VoiceXML (World Wide Web Con-sortium, 2002) or JSML (Sun Microsystems, 1999).We are experimenting at the moment with the differ-ent possible outputs and on how these outputs canbe encoded in a generation grammar enriched withVoiceXML or JSML tags.8 ConclusionIn this contribution we presented XtraGen, a real-time, template-based natural language generationsystem designed for real-world applications andbased on standard XML- and Java-technologies.
Wedescribed in detail the different aspects of its gen-eration grammars with an emphasis on their for-malism.
Then we covered architectural and imple-mentational issues of the system.
After depictingthe evaluation done for XtraGen we concluded withpresenting a new project where the system is usedand where new ideas are experimented with.AcknowledgementsWe are grateful to Sven Schmeier, Huiyan Huangand Oliver Plaehn for their collaboration on X-Booster and the Mietta-II project and especially toStephan Busemann for many fruitful discussions onTG/2.
This work was carried out in the Mietta-IIproject funded by the European Commission underthe Fifth Framework Programme IST-2000-30161.ReferencesApache XML Project.
2002.
Apache XML ProjectWebsite.
http://xml.apache.org/, June.Ste?phane Beauregard, Huiyan Huang, Karsten Kon-rad, and Sven Schmeier.
2002.
Industrial-Strength Text Classifiers.
In Proceedings of theFifth International Conference on Business Infor-mation Systems (BIS2002), Poznan?, Poland.Stephan Busemann.
1996.
Best-first surface re-alization.
In Proceedings of the 8th.
Interna-tional Workshop on Natural Language Genera-tion (INLG ?96), pages 101?110, Herstmonceux,England, June.Alison Cawsey.
2000.
Presenting tailored resourcedescriptions: will XSLT do the job?
In Pro-ceedings of the Ninth World-Wide Web confer-ence (WWW9).Songsak Channarukul.
1999.
YAG: A Natural Lan-guage Generator for Real-Time Systems.
Mas-ter?s thesis, Department of Electrical Engineeringand Computer Science, University of Wisconsin-Milwaukee, December.William W. Cohen and Yoram Singer.
1999.
ASimple, Fast, and Effective Rule Learner.
In Pro-ceedings of the Annual Conference of the Ameri-can Association for Artificial Intelligence (AAAI-99), pages 335?342.Chris Mellish and Robert Dale.
1998.
Evaluationin the Context of Natural Language Generation.Computer Speech and Language, 12(1):349?373.Ehud Reiter.
1995.
NLG vs. Templates.
In Pro-ceedings of the Fifth European Workshop on Nat-ural Language Generation, pages 95?105, Lei-den, The Netherlands, May.
Faculty of Social andBehavioural Sciences, University of Leiden.Stuart M. Shieber, Gertjan van Noord, Robert C.Moore, and Fernando C. N. Pereira.
1989.
ASemantic-Head-Driven Generation Algorithm forUnification-Based Formalisms.
In Meeting of theAssociation for Computational Linguistics, pages7?17.Sun Microsystems.
1999.
Java Speech API MarkupLanguage Specification .
http://java.sun.com/products/java-media/speech/forDevelopers/JSML/, October.Michael Wein.
1996.
Eine parametrisierbareGenerierungskomponente mit generischemBacktracking.
Diploma thesis, Department ofComputer Science, University of the Saarland,Saarbru?cken.Graham Wilcock.
2001.
Pipelines, Templates andTransformations: XML for Natural LanguageGeneration.
In Proceedings of the first NLP andXML Workshop; Workshop session of the 6th Nat-ural Language Processing Pacific Rim Sympo-sium, Tokyo, November.World Wide Web Consortium.
1999.
XML PathLanguage (XPath) Version 1.0. http://www.w3.org/TR/xpath, November.World Wide Web Consortium.
2000.
DocumentObject Model (DOM) Level 2 Core Specifica-tion Version 1.0. http://www.w3.org/TR/DOM-Level-2-Core/, November.World Wide Web Consortium.
2001.
ExtensibleStylesheet Language (XSL) Version 1.0. http://www.w3.org/TR/xsl, October.World Wide Web Consortium.
2002.
VoiceExtensible Markup Language (VoiceXML)Version 2.0. http://www.w3.org/TR/voicexml20, April.
