Paradigmatic Treatment of Arabic MorphologyMart ine  SmetsCognitive and Comput ing SciencesUniversity of Sussex, Brighton BN1 9HQ, UKmartines@cogs.susx.ac.ukAbst rac tThis paper 1 presents a language to expressmorphological processes, concatenative or non-concatenative.
The language allows the def-inition of two kinds of paradigms: helpingparadigms, which define partial morphologicalforms, and main paradigms, which combine twoor more helping paradigms to define fully spec-ified forms.1 In t roduct ionThis paper presents a language to express mor-phological processes and shows how that lan-guage applies straightforwardly to Arabic mor-phology 2.
This approach to morphology is di-rectly compatible with unification-based frame-works in that lexical entries are feature struc-tures, and morphological processes are relatedto unification of feature structures.This work departs from two-level morphol-ogy, which has been at the center of com-putational morphology since the implementa-tion of URKIMMO (Koskenniemi 1983) andwas applied to Arabic morphology first by Kay(1987), then by Beesley (1989, 1996), Kiraz(1994, 1996a) and to Syriac morphology by Ki-raz (1996b).
Two-level morphology is charac-terized by an emphasis on phonological (or or-thographic) rules, and has a rudimentary treat-ment of morphology itself.The language presented in this paper pro-poses a declarative approach to morphology 31The research was supported by a grant from theResearch Board of the University of Illinois at Urbana-Champaign.2I would like to thank two anonymous reviewers fortheir helpful comments.3Only inflectional morphology is discussed in this pa-per; but the approach can be extended to derivationalmorphology.in which morphological processes are repre-sented as paradigms of relations between fea-ture structures and orthographic/phonologicalforms.
This approach is inspired from workdone by Calder (1989) who uses paradigms toorganize morphological information, and stringequations to handle string operations.2 Organ izat ion  of  the  Lex iconThe language described here supports an orga-nization of the lexicon into three components:feature component, morphological componentand lexical entries.The feature component is a hierarchy oftypes related by monotonic multiple inher-itance.The morphological component is a set ofparadigms which relate feature structuresof the feature component to inflected forms.The lexicon of "stems" is a collection ofroots which are related to inflected formsby the morphological component.
As iscustomary in accounts of Arabic, roots areordered lists of consonants.
They are asso-ciated with relevant idiosyncratic informa-tion (mainly semantic, for example the par-ticular meaning associated with each root).3 Descr ip t ion  of  the  Language3.1 The  Feature  ComponentThe feature component consists of a hierarchyof grammatical objects constrained by relevantfeatures, similar to the type hierarchy of Head-driven Phrase Structure Grammar (Pollard andSag 1994).
This allows to capture generalitiescommon to classes of words and avoid redun-dancies in the lexicon of roots.
For example,verbs are constrained to be of category verb.58(2)H-P mel-perf 5 \]\]perf active: Vt = a V2 = a;..-, v ,  : , .
,  v ,  : i;Lperf passive R IX: land to belong to one of ten forms or binyanim.
4The first binyan carries the meaning of theroot and is unmarked morphologically, whileother binyanim bring modification to the mean-ing and to the pattern of vowels and conso-nants (though the modification in meaning isnot systematic and not always predictable: seeMe Carthy 1981).Verbs are also characterized bydifferent vowelmelodies which vary in function of aspect andvoice: a verb can be in the perfective, imper-fective or participle aspect, and in the active orpassive voice.Additionally, verbs carry affixes which vary infunction of person, number and gender.
All suchinformation which is predictable is organized inthe feature component.Thus, for example, the class verb is organizedalong two dimensions, template and melody; theclass template has ten subclasses, one for eachof the binyaxtim; the class melody is organizedalong two dimensions, aspect and voice, whichhave themselves subclasses.
Classes of the hier-archy define appropriate constraints in a mono-tonic fashion.Lexical items inherit predictable informa-tion either directly (appartenance to a specificclass is stated in the lexical entry) or throughthe morphological component ( he lexical entryspecifies to which paradigm a lexeme belongs).3.2 Morphological  ComponentThe morphological component is a set ofparadigms 6.
There are two kinds of paradigms:4Mc Carthy (1981) distinguishes 15 forms, but for thepurposes of this paper, I will consider only the first tenones, which are the productive forms.SActually, there are three different melodies for theperfective aspect of verbs of the first form (a a, a i anda u), but only one of the melodies is given here, as anillustration of helping paradigms.6The notion of paradigm defined here is closely re-lated to the traditional paradigm: paradigms are sets ofwords related to the leading form which is the conven-tional representation f the lexeme; words are consideredmain paradigms, which specify fully inflectedforms, and helping paradigms, which introducepartially specified forms.
The latter introduceinformation specific to particular morphologicalrelations, and this information is used by mainparadigms to define fully inflected word forms.The fact that helping paradigms can expressinformation independently of a particular wordform a/lows that information to be inherited indistinct environments, and to combine with in-formation from other helping paradigms.
Help-ing paradigms can then be seen as capturinggeneralizations about morphological relations,and main paradigms as expressing specific mor-phological forms.As for the interface between syntax and mor-phology, each entry of a helping paradigm as-sociates relevant features to the appropriatephonological realization through references totypes of the sort hierarchy: the name or label ofeach entry of a helping paradigms directly refersto class(es) in the type hierarchy.3.2.1 Helping ParadigmsHelping paradigms are sets of pairs (F,S),where S is a string specification and F a fea-ture structure associated with the string speci-fication.
The string specification is a partial de-scription of string which may contain variables(Calder 1989).
The feature structure is inher-ited from types in the feature component.
Thus,each helping paradigm is a subset of the Carte-sian product of the set of feature structures con-sistent with the type hierarchy, and the set ofstrings of the language.Syntax of Helping Paradigms.
Helpingparadigms have the concrete syntax in (1):H-P Name(I) PHON String of characters &{Type labels: variable instantiation}as wholes, and affixes do not have any meaning indepen-dently of a root (Matthews 1991).59(3)"H-P mel-imperf\[PHON \[V1, (C,Va*)*, Va,C\]\] &"imperf active n I: Vt = a V2 = nil Va = i;active rl {II, III, IV}: V1 = u Va = a V3 = i; imperfimperf active I"1_ { V, VI}: V1 = a V2 = a Va = a;imperf active N { VII, VIII, IX, X}: V1 = a V2 = a V3 = i;imperf passive I'i I: Vt = u V2 = nil V3 = a;imperfpassive NII, IlI ... VIlI, X: V1 = u V2 = a V3 = a;imperf passive n IX: ?The name of helping paradigms is followedby the phonology, 7 a partial description of astring, s The curly brackets denote a set ofparadigm entries, and Type Labels refers totypes in the feature component.Examples  of  He lp ing Parad igms.
Exam-ples of helping paradigms are given in (2) and(3): these are two of the melody paradigms.As said earlier, aspect and voice in Arabic areexpressed through the choice of a particularmelody: jalas is the perfective active of the verbto sit down/, while ajlis is the imperfective ac-tive of the same verb.
The root consonantsare similar, but the melody differentiates per-fective from imperfective.
This is expressed bydefining melody paradigms which specify whichmelody is associated with which features; themelody is intertwined with an abstract root inthe paradigm.Capital letters in the phonology stand forvariables: C is any consonant, V any vowel; 9lower case letters are constants.The symbol n means unification, while thesymbol & following the phonology means thatthe phonology feature is distributively associ-ated with each of the entries (there are as manyspecializations of the phonology as there are en-tries).The value nil means that this position in thestring is empty; during unification, a variableunifying with nil is removed from the pattern.rPhonology means the concrete representation f astring, the orthography or the  phonology.Sin the helping paradigms which define vowel melody,the phonologies are actually regular expressions (where *means as usual zero or more occurences of a character).9If two variables of the same type bear the same in-dex, it means that they stand for the same constant.Finally, a paradigm entry specified as 2. is un-defined.Variables of the phonology are instantiatedin the paradigm entries, according to syntacticfeatures: the first entry of the paradigm calledmel-imperf specifies the value of the vowels inthe pattern \[ 1/'1, (6, V2 *) *, V3, C \] , for the im-perfective active of verbs belonging to the firstform.The label preceding the colon, active n I,refers to names of classes in the feature com-ponent, so that the constraints defined in theseclasses are inherited by the partial form speci-fied by this paradigm entry.Sometimes, the label contains a disjunc-tion: for example in the paradigm mel-irnperf, the label of the second entry isimperf active n {II, III, IP~; the disjunction{II, III, IY} means that the melody character-izing this paradigm entry is associated with anyof these derived forms (II, III or IV) in the im-perfective active.The helping paradigms in (2) and (3) onlypartially specify the phonology and features ofArabic verbs: the melody has to be correctlyintertwined with a particular pattern of conso-nants TM.
The pattern for verbs in the perfectiveaspect is defined in helping paradigm (4).The template of triliteral verbs in the per-fective aspect is given in the PHON attributeof the paradigm perf-temp: \[P, C1,X, Cz, Y, C3 \].The value of the consonants 6"I, C2 and Ca isdetermined by particular lexical entries, whileentries of the paradigm specify what kind of ma-1?Verbs are also inflected for person, number and gen-der.
This can be readily expressed by defining more help-ing paradigms.60(4)H-P perf-temp"PHON \[P, CI, X, C2, Y,C3\]\] &" I :P= n i IX=V1 Y=V2;II: P = nil X = \[V1,C2\] Y = V2;III: P = nil X = \[Vx,V1\] Y = V2;IV: P = \[h,V1\] X = nil Y = V2;V: P = \[t,Vx\] X = \[V1,C2\] Y = V=;YI: P = \[t,V1\] X = \[VI,V1\] Y = V2;VII: P = n X = VI Y = V2;VIII: P = nil X = \[t,V1\] Y = V2;IX: P = nil X = nil Y = \[V,I,C3,V2\];IV: P = \[s,t,V1\] X = nil Y = V2;terial comes in between those root consonants:for form V, the prefix is made of the consonantt and a vowel (whose value is determined bya melody paradigm); after the first consonant,there is a vowel (the same as the one of the pre-fix), and the second consonant is duplicated; fi-nally, the third consonant is preceded by a vowel(which can be different from the first one).
Eachentry partially specifies the general pattern, andassociates the resulting string with a label cor-responding to a class of the feature component.Again, the resulting entries are partial de-scriptions of strings associated with partial syn-tactic/semantic characterisations, and these de-scriptions of strings have to be combined withother partial descriptions of strings in orderto yield fully specified verbs.
This is thetask of main paradigms.
Before turning tomain paradigms, a last characteristic of helpingparadigms needs to be presented.Inher i tance.
Helping paradigms can be re-lated by monotonic inheritance.
Similarities be-tween paradigms can thereby be captured, andthe encoding be more concise.
For example, thetemplate of verbs in the imperfective differs onlyslightly from the template of verbs in the perfec-tive: a vowel is prefixed to the latter.
This canbe expressed very concisely with inheritance (5).The paradigm imperf-temp inherits all the infor-mation specified in the entries of the paradigmper f-temp.H-P imperf-lemp: II-P perf-temp\](5) \[\[PHON Iv, P, C,, X, C2, Y,C3I\] JInheritance also provides an elegant way of ex-pressing subregularities: for example, if a classof verbs is almost completely regular, except fora few entries, the entries which are common tothe regular and the irregular paradigms are ex-pressed in one paradigm; both the regular andirregular paradigms inherit these entries, andspecify only entries which are not common toboth paradigms.3.2.2 Main Parad igmsMain paradigms relate lexemes (lexical entries,so in the case of Arabic, consonantal roots)to fully specified forms, through reference tohelping paradigms: which helping paradigmsare combined together is defined by each mainparadigm.The operation which combines helpingparadigms together is an extension of Cartesianproduct, denoted by the symbol (X).Helping paradigms are sets of pairs(PHON,  FS> (pairs of phonology and fea-ture structure); when two helping paradigmsare combined together, each pair of the firstparadigm is unified with each pair of the secondhelping paradigm: the PHON attributes arecombined together, and the feature structuresare combined together, resulting in a new pair(PHON,  FS) if unification succeeds.
If thevalues of some feature are not compatible,unification fails, and that particular pair is notreturned11.11The way paradigm entries combine is reminiscent ofKay (1984) who mentions unification ofpatterns (whichconstrain the order in which syntactic constituents mustappear) alongside unification of other types of features.61(7)M-P ver5-3 (\[G,C2,C3 \],FS):FS \[l \[H-P mel-perfFS \[3 \[ H-P mel-imperf(x) H-Pperf-temp(PHON \[P,C1,X,C2,Y,C3\])\];(x) H-P imperf-temp (PHON \[V,P,C~,X,C2,Y,C3\]) ;Syntax of Main Paradigms.
Mainparadigms have the syntax in (6):(6) M-P Name(Phon,FS): FS n {(H-P, (x)H-P2 (x) ...), (H-P3 (x) H-P4 (x)...), ...}In (6), Name is the name of the paradigm,and its argument is a lexical entry, which hastwo components, a phonology and a featurestructure.
The feature structure of the lexicalentry is distributively unified with the elementsresulting from the combination of the helpingparadigms.Thus, if an entry of a main paradigm refers totwo helping paradigms, H-P1 and H-P2, eachof the entries of H-P1 is unified with each ofthe entries of H-P2:H-Pa = {(Fa, Pa), (F2, P2), ..-, (Fk, Pk)}.H-P2 = {(F'x, P'I), (F'2, P'2), ..., (F'k, P'k)}.H-P1 (x) H-P2 = {(Fa, P1), ..-, (Fk, Pk)} (x){(F'I, P'I), ..., (F'i, P'i)} ={(F1 n F'I, P, I"1 P'I), ..., (Fk \[3 F'j, Pk N P'j)}The result is a new paradigm, a set ofpairs (PHON, FS), but this time, the phonol-ogy does not contain any more variables, andthe feature structure of the lexical entry isunified with the second member of each pair.To illustrate, the main paradigm in (7) com-bines the helping paradigms defined in (2), (3),(4) and (5).
The first entry of (7) combines theperf-temp helping paradigm with the mel-perfhelping paradigm so that each entry of the firsthelping paradigm tries to unify with each entryof the second paradigm.
For example, the thirdentry of the perf-temp aradigm unifies withthe first entry of the meI-perf paradigm:PHON \[\[C1,Va,Vx,C2,V2,C3\] n [(C,a*)*,a,C*\]\]& \[III n perf active n {II, III, IV}\]The PHON values are unified by string unifi-cation (Calder 1989), the feature structures bystandard unification of features.
The form IIIunifies with the disjunction {II, III, IV} becauseIII belongs to the disjunction.
The result ofunification is given in (8),with the class namesexpanded in feature structures (in HPSG style).
(8)PHONHEADCONTCl,a,a,C2,a,C3\]"verbASPECT imperfectVOICE activeFORM IIIThis is not a complete characterization f anArabic verb of the third form in the imperfec-tire active; it is just an illustration of how par-tial descriptions get combined to yield completedescriptions.String Unification.
String unification is theunification of two partial descriptions of stringswhich represent the same object.
As shown bySiekmann (Calder 1989), string unification isdecidable and has a finite number of substitu-tions if repeated variables are only permitted onone side of the equation.
An example of stringequation with the variable assignments result-ing from string unification is given in (9).
(9) jVVlWs = RaaSaTRIj Via S/l W/a T/sString unification is a powerful tool which al-lows other kinds of morphological relations tobe specified, besides concatenation: words aredefined as lists of elements, which can be par-tial strings or individual characters.
Some el-ements of the list are variables, which can belocated in any position of the list representingthe word, and get specified through unificationwith a complementary list.
The ability to iso-late particular positions in the word, togetherwith the ability to define in helping paradigmsspecific substrings, allows the description of anytype of morphological relation.3.3 The Lexicon of RootsLexical entries are tuples (P, F, M) where P isthe phonology (a consonantal root, as is cus-tomary in Arabic dictionaries), F the feature62structure and M, the morphological informa-tion.
The morphological information is thename of the main paradigm(s) to which the en-try belongs.The feature inventory of lexical entries is re-duced, and contains only features that cannotbe inferred from morphological processes rele-vant for the entries (typically, semantic infor-mation).4 Compar i son  w i th  o therF rameworks4.1 Calder 's  Parad igmat ic  MorphologyThe approach described in this paper is di-rectly inspired by Calder's paradigmatic ap-proach (1989); however, there are major differ-ences between the two approaches.First, lexical rules constitute the interfacebetween syntax and morphology, in Calder'sapproach, while there are no lexical rules inthe present framework: lexical entries are notspecified for features predictable from the mor-phology, and these are inherited from the fea-ture component through specification of typesin paradigm entries.Second, there is no definition of partial spec-ification of strings, in Calder (1989), whilethe distinction between helping and mainparadigms is one of the main features of thepresent approach: it allows to define morphemesindependently of any specific root, and therebyto capture generalizations about morphemes.Thus, in the case of Arabic, both the melodyand the pattern of consonants are defined inde-pendently of a root in helping paradigms, whilein Calder's approach, one has to be arbitrarilychosen as basic (as belonging to the root), andregularities about that morpheme are lost.4.2 Two-level Morpho logyThe most successful approach to morphologyin computational linguistics has been the two-level approach started by Koskenniemi (1983).Although particularly suited to concatenativemorphology, this approach as been extended toother types of morphologies, and more preciselyto templatic morphology first by Kay (1987),then by Beesley (1991,1996) and Kiraz (1994,1996) among others.
But even though two-levelsystems are successful in practice, they sufferfrom a number of shortcomings: they are notreally morphological systems, but phonologicalsystems, as theyfocus on the phonology (or or-thography) of words, and not on the morphol-ogy; morphotactics is usually implemented us-ing continuation lexicons 12 (which implies thatbound morphemes are lexical entries like stems,a disputable assumption); it assumes a linearview of phonology, which has been shown sincethe late seventies to be inadequate for the de-scription of natural language phonology (Gold-smith 1990).
Also, since this approach to mor-phology is particularly suited to concatenativemorphology, new systems have to be built in or-der to account for non-concatenative languages(with the exception, maybe, of Beesley's sys-tem which can reuse the runtime code used forother languages; but compilation necessitatesnew code specific to Arabic).I will not try to argue that the frameworkI advocate will produce better results in termsof speed and efficiency: the advantages of fi-nite state techniques in that respect have beenshown countless times.
But there are other as-pects to consider, besides efficiency: type oflinguistic analysis allowed by the framework;whether different ypes of morphological pro-cesses can be accounted for; interface with othercomponents of an NLP system (such as a syn-tactic parser), since morphological nalysis isusually not an end in itself.The language presented in this paper isdeclarative: paradigms relate partial stringsto relevant features, and richer descriptions ofstrings derive from the combination of two ormore helping paradigms.
The ability to definepartial strings in isolation, and then to combineseveral partial descriptions of strings throughunification entails that this framework is notbiased towards a specific type of morphologicalprocess.Also, this approach to morphology is similarto and therefore can readily interface with a syn-tactic theory like HPSG, which is used widelyin computational linguistics.Finally, this approach does not restrict thegrammar writer to the framework of linearphonology, and allows for the testing of a cer-tain type of morphological theories, which claimthat bound morphemes do not exist as lexiconl~There are a number of exceptions, Bear (1986),Ritchie t al.
(1992), Kiraz (1996).63entries, but exist only in morphological relations(and more particularly the Word and Paradigmapproaches (Matthew 1991, Anderson 1992, By-bee 1985 and many others)).4.3 DATRThere have been other approaches to morphol-ogy than the two-level approach in computa-tional linguistics; Gazdar and Evans have de-veloped DATR (1996), a knowledge represen-tation language, which has been used to writefragments of the morphology of a number oflanguages, among them Arabic (Gibbons 1990,Cahill 1990).
But as is the case with other ap-proaches, DATR is more suited to express con-catenative processes than other types of mor-phological processes: Cahill shows that DATRin itself cannot account for non linear morphol-ogy, and she creates a new module, MOLLUSC,to use in conjunction with DATR, whose pur-pose is to account for the phonology of morpho-logical processes.5 Future  WorkThis language has not been implemented yet,and implementation is the next goal.
The oper-ations that the language supports are well de-fined and well known: they are monotonic in-herltance, unification of feature structures andstring unification.
Inheritance (monotonic andnon-monotonic) is a feature of object-orientedprogramming languages, and both kinds of uni-fication have been extensively used, unifica-tion of feature structures in the NLP commu-nity, string unification in the field of automatictheorem proving (Calder 1989); thus we canhope that implementation will be straightfor-ward and results acceptable in terms of effi-ciency.Re ferencesAnderson, S. 1992.
A-Morphous Morphology,Camnbridge University Press.Bear, J.
1986.
"A morphological recognizer withsyntactic and phonological rules", Proceed-ings of the 7th International Conference onComputational Linguistics, pages 272-276.Beesley, K.R.
1991.
"Computer analysis of Ara-bic nmrphology: a two-level approach withdetours", Comrie, B. and Eid, M., eds., Per-spectives on Arabic Linguistics lII: Papersfrom the Third Annual Symposium on ArabicLinguistics, pages 155-172.
Benjamins, Ams-terdam.Beesley, K.R.
1996.
"Arabic finite-state mor-phological analysis and generation", Proceed-ings of the 17th International Conference onComputational Linguistics, vol.1, pages 89-94.Bybee, J.
1985.
Morphology: a Study of theRelation between Meaning and Form.
Ben-jamins, Amsterdam.Cahill, L.J.
1991.
Syllable-based Morphology forNatural Language Processing.
Cognitive Sci-ence Research Paper 181, University of Sus-sex.Calder, J.
1989.
"Paradigmatic morphology",Proceedings of the 4th Conference of theEACL, pages 106-111, University of Manch-ester.Evans, 1t., and Gazdar, G. 1996.
"DATR: a lan-guage for lexical knowledge representation",Computational Linguistics, voi.22, 2, pages167-216.Goldsmith, J.
1991.
A utosegmental and MetricalPhonology, Blackwell, London.Kay, M. 1984.
"Functional unification grammar:a formalism for machine translation", Pro-ceedings of the lOth International Conferenceon Computational Linguistics, pages 75-78.Kay, M. 1987.
"Nonconcatenative finite-statemorphology", Proceedings of the 3rd Confer-ence of the EACL, pages 2-10.Kiraz, G. 1994.
"Multi-tape two-level morphol-ogy: a case study in Semitic non-linear mor-phology', Proceedings of the 15th Interna-tional Conference on Computational Linguis-tics, vol.1, pages 180-186.Kiraz, G. 1996a.
Computational Approach toNon-Linear Morphology.
PhD thesis, Univer-sity of Cambridge.Kiraz, G. 1996b.
"SemHe: a generalised two-level system", Proceedings of the 34th AnnualMeeting of the ACL, pages 159-166, SantaCruz, CA.Koskenniemi, K. (1983).
Two-level Morphology.PhD thesis, University of Helsinki.McCarthy, J.
1981.
"A prosodic theory of non-concatenative morphology", Linguistic In-quiry, 12, vol.3, pages 373-418.
CambridgeUniversity Press, Cambridge.Matthews, P.H.
1991.
Morphology.
CambridgeUniversity Press, Cambridge.64Pollard, C., and Sag, I.
1994.
Head-DrivenPhrase Structure Grammar.
Chicago Univer-sity Press, Chicago, IL.Ritchie, G., Black, A., Russell, G. and Pulman,S.
1992.
Computational Morphology: Practi-cal Mechanisms for the English Lexicon.
MITPress, Cambridge (MA).Siekmann, J.H.
1975.
String-unification, part 1.Ms, Essex University.65
