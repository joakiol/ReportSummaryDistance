CLG (n): Constraint Logic GrammarsSergio BALARIEurotra  Espana, 25 Avda.
de VaUvidreraE-08017 BarcelonaGiovanni B. VARILECEC, Jean Monnet  Bldg., L-2920 LuxembourgLuis DAMASNelma MOREIRAUniversidade do Por to ,Campo Alegre 823P-4000 PortoAbst rac t :  CLG(2) is the latest member of a family ofgrammar formalisms centered around the notion ofcomplex constraint expression for describing phrasal andiexical information and principles of language.
Complexconstrains can be expressed in a slightly restriced form offirst order predicate logic, which makes CLG(2) well suitedfor expressing, amongst others, HPSG-style of grammars.
Asound implementation f the formal semantics of CLG(2) isachieved'by resorting to delayed evaluation of nonequational constraints.I n t roduct ionRecently a number of formalisms for grammaticaldescription have been proposed with the aim of overcomingthe expressive deficiencies of simple unification basedformalisms like PATR-II.
Except for the more simple,although not unproblematic, extensions to PATR-II likethe ones proposed by Karttunen (1984), most of theseefforts have their root in the work by Rounds, Kasper andMoshier (Rounds & Kasper, 1986; Moshier & Rounds1987), who give the proof of the existence of a sound,although non classical, logical interPretation for disjunctiveand negative feature specifications.Although Kasper (1987) has proposed an algorithmfor handling grammars with disjunctive featurespecifications, the computational tractability of complexconstraints in unification based formalism remains an openproblem (Pereira 1987).Furthermore since the introduction of Head PhraseStructure Grammar (HPSG) (Pollard & Sag, 1987) thedesirability of complex constraint expression has becomeclear.
The attractiveness of HPSG-style grammaticaldescription has made classical first order logic the candidatepar excellence for constraint expression, modulo theproblem of computationa!
tractability.Since 1988 we have ~ been engaged in the design andimplementation~ Of a number of prototype formalismssharing essentially the same constraint language, a slightlyrestricted fo rm o f  first order predicate logic includingexplicit quantification (Damas& Varile 1989).
In trying toachieve a logically sound and practical implementation, ourwork has been influenced by the CLP paradigm in logicprogramming (Jaffar & Lassez, 1988) especially our delayedevaluation Scheme which amongst Other things avoidssystematic ~mputations of normal forms of constraints.
AllCLG(n) prototypes have been implemented in Prolog usingthe YAP compiler developed at the University of PortoThe results to date have been encouraging.
Two of theCLG(n) prototypes have undergone xtensive testing withnon-trivial grammars of several European languages asreported in (Damas & VaNe 1989).In this paper we present CLG(2), the latest prototypeof the CLG(n) family, a formalism which was influenced bythe HPSG grammar model.
Although different members ofthe family differ with respect o a number of characteristicslike the structure of grammatical description and the datastructures defined by the formalism, they all share the samecomplex constraint language.1.
Sys tem Overv iewIn CLG(2) the data types defined are variables,constants, typed feature structures, list and sets of typedfeature structures.
Typed feature structure can be seen asdirected graphs with labelled arcs, every node being indexcdwith its type name.The main novel feature of CLG(2), and of the othermembers of the CLG(n) family, is its constraint language I.,a slightly constrained form of first order predicate logic,including explicit quantification.
Unification remains tllesole building operation, under the control of complexconstraints.The logical symbols of the complex constraint languageconsist of variables, constants, the logical connectives &(conjunction), I (disjunction), " (negation),-> (materialimplication), <-> (logical equivalence), the binary predicatcsymbol "=" and non-logical function and predicate symbols.The terms of the constraint language are variables,constants and path expressions.
The atomic formulae areeither equational constraints, i.e.
formulae of the formt l=t2 for terms tl,t2, or r(tl,t2,...) for terms ti and relationsymbols r. The complex constraints of CLG(2) are the nonatomic well formed formulae of L, defined in the usual way:for well formed formulae (constraints) C1, C2 and variableX:C1- C1 -> C2-c1  & C2~C1 I C2- forall(X,S) C1- exist(X,S) C11 78are also well formed formulae (constraints).
The S in thequantified constraints are used to restrict he domain of thequantification and can be omitted.
The interpretation of theconstraint language L is the standard interpretation of firstorder predicate logic.
In other words, we do not resort tointuitionistie or other non-standard interpretations, like forinstance Moshier & Rounds (1987).
Examples ofconstraints are:S.syn.local.head "= nforall(C:compl dtrs) C.syn.local.head.maj = n.In order to facilitate the statement of constraints, amacro facility is available in all members of the CLG(n)family, which is a generalization of PATR-II templates inthat it can take a list of formal parameters.
In CLG(2) thisfacility has been extended in a fashion akin to UD (Johnson& Rosner, 1989) to include reeursive user defined relations.An example of such a relation is:discharge(E,E:L,L);diseharge(E,X:Ll,X:L2) <- diseharge(E,L1,L2);In section 3 it will be shown how such definitionscontribute to the statement of linguistic principles.
We turnnow to describe the components ofa CLG(2) grammar.Global type declarations: CLG(2) relies on a strongtyping scheme similar to the concept of abstract data type.The following is a detail of the syntactic feature hierarchyused for one type of linguistic sign in one of the grammarsimplemented in CLG(2):Sign = ( phon, syn, sem,dtrs);phon = word list;syn = ( local, bind);local = ( head, compls, funhead, select, lex );head = ( vform, inv, agr, tense);vform = {fin, bse, psp, prp, pas, inf, ger };inv= { - ,+  };agr = ( num, prs );num= { sg, pl };prs = { fst, snd, thrd };tense = { past, pre};compls = Sign list;lex = (+,-};bind = (slash, subj, wh);slash = Sign list;subj = Sign list;wh = {rei, que};dtrs = (head._dtr,compl_dtrs)head._dtr = Sign ;compl..dtrs = Sign list;Other systems require typing information, includingHPSG (Pollard & Sag 1987) and UCG (Moens et al 1989).Type information is used in CLG(2) both to structure thegrammatical information and to achieve a more efficientimplementation.Global constraints:  these encode HPSG-type of linguisticprinciples.
A principle is of the form: partial-object-2specification -> constraints.
For instance, HPSG's HeadFeature Principle could be expressed as:\[head_.dtr=\[_ \]\] ->syn.local.head = head_dtr.syn.local.headPartial  descriptions of lexical signs.
Lexical andphrasal descriptions have both the same format consisting ofa pair <DAG,CS> whose first element is a DAG specifiedby a set of equations and whose second element is a set ofcomplex constraints.
Both lexical and phrasal constraintshave a number of alternative shorthand formats to suit userrequirements.Part ial  descriptions of phrasal  signs: these ;ire theCLG(2) rules.
A number of different equivalent ruleformats are supported.
For instance:\[comp= < >\] -> head_dtr,coml_dtrsM -> H,C+ where M.syn.local.comp= < >are equivalent formulations.2.
Formal SemanticsWe define in this section a denotational semantics 'forCLG(2) grammars in a similar way to what was done forCLG(0) grammars (Damas & Varile, 1989).
For reasons ofspace, we present aslightly simplified version.Starting from primitive sets Labels and Atoms ofattribute names and atomic values we would like to definethe domain of objects and the domain of values as followsObjects = Labels --> ValsVals = \[Atoms + Objects\]*Note that to simplify the semantics we are assumingthat every label can have as value a list of sub-objects.Given a set Vats of variable symbols and a set Preds ofpredicate symbols we define the following syntactic domains:Path ::= Label I Path.LabelExp ::= Var I Atom I Path I Var.PathI Exp+Exp (list concatenation)I Exp:Exp (list cons )Constraint ::= Exp = ExpI p(Exp,...,Exp)\] "Constraint.
.
.
.
.
.
I Constraint & Constraint....
I Constraint I ~nstraintDefinition ::=q(xl,x2,...,xn) <-> Constraintwhere we assume that every path which occurs m adefinition is associated with a formal argument.Grammar ::= Constraintsx:Path* x Definition* ~:: ,~ , ~ .
.
.
.
.
?The Constraints comlxment in a Grammar denotesthe conjunction of all principles with the disjunction of thedescriptions of all lexical and phrasal signs.
The Path*component specifies which paths are involved in thedominance relation for the grammar.Given an object o and a path p we will extend o topaths byo(p.l) = o(p)O)if o(p) has only one element and that element is not anatom, error otherwiseIn what follows we will omit the handling of errorvalues, which should produce rror if any partial result leadstO error.To define our semantic functions we still need thefollowing domains:VEnv = Vars o-> Objects*PEnv = Preds--> U(n)Vals- -> {T,F}Now we define the following semantic functionsV: Exps--> VEnv--> Objects-> ValsC: Constraint --> PEnv-o> VEnv -> Objects->  {T,F}D: Definition*--> PEnvG: Grammar -> Objects--> {T,F}V, which assigns a value to every expression, is definedbyV \ [v \ ] ro  = r \ [v\ ]V \ [p \ ] ro  = o(p)V\[ v.p \] r o = cardinality(r\[ v \])=1 -> r\[ v \](p)else bottomV\[ e+e' \ ]  r o = concatenate(V\[ e ] r o, V\[e'  \]r o)V\[ e:e'\] r o = cons(V\[ e \]r o, V\[ e'\]r o)C, which assigns a truth value to every constraint, isdefined byC \ [e=e ' \ ]d ro  = V \ [e \ ] ro=V\ [e ' \ ] roC\[ p(el,...,en) \]d r o =d \ [p \ ]  (V \ [e l  \ ] ro  ..... V \ [en \ ] ro )C \ [c&e ' \ ]  = C \ [c \ ]&C\ [c ' \ ]D is defined by taking, for each sequence of definitionspi(xl,..,xn)<-> Di, the least fixed point of the function H:PEnv --> PEnv defined by:H\[ pi \] d (vl, ..., vn) = C\[ Di \] d \[vi/xi\] o_nilwhere o_nil is the empty object.We can now define G asfollows:G\[ < c, <pl ,  ...,pk>, Ds > \] o = Tiff there is an environment r such that C\[ c \] d r o= T andfor every path pi such that o(pi) = <ol,  ..., o1>:G\[ < c, <p l  ..... pk>, <C1,...,Cn> > \] oj = Tfor j= 1,...,I, where d = D\[ Ds \].3, Complement izer -Trace Effects in CLG(2)We will illustrate the expressive power of CLG(2) withan analysis of those phenomena traditionally known ,~scomplementizer-trace effects (Perlmutter, 1971; Chomsky& Lasnik, 1977).
It is inspired by the HPSG framework(Pollard & Sag, 1987), but it departs from it in somerespects.The most recent account of these phenomena withinHPSG is that of Pollard (1985).
There, he aims at showingthat most of the GPSG insights (Gazdar, Klein, Pullum &Sag, 1985) can be preserved within a framework which doesnot express ubcategorization directly in PS rules, and whichdoes not make use of meta-rules.In our revision of the analysis we will follow Pollard(1989) in separating subjects election from complementselection.
Our grammar incorporates, however, someradical differences, most of them concerned with the typingof features structures, and the typology of lexical andphrasal categories it induces.In essence, our approach incorporates a much morearticulated theory of minor categories which attributes thema more privileged role than it is generally assumed in PSGframeworks.
We assume, then, that minor categories have ncertain head-like status and, consequently, seleetion,~lproperties (Chomsky, 1986; Warner, 1989).Thus, the top of our hierarchy of signs is as follows:Sign: Minor: AfftxesCliticsMajor: WordsPhrasesThe main difference between major and minor signs isthat the latter contain information of type syntactic ategoryand semantics only, while major signs may contain alsobinding information.Now consider, the following, schematic lexical entriesfor the English complementizers that and for, which areminor signs of type clitic:that =\[syn.iocal.select <v\[subj < >,compl <>,fin \] bse\] >\]for = \[syn.local.select <v\[subj < >,compl <> ,inf\] > \]Where subj and compl abbreviate subjectcomplements.And the schematic entries for the following verbs:think =\[syn.local.compl <v\[compl< >,fin\]>,~lld9 3syn.bind.subj <np>\]wantl = \[syn.local.compl <v\[compl< >,comp.for\] Iv\[sb < np 1 >,cp < >,int'\] >,syn.bind.subj <npl>\]want2 = \[syn.local.compl<npl,v\[sb<npl>,cp< >,infl>,syn.bind.subj < rip>\]complain = \[syn.local.compl<v\[comp.that\]>,syn.bind.subj <np>\]Tlaus, subject extraction from a clausal complement ofthink or want is impossible if the complement has acomplementizer, because it violates its seleetionalrestrictions.We predict then that, "in English, subject extraction isonly possible with bridge verbs (e.g.
think), and that it isalways impossible with non-bridge verbs (e.g.
wantl,complain), while complement extraction is always possible(e.g.
object extraction in object control verbs like want2).Note that the different syntactic properties of verbalcomplements (clauses, VPs) seems to have a direct semanticcorrelation in the property/proposition distinction which hasbeen advocated in some recent analyses of control, e.g.
Sag& Pollard (1988).The CLG(2) grammar which accounts for the abovefacts contains four rules and four principles.
Two rules arethe well known Complementation a d TopicaUzation rulesof standard HPSG.The other two are original: one, lhe Clitie Placementrule, licenees those stuetures in which a minor head isattached to a major head; it requires that the selectionalrestrictions of the minor head be satisfied and marks themother node with whatever features come from the minorhead (e.g., comp=that, when the complementizer isattached to a clause).
The other rule is like Topicalization,but for subject binding.
As for the principles, we have aHead Feature Principle, a Complementation Principle, aBinding Principle, and a Control Principle.As an example, we provide the CLG version of theComplementation Principle, which given its formulation hasthe direct consequence of performing gap introductionwhen some complement is not found:Complementation Principle\[head._dtr = \[ _ \],compl dtrs= \[ _ 1\]- >merge(dtrs'head-dtr'syn'l?c'c?mpis'dtrs.compl_dtrs,syn.bind.slash)where merge is a user relation defined as follows:merge(Z,\[l,Z);merge(X:L1,X:L2,X.syn.bind.slash + R 1)< - merge(L 1,L2,R 1 );merge(X:L1,Y:L2,Y:R) <_ merge(L1,Y:L2,R);The slash is computed by merge by concatenating thcslashes of each of the complement daughters with thoscelements of the compls list for which there is no matchingdaughter.4.
ImplementationThe CLG(2) parser has been implemented in Prolog.A CLG(2) grammar is compiled by successively compilingtype declarations, partial descriptions of phrasal signs,principles, user defined relations and lexical information.This implementation, uses a simple bottom-up arserwith backtracking and handles constraints using ~lnextension of the ideas described in Damas &.Varile (1989).The parser is implemented as a predicate of the formderive(Tree,\[Head I Input\],Output ) :-complete(Head,Input,Output,Tree).complete(Tree,Input,Input,Tree).complete(FirstDaughter,Input,Output,Tree) :.apply_rules(FirstDaughter,Input,Output 1,Tree 1),complete(Treel,Output 1,Output,Tree).where the apply_rules predicate is produced bycompiling each grammar rule into a clause for thispredicate, which attempts to apply the rule.
These clausesalso apply all the principles, which are partially evaluated atcompile time.
This technique usually results in verifying onlythose principles which are relevant for the particular ule.
Inthe actual implementation the amount of backtrackinginvolved is reduced by introducing other clauses for thecomplete predicate which handle rules known to have ~fLxed number of daughters.Constraints are handled in a way similar to the onedescribed in Damas & Varile (1989) by adding two extr~arguments to each of the predicates mentioned above.These arguments contain a list of constraints at clause entryand exit, respectively.
From time to time a rewriting processis applied to the list of constraints which may result intofailure or new set of simpler constraints.
Note that thisrewriting process may also cause variable instantiation as ~side effect.Constraints imposed by principles are implemented bya call to a predicate addconstraint which first attempts todecide if the constraint holds or not.
If not enoughinformation is available at that time for that purpose theconstraint is added to the list of unresolved constraints forlatter e-evaluation.However, the recursively defined constraints (e.g.
theuser defined relations) have a special treatment.Backtracking is allowed in its application, but somerestrictions are imposed, namely they are applied only whensufficiently instantiated to insure that they finitely fail.
Inparticular, for each recursively defined constraint, we must4 10specify which are the minimum conditions of application(for instance which arguments may not be undefined).Constraints on complex objects require some care ontheir interpretation and implementation.
Consider, forinstance, an object description such as\[syn.loeal.subj <NP1 >syn.loeal.compls <v\[compls < >,comp for\] Iv\[subj <NP 1 >,compls <>,inf\] > \]\].which is represented internally as a complex termcontaining only variables plus a constraint on thosevariables.
Note that, if a variable that refers to a atomicvalue is envolved in a simple equality constraint (orconjunction of)  that can be evaluated in compile time.For the above example we could have (here in the userlanguage, for simplicity) objeet(Spec,Const), and if in Specwe identifysyn.local.subj = NP1syn.local.compls = CP1CP 1.syn.loeal.head.maj =CMCP 1.syn.local.compls = CP2CPl.syn.loeal.subj = NP2CPl.syn.loeal.head.form = F1CP 1.syn.loeal.head.comp = COthenConst =( CM = v & CP2 = \[\] &((NP2 = NP1 & F1 = int') I CO = for)).Final RemarksIt is clear that the highly structured nature of CLG(2)grammatical descriptions has a number of advantages withrespect o more classical approaches, amongst which notleast the possibility to express powerful generalization aboutlanguages in a highly structured way while maintaining thenecessaiy capability for expressing exceptions.A drawback of this approach is however that while it ispossible to give a clean and simple formal semantics to eachindividual component, the formalization of the completegrammatical system is certainly more complex thandesirable and, as a consequence, the possibility to achieve anefficient implementation is unnecessarily complicated.We are currently investigating the possibility of makingthe type theory underlying the Global Declarations a firstclass citizen, namely being the unifying formal frameworkfor all the grammar components (at least for all non iexicalinformation).By this we mean that a type declaration system in theform of an algebra of sorts can cover essentially theexpressive requirements of our current formalism whileproviding a simple and uniform formal framework for thewhole.AcknowledgementThis work has been carried out within the frameworkof the Eurotra R&D programme for machine translationfinanced by the European Communities.
We are especiallygrateful to a number of colleagues for their usefulcomments on earlier versions of CLG(n).Bibliographical ReferencesChomsky, N. (1986).
Barriers, MIT Press, Cambridge.Chomsky, N. & H. Lasnik (1977).
"Filters and control",Linguistic Inquiry, 8, 425-504.Damas, L. & G.B.
Varile (1989).
CLG: A grammarformalism based on constraint resolution, inProceedings of EPIA 1989, E.M. Morgado & J.P.Martins (eds.
), Lecture Notes in Artificial Intelligence390, Springer Verlag.Gazdar, G., E. Klein, G.K. PuUum & I.A.
Sag (1985).Generalized Phrase Structure Grammar, BasilBlaekwell, Oxford.Jaffar, J., J-L. Lassez (1988).
From unification toconstraints, in Logic Programming 1987, G. Gods & J.Hartmanis (eds.)
Lecture Notes in Computer Sciencc315, Springer Verlag, 1-18.Johnson, R. & M. Rosner (1989).
A rich environmentfor experimentation with unification grammars, inProceedings of the fourth conference of the EuropeanChapter of the ACL, ACL, 182-189.Karttunen L. (1984).
Features and values in Proceedingof COLING-84, 28-33.Kasper, R. (1987).
A unification method for disjunctivefeature description, in ACL Proceedings, 24th annualmeeting, ACL, 235-242.Moens, M. J. Calder, E. Klein, M. Reape, H. Zeevat(1989).
Expressing eneralizations in unification-basedformalisms, in Proceedings of the fourth ex)nference ofthe European Chapter of the ACL, ACL, 174-181.Moshier M.D.
& W.C. Rounds (1987).
A logic forpartially specified data structures in ACM symposiumon the principles of programming languagcs,Association for Computing Machinery.Pereira, F.C.N.
(1987).
Grammars and logics of partialinformation,.
Technical Note 420, SRI International,Menlo Park.Perlmutter, D. (1971).
Deep and Surface Cxmstraints, inSyntax, Holt, Rinehart & Winston, New York.Pollard, CJ.
(1985).
"Phrase structure grammar withoutmetarules", in J. Goldberg, S .
MacKaye & M.T.Wescoat, eds., Proceedings of the West CoastConference on Formal Linguistics, 4, StanfordLinguistics Association, Stanford, 246-261.11 5Pollard, C..I.
(1989).
"The syntax-semantics interface in aunification-based phrase structure grammar", in S.Busemann, Ch.
Hauensehild & C.Umbach, eds., Viewsof the Syntax/Semantics Interface, KIT Report 74,Technische Universitaet Berlin, Berlin.Pollard, CJ.
& I.A.
Sag (1987).
Information-BasedSyntax and Semantics, CSLI Lecture Notes Series,CSLI, Stanford.Rounds, W.C. & R. Kasper (1986).
A complete logicalcalculus for record structures representing linguisticinformation, in Symposium on logic in computerscience, IEEE Computer Society.Sag, I.
& C. Pollard (1988).
A semantic theory ofobligatory control.
MS.Warner, A.R.
(1989).
"Multiple heads and minorcategories in generalized phrase structure grammar",Linguistics, 27, 179-205.6 12
