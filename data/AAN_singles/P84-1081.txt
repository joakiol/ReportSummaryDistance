INTERRUPTABLE TRANSITION NETWORKSSergei NirenburgColgate Univers i tyChagit Att iyaHebrew Univers i ty  of JerusalemABSTRACTA special ized transit ion networkmechanism, the interruptable transit ionnetwork (ITN) is used to perform the lastof three stages in a mult iprocessorsyntactic parser.
This approach can beseen as an exercise in implementing aparsing procedure of the active chartparser family.Most of the ATN parserimplementations use the left-to-r ighttop-down chronological  backtrackingcontrol structure (cf.
Bates, 1978 fordiscussion).
The control  strategies ofthe active chart type permit a blend ofbottom-up and top-down parsing at theexpense of t ime and space overhead (cf.Kaplan, 1973).
The environment in whichthe interruptable transit ion network (ITN)has been implemented is not similar to6hat of a typical  ATN model.
Nor is it astraightforward implementat ion of anactive chart.
ITN is responsible for onestage in a mult iprocessor parsingtechnique descr ibed in Lozinski i  &Nirenburg, (1982a and b), where parsing isperformed in essent ia l ly  the bottom-upfashion in paral lel  by a set of re lat ivelysmall and "dumb" processing units runningidentical software.
The process involvesthree stages: (a) producing the candidatestrings of preterminal  category symbols;(b) determining the posit ions in thisstring at which h igher- level  const i tuentsstart and (c) determining the closingboundaries of these constituents.Each of the processors al located tothe f irst stage obtains the set of allsyntact ic readings of one word in theinput string.
Using a table grammar, theprocessors then choose a subset of theword's readings to ensure compat ib i l i tywith similar subsets generated by thisprocessor 's right and left neighbor.Stage 2 uses the results of stage 1and a di f ferent tabular grammar toestabl ish the left ("opening") boundariesfor composite sentence constituents, suchas NP or PP.
The output of this stageassumes the form of a str ing of tr iadsl label  x M), where lah~l belongs to thevocabulary of const ituent types.
In ourimplementat ion this set includes S, NP,VP, PP, NP& (the "virtual" NP), Del (thedelimiter), etc.
X and M are the left andthe right indices of the boundaries ofthese const ituents in the input string.They mark the points at which parenthesesare to be opened (x) and closed (y) in thetree representation.
The values x and yrelate to posit ions of words in theinitial input string.
For example, thesentence (i) wi l l  be processed at stage 2into the str ing (2).
The '?'
in (2) standfor unknown coordinates y.
(i) The very big br ick bui lding that sits1 2 3 4 5 6 7on the hi l l  belongs to the university.8 9 i0 ii 12 13 14(2) (s 1 ?
)(np 1 ?
)(s 6 ?
)(np& 6 6)(vp 7 ?
)(pp 8 ?
)(np 9 ?
)(vp ii ?
)(pp 12 ?
)(np 13 ?
)It is at this point that theinterruptable transi t ion network startsits work of f inding the unknown boundarycoordinates and thus determining the upperlevels of the parse tree.An input str ing ~ tr iads long wi l l  beal located n identical processors.Init ial ly the chunk of every part ic ipat ingprocessor wi l l  be one tr iad long.
Afterthese processors f inish with their chunks(either succeeding or fai l ing to find themissing coordinate) a "change of levels"interrupt occurs: the size of the chunksis doubled and the number of ac t iveprocessors halved.
These latter continuethe scanning of the I TN from the pointthey were interrupted taking as input whatwas formerly the chunk of their rightneighbor.
Note that all const i tuentsalready closed in that chunk aretransparent to the current processor andalready closed in that chunk aretransparent to the current processor andare not rescanned.
The number of activeprocessors s tead i ly  reduces duringparsing.
The choice of processors thatare to remain act ive is made with the helpof the Pyramid protocol  (cf.
Uozinski i  &Nirenburg, 1982).
The processors released393after each "layout" are returned to thesystem pool of avai lable resources.
Atthe top level in the pyramLd only oneprocessor wL\] l  remain.
The status of sucha processor is declared final, and thistrlggers the wrap-up operat ions and theconstruct ion of output.
The wrap-up usesthe or iginal  string of words and theappropr iate string of preterminal  symbolsobtalned at stage 1 together with theresults of stage 3 to build the parsetree.ITN can start processing at anarbl trary posit ion in the input string,not necessar i ly  at the beginning of asentence.
Therefore, we introduce anaddit ional  subnetwork, "initial", used forhandl ing control  f low among the othersubnetworks.The llst of "closed" const i tuentsobtained through ITN-based parsing ofstring (2) can be found in (3), whi le (4)is the output of ITN processing of (3).
(3) (s 1 \[4)(np 1 10)(s 6 10)(np& 6 6)(vp 7 10)(pp 8 10)(np 9 10)(vp ll 14)(pp 12 14)(np 13 14)(4) (s(np(s(np&)(vp(pp(np))) ) ) (vp(pp)))3.
An ITN Interpreter.The interpreter was designed for aparal lel  processing system.
This goalcompel led us to use a program environmentsomewhat di f ferent from the usual pract iceof wr it ing ATN interpreters.
Ourinterpreter can, however, be used tointerpret both ITNs and ATNs.A new type of arc was introduced:the interrupt arc INTR.
The interrupt arcis a way out of a network state addit ionalto the regular POP.
It g ives the processthe opportuni ty  to resume from the verypoint where the interrupt had been called,but at a later stage (this mechanlsm israther similar to the detach-type commandsin programming languages which supportcoroutines, such as, for instance,SIMULA).
Thus, the interpreter must beable to suspend processing after trying toproceed through any arc in a state and toresume processing later in that verystate, from the arc immediately fol lowingthe interrupt arc.
For example, if \[NTRis the fourth of seven arcs in a state,the work resumes from the fifth arc inthis state.
This is implemented with astack in which the transit ions in the netare recorded.
The PUSH and POP arcs arealso implemented through this stack andnot through the recursion handl ingmechanisms built into Lisp.Since it is never known to anyprocessor whether it wi l l  be act ive at thenext stage, it is necessary that theinformation it obtained be saved in aplace where another processor wi l l  be ableto find it.
Unl ike the standard ATNparsers (which return the parse tree asthe value of the parsing function), theI%N parser records the results in aspecial  working area (see d iscuss ionbelow).impl~m~nLaL iunThe ITN interpreter was implementedin YLISP, the dia lect  of LISP developed atthe Hebrew Univers i ty  of Jerusalem.
Aspecial  scheduler routine for s imulat ingparal lel  processes on a VAX 11/780 waswr i t ten by Jacob Levy.
The interpreteralso uses the pyramid protocol  program byShmuel Bahr.In what fol lows we wi l l  descr ibe theorganizat ion of the stack, the work ingarea, and the program itself.a) The stack.
The item to be stackedmust descr ibe a posi t ion in the network.An item is pushed onto the stack everytime a PUSH or an INTR arc is traversed.Every time a POP arc is t raversed or areturn from an interrupt occurs one itemis popped.
The stack item consists of:I) names and values of the current networkregisters; 2) the remainder of the arcsin the state (after the PUSH or the INTRtraversed); 3) the actions of the PUSHarc traversed; 4) the name of the currentnetwork (i.e.
that of the latter'sinitial state); 5) the value of the inputpointer (for the case of a PUSH failure).The working area is used for twopurposes: to support message passingbetween the processors and to hold thefindings.
The working area is organizedas an array, R, that holds a doubly linkedlist used to construct  the output tree.The actions def ined on the working areaare: a) in i t ia l izat ion (procedureinit- input): every cell R\[i\] in R obtainsa token from input, whi le the linksRi l l .
\ [next- index\]  andR\[ i \ ] .
\ [previous- index\]  obtain the valuesi+l and i-l, respectively; b) CLOSE, thetool for del imit ing subtrees in the inputstring;The array R is used in paral le l  by anumber of processors.
At every level ofprocessing the active processors' chunkscover the array R. This arrangement doesnot corrupt the paral le l  character of theprocess, since no processor actual ly  seeksinformation from the chunks other than itsown.394The main funct ion of the interpreteri s  cal led //,El.
It obtains the stackcontain ing the h istory of processing.
Ifan interrupt is encountered, the funct ionreturns the stack with new history, to beused for invoking this funct ion again, bythe pyramid protocol.If a call to i tn is a return from theinterrupt status, then a stack item ispopped (it corresponds to the last stateentered during the previous run).
If thefunction call is the initial one, we startto scan the network from the first stateof the "initial" subnetwork.At this stage we already know whichstate of which network fragment we are in.Moreover, we even know the path throughthe states and fragments we took in orderto reach this state and the exact arc inthis state from which we have to startprocessing.
So, we execute the test onthe current arc.
If the test succeeds weperform branching on the arc name.The INTR arc has the fo l lowingsyntax: ( INTR<dummy><test><act ion>*).The current state is stacked and theprocedure is exited returning the stack asthe value.
<dummy> was inserted s imply topreserve the usual convent ion of s i tuat ingthe test in the third slot in an arc.The ABORT arc has the syntax(ABORT<message><test>).When we encounter an error and itbecomes clear that the input str ing isillegal, we want to be able to stopprocessing immediately and print adiagnost ic  message.The actions on the stack involve themovement of an item to and from the stack.The stack item is the quantum value thatcan be pushed and popped, that is no partof the item is accessed separate ly  fromthe rest of the values in it.
Thefunctions managing the stack arepush-on-stack and pop-from-stack.The push-on-stack is cal led whenevera PUSH or an INTR arc is traversed.
Thepop-f rom-stack is called, first, when thePOP arc is traversed and, second, when theprocess resumes after return from aninterrupt.The closa action is performed when wefind a boundary for a certain subtree forwhich the opposite boundary is a l readyknown (in our case the boundary that isfound is always the right boundary, y).QIo~@ performs two tasks: first, itinserts the numeric value for y and,second, it declares the newly builtsubtree a new token in the input string.For example, if the input str ing had been<s 1 ?><np 1 ?><vp 4 ?><np 6 8><pp 9 i0>1 2 3 4 5after the act ion (close 3 i0) is performedthe input for further processing has theform:<s 1 ?><np i ?><vp 4 I0>.The parameters of ~lose are i) thenumber of the tr iad we want to close and2) the value for which the y in this triadis to be substituted.
The default  valuefor the second parameter is the value ofthe y in the tr iad current at the moment acall to ~ios~ is made.When the processing is parallel,?1os~ is appl ied mul t ip ly  at every level,which would mean that a higher levelprocessor wi l l  obtain prefabr icatedsubtrees as e lementary input tokens.
Thisis a major source of the efficiency ofmultiprocessor parsing.The ITN in the current implementationi s  re lat ively small.
A broaderimplementat ion wi l l  be needed to study thepropert ies of this parsing scheme,including the est imates for its timecomplexity, and the extendabi l i ty  of thegrammar.
A compar ison should also be madewith other mult iprocessor  parsing schemes,including those that are based not onorganiz ing communicat ion among re lat ive ly"dumb" processors running identicalsoftware but rather on interaction ofh ighly  special ized and " intel l igent"processors -- cf., e.g., the word expertparser (Small, 1981).Acknowledgments.
The authors thankE.
Lozinski i  and Y. Ben Asher for the manydiscussions of the ideas descr ibed in thispaper.B ib l iographyBates, M. (1978), The theory and pract iceof augmented t rans i t ion networkgrammars.
In: L. Bolc (ed.
), NaturalLanguage Communicat ion wi th  Computers.Berlin: Springer.Kaplan, R. M. (1973), A general  syntact icprocessor.
In R. Rust in (ed.
), NaturalLanguage Processing.
NY: AcademicPress.Loz~nski i ,  E .L .
and S. N l renburg(1982a).
Local i ty  in Natural  Languageprocessing.
In: R. Trappl (ed.
),Cybernet ics and Systems Research.Amsterdam: North Holland.395Lozinskii,(1982b),language.France.E .L .
and S. NirenburgParal lel processing of naturalProceedings of ECAI, Orsay,Small, S. (1981), Viewing word expertparsing as a l inguistic theory.Proceedings of IJCAI, Vancouver, B.C..Appendix A. ITN: the main function ofthe interruptable transit ion networkinterpreter(def Itn(lambda ( stack ); stack - current processing stack(prog (regs curr-state-arcs net-namecurt-arc $ test arc-name); regs - current registers of the network; curr-state-arcs list of arcs not yet; processed zn current state; net-name - name of network being: processed; curt-arc - arc in processing;(all these are pushed on stack when a; 'push' arc occurs); $ - a special register.
; the functlon first checks if stack is; nil; if not then this call is a return; from interrupt previous values must be; popped from the stack\[cond (stack (seta ec pn nil);set end-chunk flag to nil(pop-from-stack t))(t (set-net 'al\]loop\[ cond ((null curr-state-arcs)(cond((null  (pop nil)) (return nil)\](set 'curt-arc (setcdr 'curt-state-arcs))( set 'test (*nth curr-arc 3) )( cond ((eval test);test succeeds - traverse the arc( set 'arc-name (car curr-arc))\[cond((eq arc-name 'push ) ; PUSH(evlist (*nth curr-arc 4))(push-on-stack)(set-net (cadr curr-arc))(go loop))((eq arc-name 'pop ) ; POP(evlist (*nthcdr curr-arc 3))(cond((null (pop(eval(cadr curr-arc))))(return $)))(go loop))((eq arc-name 'jump ) ; JUMP(evlist (*nthcdr curr-arc 3))(set-state (*nth curt-arc 2))(go loop))((eq arc-name 'to) ; TO(evlist (*nthcdr curr-arc 3))(set-state (*nth curr-arc 2))(get-input)(go loop))((eq arc-name 'cat) ; CAT(cond L\[eq (currlI~B))(*nth curt-arc 2))(evlist(*nthcdr curr-arc 3))))(go loop))((eq arc-name 'abort) ; ABORT(tpatom (*nth curr-arc 2))(return nil))((eq arc-name 'intr) ; INTeRrupt(push-on-stack)(return stack))(t ; error(tpatom '"i l legal arc")(return nil))( go loop \] ; try next arcAppend ix B.A Fragment of an ITN network(the "init ial" and the sentence subnetworks);Note that "jump" and "to" can be either;terminal actions on an arc or separate;arcs(def-net '(s-place) '(( initial(pop t (end-of-sent) (close*))(intr nil (end-of-chunk)((to initial)))(push S (lab s)((setr s-place (inp-pointer)))((jump initial/DEL)))(push NP (lab np) nil ((to initial)))(push VP (lab vp) nil ((to initial)))(push PP (lab pp) nil ((to initial)))(cat np& t (to initial))(cat del t (to initial)))( init ia l /DEL(cat del t (close* (getr s-place))(to initial))(to initial t\](def-net '( vp-place no-pp pp-placenp-place),((s(pop t (is-def (Y))(close ( inp-pointer)))(to S/ t (setr no-pp 0)))(S/(intr nil (end-of-chunk)((to S/)))(Bush PP (and (lab pp)(le (getr no-pp) 2))((and (gt (getr no-pp) 0)(close* (getr pp-p lace) ) )(setr pp-place (inp-pointer)) )((setr no-pp (addl(getr no-pp)))(jump S/)))(abort "more than 2 PPs in S" (lab pp) )(cat np& t (to S/NP&));(s (pp & pp) ..)(cat del (gt (getr no-pp) 0)(close* pp-place)(setr no-pp l)(to S/))(abort "DEL cannot appear atbeginning of sent" (lab del))(jump S/NP& t\](S/NP&(intr nil (end-of-chunk)((to S/NP&)))(push NP396(lab np)((and(getr pp-place)(close* (getr pp-place)))(setr np-place (inp-pointer)))((to S/NP)));here we can allow PPs after an NP!
(push VP(lab vp)((and (getr pp-place)(close* (getr pp-place))))((jump S/OUT)))(abort =no NP or VP inthe input sentence" t)(jump S/NP t\](S/NP(abort "not enough VPs in S"(end-of-sent))(intr nil (end-of-chunk)((to S/NP)))(push VP (lab vp)((setr vp-place (inp-pointer));if there is a del(close* (getr np-place)));close the preceding NP;and everything in it((jump S/VP)));(s .. (np & np) ..)(cat del (lab del)(close" (getr np-place))(to S/NP&))(abort "too many NPs before a VP"(lab np\](s/vP(cat del (lab del)(close* (getr vp-place))(jump S/VP/DEL))(jump S/OUT t\](S/VP/DEL;standing at 'del' and looking ahead(abort "del at EOS?
"(ge (next-one (inp-pointer))sent-len)); the above is a test for eos(intr nil (null (look-ahead i))((lump S/VP/DEL)))(to S/NP (eq (look-ahead l) 'vp))(jump S/OUT t\];exit: it must be an s(S/OUT(pop t (end-of-sent) (close*))(pop t t\]397
