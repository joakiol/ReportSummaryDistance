The Primordial Soup AlgorithmA Systematic Approach to the  Speci f icat ion of Parallel ParsersWil Janssen, Mannes l)oel, t(laa,s Sikkel, Job ZwicrsUniversity of Twente, Dept.
of Computer ScienceP.O.
Box 217, 7500 AE Ensehede, The NetherlandsE-mail: {janssenw,mpoel,sikkel,zwiers}(c~cs.utwente.nlAbst ractA general framework for parallel parsing is pre-sented, which allows for a unitied, systematicapproach to parallel parsing.
The l'rimordialSoup Algorithm creates trees by alh)wing par-tial parse trees to combine arbitrarily.
By addingconstraints o the general algorithm, a large, classof parallel parsing strategies can be detined.
Thisis exemplified by CYK, (hot, torn up) Earley andde Vreught & Honig parsers.
From such a pars-ing strategy algorithms for various machine ar-chitectures can be derived in a systematic way.1 In t roduct ionIn this paper we present a general framework forparallel parsing algorithms.
Parsing ean be seenms a process in which a set of partial parse treesis recognized.
One starts with the productions aselementary trees.
Small trees Cml be combinedinto larger trees, yielding ew~.r larger and largerstructures, until completed parses for a particu-lar target sentence are produced.
We envisagethe set of recognized trees as a kind of primor-dial soup.
Small trees float around and if theyfit together they can be combined into a largertree.
This is, in a nutshell, the Primordial Sotq)paradigm.In the most general approach, trees can com-bine in arbitrary ways.
That is, a new tree can becreated from two existing trees if there is a par-tiaI overlap between the trees.
The overlappingpart is unified.
Tree creation is nondestructive,in tim sense that a tree can be used more thanonce for the production of a larger tree.
Or, t(~put it in a different way, the initial soup containsan abundant amount of raw material.
Thus allrelevant rees can actually be created.The Primordial Soup Algorithm can be re-lined into a variety of parsing strategies by add-ing constraints, either on the allowed type oftrees or on the way in which existing trees eanbe combined.
A parsing strategy specifies whichtrees will be recognizerl, without bothering tospecify control and data structures that must beadded in order to arrive at practical implemen-tations.For the development of parallel implementa-tions, the (initial) absence of control structure is&n :-:u'~s?
?l;~ a '~ decisions about system architecturecan be deferred to a later stage when the strategyhas been fleshed out in more detail.
Our specifi-cation of the Primordial Soup Algorithm allowsfor a systematic derivation of implementations ofparsing strategies as is shown in a more detailedtechnical report \[JPSZ\].
These derivations areem'ried out within a partial order framework asintroduced in \[JPZ\].
In the restricted space avail-able here we concentrate on the Primordial SoupAlgorithm ~ a fi'amework for the specification ofparsing strategies.In section 2 the l'rimordial Soup Algorithm isintroduced, exemplified by a CYK-like approach.\[n section 3, t.im formalism is slightly extendedso ~ to allow for the description of almost anyparallel or sequential parser.2 The  Pr imord ia l  SoupThe Primordial Soup Algorithm will be introduced after some renlarks about notation andparsers We show that the algorithm is a gener-alization ()\[ well-known parsing strategies.2.1 l ' re l im inar iesWe nse the following notational conventions.Nonterminals are denoted by A, 1/,.., E N; terrninals arc denoted by a,b,.. .
E ~:.
We write Vfor NUY\], with typieal elements X, Y~.... Terminal strings are denoted by s, t ,u ,v ,w, .
.
.
E E*,ACI~.S DE COLING-92, NAN'IES, 23-28 AO(Z|' 1992 3 7 3 PkoC.
oJ: COLING-92, N^N'rES, AUC;.
23 28.
1992arbitrary strings by c~,/3,.., E V*.Let G = (N, Z, P, S) be a context free gram-mar.
Let w -= a l .
.
.a ,  E ~* be the sentence.While executing an arbitrary parsing algorithm,we maintain a set of trees that might be su.b-trees of a parse for w. Let .Tbt be the class offinitely branching trees, in which all nodes havea label from some universal class of symbols.
LetT(G) C J:bt be the class of trees that can be con-structed from P; i.e., if some node is labelled Aand its children X1, .
.
.
,  X~, then A--~XI .
.
.
X ,  EP.
We will usually write T for T(G); individualtrees are denoted p, a, T,.
?
?
E T.We write root(T) for the label of the root of atree T. The yield of a tree T, denoted by yield(T)~is defined as the concatenation of the labels ofthe leaves.
Clearly, y~eld(T) ~ V*.
Note thatleaves labelled ?
(generated by empty produc-tions) are not visible in the yield as ?
disappearsin concatenation.
A tree T is a parse tree for wif root(v) = S and yield(v) = w. For arbitraryw E \]E* a subclass T~ C T is defined that con-rains trees v with yield(v) = a i .
.
.a j  for somesubstring a l .
.
-a j  of w. T~ is called the set ofsubparses of w. The root of a subparse need notbe 8, it can be any nonterminal A E N.As a convenient notation for trees we write= (A "~ ~) for an arbitrary tree with A =root(T) and c~ = yield(T).
In general {A-~ c~)is not uniquely determined, as every derivationA=~+a defines a tree (A -,-* a).
If we want tostress that a derivation A=~,+a/3"~ can be obtainedas A:::~+ aB"/::~+ afl"/ we write (A',-* a (B",~ ~) ~/)for the tree (A-,-*~fl-y).
Thus the tree notation isgeneralized into (A ' ,~ I .
.
.
~.
), where ~ is eithera leaf or a subtree.
This simple tree notation isextended with the following conventions:?
A tree (A-,,*~) corresponding to a single-stepderivation A=~a is also denoted as (A--~a).This corresponds to a production A-..*a E P.?
As a convenient shorthand, a tree(A--~a (B~--*/31} .. .
(B~-,zfl.}
7)will be abbreviated to(A,',~o~ (BI " .
B,,",~ /31" " fl,,) "y).2.2 Var ious  bot tom-up  parsersOur basic approach results from a generalizationof various bottom-up parsing algorithms.
Theoldest and perhaps best known of these is theCocke-Younger-Kasami (CYK) algorithm \[You\].It requires the grammar to be in Chomsky Nor-mal Form, i.e., productions have the form A---*BCor A--re.
If we have trees vl = (B".za~+l.. .
ak)and v2 -- (C ' ,*a~+l .
.
.at )  and if there is a pro-duction A~BC E P, we can construct a largertree (A',~a~+l .
.
.
aj) from vl and v~.
This can becontinued until (S ' ,~a l .
.
.
a,  / has been derived,or no new trees can be constructed.The CYK algorithm is usually described as arecognizer, rather than a parser.
A recognitionalgorithm collects a set of items that denote theexistence of trees, rather than trees themselves.If it is deduced that A:~*a~+l .. ?
a t (without hav-ing constructed a corresponding tree), this willbe denoted by an item \[A',.*a~+l...
at\].
In gen-eral, an item \[A.-~ a\] denotes the existence of oneor more trees (A. ,*a I.
The string w is grammat-ically correct if and only if an item \[S-~ w\] canbe recognized.The CYK algorithm recognizes items of theform \[A-,-* a~+l...aj\].
For notational conve-nience, such an item is usually written as \[i, A,j\].Thus we get the conventional description of CYKrecognition: An item \[i,A,j\] can be recognizediff \[i, B, k\] and \[k, C, j\] have been recognized pre-viously for some i < k < j and A---*BC E P.Several recognition and parsing algorithmsdeal with arbitrary context-free grammars alongthe same line as CYK, involving some more tech-nicalities for handling productions of arbitrarylength, including e-productions.
For example, abottom-up variant of Earley's recognition algo-rithm \[Ear, GHR\] recognizes items of the form\[i, A--*ao/3, j\]denoting the fact that a~*a~+l .
.
.a j .
That is,the first part of a production has been recog-nized.
If fl = e, i.e.
the item is of the form\[i, A--~a.,j\], the entire production has been rec-ognized; such an item denotes the existence ofa tree (A-~ a~+l.., at).
We call this algorithmBottom- Up Earley (BUE) in the sequel; the top-down filter of Earley's algorithm has been deletedso as to allow parallel bottom-up, rather thanleft-to-right processing of the string.Still, BUE recognizes each individual nonter-minal in left-to-right manner, for which thereis no a priori reason.
De Vreught and Honig\[dVH\] describe a similar, more general algorithm(which we abbreviate VH), using double dotteditems \[i,A--*a./3,'y,j\] where/3=?.
*a~+1 . "
a t. Inthis case /3 corresponds to a part of the stringthat has been recognized, whereas a and "~ stillneed to be recognized.Both BUE and VH can easily be extendedAcrEs DE COLING-92, NANTES, 23-28 AOOT 1992 3 7 4 Pgoe.
OF COLING-92, NANTES, AUG. 23-28, 1992to parsing algorithms, producing part ial  parsetrees of the form (A---, (a ".~ a i+ l .
.
.a j )~)  and(A--*~ ( /~"-*ai+l '"  aj)  7), respectively.2.3 The Pr imord ia l  Soup AlgorithmVH is by no means the most general algorithm.As the u l t imate general izat ion we can allow anytree in T.  The top is a nonterminal  and theleaves (:an be any symbol in V; a tree may ormay not be part of a parse for w.Init ia l ly we start with elementary trees thatcorrespond to the product ions in our grammar.New trees can be added by merging (copies of)exist ing trees which agree on their  common parts.This can be seen as some kind of unification pro-cess on parse trees.
The str ing is parsed whena tree T = (S ",~ al .
.
.
a,,) is produced; the al-gor i thm terminates when no new trees can beadded.
Metaphorical ly  speaking, one can thinkof the init ial  set of trees as a primordial  soupin which small  structures react with each other,creating ever larger and more complicated struc-tures.
We therefore call it the Primordial SoupAlgorithm.
Superficially, it may resemble theunification space of Vosse and Kempen \[VK\], whoth ink of molecules f loating in a test-tube and en-ter ing into chemical bonds with other molecules.The paradigms are different however, as in thepr imordial  soup, unlike the test-tube, raw ma-terial abounds and and mult iple copies of anystructure can be created.The most general version of the Pr imordialSoup A lgor i thm--a l lowing to combine trees byunification of arbitrary overlapping parts is aformalism in which a wide variety of parsing al-gor ithms can be specified with great ease.
Be-fore that,  we first formalize a sl ightly l imited,but somewhat easier version of the Pr imordialSoup Algorithm.The algor i thm starts of with an init ial  set ofrecognized trees S consisting of trees correspond-ing to the productions in our grammar.
Newtrees can be added to S by taking combinationsof exist ing trees.
The simplest way to combinetrees is the following.Let c~ = (A~-* c~B3') ?
S and r = (B--~ fl) (:S. We can unify the leaf B in a with the rootB in r ,  yielding a new tree (A --~ a (B ,,~ fl} "/).This tree is denoted by o<1T.
The (partial) func-tion <1 : QCbt x Ybt--,.Ybt is called composition.Note that  there can be inult iple occurrences ofB in yield(a), which means that a<lT need notbe determined uniquely.
Also, we will use theoperator <1 in a l iberal way, allowing more thanone extension to be made at the same time.
Let= (A"--,aoH1cqB2c~2) and Ti = (Bi",~fli).
Wewritecr<1~-l, T ~for the tree (A"~a0 (B, ' -~f l~)ch (B=',zf~2) ~2),using <1 as a polyadic operator with one left-handargument and an arbi t rary number of r ight-handarguments.As init ial  contents of the pr imordial  soup, wetake the trees (A--*~} corresponding to produc-tions A--*~ e P. Such a tree (A-+c~) is called aproduction tTee or a production for short.
We de-fine an operator  `4 : 27--~27 that  yields all newtrees that  can be composed from the contents ofthe soup byA(s) "?--' {~<1r,,..., rk ~ 7- I{~, ~, .
.
.
,  ~k} c s}.This definition of .4 has one shortcoming,however.
Rather  than all parses for all sentenceswe only want the parses for one part icular sen-tence w (~ Z*.
In general, this problem is tackledby redefining A as`4(S) "?'
{a<~,.
., ~ C 7- I {a, ~,,..., ~~} C SA allowed(a<1rh..., ~'k)}in which a predicate allowed specifies which treesare allowed to be added.
Which trees can bediscarded right away, and which ones should beadded to the soup?
As we are only interestedin trees that  can be extended to parses for somespecific sentence w, the terminal  part of the yieldshould he extendable to w. That  is, w can be pro-duced from yield(r) by replacing every nontermi-nal in r with some string of terminals.
Formally,for terminal strings s (~ E* we defineextends(s, t) d~r 3U, v C ~:*(t = USV),i.e.
s is a substr ing of t. For strings in V*containing at least one nonterminal,  we defineextends reeursively a.~extend4(~Z,  t) '~?~ 3s C ~: (extends(~sZ, t)).Finally we defineatto~ed (r ) a?S extends(~ield(?
), w),in accordance with the informal definition givenabove.
Note, however, that  we still may createan infinite number of useless trees, simply by notadding terminals to the yieht!
If yield(r) C N*then allowed(T) holds: each leaf can be extendedt() ~, and the empty string is indeed a substringof w. In 3.2 we will see how this problem canbe tackled in general; here we will only regarda subclass of 7" ttmt does not contain trees witharbitrar i ly large nonterminal yields.ACq'ES DE COL1NG-92, NANTES, 23-28 Aotrr 1992 3 7 5 Paoc.
OF COLING-92.
NANTES, AUG. 23-28.
1992This finally allows us to define the PrimordialSoup Algorithm.\[ Program primordial_soup declarei 8: set of TI beginI s := {r ~ 7- \[ production(r)};while (A(S) - S) ?
0 do $ := S U A(,S)\[ end  {primordial_so~zp} .
.
.
.
.
.
.
.
.
.
.
.
.
.
.2.4 Spec i fy ing  parse strategiesMore specific and more useful instances of the al-gorithm can be defined by imposing restrictionson the trees to be added.
A strategy is a char-acterization of trees that are to be added to theprimordial soup S under some additional con-straints.
Different constraints pecify differentstrategies.
We call it strategy, rather than al-gorithm, as no control structure is specified ex-plicitly.
For the sake of simplicity we assumethat ~4(S) is added all at once, but it shouldbe understood that, if so desired, only a subsetsof ~4(S) need be added at each step.
A strat-egy can be refined into a (parallel or sequential)algorithm by adding control structure and datastructures o as to keep track of intermediate re-sults in an efficient manner.
For examples of thedesign of parsing algorithms from such strategies,see \[JPSZ\].Parsing strategies can be characterized bytwo types of restrictions: on the types of treesallowed in the soup and on the operators thatcreate new trees from existing ones.
Both kindsof restrictions are interchangeable most of thetime; if trees are allowed to combine only in somespecific way, the set of generated trees will berestricted, and vice versa.As a simple example, we will specify a strat-egy for the CYK parser.
To that end, we definean additional predicatecomplete(T) a~ yield(r) e ~*i.e., a tree is complete if its yield does not con-tain any uonterminal.
Such a tree can only beu~'d as a right-hand side argument of a com-position.
Recalling that the CYK algorithm isdefined only for grammars in Chomsky NormalForm (i.e., productions are of the type A---~BCand A-+a), we can define the CYK strategy bydes .AcyK(S) = {a<~rl, r2 \] eomplete(a<~rl, r2)^ altowed(a<r~, r~)}.Apart from the initial production trees, S willonly contain trees of the form (A-,~ ai+l .
- ,  aj).The complete predicate specifies that newly cre-ated trees have a terminal yield; this must be asubtring of w due to the allowed predicate.
It istrivial to verify that all such trees are added toS in due course.
Hence the specification of CYKis sound and complete.3 Other  parse  s t ra teg iesWe redefine the Primordial Soup Algorithm fromsection 2 in a more general manner, and showits power and elegance by specifying the parsingstrategies of Bottom-Up Earley, De Vreught &Honig and some variants of CYK.3.1 Unif ication and superposit ionIn section 2 we used only the composition oper-ator <1 to create new trees from existing ones.Composition can be seen as a specific case of su-perposition, in which arbitrary overlapping partsof trees can be unified.We will first define unification, which is a spe-cial case of superposition in which the roots oftwo trees are mapped onto each other, for thedefinition of unification, we use the derivationoperator =~ for trees.
If T = (A '~ c~B~) anda = (A-~ ~(B--~)'y) ,  we write r=~cr.
A tree ais called an extensioT, of r if r=C'*a, where =~*means applying the derivation =?- zero or moretimes.
Now two trees r and a unify if a tree pexists that is an extension of both cr and r. I.e.,unify(a, r) %~ ~p C T(T=C.
*p A a:=?.
* p) .p is called an upper bound of r and a. Further-more, if a and r unify, there is a unique leastupper bound, denoted by rkla, satisfyingif T=C-*p and a=:C,*p then rllff=:~'*p .rt Ja is called the unification of T and a. Notethat the roots of r and a coincide in TUcr.
Unifi-cation can be generalized to superposition by al-lowing the root of one tree to be unified with anarbitrary node of the other tree, under the con-straint that the overlapping parts of both treesare be identical; see Figure 1.
This superpositionoperator is denoted by ~.
Note that, in general,superposition is not uniquely determined.
Henceit is defined as a function ~ : .7:bt ?
.Ybt--*2 3:bt,whereas unification is defined as a partial func-tion kl : .Ybt x .Wbt---*JYbt.
For a more formaldefinition, see \[JPSZ\].ACT,S DE COLING-92, N^NTES.
23-28 AOUT 1992 3 7 6 PROC.
OF COLING-92.
NANTES.
AUG. 23-28.
1992Tif anT' = p for a subtree r t of % then 7" isreplaced by p.Figure 1: superposition of trees3.2 Some genera l  res t r i c t ionsAs discussed in 2.3, we do not want to recognizeall trees leading to parses of arbitrary strings.We introduced the general idea that a tree isallowed only if the terminal part of the yieldextends to the sentence.
For the CYK algo-rithm, this simple criterion is fine.
In general,however, it is too restrictive, in the sense thatsome familiar parsing algorithms cannot handleit.
Suppose, for example, that a tree (A,',~ aB)is extcnded with a production (B--*bCd) into{A ,~ abCd).
In principle, this should only beallowed if ab and d occur in w in this order.
Aparser which uses only local information, e.g.
anLR(1) parser, cannot determine wtmther a ter-minal d occurs somewhere in the string, perhapsafter a large substring produced by (7.We will use a rather more subtle scheme tomatch the yield of a tree against he sentence, soas to allow for refinement into arbitrary parsingalgorithms.
Having a tree {A-,~ aB) we can checkthat a occurs in w and mark the leaf a accord-ingly.
Marking a leaf is denoted by underliningthe terminal symbol.
The tree (A ~ aB) canbe extended to (A'~ a(B-+bCd)  = (A~.~ abCd)and then to {A~,~abCd), irrespective of whetherd occurs in the string at all.The notion of marking ternfinals with occur-rences in the string fits quite well to parsing nat-ural languages, rather than un-interpreted con-text-free grammars.
In practical NL parsing, theword categories rather than the individual wordsare used as terminals, although they are in factpre-terminals.
Using the word categories as ter-minals, a marked terminal is a word categoryapplied to a word from the sentence.As an example, consider the sentence the birdflies.
The initial soup might contain:(,wNP vt~ (det--,the){NP~detnoun) (noun--*bird)( VP-~ verb) {noun-allies)(verb-~flies)Word categories need not be uniquely defined.
Inthis case the word flies fits into two categories.
Atree (NP ~ the noun) could be combined with(noun~fiies), yielding a noun phrase the flies.This tree is ruled out by extends, however, asthe flies does not extend to the bird flies.In summary, we distinguish two types of initial trees:initial(r) d,=f production(r) V marker(r),produetion( (A---*a) a,r = A- -~aEP,marker((a-m)) ~t a (~ T,a in the sentence.The extends predicate can be defined so as toapply to strings of markings (i.e.
words) ratherthan terminals.
Furthermore, if we do not wantto construct arbitrarily large trees with a non--marked yield, we can definedef allowed ( r ) =extends(yield(r),w) ^ lyield(r)l < Iwl.Finally, allowing arbitrary tree constructionwith superposition (~) rather than composition(<1), a general version of the operator A is givenbyA(s)%f {oe r~o Jr es^aesA allowed(p)}.The algorithm is now given byProgram pr:imordiaL soup -declareS: set of Tbegin/ 5 := {r e 7- I i,~it~al(r)} ; r/ whi le (A(S) - S) -~ 0 do S := S U J\[(S) /\[ end (primordial soup) .
.
.
.
\]For acyclic grammars (i.e., grammars that donot allow a derivation A:=~+A), only a finite num-ber of trees can be constructed, hence the algo-rithm is guaranteed to halt.
When a gramnlar iscyclic, an infinite number of parses exist.
Everyfinite (subtree of a) parse will be found within afinite number of steps.From the point of efficiency, the above al-gorithm isn't sensible at all.
lts strength, how-ever, derives from the fact that a very large classof parallel parsing algorithms can be defined asspecializations, by constraining the general algo-rithm in various ways.
Some examples will begiven shortly.Ac2Y~s DE COLING-92, NANTES, 23-28 AOt~2" 1992 3 7 7 PROC.
OF COL1NG-92, NANTES, AUG. 23-28, 1992We have concentrated on context-free gram-mars for the sake of simplicity.
It should be clear,though, that extension to various types of unifi-cation grammars i straightforward.3.3 Different breeds of treesAs we have seen in the CYK example, completetrees are an important class of trees.
But, hav-ing introduced markers, it is obvious that we con-sider a tree to be complete only if the entire yieldhas been marked.
Therefore we redefinecomplete(v) d.~ yield(~) e U*.Note that all marker trees are complete, and thatproduction trees axe complete iff they correspondto an e-production.Palm trees consist of a roof (correspondingto a single production) and a trunk (consistingof a number of adjacent complete trees).
Theyare the result of composing production trees andcomplete trees.
We can define them as)d~f palm (r =T = (A-*a (fl,-,~ v) 7) A a7 # e ^ /3 # e.By notational convention, A -~f l ?
is a pro~duction and v E E*.
Note that in generalis a sequence of symbols X1 .. '  X,; each X~ isthe root of a complete tree XC,~ P-r Degeneratecases, with only a trunk (a~ = e) or only a roof(3 = ?
= v) are excluded explicitly.As a generalization of palm trees, we mayconsider trees with more than one trunk.
Thistype of tree is denoted by baobab)baobab(r)^ a , .
.
.a~ #e A 31 ' "~ #~.For baobabs, like palms, we exclude degener-ate cases.
Note, however, that any palm is alsoa baobab.
Palms and baobabs are illustrated inFigure 2.A Agt~ ix3,v- palm tree baobabFigure 2: palm trees and baobabsIThe baobab is~.n African tree that has branches fromwhich roots originate, supporting the roof.
Such rootsgrow out to additional trunks.3.4 CYK rev is i tedThe only addition to our previous pecification ofCYK is that it should produce trees with markedyields.
To that end, we can define an initial stepA0(S) doj (a<T e TIa, T e SA production(g) A marker(r)).For the remainder of the algorithm, productiontrees a = (A~BC)  are composed with two com-plete trees T1 and T2 as usual, denoting ternarycomposition by a<lzl, T2.TO keep in line with other algorithms to fol-low, we could alternatively define CYK with abinary composition operator.
As a consequence,a new tree is created in two steps.
First a pro-duction tree is combined with a complete tree,giving a palm.
In the second step the palm iscombined with a second complete tree, giving anew complete tree.
We define two functions A:Ads)  %f (~<T e Tl~,~ ~ sh production (a) A complete (T) },Ads)  %f (~<T e Tla, T e s ^ Tetra(a)A complete(T) A allowed(a<lT)}.But as intermediate palm trees do not occur inthe CYK algorithm as such, we define the func-tion A'cyK (for other than initial steps) asA'cvK(s) %' ~(A~(s) u s).A more liberal approach would be to allowthe intermediate r sults to be in the soup:A,, ~S ~ d.~ At ($) u As(8).
CYKk \] =For grammars in Chomsky Normal Form thishardly seems sensible.
But when CYK is ex-tended to arbitrary CFGs, a complete tree canbe created from a production tree through an in-termediate series of palm trees.
If symbols in theright-hand side of a production can be recognizedin arbitrary order, the condition palm(g) in thedefinition of A2 should be replaced by baobab (a).3.5 Bot tom-Up Ear leyThe BUE algorithm is defined for arbitrary con-text-free grammars.
It is usually described asa recognition algorithm.
An item \[i,A---*a,3,j\]denotes the fact that a~a,+t  ' ?
?
a s has been rec-ognized.
From \[i, A-~a.B%j\]  and LJ, B-*3o, k\]anew item \[i, A--~aB?% k) can be derived.
We willdefine the algorithm on trees, rather than items.Trees of the form (A--* (a',~v / 3) are recognizedfor v = ai+l ?.
?
aj a substring of w.ACTES DE COLING-92.
NANTES, 23-28 AOOT 1992 3 7 8 PgoC.
OF COLING-92.
NANTES, AUG, 23-28, 1992We define the set of Earley trees g C 7" as?
d?d {(A--* (a-,~v)Z) ?
T \ ]A--~a/~ E P ^ v E E*}.Note that productions (~ = e) and completetrees (~ = e) are also included in 8.
The op-eration of the algorithm is described by?
ABuE(8) d.f { a.~r E ?
I o, r  ?
8^ allowed(a,~r)}.From the definition of g' it follows that a,~r ?
Eiff complete(T) and the leftmost unmarked sym-bol of yield(a) is root(T).
The soundness followsfrom the definitions and completeness is triviallyproven with induction on the size of the tree,hence the algorithm is correct.3.6 De  Vreught  and  Hon ig ' s  a lgor i thmThe VH algorithm also uses complete trees andpalm trees, with the difference that the trunk ofa palm tree does not necessarily cover the left-most part of the roof.
We define a set l) of trees,analogously to the set of Earley trees byV ~f {(A--.c~ (f/-.~ v~ -y) e 12 \[A~a/37  ~ P A v E ~*}.The functions to combine trees are defined dif-ferently, however:Ads)  ~?J {o~r e v l o,r e sh production(o)A complete(r)},A~(s)~our  eV la ,  r es  ^ palm(o)A palm(T) ^  allowed(our)},Av.
(s) ~ At(s) u A~(s).The first operation was originally called inclu-sion, the second concatenation.
The former com-bines a nonterminal tree and a complete tree to apalm tree, whereas the latter combines two palmtrees into a palm tree with a wider trunk, usingunification.
It cannot result in a proper baobabbecause of the definition of 12.
A subtle differ-ence to the original algorithm is that we allowtrunks of o and r to overlap, which is prohibitedin their approach.
It is not difficult to add thiscondition, if required.A similar result is obtained by replacing thefunctions ~4t and .A2 by a function similar to theone used for Earley's algorithm (but now for treesin 12 instead of in ?).
Thus a generalized bottom-up Earley parser, for which left-to-right parsingof a constituent is not necessary, is defined byA(S) ~f {o~r ?
v t o, ~ ?
sA complete(r) A allowed(a~r)}.4 Conc lus ionsThe Primordial Soup paradigm facilitates thespecification of parsing strategies, i.e., high-levelspecifications or parsing algorithms, without ex-plicit control flow and data structures.A specification without control flow is a goodbasis for the design of a parallel implementation,as it allows a further refinement of the designbefore any decision on architecture is taken.
Formore details, see \[JPSZ\], where this has been ex-emplified with a design for a parallel CYK parser,using the Primordial Soup paradigm and the for-malism introduced in \[JPZ\].The Primordial Soup framework can be usedto design new parsing algorithms by mixing fea-tures of existing algorithms.
For example, theEarley operator for tree composition i  combina-tion with the De Vreught & Honig set of allowedtrees yields a generalized Earley parser that hasbeen rigorously defined in only two lines.The specification of parsing strategies i givenin a formalism closely resembling predicate logic.This makes it almost trivial to derive prototypeimplementations i  (parallel) logic programminglanguages like Prolog or Parlog \[JPSZ\].Re ferences\[Earl J. Earley.
An efficient Context-Free Parsing Al-gorithm.
Comm.
ACM, 13 (1970) 90-102.\[GHR\] S.L.
Graham, M.A.
Harrison, W.L.
Ruzzo.An Improved Context-Free Recognizer.
Trans.on Prog.
Lang.
and Syst.
2 (1980) 415-462.\[JPSZ\] W. Janssen, M. Poel, K. Sikkel, J. Zwiers.Tile Primordial Soup Algorithm.
MemorandaInformatica 91-77, University of Twente (1991).\[JPZ\] W. Janssen~ M. Poel, J. Zwiers.
Action Sys-tems and Action Refinement in the Devel-opment of Parallel Systems, CONCUR 'gLSpringer Lectures Notes in Computer Science527 (1991) 298-316.\[VK\] T. Vosse, G. Kempen.
A Hybrid Model ofHuman Sentence Processing: Parsing Right-Branching, Center-Embedded and Cross-SerialDependencies.
Proc.
2 "d Int.
Workshop onParsing Technologies, Cancun, (1991) 73-78.\[dVft\] J.P.M.
de Vreught, H.J.
ttonig.
A Tab-ular Bottom-Up recognizer.
Report 89-78, Fac-ulty of Technical Mathematics and Informatics,Delft University of Technology (1989).\[You\] D.H.
Younger.
Recognition of context-free lan-guages in time n 3.
Information and Control 10(1967) 189 208.ACTES De COLING-92, NANTES, 23-28 AOm" 1992 3 7 9 PROC.
OF COLING-92.
NANTES.
AUG. 23-28, 1992
