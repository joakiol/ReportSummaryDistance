A TOOL FOR COLLECT ING DOMAIN DEPENDENTSORTAL  CONSTRAINTS FROM CORPORAFrangois Andry*, Marl( Gawron, John Dowding, and Robert MooreSRI International, Menlo Pmq% CA*CAP GEMINI Innovation, Boulogne I:lilla.ncourt, FranceInternet: andry@capsogeti.fi:Topical paper : Tools for NL Understanding(Portability).1 ABSTRACTIn this paper, we describe a tool designed to gener-ate semi-automatically the sortal constraints spe-cific to a domain to be used in a natural anguage(NL) understanding system.
This tool is evaluatedusing the Sll,I Gemini NL understanding system intile ATIS domain.of work we put into the first domain application 1.In this paper, we describe tile results of us-ing this semi-automatic tool to port the (',e, udliiNL system to the ATIS domahi, a (lomltin that(ienlini had ah'eady been ported to, arid for whichit \]lad achiew~,d high perl'orluance ~ttld gi'al'l-illiati-cal coverage using hand-written sortal constraints.Chossing a known domain, rather than a new one,allowed us to compare tile performance of tile de-rived sorts to the hand-written ones, holding thedomain, grammar, and lexicon constant.
It alsoallowed us to evahlate the selni-~ultoma.tically ob-tained cown'age using the ewduation tools pro-vided for the A'I?IS corpus.2 INTRODUCTIONThe construction of a knowledge base related toa specific domain for a NL understanding systemis time consuming.
In the Gemini system, thedomain-specific knowledge base includes a sort hi-erarchy and a set ot" sort rules tha~ provide (largelydomain-specific) selectional restrictions for ew~rypredicate invoked by the lexicon and the gram-mar.
The selectional restrictions provide a sourceof constraints over and above syntactic onstraintsfor choosing the correct analysis of a sentem:e. Thesort rules are generally entered by a linguist, byhand, from the study of a corpus and while tuningthe grammar.IIowever, the use of an interactiw; tool thatcan help the linguist to acquire this knowledgefrom a corpus\[a\]\[5\], can drastically reduce the timededicated to this task, and also improve the qual-ity of the knowledge base in terms of both ac-curacy and conipleteness.
'l'he reduction in theamount of etfort to develop the knowledge basebecomes obvious when porting an existing systemto a new domain.
At SR,I, our main concern wasto port Gemini, our NL understanding system toother domains without investing the same amount3 PARSING WITH SORTSGemini\[2\] implements a clear separation Imtweensyntactic and sem~mtic information.
Each syntac-tic node invokes a set of semantic rules which re-sult in the bnihling of a set of logical forms forthat node.
Selectlomd restrictions are enforced onthe logical fornls through the sorts nlechanism: Allprcdlcations in :~ catldiihd.e logical form IlallSt I)e li-censed by some sorts rule.
The sorts are located in~ conceptual hierarchy of approxhmd;cly 200 con-cepts mid are imphmleiH.ed as Pro\]og terms suchthat nlol'e gellorai sorts SllltSllllle lliore specificsorts\[6\].
Failure to match any available sorts rulecan thus he implernented as unification-failure.Gemini parser creates logical forms expres-sions like the fbllowing one :exi.sl.s( A ; \[flighl\]),\[and, \[fli~lht, (A; \[fli~.lht\])\]; [prop\],\[to, (A; \[flight\]),(' I:~05'!I'ON'; \[city\])\]; \[prop\]\]; ~r, op\]); \[prop\]In these logical form expressions, every sub-expression is assigned a sort, represented as theIThe actual dom;dn is Air Transportation (ATIS)used as a benchmaxk in the ARPA community.598right-hand-side of a ';' operator\[l\].
Sorts rules forpredicates are declared with sor/2 clauses:~or(' l~O,?
'rO N', \[,,;ey\]).sot(to, (\[\[flight\], [city\]\], \[prot,\]) ).The above declarations lic.ense the use of'BOSTON' as a zero-ary predicate with "result-ing" sort \[city\] and 'to' as a two-place predicaterelating flights and cities with resulting sort \[prop\](or proposition).In the ATIS application domain, for exaulple,the subject (or actor) of the verb deparl, as in'the morning flights deparling for denver', can 1)ea flight.
For this, we use the following set of sortdefinitions:.~o,'(d~v,,,'t, (\[\[d~v~,,'~,,,'~\]\], \[p,,ov\]))so,,(ftighl, (\[\[fligtd\]\], \[prop\]))so,.
(acto,., (\[\[departure\], \[flivhl\]\], \[p,.np\]))'Phe tirst two definitions make depart and flightp,'edieates compatible with departure and llightewmts respectively, returning a proposition; thethird makes aelor a relation that (:an hold be-tween flights and tlights, also returning a llroposi-Lion.
A simple example of a logical form lice.nsedby these rules follows (with the result sort \[prop\]suppressed):qterm( .
.
.
.
.
.
.
( ( X ; \[flight\]),\[.rid, \[flight, (X; \[flight\])\],ezists( Y; \[flight\]),\[.,,,I, \[a~v.,.t, (r; \[,t~v.,.t,,~\])\],(v; \[,l~v,,~t,,,,d),\[actor, (Y; \[del>art,vre\]) , (X; \[f lighl\])\]\])\])Which would be roughly the logical form for'a deparling flight'.4 SORT ACQUIS IT ION't'he apl)roach we have taken is to start fi'om anil, itial "schematic" sorts fih: we call the signaturefile (explained below), which essentially allows allpredicate argument coml)inations.
We tJlell hal'-vest a set of preliminary sort rules by parsing alarge corpus.
The logical forms that induce thesepreliminary rules e61rle frona parses that; essentiallyincorporate only syntactic onstraints.
The resu\] l-ing sorts rules are filtered by \]lalld alld the processis iterated with an increasingly accurate sorts file,converging rapidly on the sorts file specific to theapplication domain (fig.
1).4.1 S ignature  and  l Les t r i c t ionsIf we started the abow~ iteration process with nosortal information,.then the logical forms resulting\[ -co,,i,,5; .
.
.
.. \] _~~.- ----7~ step::l Sg\ ] t .
l '~  .'
e "~':---Figure 1: lterative Acquisition of Sorts.frolll a parse would colH.aill iio sortal ill\['Ol'nlatioil,alld only vacnons ortal rules wotlld \])e harvested.
"\['\]le first ste l) is tlllls to huild an initial sortfile we call the signat'ure \[il~.
The idea is to as-sign lexical predicates inherent sorts, but not toassign assign ally rllles which constrain which lex-ica\] itelns (:all colnhine with which.
The signaturefile, then, is m~t just domain-independe.nt.
It hasno information at all ahout semantic oml>inal;o.rial Imssil)ilities, not even those determined by thelallgtla,~e (for example, that the verb break doesnot allow prolmsitional subjects).
The reason forthis is so that it can be generated largely automat-ically from the lexicon.4.2 The  S ignatureI,ets Im,e;in with certain inherently relational pred-icates, for which the sigllatnre file gives only anarity and the result sort.
I"or example the signa-ture fc~r the predica.tes al (corresponding to thepreposition) and actor (corresponding to logicalsubject) wouhl be the same:.~#.,.~,,,.,,.
(.t, (IX, r\], b,,'ov\]).~i~t,.,v,,,.,~(.,,z,,,., (IX, v\], \[v,',,v\])This signature is u~ed as the sort rule R~r atand actor in the sorts tool's first iteration.
Theefl>ct is t.o limit the choice of sorts rules for theseln'edicates 1.o rules which are further instantiat,ionstheir signatm'os, that is, to rules licensing them to599take two arguments of any sort to make a proposi-tion.
The object in successive iterations will beto assign these relational predicates ubstantivesortal constraints, thus constraining head modifierrelations and the parse possibilities.Verbs, nouns, some adjective and adverbs, onthe other hand, have signatures with fully or par-tially instanciated arguments: For example, in theATIS domain, the verbs depart, get_in, mad thenouns data, flight have the signatures:signature(depart, (\[\[departure\]\]~ \[prop\]))si~nat~,re(get_in, (\[\[a,'ri~at\]\], \[prop\]))signature(data, (\[\[information\]\], b,rop\]))slgnature(flight, (\[\[flight\]\], \[prop\]))These declarations have no effect on the combi-natorial possibilities of these words (they tell usnothing about what can be the subject of the verbdepart or what verbs the noun flight can be sub-ject of), but when a logical form is built up fl'oma syntactically licensed parse (like the one give.nabove for a departing flight), these sortal decla-rations will "fill in" the sorts for the connectingpredicate actor, generating the sort rulc:slgnature(actor, (\[\[departure\], \[flight\]\], [prop\])Thus in the signature file, lexical predicates havetheir own "inherent" sort rules, which then helpbuild up the sort rules for the relational predi-cates.
The inherent sort rules for adjectives likecheap and late will constrain only their first argu-ment.
The reason for this is that it is this firstargument that modifiers (such as intensifying ad-verbs and specifiers), will hook on to.
*ig.ature(eheap, (\[\[eost_soa\], A, n\], \[prop\]))~ignat~re(tate, (\[\[temporal_stage\], A, 13\], \[p,'op\]))At the same time the argument position filledin by what the adjectives modify is left uncon-strained.
The signature file thns makes no com-mitment about what sorts of things can be late orcheap; it just needs to say there is such a thingas lateness and cheapness.
This is why for a newdomain the signature file can be generated largelyautomatically, using a new inherent sort for eachnew lexical item, mssigning the type of predicateappropriate to its grammatical category.All zero-arity predicates (names) need tohave inherent sorts.
Certain general 'tool words'which include numbers, dates, time, and commonswords, will receive the same signatures in any do-ma in  :signature(3, (\[number\]))signature(lriday, (\[\[day\]\], [prop\]))signature(pm, (\[nonagent\]) )signature(yes, (\[p,'op\]))In addition to this, however, there is a whole list ofwords specific to the dornain which riced to be in-herently sorted.
This part of creating a signaturefile will need to be done by band:signature(' N AS II Y I L L E', (\[city\]))signature(' AI l~_C AN A1k A', (\[airline\]))signature(' LA_GU AfUg l A', (\[airport\]))4.3 Ext rac t ing  the  Sor tsWe now give a more detailed example of how sortrules are extracted fl'om logical forms (bFs) builtby the parser.
For '*he morning flights flying todenver', we obt~dn roughly the following Logical1,~or m :qterm(the; \[non_symmetric_determiner\],A; \[flight\],\[and,\[fllqht, (A; \[flltfl,t\])\],\[n_n_rel,(z~; \[dau-Va,'t\]) \[and,\[morning,(13; \[day-part\])\]\]; \[\[da:,/-v..'tl\], \[prop\],A; \[flight\]\],ea:isZs( U; \[flight\],\[,,.d,If In, (C; \[flight\])\],\[actor, (C; \[ftlght\]),(A; \[flight\])\],\[has_aspect,(C; \[flight\]),(in_progress; \[aspect\])\],\[to, (C; \[flight\]),(' D :;:N V :~':e' ; \[e'it,v\])\]\])\]);\[yli,jl;t\]The eXLracLiotl process COllSiStS Of a recursiveexploration of the logical form and retrie, val of eachpredirate gild its arglllliellts, ldor example, fromthe LFs above, our tool would extract the follow-ing sort definitions set  7 :sot(flight, \[\[flight\]I, [prop\])~o~(..o.,i,,g, \[\[,t.u-v..~\]\], \[v~ov\])sor(n_n_rel, \[(\[\[,lay.port\]\], bJrop\]), \[flight\]\], b,rop\])sot(fly, \[\[flight\]\], [prop\])sor(aelor, \[\[fti~aht\], \[ftiyht\]\], \[prop\])sot(to, \[\[flight\], \[city\]\], \[prop\])sor(f rag-nl,, \[\[flight\]\], b,'rop\])2For reason of efficiency and simplification, we ex-clude some very common predicates independent ofthe domain, such as 'and', 'equal', exists', 'has_aspect',;tnd 'qterm'.600sor(np_f rag, \[\[prop\]\], [prop\])When constrained only by signatures, theparser typically finds a large number of logicalforms.
The sorts tool provides the option of har-vesting sort rules in one of two ways, either fromall generated logical forms, or only from the Pre-ferred Logical I'brm (PLF).
The parse preferencecomponent implemented in Gemini chooses thebest intepretation from the chart, based on syn-tactic heuristics\[2\], and provides a set of PLFs.In addition to the extraction of the sort rules,we also calculate tire occurrence ?i of each sortrule for all the sentences of the corpus.
We thennormalized ?i by the number of logical forms thatinclude the sort rule (Ni).
F, ach value Oi is storedalong with its sort, rule and used to calculate theprobabilities related to the sort rule :- ~=o 6)iIn fact three sets of probabilitilies are calcu-lated for each rule R: (1) Global probability of sortrule R: the number of invocations of rule 1% nor-malized by the number of LFs containing I~ anddivided by the total nmnbcr of rule invocations inthe corpus; (2) Conditional probability of rule 1~given a particular predicate; (3) Conditional prob-ability of 1% given the predicate in l~ and an argu-ment of the same sort as the first argument of R..Also, associated to each sort definition, wekeep the list of the indexes of a small set of sen-tences which contain the corresponding sort def-inition in its logical form.
This set is used as asample for the set editor tool.4 .4  The  Argument  Rest r i c t ionsThe argument restrictions are instantiated ver-sions of the signatures for each predicate.
For ex-ample, after parsing and extraction from tire logi-cal forms, the arguments X and Y of the signatureassociated to the preposition at will help to gen-erate a list of several sort definitions uch as :so,.
(.t, (\[\[.i~po~t\], \[eitu\]\], \[p,.op\])as in : 'the aiport at Dallas',so~(.t, (\[\[dom.in_e,~nt\], \[~i.r~_Vo;n*\]\], b"op\])as in : 'departure at 9prn'.5 SORT EDIT INGAt each step of tire process, after parsing, tile lin-guist, using the interactive sort editor, can exam-ine the new sort file which has been generated andchoose which sortal definition need to be elimi-nated.
Statistical information ~sociated to eachsort definition helps him decide which ones are rev-elant or not.
We have also included tire possiblilityof adding a sort definition, although this kind ofoperations hould be very rare.
In fact the mainactivity of the linguist using the sort editor tool,will be to filter the sort definitions generated bythe parsing of the corpus.5.1 Descr ip t ion  o f  the  too lThe sort editor tool is all interactive, window-based program.
It hms a main window for dis-playing and editing the sorts and a set of buttonsthat help the user to either display additional in-formation or perform actions such as :?
load or save a sort file,?
select a fimctor among tile list.
of Ml fimctorsand disphty the list of its possible arguments,result and probabilities,?
deletion and insertion of a sort definition,?
display a sample of sentences associated to aspecific sort definition,?
mapping between the sort definitions and a ref-erence sort file (for evaluation),?
changing the way the sort definitions are dis-played (result or not, mapping or not, globalprolmhility, conditional to a functor, or relativeto the first argument of a definition),?
use of a threshold on the ln'ol>abilities to filterthe sort definitions,?
retrieve I.he list or I'unctors giwm a certain argu-\[|I(HIL)?
display the sentences associated to a sort defi-nition,?
display the list of predicates which have beenexcluded form the extraction,?
specification of a sortal hierarchy to be usedwith the sort definitions for the next iteration,?
use of a whiteboard to save specific sentencesand information daring a session.The tool uses ProXT, the Quintus Prolog in-terface to MOTIF widget, set and the X-Toolkit.6016 EVALUATION AND RESULTSEvaluate the porting to a new domain require rnea-suring how the new sort file contributes to per-form the target task within the new domain.
Thiskind of evaluation is difficult because it is hard toseparate the contribution of the grammar and thecontribution of the sorts constraints.
One way toevaluate our tool would be to have a file of " cor-rect" sortal constraints that we use as a referenceto check the ones we generate with our tool.
"riteproblem is that this kind of file does not exist fornew domMns, since obtaining such file is preciselythe purpose of our tool.The approach we have chosen was to use thesort file built by hand for the ATIS corpus and tocheck this 'reference file' against the new sort filewe intend to build, using our tool on a corl)us ofthe same domaine.6.1 Bu i ld ing  the  s ignature  fileFor the this first experimental exercise with thesort tool, we built the signature file somewhat dif-ferently than we wonld build it for a new appli-cation.
In order to facilitate evaluating tl,e tool,our goal this t ime was to come up with a signaturefile be compatible with the reference file built byhand.The tirst step in the experiment was to auto-matically extract the signatures from the lexiconand reference sorts file, which contains nearly 2200sort definitions.
Signatures are largely predictablefrom the grammatical category of a word 1"o,' ex-ample, most of the verbs (except the auxiliaries)with one argmnent, receiw'.d a signature identicalto the sort definition.
On the other \[laad, nlosl.of the prepositions received a signature with alltheir arguments replaced by a varial)h.' (since theyare domain-specific).
In this maiden voyage of thesort acquisition system, the signatures chosen forverbs, adjectives and nouns were made coml)ati-ble with the sort hierarchy used by the referencesorts file.
In porting to a new domain, the lexicalsignatures would presumahly use an automaticallygenerated sort hierarchy, almost entirely fiat, witha unique lexical sort for each lexical item.In addition to this, some signatures, for logicalpredicates and predicates introduced in semanticrules, were added by hand.
These represent a lit-tle bit more titan 15% of the final signature filewhich contains a total of 1357 signatures, llalf ofthese signatures are zero-arity predicates mostlyautomatically built from the lexicon.6.2 Pars ing  MadeowThe next step of our experiment was to parse acorpus from the A'I'IS domain using the signa-ture file we haw; Imilt.
For this, we have used theMADCOW corpus\[4\], that includes 7{24:t sentencesof various length (from 1 to 36 words) with a largelinguistic coverage from this domain.
This processhad been done in both modes LFs anti PLI,'s.
q'heidea was to compare the result in both modes, tocheck whether the use of parsing preferences wasrelewmt for the extraction of tile sort definitionsor if we had to use all the Logical l,'orms from tileparsing.The first iteration of parsing MAI)COW In'O-dated 5917 and 2275 sort rules a respectively forthe LI,'s and PLFs modes.6.3 Mapp ing  corpus  and re ferencerulesFor this first ewthmtion, we also used a feature ofour tool which ran map each sort rule producedby the extraction phase against the rules of a ref-erence sort file.
'i'he mapping consists of assigningone of the following categories to each corpus ac-quired sort rule :?
Exact : the corpus rule match exactly with areference rule,?
Incompatible : the corpus rule does not matchwith any reference rule,?
Sabsnmed-by : tile corpus rule is subsumed byat least one reference rule,?
~tlhstunes : the corpas rule subsumes at leastone re\['ereace rule,?
lncomparal)h~ : the corpus rule is incomlmrabh:wil.h nt hmst one reference rule.q'he following table shows the repartition ofmapping categories modes IA,'s and PLl:s :xact 1--40  I a27 Ih~compatibleSubsumed-bySubsumes_hlcomparahh.
""total _ D ~ ~aSiuce zero-arity sort l)redicalcs h~Lve a signatureidentical t,o their sort rule, only sorts rules with atleast an argmnmlt were extra(:ted uring the parsing<>f MAI)COW.4'l'wo sort rules are incomparable, whell they unifyeach other while none of them subsumes the other one.602Tim first comments concerning these figures isthat the percentage of incompatible rules is higherfor the LFs than the PLFs mode (respectively 52%vs 30%), and the number of 'exact' sorts is morethan half for lAPs than PLFs.
This shows that theuse of Preferred Logical l"orms for parsing is moreefl\]cient in extracting the 'good sorts'.tIowever, the figures do not give an exact ideaof the completeness and precision of our tool, sincethere is a large number of rules sul}sumed by otlmrones (more than 30% for I,Fs and almost 50% forPLies mode).
In fact, some of tile corpus rules aresubsuined by more general rules ill the referencesort file while providing the same coverage as thereference sort rules.Therefore, the prec is ion of our tool fc)r thel'Ll"s mode just after the extraction phase canbe estimated between 16% (exacts rules) and 55%(exact rules plus subsumed n\]les).
This \[mml}ergets better and more precise very q,,ickly after thefirst iteration of editing since the work of the lin-gnist is precisely to remove most of the incompat-ible and incomparable rules and rules whi{:h areeither to() general or too speciiic.The ovt,.rge.neration of the tool just afterparsing, for the Pl,l,'s mode, can I)e estimated toat least 30% (the percentage of incorrect rules).After tile first iteration of editing, this numberdecreases very quickly since low probahilitles helpthe lingnist to eliminate rules that are incomI}ati-hie or ineomparable.The reeal l  for the Pl,Fs mode after parsing,which is the ratio of the 'Exact' corpus rules by thenumber of reference rules used for the mappillg inour evaluation (636 non zero-arity sorts rules), canbe estimated to at least 57%.A more precise estimation of the exact ram>bet of 'Exact' rules could be COmlmted by usingthe sortal hierarchy, and generate tbr the two setsof rules (corpus and reference) all the rules thatcan be subsumed, and realize the mal}plng onlywith these rules.7 CONCLUSIONThis first evahmtion of our tool in the ATIS do-main shows tlmt the acquisition of sorts from acorpus can be partially automated, reducing dras-tically the time the linguistic dedicates to this task(the precision converges in few editing iteration).In addition to this, the possibility of a systematicexamination for all predicates with crosschecldngtools such as sentence visualisation and funetorbrowing helps the linguist to establish strict aqui-sition methods for the knowledge base in new do-nlgins.In addition to this, the tool can also lie usedto improve an existing knowledge /)ase.
For ex-ample, the study of the ineoml)atilde rules d,,r-ing this \[i,'st evaluatio,l helped us {.o discover newrules that will increase the coverage of (iemini inthe ATIS system.8 AcknowledgementsThis research was supported hy the A{lwmced I{e-search Projects Agency mtder contract with the Of liceof Nawd lh~sear(:h, and by a grant of the \],avoisier Pro-gram from the l"rench l;'{}reign Ollice.
The views ~uulconclusions contained in this document are those nfthe ~ulthors and should ,,ot be interpreted as necessa.r-ily represe,lti,lg tile.
official i}olicie.s, either exl)ressed orimplied, t}f the Adwmced lh:sear{:h l}rojects Agency {}1th{: U.S. (',overnnxe,tt, or those of the Sciel~Lific Mission{}f the l"rench l"oreign Ollice.References\[l\] Alshawi, I1.
(ed.
), The Core Lawfuage l'/n.-9b~e, M IT Press, 1!
)92.\[2\] I)owding J., Gawron ,I.M., Appelt 1)., BearJ., Cherny L., Moore IL and Mortal 1).,%II",MINI : A Natural I,anguage Systenl Fro'Spoken-l,anguage Understanding", Proceed-ings of the 31st Meeting of the Association forComputational \[,inguistics, Ohio State I In iw'.rsity, Columbus, Ohio, pp.
5d-6 l, 1993\[3\] (',rishnmn R., llirschman L. and Ngo 'I'.N.,"l)iseovery Procedures for Subhmguage Se-lectional Patterus : Initial li',xperinlents ",Comlmtalio',al Liwlui.~lics , Vol.
12:3 pp.
205,198(i.\[4\] Ilirschrnal, l,., "Multi-.Site l )a ta  Colhx'.ti<mfor a Sl)oken {,ai,g,mge {2}rpus", MAI)COW,in l'roccedings of the I)A I~ I'A ?'peech.
and Nal-ural l,a~tguage Workshop, pp.
7-l d, II'e}}.
J992.\[5\] l,ang I".M., llirsehman 1,., "hnproved l}orta-bitity and l'arsing Through hlte,'aetive Ac-quisition of Semantic hfforna~tio,,", In #ec-ond Confi:rence on Applied Nal'ural Lang'uagcl'rocessiu 9', Feb. 1988.\[6\] Mellish, C., "Implenlenting Systemic Classi-fication by UldIieation".
Compulational Li~>g'.islics, V'ol.
14, pp.
40-511, 1988.60.3
