Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 1180?1191,Edinburgh, Scotland, UK, July 27?31, 2011. c?2011 Association for Computational LinguisticsJoint Models for Chinese POS Tagging and Dependency ParsingZhenghua Li?, Min Zhang?, Wanxiang Che?, Ting Liu?, Wenliang Chen?
and Haizhou Li?
?Research Center for Social Computing and Information RetrievalHarbin Institute of Technology, China{lzh,car,tliu}@ir.hit.edu.cn?Institute for Infocomm Research, Singapore{mzhang,wechen,hli}@i2r.a-star.edu.sgAbstractPart-of-speech (POS) is an indispensable fea-ture in dependency parsing.
Current researchusually models POS tagging and dependencyparsing independently.
This may suffer fromerror propagation problem.
Our experimentsshow that parsing accuracy drops by about6% when using automatic POS tags insteadof gold ones.
To solve this issue, this pa-per proposes a solution by jointly optimiz-ing POS tagging and dependency parsing in aunique model.
We design several joint modelsand their corresponding decoding algorithmsto incorporate different feature sets.
We fur-ther present an effective pruning strategy to re-duce the search space of candidate POS tags,leading to significant improvement of parsingspeed.
Experimental results on Chinese PennTreebank 5 show that our joint models sig-nificantly improve the state-of-the-art parsingaccuracy by about 1.5%.
Detailed analysisshows that the joint method is able to choosesuch POS tags that are more helpful and dis-criminative from parsing viewpoint.
This isthe fundamental reason of parsing accuracyimprovement.1 IntroductionIn dependency parsing, features consisting of part-of-speech (POS) tags are very effective, since purelexical features lead to severe data sparseness prob-lem.
Typically, POS tagging and dependency pars-ing are modeled in a pipelined way.
However, thepipelined method is prone to error propagation, es-pecially for Chinese.
Due to the lack of morpholog-ical features, Chinese POS tagging is even harderthan other languages such as English.
The state-of-the-art accuracy of Chinese POS tagging is about93.5%, which is much lower than that of English(about 97% (Collins, 2002)).
Our experimental re-sults show that parsing accuracy decreases by about6% on Chinese when using automatic POS taggingresults instead of gold ones (see Table 3 in Section5).
Recent research on dependency parsing usuallyoverlooks this issue by simply adopting gold POStags for Chinese data (Duan et al, 2007; Zhang andClark, 2008b; Huang and Sagae, 2010).
In this pa-per, we address this issue by jointly optimizing POStagging and dependency parsing.Joint modeling has been a popular and effec-tive approach to simultaneously solve related tasks.Recently, many successful joint models have beenproposed, such as joint tokenization and POS tag-ging (Zhang and Clark, 2008a; Jiang et al, 2008;Kruengkrai et al, 2009), joint lemmatization andPOS tagging (Toutanova and Cherry, 2009), jointtokenization and parsing (Cohen and Smith, 2007;Goldberg and Tsarfaty, 2008), joint named en-tity recognition and parsing (Finkel and Manning,2009), joint parsing and semantic role labeling(SRL) (Li et al, 2010), joint word sense disambigua-tion and SRL (Che and Liu, 2010), joint tokenizationand machine translation (MT) (Dyer, 2009; Xiao etal., 2010) and joint parsing and MT (Liu and Liu,2010).
Note that the aforementioned ?parsing?
allrefer to constituent parsing.As far as we know, there are few successful mod-els for jointly solving dependency parsing and othertasks.
Being facilitated by Conference on Com-putational Natural Language Learning (CoNLL)2008 and 2009 shared tasks, several joint modelsof dependency parsing and SRL have been pro-posed.
Nevertheless, the top-ranked systems alladopt pipelined approaches (Surdeanu et al, 2008;1180Hajic?
et al, 2009).
Theoretically, joint modelingof POS tagging and dependency parsing should behelpful to the two individual tasks.
On the one hand,syntactic information can help resolve some POSambiguities which are difficult to handle for the se-quential POS tagging models.
On the other hand,more accurate POS tags should further improve de-pendency parsing.For joint POS tagging and dependency parsing,the major issue is to design effective decoding algo-rithms to capture rich features and efficiently searchout the optimal results from a huge hypothesisspace.1 In this paper, we propose several dynamicprogramming (DP) based decoding algorithms forour joint models by extending existing parsing algo-rithms.
We also present effective pruning techniquesto speed up our decoding algorithms.
Experimen-tal results on Chinese Penn Treebank show that ourjoint models can significantly improve the state-of-the-art parsing accuracy by about 1.5%.The remainder of this paper is organized as fol-lows.
Section 2 describes the pipelined method, in-cluding the POS tagging and parsing models.
Sec-tion 3 discusses the joint models and the decod-ing algorithms, while Section 4 presents the pruningtechniques.
Section 5 reports the experimental re-sults and error analysis.
We review previous workclosely related to our method in Section 6, and con-clude this paper in Section 7.2 The Baseline Pipelined MethodGiven an input sentence x = w1...wn, we denote itsPOS tag sequence by t = t1...tn, where ti ?
T , 1 ?i ?
n, and T is the POS tag set.
A dependency treeis denoted by d = {(h,m) : 0 ?
h ?
n, 0 < m ?n}, where (h,m) represents a dependency wh ?wm whose head word (or father) is wh and modifier(or child) is wm.
w0 is an artificial root token whichis used to simplify the formalization of the problem.The pipelined method treats POS tagging and de-pendency parsing as two cascaded problems.
First,1It should be noted that it is straightforward to simultane-ously do POS tagging and constituent parsing, as POS tags canbe regarded as non-terminals in the constituent structure (Levyand Manning, 2003).
In addition, Rush et al (2010) describesan efficient and simple inference algorithm based on dual de-composition and linear programming relaxation to combine alexicalized constituent parser and a trigram POS tagger.an optimal POS tag sequence t?
is determined.t?
= arg maxtScorepos(x, t)Then, an optimal dependency tree d?
is determinedbased on x and t?.d?
= arg maxdScoresyn(x, t?,d)2.1 POS TaggingPOS tagging is a typical sequence labeling prob-lem.
Many models have been successfully appliedto sequence labeling problems, such as maximum-entropy (Ratnaparkhi, 1996), conditional randomfields (CRF) (Lafferty et al, 2001) and perceptron(Collins, 2002).
We use perceptron to build our POStagging baseline for two reasons.
Firstly, as a linearmodel, perceptron is simple, fast, and effective.
It iscompetitive to CRF in tagging accuracy but requiresmuch less training time (Shen et al, 2007).
Sec-ondly, perceptron has been successfully applied todependency parsing as well (Koo and Collins, 2010).In this paper, perceptron is used in all models includ-ing the POS tagging model, the dependency parsingmodels and the joint models.In a perceptron, the score of a tag sequence isScorepos(x, t) = wpos ?
fpos(x, t)where fpos(x, t) refers to the feature vector andwposis the corresponding weight vector.For POS tagging features, we follow the work ofZhang and Clark (2008a).
Three feature sets areconsidered: POS unigram, bigram and trigram fea-tures.
For brevity, we will refer to the three sets aswi ti, ti?1 ti and ti?2 ti?1 ti.Given wpos, we adopt the Viterbi algorithm to getthe optimal tagging sequence.2.2 Dependency ParsingRecently, graph-based dependency parsing hasgained more and more interest due to its state-of-the-art accuracy.
Graph-based dependency parsingviews the problem as finding the highest scoring treefrom a directed graph.
Based on dynamic program-ming decoding, it can efficiently find an optimal treein a huge search space.
In a graph-based model, the1181score of a dependency tree is factored into scores ofsmall parts (subtrees).Scoresyn(x, t,d) = wsyn ?
fsyn(x, t,d)=?p?dScoresyn(x, t, p)where p is a scoring part which contains one or moredependencies in the dependency tree d. Figure 1shows different types of scoring parts used in currentgraph-based models.h mdependencyh ssiblingm g hgrandparentmh stri-siblingmth sgrand-siblingmgFigure 1: Different types of scoring parts used in currentgraph-based models (Koo and Collins, 2010).Eisner (1996) proposes an O(n3) decoding al-gorithm for dependency parsing.
Based on the al-gorithm, McDonald et al (2005) propose the first-order model, in which the scoring parts only con-tains dependencies.
The second-order model of Mc-Donald and Pereira (2006) incorporates sibling partsand also needs O(n3) parsing time.
The second-order model of Carreras (2007) incorporates bothsibling and grandparent parts, and needs O(n4)parsing time.
However, the grandparent parts arerestricted to those composed of outermost grand-children.
Koo and Collins (2010) propose efficientdecoding algorithms of O(n4) for third-order mod-els.
In their paper, they implement two versionsof third-order models, Model 1 and Model 2 ac-cording to their naming.
Model 1 incorporates onlygrand-sibling parts, while Model 2 incorporates bothgrand-sibling and tri-sibling parts.
Their experi-ments on English and Czech show that Model 1 andModel 2 obtain nearly the same parsing accuracy.Therefore, we use Model 1 as our third-order modelin this paper.We use three versions of graph-based dependencyparsing models.?
The first-order model (O1): the same with Mc-Donald et al (2005).?
The second-order model (O2): the same withModel 1 in Koo and Collins (2010), but withoutusing grand-sibling features.2?
The third-order model (O3): the same withModel 1 in Koo and Collins (2010).We adopt linear models to define the score of a de-pendency tree.
For the third-order model, the scoreof a dependency tree is represented as:Scoresyn(x, t,d) =?
{(h,m)}?dwdep ?
fdep(x, t, h,m)+?
{(h,s)(h,m)}?dwsib ?
fsib(x, t, h, s,m)+?
{(g,h),(h,m)}?dwgrd ?
fgrd(x, t, g, h,m)+?
{(g,h),(h,s),(h,m)}?dwgsib ?
fgsib(x, t, g, h, s,m)For the first- and second-order models, the aboveformula is modified by deactivating extra parts.For parsing features, we follow standard prac-tice for graph-based dependency parsing (McDon-ald, 2006; Carreras, 2007; Koo and Collins, 2010).Since these features are highly related with our jointdecoding algorithms, we summarize the features asfollows.?
Dependency Features, fdep(x, t, h,m)?
Unigram Features: whth dir, wmtm dir?
Bigram Features: whth wmtm dir dist?
In Between Features: th tb tm dir dist?
Surrounding Features:th?1 th th+1 tm?1 tm tm+1 dir dist?
Sibling Features, fsib(x, t, h, s,m)wh th ws ts wm tm dir?
Grandparent Features, fgrd(x, t, g, h,m)wg tg wh th wm tm dir gdir?
Grand-sibling Features, fgsib(x, t, g, h, s,m)wg tg wh th ws ts wm tm dir gdir2This second-order model incorporates grandparent featurescomposed of all grandchildren rather than just outermost ones,and outperforms the one of Carreras (2007) according to theresults in Koo and Collins (2010).1182where b denotes an index between h and m; dirand dist are the direction and distance of (h,m);gdir is the direction of (g, h).
We also use back-off features by generalizing from very specific fea-tures over word forms, POS tags, directions and dis-tances to less sparse features over just POS tags orconsidering fewer nodes.
To avoid producing toomany sparse features, at most two word forms areused at the same time in sibling, grandparent andgrand-sibling features, while POS tags are used in-stead for other nodes; meanwhile, at most four POStags are considered at the same time for surroundingfeatures.3 Joint ModelsIn the joint method, we aim to simultaneously solvethe two problems.
(t?, d?)
= arg maxt,dScorejoint(x, t,d)Under the linear model, the score of a tagged de-pendency tree is:Scorejoint(x, t,d) = Scorepos(x, t)+ Scoresyn(x, t,d)= wpos?syn ?
fpos?syn(x, t,d)where fpos?syn(.)
means the concatenation of fpos(.
)and fsyn(.).
Under the joint model, the weights ofPOS and syntactic features, wpos?syn, are simulta-neously learned.
We expect that POS and syntacticfeatures can interact each other to determine an op-timal joint result.Similarly to the baseline dependency parsingmodels, we define the first-, second-, and third-orderjoint models according to the syntactic features con-tained in fsyn(.
).In the following, we propose two versions of jointmodels which can capture different feature sets andhave different complexity.3.1 Joint Models of Version 1The crucial problem for the joint method is to de-sign effective decoding algorithms to capture richfeatures and efficiently search out the optimal re-sults from a huge hypothesis space.
Eisner (2000)describes a preliminary idea to handle polysemy byextending parsing algorithms.
Based on this idea,we extend decoding algorithms of McDonald et al(2005) and Koo and Collins (2010), and propose twoDP based decoding algorithms for our joint modelsof version 1.
(b)(a)i r r jr+1 ji ri ji jFigure 2: The DP structures and derivations of the first-order decoding algorithm of joint models of version 1.We omit symmetric right-headed versions for brevity.Trapezoids denote incomplete spans.
Triangles denotecomplete spans.
Solid circles denote POS tags of the cor-responding indices.The decoding algorithm of O1: As shown inFigure 2, the first-order joint decoding algorithmutilizes two types of dynamic programming struc-tures.
(1) Incomplete spans consist of a dependencyand the region between the head and modifier; (2)Complete spans consist of a headword and its de-scendants on one side.
Each span is recursively cre-ated by combining two smaller and adjacent spansin a bottom-up fashion.The pseudo codes are given in Algorithm 1.I(i,j)(ti,tj) denotes an incomplete span from i to jwhose boundary POS tags are ti and tj .
C(i,j)(ti,tj)refers to a complete span from i to j whose bound-ary POS tags are ti and tj .
Conversely, I(j,i)(tj ,ti)andC(j,i)(tj ,ti) represent spans of the other direction.Note that in these notations the first argument indexalways refers to the head of the span.Line 6 corresponds to the derivation in Figure 2-(a).
Scorejoint(x, ti, tr, tr+1, tj , p = {(i, j)}) cap-tures the joint features invented by this combina-tion, where p = {(i, j)} means that the newly ob-served scoring part is the dependency (i, j).
Thesyntactic features, denoted by fsyn(x, ti, tj , i, j), canonly incorporate syntactic unigram and bigram fea-tures.
The surrounding and in between featuresare unavailable, because the context POS tags, suchas tb and ti?1, are not contained in the DP struc-1183Algorithm 1 The first-order joint decoding algorithm of version 11: ?0 ?
i ?
n, ti ?
T C(i,i)(ti,ti) = 0 ?
initialization2: for w = 1..n do ?
span width3: for i = 0..(n?
w) do ?
span start index4: j = i + w ?
span end index5: for (ti, tj) ?
T 2 do6: I(i,j)(ti,tj) = maxi?r<j max(tr,tr+1)?T 2{C(i,r)(ti,tr) + C(j,r+1)(tj ,tr+1) + Scorejoint(x, ti, tr, tr+1, tj , p = {(i, j)})}7: I(j,i)(tj ,ti) = maxi?r<j max(tr,tr+1)?T 2{C(i,r)(ti,tr) + C(j,r+1)(tj ,tr+1) + Scorejoint(x, ti, tr, tr+1, tj , p = {(j, i)})}8: C(i,j)(ti,tj) = maxi<r?j maxtr?T {I(i,r)(ti,tr) + C(r,j)(tr,tj) + Scorejoint(x, ti, tr, tj , p = ?
)}9: C(j,i)(tj ,ti) = maxi?r<j maxtr?T {C(r,i)(tr,ti) + I(j,r)(tj ,tr) + Scorejoint(x, ti, tr, tj , p = ?
)}10: end for11: end for12: end fortures.
Therefore, we adopt pseudo surroundingand in between features by simply fixing the con-text POS tags as the single most likely ones (Mc-Donald, 2006).
Taking the in between featuresas an example, we use ti t?b tj dir dist instead,where t?b is the 1-best tag determined by the base-line POS tagger.
The POS features, denoted byfpos(x, ti, tr, tr+1, tj), can only incorporate all POSunigram and bigram features.3 Similarly, we usepseudo POS trigram features such as t?r?1 tr tr+1.Line 8 corresponds to the derivation in Figure 2-(b).
Since this combination invents no scoring part(p = ?
), Scorejoint(x, ti, tr, tj , p = ?)
is only com-posed of POS features.4Line 7 and Line 9 create spans in the opposite di-rection, which can be analogously illustrated.
Thespace and time complexity of the algorithm are re-spectively O(n2q2) and O(n3q4), where q = |T |.5The decoding algorithm of O2 & O3: Figure3 illustrates the second- and third-order decodingalgorithm of joint models of version 1.
A newkind of span, named the sibling span, is used tocapture sibling structures.
Furthermore, each spanis augmented with a grandparent-index to captureboth grandparent and grand-sibling structures.
It isstraightforward to derive the pseudo codes of the al-3?
wr tr if i ?= r; ?
wr+1 tr+1 if r + 1 ?= j; ?
tr tr+1if r ?= i or r + 1 ?= j; ?
ti tr if r ?
1 = i; ?
tr+1 tj ifr + 2 = j.
Note that wi ti, wj tj and ti tj (if i = j ?
1) arenot incorporated here to avoid double counting.4?
wr tr if r ?= j;?
ti tr if i = r?1;?
tr tj if r+1 = j.Pseudo trigram features can be added accordingly.5We can reduce the time complexity to O(n3q3) by strictlyadopting the DP structures in the parsing algorithm of Eisner(1996).
However, that may make the algorithm harder to com-prehend.ig j g i i ji+1(a)g i j g i k i k j(b)i k j i ik jr+1r(c)g i j g i r i r j(d)Figure 3: The DP structures and derivations of thesecond- and third-order joint decoding algorithm of ver-sion 1.
For brevity, we elide the right-headed and right-grandparented versions.
Rectangles represent siblingspans.i j i r r ji j i r r+1 j(b)(a)Figure 4: The DP structures and derivations of the first-order joint decoding algorithm of version 2.
We omit theright-headed version for brevity.1184gorithm from Figure 3.
We omit them due to spacelimitation.
Pseudo surrounding, in between and POStrigram features are used due to the same reason asabove.
The space and time complexity of the algo-rithm are respectively O(n3q3) and O(n4q5).3.2 Joint Models of Version 2To further incorporate genuine syntactic surround-ing and POS trigram features in the DP structures,we extend the algorithms of joint models of version1, and propose our joint models of version 2.The decoding algorithm of O1: Figure 4 illus-trates the first-order joint decoding algorithm of ver-sion 2.
Compared with the structures in Figure 2,each span is augmented with the POS tags surround-ing the boundary indices.
These context POS tagsenable Scorejoint(.)
in line 6-9 of Algorithm 1 tocapture the syntactic surrounding and POS trigramfeatures, but also require enumeration of POS tagsover more indices.
For brevity, we skip the pseudocodes which can be easily derived from Algorithm1.
The space and time complexity of the algorithmare respectively O(n2q6) and O(n3q10).The decoding algorithm of O2 & O3: Using thesame idea as above, the second- and third-order jointdecoding algorithms of version 2 can be derivedbased on Figure 3.
Again, we omit both its DP struc-tures and pseudo codes for the sake of brevity.
Itsspace and time complexity are respectively O(n3q7)and O(n4q11).In between features, which should be regarded asnon-local features in the joint situation, still cannotbe incorporated in our joint models of version 2.Again, we adopt the pseudo version.3.3 ComparisonBased on the above illustration, we can see that jointmodels of version 1 are more efficient with regardto the number of POS tags for each word, but fail toincorporate syntactic surrounding features and POStrigram features in the DP structures.
On the con-trary, joint models of version 2 can incorporate bothaforementioned feature sets, but have higher com-plexity.
These two versions of models will be thor-oughly compared in the experiments.4 Pruning TechniquesIn this section, we introduce two pruning strategiesto constrain the search space of our models due totheir high complexity.4.1 POS Tag PruningThe time complexity of the joint decoding algorithmis unbearably high with regard to the number of can-didate POS tags for each word (q = |T |).
Wefind that it would be extremely time-consuming evenwhen we only use two most likely POS tags for eachword (q = 2) even for joint models of version 1.To deal with this problem, we propose a pruningmethod that can effectively reduce the POS tag spacebased on a probabilistic tagging model.We adopt a conditional log-linear model (Laffertyet al, 2001), which defines a conditional distributionof a POS tag sequence t given x:P (t|x) = ewpos?fpos(x,t)?t ewpos?fpos(x,t)We use the same feature set fpos defined in Sec-tion 2.1, and adopt the exponentiated gradient algo-rithm to learn the weight vector wpos (Collins et al,2008).The marginal probability of tagging a word wi ast isP (ti = t|x) =?t:t[i]?tP (t|x)which can be efficiently computed using theforward-backward algorithm.We define pmaxi(x) to be the highest marginalprobability of tagging the word wi:pmaxi(x) = maxt?T P (ti = t|x)We then define the allowable candidate POS tagsof the word wi to beTi(x) = {t : t ?
T , P (ti = t|x) ?
?t?pmaxi(x)}where ?t is the pruning threshold.
Ti(x) is used toconstrain the POS search space by replacing T inAlgorithm 1.11854.2 Dependency PruningThe parsing time grows quickly for the second- andthird-order models (both baseline and joint) whenthe input sentence gets longer (O(n4)).
Follow-ing Koo and Collins (2010), we eliminate unlikelydependencies using a form of coarse-to-fine prun-ing (Charniak and Johnson, 2005; Petrov and Klein,2007).
On the development set, 68.87% of the de-pendencies are pruned, while the oracle dependencyaccuracy is 99.77%.
We use 10-fold cross validationto do pruning on the training set.5 ExperimentsWe use the Penn Chinese Treebank 5.1 (CTB5) (Xueet al, 2005).
Following the setup of Duan et al(2007), Zhang and Clark (2008b) and Huang andSagae (2010), we split CTB5 into training (secs 001-815 and 1001-1136), development (secs 886-931and 1148-1151), and test (secs 816-885 and 1137-1147) sets.
We use the head-finding rules of Zhangand Clark (2008b) to turn the bracketed sentencesinto dependency structures.We use the standard tagging accuracy to evalu-ate POS tagging.
For dependency parsing, we useword accuracy (also known as dependency accu-racy), root accuracy and complete match rate (allexcluding punctuation) .For the averaged training, we train each model for15 iterations and select the parameters that performbest on the development set.5.1 Results of POS Tag PruningFigure 5 shows the distribution of words with dif-ferent number of candidate POS tags and the k-bestoracle tagging accuracy under different ?t.
To avoiddealing with words that have many candidate POStags, we further apply a hard criterion that the decod-ing algorithms only consider top k candidate POStags.To find the best ?t, we train and evaluate thesecond-order joint model of version 1 on the train-ing and development sets pruned with different ?t(top k = 5).
We adopt the second-order joint modelof version 1 because of its efficiency compared withthe third-order models and its capability of captur-ing rich features compared with the first-order mod-els.
The results are shown in Table 1.
The model01020304050607080901001 2 3 4 5 >5proportionofwords (%)number of candidate POS tags0.10.010.001939495969798991001 2 3 4 5 ?k-bestoracletaggingaccuracy (%)k0.10.010.001Figure 5: Results of POS tag pruning with different prun-ing threshold ?t on the development set.
?t word root compl.
acc.
speed0.1 81.53 76.88 30.00 94.17 2.50.01 81.83 76.62 30.62 93.16 1.20.001 81.73 77.38 30.50 93.41 0.5Table 1: Performance of the second-order joint model ofversion 1 with different pruning threshold ?t (top k = 5)on the development set.
?Acc.?
means the tagging accu-racy.
?Speed?
refers to the parsing speed (the number ofsentences processed per second).with ?t = 0.1 obtains the highest tagging accuracy,which is much higher than that of both ?t = 0.01and ?t = 0.001.
However, its parsing accuracyis inferior to the other two.
?t = 0.01 producesslightly better parsing accuracy than ?t = 0.001,and is twice faster.
Finally, we choose ?t = 0.01due to the efficiency factor and our priority over theparsing accuracy.Then we do experiments to find an optimal topk.
Table 2 shows the results.
We decide to choosek = 3 since it leads to best parsing accuracy.From Table 1 and 2, we can have an interestingfinding: it seems that the harder we filter the POStag space, the higher tagging accuracy we get.
Inother words, giving the joint model less flexibilityof choosing POS tags leads to better tagging per-formance.Due to time limitation, we do not tune ?t and k forother joint models.
Instead, we simply adopt ?t =0.01 and top k = 3.5.2 Final ResultsTable 3 shows the final results on the test set.
We lista few state-of-the-art results in the bottom.
Duan07refers to the results of Duan et al (2007).
Theyenhance the transition-based parsing model with1186Syntactic Metrics Tagging Accuracy Parsing Speedword root compl.
all-word known unknown Sent/SecJoint Models V2O3 80.79 75.84 29.11 92.80 93.88 76.80 0.3O2 80.49 75.49 28.24 92.68 93.77 76.27 0.6O1 77.37 68.64 23.09 92.96 94.05 76.64 2.0Joint Models V1O3 80.69 75.90 29.06 92.89 93.96 76.80 0.5O2 80.74 75.80 28.24 93.08 94.11 77.53 1.7O1 77.38 69.69 22.62 93.20 94.23 77.76 8.5Auto POSO3 79.29 74.65 27.2493.51 94.36 80.782.0O2 79.03 74.70 27.19 5.8O1 75.68 68.06 21.10 17.4MSTParser2 77.95 72.04 25.50 4.1MSTParser1 75.84 68.55 21.36 5.2MaltParser 75.24 65.92 23.19 2.6Gold POSO3 86.00 77.59 34.02100.0 100.0 100.0-O2 86.18 78.58 34.07 -O1 82.24 70.10 26.02 -MSTParser2 85.24 77.41 33.19 -MSTParser1 83.04 71.49 27.59 -MaltParser 82.62 69.34 29.06 -H&S10 85.20 78.32 33.72 -Z&C08 single 84.33 76.73 32.79 -Z&C08 hybrid 85.77 76.26 34.41 -Duan07 83.88 73.70 32.70 -Table 3: Final results on the test set.
?Gold POS?
means that gold POS tags are used as input by the pipelined parsingmodels; while ?Auto POS?
means that the POS tags are generated by the baseline POS tagging model.top k word root compl.
acc.
speed2 81.46 76.12 30.50 93.51 2.73 82.11 76.75 29.75 93.31 1.74 81.75 76.62 30.38 93.25 1.45 81.83 76.62 30.62 93.16 1.2Table 2: Performance of the second-order joint model ofversion 1 with different top k (?t = 0.01) on the devel-opment set.the beam search.
H&S10 refers to the results ofHuang and Sagae (2010).
They greatly expand thesearch space of the transition-based model by merg-ing equivalent states with dynamic programming.Z&C08 refers to the results of Zhang and Clark(2008b).
They use a hybrid model to combine theadvantages of both graph-based and transition-basedmodels.
We also do experiments with two publiclyavailable and widely-used parsers, MSTParser6 andMaltParser7.
MSTParser1 refers to the first-order6http://sourceforge.net/projects/mstparser/7http://maltparser.org/graph-based model of McDonald et al (2005), whileMSTParser2 is the second-order model of McDon-ald and Pereira (2006).
MaltParser is a transition-based parsing system.
It integrates a number of clas-sification algorithms and transition strategies.
Weadopt the support vector machine classifier and thearc-standard strategy (Nivre, 2008).We can see that when using gold tags, ourpipelined second- and third-order parsing modelsachieve best parsing accuracy, which is even higherthan the hybrid model of Zhang and Clark (2008b).It is a little surprising that the second-order modelslightly outperforms the third-order one.
This maybe possible, since Koo and Collins (2010) shows thatthe third-order model outperforms the second-orderone by only 0.32% on English and 0.07% on Czech.In addition, we only use basic third-order features.Both joint models of version 1 and 2 can consis-tently and significantly improve the parsing accu-racy by about 1.5% for all first-, second- and third-order cases.
Accidentally, the parsing accuracy ofthe second-order joint model of version 2 is lower1187error pattern # ?
error pattern # ?DEC ?
DEG 237 114 NR ?
NN 184 100NN ?
VV 389 73 NN ?
NR 106 91DEG ?
DEC 170 39 NN ?
JJ 95 70VV ?
NN 453 27 VA ?
VV 29 41P ?
VV 52 24 JJ ?
NN 126 29P ?
CC 39 13 VV ?
VA 67 10Table 4: Error analysis of POS tagging.
# means theerror number of the corresponding pattern made by thebaseline tagging model.
?
and ?
mean the error numberreduced or increased by the joint model.than that of its counterparts by about 0.3%.
Moreexperiments and further analysis may be needed tofind out the reason.
The two versions of joint modelsperforms nearly the same, which indicates that usingpseudo surrounding and POS trigram features maybe sufficient for the joint method on this data set.In summary, we can conclude that the joint frame-work is certainly helpful for dependency parsing.It is clearly shown in Table 3 that the jointmethod surprisingly hurts the tagging accuracy,which diverges from our discussion in Section 1.Some insights into this issue will be given in Sec-tion 5.3.
Moreover, it seems that the more syntac-tic features the joint method incorporates (fromO1 to O3), the more the tagging accuracy drops.We suspect that this is because the joint models aredominated by the syntactic features.
Take the first-order joint model as an example.
The dimension ofthe syntactic features fsyn is about 3.5 million, whilethat of fpos is only about 0.5 million.
The gap be-comes much larger for the second- and third-ordercases.Comparing the parsing speed, we can find that thepruning of POS tags is very effective.
The second-order joint model of version 1 can parse 1.7 sen-tences per second, while the pipelined second-orderparsing model can parse 5.8 sentences per second,which is rather close considering that there is a fac-tor of q5.5.3 Error AnalysisTo find out the impact of our joint models on theindividual tasks, we conduct detailed error analy-sis through comparing the results of the pipelinedsecond-order parsing model and the second-orderjoint model of version 1.Impact on POS tagging: Table 4 shows how thejoint model changes the quantity of POS tagging er-ror patterns compared with the pipelined model.
Anerror pattern ?X ?
Y?
means that the focus word,whose true tag is ?X?, is assigned a tag ?Y?.
Wechoose these patterns with largest reduction or in-crease in the error number, and rank them in de-scending order of the variation.From the left part of Table 4, we can see thatthe joint method is clearly better at resolving tag-ging ambiguities like {VV, NN} and {DEG, DEC}.8One common characteristic of these ambiguouspairs is that the local or even whole syntactic struc-ture will be destructed if the wrong tag is chosen.
Inother words, resolving these ambiguities is criticaland helpful from the parsing viewpoint.
From an-other perspective, the joint model is capable of pre-ferring the right tag with the help of syntactic struc-tures, which is impossible for the baseline sequentiallabeling model.In contrast, pairs like {NN, NR}, {VV, VA} and{NN, JJ} only slightly influence the syntactic struc-ture when mis-tagged.
The joint method performsworse on these ambiguous pairs, as shown in theright part of Table 4.Impact on parsing: Table 5 studies the change ofparsing error rates between the pipelined and jointmodel on different POS tag patterns.
We present themost typical and prominent patterns in the table, andrank them in descending order of X?s frequency ofoccurrence.
We also show the change of proportionof different patterns, which is consistent with the re-sults in Table 4.From the table, we can see the joint model canachieve a large error reduction (0.8?4.0%) for allthe patterns ?X ?
X?.
In other words, the jointmodel can do better given the correct tags thanthe pipelined method.For all the patterns marked by ?, except for theambiguous pair {NN, JJ} (which we find is difficultto explain even after careful result analysis), the jointmodel also reduces the error rates (2.2?15.4%).
As8DEG and DEC are the two POS tags for the frequently usedauxiliary word ???
(de?, of) in Chinese.
The associative ??
?is tagged as DEG, such as ??
?/father ?
?
?/eyes (eyes ofthe father)?
; while the one in a relative clause is tagged as DEC,such as ?
?/he ?
?/made ?
?
?/progress (progress that hemade)?.1188pattern pipelined jointprop (%) error (%) prop (%) error (%)NN ?
NN 94.6 16.8 -1.1 -1.8?
VV ?
2.9 55.5 -0.5 +15.1?
NR ?
0.8 24.5 +0.7 -2.2?
JJ ?
0.7 17.9 +0.5 +2.1VV ?
VV 89.6 34.2 -0.3 ?4.0?
NN ?
6.6 66.4 -0.4 +0.7?
VA ?
1.0 38.8 +0.1 -15.4NR ?
NR 91.7 15.4 -3.7 -0.8?
NN ?
5.9 21.7 +3.2 -3.7P ?
P 92.8 22.6 +3.4 -3.2?
VV ?
3.0 50.0 -1.4 +10.7?
CC ?
2.3 74.4 -0.7 +21.9JJ ?
JJ 80.5 11.2 -2.8 -2.0?
NN ?
9.8 18.3 +2.2 +1.8DEG ?
DEG 86.5 11.1 +2.8 -3.6?
DEC ?
13.5 61.8 -3.1 +37.4DEC ?
DEC 79.7 17.2 +12.1 -4.0?
DEG ?
20.2 56.5 -9.7 +40.2Table 5: Comparison of parsing error rates on differentPOS tag patterns between the pipelined and joint models.Given a pattern ?X ?
Y?, ?prop?
means its proportion inall occurrence of ?X?
(Count(X?Y )Count(X) ), and ?error?
refersto its parsing error rate ( Count(wrongly headed X?Y )Count(X?Y ) ).The last two columns give the absolute reduction (-) orincrease (+) in proportion and error rate made by the jointmodel.
?
marks the patterns appearing in the left part ofTable 4, while ?
marks those in the right part of Table 4.discussed earlier, these patterns concern ambiguoustag pairs which usually play similar roles in syn-tactic structures.
This demonstrates that the jointmodel can do better on certain tagging error pat-terns.For patterns marked by ?, the error rate of thejoint model usually increases by large margin.
How-ever, the proportion of these patterns is substantiallydecreased, since the joint model can better resolvethese ambiguities with the help of syntactic knowl-edge.In summary, we can conclude that the joint modelis able to choose such POS tags that are more helpfuland discriminative from parsing viewpoint.
This isthe fundamental reason of the parsing performanceimprovement.6 Related WorkTheoretically, Eisner (2000) proposes a preliminaryidea of extending the decoding algorithm for de-pendency parsing to handle polysemy.
Here, wordsenses can be understood as POS-tagged words.Koo and Collins (2010) also briefly discuss that theirthird-order decoding algorithm can be modified tohandle word senses using the idea of Eisner (2000).In his PhD thesis, McDonald (2006) extends hissecond-order model with the idea of Eisner (2000)to study the impact of POS tagging errors on pars-ing accuracy.
To make inference tractable, he usestop 2 candidate POS tags for each word based ona maximum entropy tagger, and adopts the singlemost likely POS tags for the surrounding and in be-tween features.
He conducts primitive experimentson English Penn Treebank, and shows that parsingaccuracy can be improved from 91.5% to 91.9%.However, he finds that the model is unbearably time-consuming.7 ConclusionsIn this paper, we have systematically investigatedthe issue of joint POS tagging and dependency pars-ing.
We propose and compare several joint modelsand their corresponding decoding algorithms whichcan incorporate different feature sets.
We also pro-pose an effective POS tag pruning method which cangreatly improve the decoding efficiency.
The experi-mental results show that our joint models can signif-icantly improve the state-of-the-art parsing accuracyby more than 1.5%.
Detailed error analysis showsthat the fundamental reason for the parsing accu-racy improvement is that the joint method is able tochoose POS tags that are helpful and discriminativefrom parsing viewpoint.AcknowledgmentsWe thank the anonymous reviewers for their helpfulcomments.
This work was supported by NationalNatural Science Foundation of China (NSFC) viagrant 60803093, 60975055, the Natural ScientificResearch Innovation Foundation in Harbin Instituteof Technology (HIT.NSRIF.2009069) and the Fun-damental Research Funds for the Central Universi-ties (HIT.KLOF.2010064).ReferencesXavier Carreras.
2007.
Experiments with a higher-order projective dependency parser.
In Proceedings of1189EMNLP/CoNLL, pages 141?150.Eugene Charniak and Mark Johnson.
2005.
Coarse-to-fine n-best parsing and maxent discriminative rerank-ing.
In Proceedings of ACL-05, pages 173?180.Wanxiang Che and Ting Liu.
2010.
Jointly modelingwsd and srl with markov logic.
In Proceedings of the23rd International Conference on Computational Lin-guistics (Coling 2010), pages 161?169.Shay B. Cohen and Noah A. Smith.
2007.
Joint morpho-logical and syntactic disambiguation.
In Proceedingsof EMNLP-CoNLL 2007, pages 208?217.Michael Collins, Amir Globerson, Terry Koo, XavierCarreras, and Peter Bartlett.
2008.
Exponentiatedgradient algorithms for conditional random fields andmax-margin markov networks.
JMLR, 9:1775?1822.Michael Collins.
2002.
Discriminative training meth-ods for hidden markov models: Theory and experi-ments with perceptron algorithms.
In Proceedings ofEMNLP 2002.Xiangyu Duan, Jun Zhao, , and Bo Xu.
2007.
Proba-bilistic models for action-based Chinese dependencyparsing.
In Proceedings of ECML/ECPPKDD.Chris Dyer.
2009.
Using a maximum entropy modelto build segmentation lattices for mt.
In Proceedingsof Human Language Technologies: The 2009 AnnualConference of the North American Chapter of the As-sociation for Computational Linguistics, pages 406?414.Jason Eisner.
1996.
Three new probabilistic models fordependency parsing: An exploration.
In Proceedingsof COLING 1996, pages 340?345.Jason Eisner.
2000.
Bilexical grammars and their cubic-time parsing algorithms.
In Advances in Probabilisticand Other Parsing Technologies, pages 29?62.Jenny Rose Finkel and Christopher D. Manning.
2009.Joint parsing and named entity recognition.
In Pro-ceedings of Human Language Technologies: The 2009Annual Conference of the North American Chapter ofthe Association for Computational Linguistics, pages326?334.Yoav Goldberg and Reut Tsarfaty.
2008.
A single gener-ative model for joint morphological segmentation andsyntactic parsing.
In Proceedings of ACL-08: HLT,pages 371?379, Columbus, Ohio, June.
Associationfor Computational Linguistics.Jan Hajic?, Massimiliano Ciaramita, Richard Johans-son, Daisuke Kawahara, Maria Anto`nia Mart?
?, Llu?
?sMa`rquez, Adam Meyers, Joakim Nivre, SebastianPado?, Jan S?te?pa?nek, Pavel Stran?a?k, Mihai Surdeanu,Nianwen Xue, and Yi Zhang.
2009.
The CoNLL-2009 shared task: Syntactic and semantic dependen-cies in multiple languages.
In Proceedings of CoNLL2009.Liang Huang and Kenji Sagae.
2010.
Dynamic pro-gramming for linear-time incremental parsing.
In Pro-ceedings of the 48th Annual Meeting of the Associa-tion for Computational Linguistics, pages 1077?1086,Uppsala, Sweden, July.
Association for ComputationalLinguistics.Wenbin Jiang, Liang Huang, Qun Liu, and Yajuan Lu?.2008.
A cascaded linear model for joint chinese wordsegmentation and part-of-speech tagging.
In Proceed-ings of ACL-08: HLT, pages 897?904.Terry Koo and Michael Collins.
2010.
Efficient third-order dependency parsers.
In Proceedings of the 48thAnnual Meeting of the Association for ComputationalLinguistics, pages 1?11, Uppsala, Sweden, July.
Asso-ciation for Computational Linguistics.Canasai Kruengkrai, Kiyotaka Uchimoto, Jun?ichiKazama, Yiou Wang, Kentaro Torisawa, and HitoshiIsahara.
2009.
An error-driven word-character hy-brid model for joint chinese word segmentation andpos tagging.
In Proceedings of the Joint Conferenceof the 47th Annual Meeting of the ACL and the 4thInternational Joint Conference on Natural LanguageProcessing of the AFNLP, pages 513?521.John Lafferty, Andrew McCallum, and Fernando Pereira.2001.
Conditional random fields: Probabilistic mod-els for segmenting and labeling sequence data.
In Pro-ceedings of ICML 2001, pages 282?289.Roger Levy and Christopher D. Manning.
2003.
Is itharder to parse chinese, or the chinese treebank?
InProceedings of the 41st Annual Meeting of the Associ-ation for Computational Linguistics, pages 439?446,Sapporo, Japan, July.
Association for ComputationalLinguistics.Junhui Li, Guodong Zhou, and Hwee Tou Ng.
2010.Joint syntactic and semantic parsing of chinese.
InProceedings of the 48th Annual Meeting of the As-sociation for Computational Linguistics, pages 1108?1117.Yang Liu and Qun Liu.
2010.
Joint parsing and trans-lation.
In Proceedings of the 23rd International Con-ference on Computational Linguistics (Coling 2010),pages 707?715.Ryan McDonald and Fernando Pereira.
2006.
On-line learning of approximate dependency parsing al-gorithms.
In Proceedings of EACL 2006.Ryan McDonald, Koby Crammer, and Fernando Pereira.2005.
Online large-margin training of dependencyparsers.
In Proceedings of ACL 2005, pages 91?98.Ryan McDonald.
2006.
Discriminative Training andSpanning Tree Algorithms for Dependency Parsing.Ph.D.
thesis, University of Pennsylvania.Joakim Nivre.
2008.
Algorithms for deterministic in-cremental dependency parsing.
In Computational Lin-guistics, volume 34, pages 513?553.1190Slav Petrov and Dan Klein.
2007.
Improved inferencefor unlexicalized parsing.
In Proceedings of NAACL2007.Adwait Ratnaparkhi.
1996.
A maximum entropy modelfor part-of-speech tagging.
In Proceedings of EMNLP1996.Alexander M Rush, David Sontag, Michael Collins, andTommi Jaakkola.
2010.
On dual decomposition andlinear programming relaxations for natural languageprocessing.
In Proceedings of the 2010 Conference onEmpirical Methods in Natural Language Processing,pages 1?11.Libin Shen, Giorgio Satta, and Aravind Joshi.
2007.Guided learning for bidirectional sequence classifica-tion.
In Proceedings of the 45th Annual Meeting ofthe Association of Computational Linguistics, pages760?767, Prague, Czech Republic, June.
Associationfor Computational Linguistics.Mihai Surdeanu, Richard Johansson, Adam Meyers,Llu?
?s Ma`rquez, and Joakim Nivre.
2008.
The CoNLL-2008 shared task on joint parsing of syntactic and se-mantic dependencies.
In CoNLL-2008.Kristina Toutanova and Colin Cherry.
2009.
A globalmodel for joint lemmatization and part-of-speech pre-diction.
In Proceedings of the Joint Conference of the47th Annual Meeting of the ACL and the 4th Interna-tional Joint Conference on Natural Language Process-ing of the AFNLP, pages 486?494.Xinyan Xiao, Yang Liu, YoungSook Hwang, Qun Liu,and Shouxun Lin.
2010.
Joint tokenization and trans-lation.
In Proceedings of the 23rd International Con-ference on Computational Linguistics (Coling 2010),pages 1200?1208.Nianwen Xue, Fei Xia, Fu-Dong Chiou, and MarthaPalmer.
2005.
The Penn Chinese Treebank: Phrasestructure annotation of a large corpus.
In Natural Lan-guage Engineering, volume 11, pages 207?238.Yue Zhang and Stephen Clark.
2008a.
Joint word seg-mentation and POS tagging using a single perceptron.In Proceedings of ACL-08: HLT, pages 888?896.Yue Zhang and Stephen Clark.
2008b.
A tale of twoparsers: Investigating and combining graph-based andtransition-based dependency parsing.
In Proceedingsof the 2008 Conference on Empirical Methods in Nat-ural Language Processing, pages 562?571, Honolulu,Hawaii, October.
Association for Computational Lin-guistics.1191
