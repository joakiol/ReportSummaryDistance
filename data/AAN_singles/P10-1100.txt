Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 979?988,Uppsala, Sweden, 11-16 July 2010. c?2010 Association for Computational LinguisticsLearning Script Knowledge with Web ExperimentsMichaela Regneri Alexander KollerDepartment of Computational Linguistics and Cluster of ExcellenceSaarland University, Saarbru?cken{regneri|koller|pinkal}@coli.uni-saarland.deManfred PinkalAbstractWe describe a novel approach to unsuper-vised learning of the events that make upa script, along with constraints on theirtemporal ordering.
We collect natural-language descriptions of script-specificevent sequences from volunteers over theInternet.
Then we compute a graph rep-resentation of the script?s temporal struc-ture using a multiple sequence alignmentalgorithm.
The evaluation of our systemshows that we outperform two informedbaselines.1 IntroductionA script is ?a standardized sequence of events thatdescribes some stereotypical human activity suchas going to a restaurant or visiting a doctor?
(Barrand Feigenbaum, 1981).
Scripts are fundamentalpieces of commonsense knowledge that are sharedbetween the different members of the same cul-ture, and thus a speaker assumes them to be tac-itly understood by a hearer when a scenario re-lated to a script is evoked: When one person says?I?m going shopping?, it is an acceptable replyto say ?did you bring enough money?
?, becausethe SHOPPING script involves a ?payment?
event,which again involves the transfer of money.It has long been recognized that text under-standing systems would benefit from the implicitinformation represented by a script (Cullingford,1977; Mueller, 2004; Miikkulainen, 1995).
Thereare many other potential applications, includ-ing automated storytelling (Swanson and Gordon,2008), anaphora resolution (McTear, 1987), andinformation extraction (Rau et al, 1989).However, it is also commonly accepted that thelarge-scale manual formalization of scripts is in-feasible.
While there have been a few attempts atdoing this (Mueller, 1998; Gordon, 2001), effortsin which expert annotators create script knowledgebases clearly don?t scale.
The same holds true ofthe script-like structures called ?scenario frames?in FrameNet (Baker et al, 1998).There has recently been a surge of interest inautomatically learning script-like knowledge re-sources from corpora (Chambers and Jurafsky,2008b; Manshadi et al, 2008); but while theseefforts have achieved impressive results, they arelimited by the very fact that a lot of scripts ?
suchas SHOPPING ?
are shared implicit knowledge, andtheir events are therefore rarely elaborated in text.In this paper, we propose a different approachto the unsupervised learning of script-like knowl-edge.
We focus on the temporal event structure ofscripts; that is, we aim to learn what phrases candescribe the same event in a script, and what con-straints must hold on the temporal order in whichthese events occur.
We approach this problem byasking non-experts to describe typical event se-quences in a given scenario over the Internet.
Thisallows us to assemble large and varied collectionsof event sequence descriptions (ESDs), which arefocused on a single scenario.
We then compute atemporal script graph for the scenario by identify-ing corresponding event descriptions using a Mul-tiple Sequence Alignment algorithm from bioin-formatics, and converting the alignment into agraph.
This graph makes statements about whatphrases can describe the same event of a scenario,and in what order these events can take place.
Cru-cially, our algorithm exploits the sequential struc-ture of the ESDs to distinguish event descriptionsthat occur at different points in the script storyline,even when they are semantically similar.
We eval-uate our script graph algorithm on ten unseen sce-narios, and show that it significantly outperformsa clustering-based baseline.The paper is structured as follows.
We willfirst position our research in the landscape of re-lated work in Section 2.
We will then define how979we understand scripts, and what aspect of scriptswe model here, in Section 3.
Section 4 describesour data collection method, and Section 5 explainshow we use Multiple Sequence Alignment to com-pute a temporal script graph.
We evaluate our sys-tem in Section 6 and conclude in Section 7.2 Related WorkApproaches to learning script-like knowledge arenot new.
For instance, Mooney (1990) describesan early attempt to acquire causal chains, andSmith and Arnold (2009) use a graph-based algo-rithm to learn temporal script structures.
However,to our knowledge, such approaches have neverbeen shown to generalize sufficiently for widecoverage application, and none of them was rig-orously evaluated.More recently, there have been a number of ap-proaches to automatically learning event chainsfrom corpora (Chambers and Jurafsky, 2008b;Chambers and Jurafsky, 2009; Manshadi et al,2008).
These systems typically employ a methodfor classifying temporal relations between givenevent descriptions (Chambers et al, 2007; Cham-bers and Jurafsky, 2008a; Mani et al, 2006).They achieve impressive performance at extract-ing high-level descriptions of procedures such asa CRIMINAL PROCESS.
Because our approach in-volves directly asking people for event sequencedescriptions, it can focus on acquiring specificscripts from arbitrary domains, and we can con-trol the level of granularity at which scripts aredescribed.
Furthermore, we believe that muchinformation about scripts is usually left implicitin texts and is therefore easier to learn from ourmore explicit data.
Finally, our system automat-ically learns different phrases which describe thesame event together with the temporal orderingconstraints.Jones and Thompson (2003) describe an ap-proach to identifying different natural language re-alizations for the same event considering the tem-poral structure of a scenario.
However, they don?taim to acquire or represent the temporal structureof the whole script in the end.In its ability to learn paraphrases using Mul-tiple Sequence Alignment, our system is relatedto Barzilay and Lee (2003).
Unlike Barzilay andLee, we do not tackle the general paraphrase prob-lem, but only consider whether two phrases de-scribe the same event in the context of the samescript.
Furthermore, the atomic units of our align-ment process are entire phrases, while in Barzilayand Lee?s setting, the atomic units are words.Finally, it is worth pointing out that our workis placed in the growing landscape of researchthat attempts to learn linguistic information out ofdata directly collected from users over the Inter-net.
Some examples are the general acquisition ofcommonsense knowledge (Singh et al, 2002), theuse of browser games for that purpose (von Ahnand Dabbish, 2008), and the collaborative anno-tation of anaphoric reference (Chamberlain et al,2009).
In particular, the use of the Amazon Me-chanical Turk, which we use here, has been evalu-ated and shown to be useful for language process-ing tasks (Snow et al, 2008).3 ScriptsBefore we delve into the technical details, let usestablish some terminology.
In this paper, we dis-tinguish scenarios, as classes of human activities,from scripts, which are stereotypical models of theinternal structure of these activities.
Where EAT-ING IN A RESTAURANT is a scenario, the scriptdescribes a number of events, such as ordering andleaving, that must occur in a certain order in orderto constitute an EATING IN A RESTAURANT activ-ity.
The classical perspective on scripts (Schankand Abelson, 1977) has been that next to defin-ing some events with temporal constraints, a scriptalso defines their participants and their causal con-nections.Here we focus on the narrower task of learningthe events that a script consists of, and of model-ing and learning the temporal ordering constraintsthat hold between them.
Formally, we will spec-ify a script (in this simplified sense) in terms of adirected graph Gs = (Es, Ts), where Es is a setof nodes representing the events of a scenario s,and Ts is a set of edges (ei, ek) indicating that theevent ei typically happens before ek in s. We callGs the temporal script graph (TSG) for s.Each event in a TSG can usually be expressedwith many different natural-language phrases.
Asthe TSG in Fig.
3 illustrates, the first event in thescript for EATING IN A FAST FOOD RESTAURANTcan be equivalently described as ?walk to thecounter?
or ?walk up to the counter?
; even phraseslike ?walk into restaurant?, which would not usu-ally be taken as paraphrases of these, can be ac-cepted as describing the same event in the context9801.
walk into restaurant2.
find the end of the line3.
stand in line4.
look at menu board5.
decide on food and drink6.
tell cashier your order7.
listen to cashier repeat order8.
listen for total price9.
swipe credit card in scanner10.
put up credit card11.
take receipt12.
look at order number13.
take your cup14.
stand off to the side15.
wait for number to be called16.
get your drink1.
look at menu2.
decide what you want3.
order at counter4.
pay at counter5.
receive food at counter6.
take food to table7.
eat food1.
walk to the counter2.
place an order3.
pay the bill4.
wait for the ordered food5.
get the food6.
move to a table7.
eat food8.
exit the placeFigure 1: Three event sequence descriptionsof this scenario.
We call a natural-language real-ization of an individual event in the script an eventdescription, and we call a sequence of event de-scriptions that form one particular instance of thescript an event sequence description (ESD).
Ex-amples of ESDs for the FAST FOOD RESTAURANTscript are shown in Fig.
1.One way to look at a TSG is thus that its nodesare equivalence classes of different phrases thatdescribe the same event; another is that valid ESDscan be generated from a TSG by randomly select-ing phrases from some nodes and arranging themin an order that respects the temporal precedenceconstraints in Ts.
Our goal in this paper is to takea set of ESDs for a given scenario as our inputand then compute a TSG that clusters different de-scriptions of the same event into the same node,and contains edges that generalize the temporal in-formation encoded in the ESDs.4 Data AcquisitionIn order to automatically learn TSGs, we selected22 scenarios for which we collect ESDs.
We de-liberately included scenarios of varying complex-ity, including some that we considered hard todescribe (CHILDHOOD, CREATE A HOMEPAGE),scenarios with highly variable orderings betweenevents (MAKING SCRAMBLED EGGS), and sce-narios for which we expected cultural differences(WEDDING).We used the Amazon Mechanical Turk1 to col-lect the data.
For every scenario, we asked 25 peo-ple to enter a typical sequence of events in this sce-nario, in temporal order and in ?bullet point style?.1http://www.mturk.com/We required the annotators to enter at least 5 andat most 16 events.
Participants were allowed toskip a scenario if they felt unable to enter eventsfor it, but had to indicate why.
We did not restrictthe participants (e.g.
to native speakers).In this way, we collected 493 ESDs for the 22scenarios.
People used the possibility to skip aform 57 times.
The most frequent explanation forthis was that they didn?t know how a certain sce-nario works: The scenario with the highest pro-portion of skipped forms was CREATE A HOME-PAGE, whereas MAKING SCRAMBLED EGGS wasthe only one in which nobody skipped a form.
Be-cause we did not restrict the participants?
inputs,the data was fairly noisy.
For the purpose of thisstudy, we manually corrected the data for orthog-raphy and filtered out forms that were written inbroken English or did not comply with the task(e.g.
when users misunderstood the scenario, ordid not list the event descriptions in temporal or-der).
Overall we discarded 15% of the ESDs.Fig.
1 shows three of the ESDs we collectedfor EATING IN A FAST-FOOD RESTAURANT.
Asthe example illustrates, descriptions differ in theirstarting points (?walk into restaurant?
vs. ?walk tocounter?
), the granularity of the descriptions (?paythe bill?
vs. event descriptions 8?11 in the thirdsequence), and the events that are mentioned inthe sequence (not even ?eat food?
is mentioned inall ESDs).
Overall, the ESDs we collected con-sisted of 9 events on average, but their lengths var-ied widely: For most scenarios, there were sig-nificant numbers of ESDs both with the minimumlength of 5 and the maximum length of 16 and ev-erything in between.
Combined with the fact that93% of all individual event descriptions occurredonly once, this makes it challenging to align thedifferent ESDs with each other.5 Temporal Script GraphsWe will now describe how we compute a temporalscript graph out of the collected data.
We proceedin two steps.
First, we identify phrases from dif-ferent ESDs that describe the same event by com-puting a Multiple Sequence Alignment (MSA) ofall ESDs for the same scenario.
Then we postpro-cess the MSA and convert it into a temporal scriptgraph, which encodes and generalizes the tempo-ral information contained in the original ESDs.981row s1 s2 s3 s41  walk into restaurant  enter restaurant2   walk to the counter go to counter3  find the end of the line4  stand in line5 look at menu look at menu board6 decide what you want decide on food and drink  make selection7 order at counter tell cashier your order place an order place order8  listen to cashier repeat order9 pay at counter  pay the bill pay for food10  listen for total price11  swipe credit card in scanner12  put up credit card13  take receipt14  look at order number15  take your cup16  stand off to the side17  wait for number to be called wait for the ordered food18 receive food at counter get your drink get the food pick up order19    pick up condiments20 take food to table  move to a table go to table21 eat food  eat food consume food22    clear tray22   exit the placeFigure 2: A MSA of four event sequence descriptions5.1 Multiple Sequence AlignmentThe problem of computing Multiple SequenceAlignments comes from bioinformatics, where itis typically used to find corresponding elements inproteins or DNA (Durbin et al, 1998).A sequence alignment algorithm takes as its in-put some sequences s1, .
.
.
, sn ?
??
over some al-phabet ?, along with a cost function cm : ???
?R for substitutions and gap costs cgap ?
R for in-sertions and deletions.
In bioinformatics, the ele-ments of ?
could be nucleotides and a sequencecould be a DNA sequence; in our case, ?
containsthe individual event descriptions in our data, andthe sequences are the ESDs.A Multiple Sequence Alignment A of these se-quences is then a matrix as in Fig.
2: The i-th col-umn of A is the sequence si, possibly with somegaps (?
?)
interspersed between the symbols ofsi, such that each row contains at least one non-gap.
If a row contains two non-gaps, we take thesesymbols to be aligned; aligning a non-gap with agap can be thought of as an insertion or deletion.Each sequence alignment A can be assigned acost c(A) in the following way:c(A) = cgap ?
?
+n?i=1m?j=1,aji 6=m?k=j+1,aki 6=cm(aji, aki)where ?
is the number of gaps in A, n is thenumber of rows and m the number of sequences.In other words, we sum up the alignment cost forany two symbols from ?
that are aligned witheach other, and add the gap cost for each gap.There is an algorithm that computes cheapest pair-wise alignments (i.e.
n = 2) in polynomial time(Needleman and Wunsch, 1970).
For n > 2, theproblem is NP-complete, but there are efficient al-gorithms that approximate the cheapest MSAs byaligning two sequences first, considering the resultas a single sequence whose elements are pairs, andrepeating this process until all sequences are incor-porated in the MSA (Higgins and Sharp, 1988).5.2 Semantic similarityIn order to apply MSA to the problem of aligningESDs, we choose ?
to be the set of all individ-ual event descriptions in a given scenario.
Intu-itively, we want the MSA to prefer the alignmentof two phrases if they are semantically similar, i.e.it should cost more to align ?exit?
with ?eat?
than?exit?
with ?leave?.
Thus we take a measure of se-mantic (dis)similarity as the cost function cm.The phrases to be compared are written inbullet-point style.
They are typically short andelliptic (no overt subject), they lack determinersand use infinitive or present progressive form forthe main verb.
Also, the lexicon differs consider-ably from usual newspaper corpora.
For these rea-sons, standard methods for similarity assessmentare not straightforwardly applicable: Simple bag-of-words approaches do not provide sufficientlygood results, and standard taggers and parsers can-not process our descriptions with sufficient accu-racy.We therefore employ a simple, robust heuristics,which is tailored to our data and provides very982get in lineenter restaurantstand in linewait in linelook at menu boardwait in line to order my foodexamine menu boardlook at the menulook at menugo to cashiergo to ordering countergo to counteri decide what i wantdecide what to eatdecide on food and drinkdecide on what to ordermake selectiondecide what you wantorder foodi order ittell cashier your orderorder items from wall menuorder my foodplace an orderorder at counterplace orderpay at counterpay for the foodpay for foodgive order to the employeepay the billpaypay for the food and drinkspay for ordercollect utensilspay for orderpick up ordermake paymentkeep my receipttake receiptwait for my orderlook at priceswaitlook at order numberwait for order to be donewait for food to be readywait for orderwait for the ordered foodexpect orderwait for foodpick up condimentstake your cupreceive foodtake food to tablereceive tray with orderget condimentsget the foodreceive food at counterpick up food when readyget my orderget foodmove to a tablesit downwait for number to be calledseat at a tablesit down at tableleavewalk into the reasturantwalk up to the counterwalk into restaurantgo to restaurantwalk to the counterFigure 3: An extract from the graph computed for EATING IN A FAST FOOD RESTAURANTshallow dependency-style syntactic information.We identify the first potential verb of the phrase(according to the POS information provided byWordNet) as the predicate, the preceding noun (ifany) as subject, and all following potential nounsas objects.
(With this fairly crude tagging method,we also count nouns in prepositional phrases as?objects?.
)On the basis of this pseudo-parse, we computethe similarity measure sim:sim = ?
?
pred+ ?
?
subj + ?
?
objwhere pred, subj, and obj are the similarity val-ues for predicates, subjects and objects respec-tively, and ?, ?, ?
are weights.
If a constituentis not present in one of the phrases to compare,we set its weight to zero and redistribute it overthe other weights.
We fix the individual simi-larity scores pred, subj, and obj depending onthe WordNet relation between the most similarWordNet senses of the respective lemmas (100 forsynonyms, 0 for lemmas without any relation, andintermediate numbers for different kind of Word-Net links).We optimized the values for pred, subj, andobj as well as the weights ?, ?
and ?
using aheld-out development set of scenarios.
Our exper-iments showed that in most cases, the verb con-tributes the largest part to the similarity (accord-ingly, ?
needs to be higher than the other factors).We achieved improved accuracy by distinguishinga class of verbs that contribute little to the meaningof the phrase (i.e., support verbs, verbs of move-ment, and the verb ?get?
), and assigning them aseparate, lower ?.5.3 Building Temporal Script GraphsWe can now compute a low-cost MSA for eachscenario out of the ESDs.
From this alignment, weextract a temporal script graph, in the followingway.
First, we construct an initial graph which hasone node for each row of the MSA as in Fig.
2.
Weinterpret each node of the graph as representinga single event in the script, and the phrases thatare collected in the node as different descriptionsof this event; that is, we claim that these phrasesare paraphrases in the context of this scenario.
Wethen add an edge (u, v) to the graph iff (1) u 6=v, (2) there was at least one ESD in the originaldata in which some phrase in u directly precededsome phrase in v, and (3) if a single ESD containsa phrase from u and from v, the phrase from udirectly precedes the one from v. In terms of theMSA, this means that if a phrase from u comesfrom the same column as a phrase from v, thereare at most some gaps between them.
This initialgraph represents exactly the same information asthe MSA, in a different notation.The graph is automatically post-processed ina second step to simplify it and eliminate noisethat caused MSA errors.
At first we prune spu-rious nodes which contain only one event descrip-tion.
Then we refine the graph by merging nodeswhose elements should have been aligned in thefirst place but were missed by the MSA.
We mergetwo nodes if they satisfy certain structural and se-mantic constraints.The semantic constraints check whether theevent descriptions of the merged node would besufficiently consistent according to the similaritymeasure from Section 5.2.
To check whether wecan merge two nodes u and v, we use an unsuper-vised clustering algorithm (Flake et al, 2004) to983first cluster the event descriptions in u and v sep-arately.
Then we combine the event descriptionsfrom u and v and cluster the resulting set.
If theunion has more clusters than either u or v, we as-sume the nodes to be too dissimilar for merging.The structural constraints depend on the graphstructure.
We only merge two nodes u and v iftheir event descriptions come from different se-quences and one of the following conditions holds:?
u and v have the same parent;?
u has only one parent, v is its only child;?
v has only one child and is the only child ofu;?
all children of u (except for v) are also chil-dren of v.These structural constraints prevent the merg-ing algorithm from introducing new temporal re-lations that are not supported by the input ESDs.We take the output of this post-processing stepas the temporal script graph.
An excerpt of thegraph we obtain for our running example is shownin Fig.
3.
One node created by the node merg-ing step was the top left one, which combines oneoriginal node containing ?walk into restaurant?
andanother with ?go to restaurant?.
The graph mostlygroups phrases together into event nodes quitewell, although there are some exceptions, such asthe ?collect utensils?
node.
Similarly, the tempo-ral information in the graph is pretty accurate.
Butperhaps most importantly, our MSA-based algo-rithm manages to keep similar phrases like ?waitin line?
and ?wait for my order?
apart by exploitingthe sequential structure of the input ESDs.6 EvaluationWe evaluated the two core aspects of our sys-tem: its ability to recognize descriptions of thesame event (paraphrases) and the resulting tem-poral constraints it defines on the event descrip-tions (happens-before relation).
We compare ourapproach to two baseline systems and show thatour system outperforms both baselines and some-times even comes close to our upper bound.6.1 MethodWe selected ten scenarios which we did not usefor development purposes, five of them taken fromthe corpus described in Section 4, the other fivefrom the OMICS corpus.2 The OMICS corpus is afreely available, web-collected corpus by the OpenMind Initiative (Singh et al, 2002).
It containsseveral stories (?
scenarios) consisting of multi-ple ESDs.
The corpus strongly resembles ours inlanguage style and information provided, but is re-stricted to ?indoor activities?
and contains muchmore data than our collection (175 scenarios withmore than 40 ESDs each).For each scenario, we created a paraphrase setout of 30 randomly selected pairs of event de-scriptions which the system classified as para-phrases and 30 completely random pairs.
Thehappens-before set consisted of 30 pairs classifiedas happens-before, 30 random pairs and addition-ally all 60 pairs in reverse order.
We added thereversed pairs to check whether the raters reallyprefer one direction or whether they accept bothand were biased by the order of presentation.We presented each pair to 5 non-experts, allUS residents, via Mechanical Turk.
For the para-phrase set, an exemplary question we asked therater looks as follows, instantiating the Scenarioand the two descriptions to compare appropriately:Imagine two people, both telling a storyabout SCENARIO.
Could the first onesay event2 to describe the same part ofthe story that the second one describeswith event1 ?For the happens-before task, the question templatewas the following:Imagine somebody telling a story aboutSCENARIO in which the events event1and event2 occur.
Would event1 nor-mally happen before event2?We constructed a gold standard by a majority deci-sion of the raters.
An expert rater adjudicated thepairs with a 3:2 vote ratio.6.2 Upper Bound and BaselinesTo show the contributions of the different systemcomponents, we implemented two baselines:Clustering Baseline: We employed an unsu-pervised clustering algorithm (Flake et al, 2004)and fed it all event descriptions of a scenario.
Wefirst created a similarity graph with one node perevent description.
Each pair of nodes is connected2http://openmind.hri-us.com/984SCENARIOPRECISION RECALL F-SCOREsys basecl baselev sys basecl baselev sys basecl baselev upperMTURKpay with credit card 0.52 0.43 0.50 0.84 0.89 0.11 0.64 0.58 ?
0.17 0.60eat in restaurant 0.70 0.42 0.75 0.88 1.00 0.25 0.78 ?
0.59 ?
0.38 ?
0.92iron clothes I 0.52 0.32 1.00 0.94 1.00 0.12 0.67 ?
0.48 ?
0.21 ?
0.82cook scrambled eggs 0.58 0.34 0.50 0.86 0.95 0.10 0.69 ?
0.50 ?
0.16 ?
0.91take a bus 0.65 0.42 0.40 0.87 1.00 0.09 0.74 ?
0.59 ?
0.14 ?
0.88OMICSanswer the phone 0.93 0.45 0.70 0.85 1.00 0.21 0.89 ?
0.71 ?
0.33 0.79buy from vending machine 0.59 0.43 0.59 0.83 1.00 0.54 0.69 0.60 0.57 0.80iron clothes II 0.57 0.30 0.33 0.94 1.00 0.22 0.71 ?
0.46 ?
0.27 0.77make coffee 0.50 0.27 0.56 0.94 1.00 0.31 0.65 ?
0.42 ?
0.40 ?
0.82make omelette 0.75 0.54 0.67 0.92 0.96 0.23 0.83 ?
0.69 ?
0.34 0.85AVERAGE 0.63 0.40 0.60 0.89 0.98 0.22 0.73 0.56 0.30 0.82Figure 4: Results for paraphrasing task; significance of difference to sys: ?
: p ?
0.01, ?
: p ?
0.1with a weighted edge; the weight reflects the se-mantic similarity of the nodes?
event descriptionsas described in Section 5.2.
To include all input in-formation on inequality of events, we did not allowfor edges between nodes containing two descrip-tions occurring together in one ESD.
The underly-ing assumption here is that two different event de-scriptions of the same ESD always represent dis-tinct events.The clustering algorithm uses a parameterwhich influences the cluster granularity, withoutdetermining the exact number of clusters before-hand.
We optimized this parameter automaticallyfor each scenario: The system picks the value thatyields the optimal result with respect to densityand distance of the clusters (Flake et al, 2004),i.e.
the elements of each cluster are as similar aspossible to each other, and as dissimilar as possi-ble to the elements of all other clusters.The clustering baseline considers two phrasesas paraphrases if they are in the same cluster.
Itclaims a happens-before relation between phrasese and f if some phrase in e?s cluster precedessome phrase in f ?s cluster in the original ESDs.With this baseline, we can show the contributionof MSA.Levenshtein Baseline: This system follows thesame steps as our system, but using Levenshteindistance as the measure of semantic similarity forMSA and for node merging (cf.
Section 5.3).
Thislets us measure the contribution of the more fine-grained similarity function.
We computed Leven-shtein distance as the character-wise edit distanceon the phrases, divided by the phrases?
characterlength so as to get comparable values for shorterand longer phrases.
The gap costs for MSA withLevenshtein were optimized on our developmentset so as to produce the best possible alignment.Upper bound: We also compared our systemto a human-performance upper bound.
Because nosingle annotator rated all pairs of ESDs, we con-structed a ?virtual annotator?
as a point of com-parison, by randomly selecting one of the humanannotations for each pair.6.3 ResultsWe calculated precision, recall, and f-score for oursystem, the baselines, and the upper bound as fol-lows, with allsystem being the number of pairs la-belled as paraphrase or happens-before, allgold asthe respective number of pairs in the gold standardand correct as the number of pairs labeled cor-rectly by the system.precision = correctallsystem recall = correctallgoldf -score = 2 ?
precision ?
recallprecision+ recallThe tables in Fig.
4 and 5 show the results of oursystem and the reference values; Fig.
4 describesthe paraphrasing task and Fig.
5 the happens-before task.
The upper half of the tables describesthe test sets from our own corpus, the remainderrefers to OMICS data.
The columns labelled syscontain the results of our system, basecl describesthe clustering baseline and baselev the Levenshteinbaseline.
The f-score for the upper bound is in thecolumn upper.
For the f-score values, we calcu-lated the significance for the difference betweenour system and the baselines as well as the upperbound, using a resampling test (Edgington, 1986).The values marked with ?
differ from our systemsignificantly at a level of p ?
0.01, ?marks a levelof p ?
0.1.
The remaining values are not signifi-cant with p ?
0.1.
(For the average values, no sig-985SCENARIOPRECISION RECALL F-SCOREsys basecl baselev sys basecl baselev sys basecl baselev upperMTURKpay with credit card 0.86 0.49 0.65 0.84 0.74 0.45 0.85 ?
0.59 ?
0.53 0.92eat in restaurant 0.78 0.48 0.68 0.84 0.98 0.75 0.81 ?
0.64 0.71 ?
0.95iron clothes I 0.78 0.54 0.75 0.72 0.95 0.53 0.75 0.69 ?
0.62 ?
0.92cook scrambled eggs 0.67 0.54 0.55 0.64 0.98 0.69 0.66 0.70 0.61 ?
0.88take a bus 0.80 0.49 0.68 0.80 1.00 0.37 0.80 ?
0.66 ?
0.48 ?
0.96OMICSanswer the phone 0.83 0.48 0.79 0.86 1.00 0.96 0.84 ?
0.64 0.87 0.90buy from vending machine 0.84 0.51 0.69 0.85 0.90 0.75 0.84 ?
0.66 ?
0.71 0.83iron clothes II 0.78 0.48 0.75 0.80 0.96 0.66 0.79 ?
0.64 0.70 0.84make coffee 0.70 0.55 0.50 0.78 1.00 0.55 0.74 0.71 ?
0.53 ?
0.83make omelette 0.70 0.55 0.79 0.83 0.93 0.82 0.76 ?
0.69 0.81 ?
0.92AVERAGE 0.77 0.51 0.68 0.80 0.95 0.65 0.78 0.66 0.66 0.90Figure 5: Results for happens-before task; significance of difference to sys: ?
: p ?
0.01, ?
: p ?
0.1nificance is calculated because this does not makesense for scenario-wise evaluation.
)Paraphrase task: Our system outperformsboth baselines clearly, reaching significantlyhigher f-scores in 17 of 20 cases.
Moreover, forfive scenarios, the upper bound does not differ sig-nificantly from our system.
For judging the pre-cision, consider that the test set is slightly biased:Labeling all pairs with the majority category (noparaphrase) would result in a precision of 0.64.However, recall and f-score for this trivial lowerbound would be 0.The only scenario in which our system doesn?tscore very well is BUY FROM A VENDING MA-CHINE, where the upper bound is not significantlybetter either.
The clustering system, which can?texploit the sequential information from the ESDs,has trouble distinguishing semantically similarphrases (high recall, low precision).
The Leven-shtein similarity measure, on the other hand, is toorestrictive and thus results in comparatively highprecisions, but very low recall.Happens-before task: In most cases, and onaverage, our system is superior to both base-lines.
Where a baseline system performs betterthan ours, the differences are not significant.
Infour cases, our system does not differ significantlyfrom the upper bound.
Regarding precision, oursystem outperforms both baselines in all scenariosexcept one (MAKE OMELETTE).Again the clustering baseline is not fine-grainedenough and suffers from poor precision, onlyslightly better than the majority baseline.
The Lev-enshtein baseline gets mostly poor recall, exceptfor ANSWER THE PHONE: to describe this sce-nario, people used very similar wording.
In such ascenario, adding lexical knowledge to the sequen-tial information makes less of a difference.On average, the baselines do much better herethan for the paraphrase task.
This is because oncea system decides on paraphrase clusters that areessentially correct, it can retrieve correct informa-tion about the temporal order directly from theoriginal ESDs.Both tables illustrate that the task complexitystrongly depends on the scenario: Scripts that al-low for a lot of variation with respect to ordering(such as COOK SCRAMBLED EGGS) are particu-larly challenging for our system.
This is due to thefact that our current system can neither representnor find out that two events can happen in arbitraryorder (e.g., ?take out pan?
and ?take out bowl?
).One striking difference between the perfor-mance of our system on the OMICS data and onour own dataset is the relation to the upper bound:On our own data, the upper bound is almost al-ways significantly better than our system, whereassignificant differences are rare on OMICS.
Thisdifference bears further analysis; we speculate itmight be caused either by the increased amount oftraining data in OMICS or by differences in lan-guage (e.g., fewer anaphoric references).7 ConclusionWe conclude with a summary of this paper andsome discussion along with hints to future workin the last part.7.1 SummaryIn this paper, we have described a novel approachto the unsupervised learning of temporal script in-formation.
Our approach differs from previouswork in that we collect training data by directlyasking non-expert users to describe a scenario, and986then apply a Multiple Sequence Alignment algo-rithm to extract scenario-specific paraphrase andtemporal ordering information.
We showed thatour system outperforms two baselines and some-times approaches human-level performance, espe-cially because it can exploit the sequential struc-ture of the script descriptions to separate clustersof semantically similar events.7.2 Discussion and Future WorkWe believe that we can scale this approach tomodel a large numbers of scenarios represent-ing implicit shared knowledge.
To realize thisgoal, we are going to automatize several process-ing steps that were done manually for the cur-rent study.
We will restrict the user input to lex-icon words to avoid manual orthography correc-tion.
Further, we will implement some heuristicsto filter unusable instances by matching them withthe remaining data.
As far as the data collection isconcerned, we plan to replace the web form with abrowser game, following the example of von Ahnand Dabbish (2008).
This game will feature analgorithm that can generate new candidate scenar-ios without any supervision, for instance by identi-fying suitable sub-events of collected scripts (e.g.inducing data collection for PAY as sub-event se-quence of GO SHOPPING)On the technical side, we intend to address thequestion of detecting participants of the scripts andintegrating them into the graphs, Further, we planto move on to more elaborate data structures thanour current TSGs, and then identify and repre-sent script elements like optional events, alterna-tive events for the same step, and events that canoccur in arbitrary order.Because our approach gathers information fromvolunteers on the Web, it is limited by the knowl-edge of these volunteers.
We expect it will per-form best for general commonsense knowledge;culture-specific knowledge or domain-specific ex-pert knowledge will be hard for it to learn.
Thislimitation could be addressed by targeting spe-cific groups of online users, or by complementingour approach with corpus-based methods, whichmight perform well exactly where ours does not.AcknowledgementsWe want to thank Dustin Smith for the OMICSdata, Alexis Palmer for her support with AmazonMechanical Turk, Nils Bendfeldt for the creationof all web forms and Ines Rehbein for her effortwith several parsing experiments.
In particular, wethank the anonymous reviewers for their helpfulcomments.
?
This work was funded by the Clusterof Excellence ?Multimodal Computing and Inter-action?
in the German Excellence Initiative.ReferencesCollin F. Baker, Charles J. Fillmore, and John B. Lowe.1998.
The berkeley framenet project.
In Proceed-ings of the 17th international conference on Compu-tational linguistics, pages 86?90, Morristown, NJ,USA.
Association for Computational Linguistics.Avron Barr and Edward Feigenbaum.
1981.
TheHandbook of Artificial Intelligence, Volume 1.William Kaufman Inc., Los Altos, CA.Regina Barzilay and Lillian Lee.
2003.
Learn-ing to paraphrase: An unsupervised approach us-ing multiple-sequence alignment.
In Proceedings ofHLT-NAACL 2003.Jon Chamberlain, Massimo Poesio, and Udo Kru-schwitz.
2009.
A demonstration of human compu-tation using the phrase detectives annotation game.In KDD Workshop on Human Computation.
ACM.Nathanael Chambers and Dan Jurafsky.
2008a.
Jointlycombining implicit constraints improves temporalordering.
In Proceedings of EMNLP 2008.Nathanael Chambers and Dan Jurafsky.
2008b.
Unsu-pervised learning of narrative event chains.
In Pro-ceedings of ACL-08: HLT.Nathanael Chambers and Dan Jurafsky.
2009.
Unsu-pervised learning of narrative schemas and their par-ticipants.
In Proceedings of ACL-IJCNLP 2009.Nathanael Chambers, Shan Wang, and Dan Juraf-sky.
2007.
Classifying temporal relations betweenevents.
In Proceedings of ACL-07: InteractivePoster and Demonstration Sessions.Richard Edward Cullingford.
1977.
Script applica-tion: computer understanding of newspaper stories.Ph.D.
thesis, Yale University, New Haven, CT, USA.Richard Durbin, Sean Eddy, Anders Krogh, andGraeme Mitchison.
1998.
Biological SequenceAnalysis.
Cambridge University Press.Eugene S Edgington.
1986.
Randomization tests.Marcel Dekker, Inc., New York, NY, USA.Gary W. Flake, Robert E. Tarjan, and Kostas Tsiout-siouliklis.
2004.
Graph clustering and minimum cuttrees.
Internet Mathematics, 1(4).Andrew S. Gordon.
2001.
Browsing image collec-tions with representations of common-sense activi-ties.
JASIST, 52(11).987Desmond G. Higgins and Paul M. Sharp.
1988.Clustal: a package for performing multiple sequencealignment on a microcomputer.
Gene, 73(1).Dominic R. Jones and Cynthia A. Thompson.
2003.Identifying events using similarity and context.
InProceedings of CoNNL-2003.Inderjeet Mani, Marc Verhagen, Ben Wellner,Chong Min Lee, and James Pustejovsky.
2006.Machine learning of temporal relations.
InCOLING/ACL-2006.Mehdi Manshadi, Reid Swanson, and Andrew S. Gor-don.
2008.
Learning a probabilistic model of eventsequences from internet weblog stories.
In Proceed-ings of the 21st FLAIRS Conference.Michael McTear.
1987.
The Articulate Computer.Blackwell Publishers, Inc., Cambridge, MA, USA.Risto Miikkulainen.
1995.
Script-based inference andmemory retrieval in subsymbolic story processing.Applied Intelligence, 5(2), 04.Raymond J. Mooney.
1990.
Learning plan schematafrom observation: Explanation-based learning forplan recognition.
Cognitive Science, 14(4).Erik T. Mueller.
1998.
Natural Language Processingwith Thought Treasure.
Signiform.Erik T. Mueller.
2004.
Understanding script-based sto-ries using commonsense reasoning.
Cognitive Sys-tems Research, 5(4).Saul B. Needleman and Christian D. Wunsch.
1970.A general method applicable to the search for simi-larities in the amino acid sequence of two proteins.Journal of molecular biology, 48(3), March.Lisa F. Rau, Paul S. Jacobs, and Uri Zernik.
1989.
In-formation extraction and text summarization usinglinguistic knowledge acquisition.
Information Pro-cessing and Management, 25(4):419 ?
428.Roger C. Schank and Robert P. Abelson.
1977.
Scripts,Plans, Goals and Understanding.
Lawrence Erl-baum, Hillsdale, NJ.Push Singh, Thomas Lin, Erik T. Mueller, Grace Lim,Travell Perkins, and Wan L. Zhu.
2002.
Openmind common sense: Knowledge acquisition fromthe general public.
In On the Move to MeaningfulInternet Systems - DOA, CoopIS and ODBASE 2002,London, UK.
Springer-Verlag.Dustin Smith and Kenneth C. Arnold.
2009.
Learninghierarchical plans by reading simple english narra-tives.
In Proceedings of the Commonsense Work-shop at IUI-09.Rion Snow, Brendan O?Connor, Daniel Jurafsky, andAndrew Y. Ng.
2008.
Cheap and fast?but is itgood?
: evaluating non-expert annotations for natu-ral language tasks.
In Proceedings of EMNLP 2008.Reid Swanson and Andrew S. Gordon.
2008.
Say any-thing: A massively collaborative open domain storywriting companion.
In Proceedings of ICIDS 2008.Luis von Ahn and Laura Dabbish.
2008.
Designinggames with a purpose.
Commun.
ACM, 51(8).988
