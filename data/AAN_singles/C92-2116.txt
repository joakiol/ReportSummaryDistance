TERM-REWRIT ING AS A BASIS FOR A UNIFORMARCHITECTURE IN MACHINE TRANSLAT IONWilhelm WEISWEBERTechnical University of BerlinInstitute for Software and Theoretical Computer ScienceProject KIT-FAST, Sekr.
FR 5-12Franklinstr.
28/29, D-1000 Berlin I0E-mail: ww@kit.cs.tu-berlin.de or weisweb@tubvm.cs.tu-berlin.deAbstractIn machine translation (MT) different levels ofrepresentation can be used to translate a sourcelanguage sentence onto its target language quivalent.These levels have to be related to each other.
Thispaper describes a declarative formalism on the basis ofterm-rewriting which maps one representation to anequivalent adjacent one.
The different levels (e.g.represented by derivational trees, feature structures orexpressions of a knowledge representation language)can be represented asterms.
The equivalences betweenthem are stated as axioms which are directed to form anon-confluent and terminating term-rewrite system.
Acourplete and coherent' algorithm has been developexlwhich interprets these systems and is able to handledefault rules.1 Introduct ionIn general there are different models of machinetranslation (MT).
Regardless of the model used as thebasis for an MT system, the architecture looks like thefollowing (see \[Arnold et at.
86\] and \[Sharp 88\]):G: G 2 Gn.
: G,I I I ISs --} RI -~ R2 --~ ... --} R._: -~ R. --} STsT: IT2 2T3 n-2Tn.l ..IT.
.
'ITThe Ri's are representations, e.g.
derivational trees (forexample the syntactic stuetures) or directed acyclicgraphs (for example f-structures of LFG or KL-ONEbased conceptual representations), the Gi's are theformalisms which generate these representations, e.g.context free grammars or signatures, the Ti's aremappings from one representation to an equivalentadjacent one and S s, S T are the source and targetlanguage sentences, respectively.If the MT system is interlingua based, one of the R: isthe interlingua nd if it is transfer based one of the iTi+lis the transfer system.
Usnally the first and lastmappings have different status and are realized by aparser and a generator, respectively.The MT system of our project KIT-FAST ~ is based ona transfer model and i = 4, where RI is the sourceGPSG structure (see \[Gazdar etal.
85\] and \[Busemann/Hauenschild 88\]), R 2 is the source Fanctor-Argument-Structure (FAS) 2, R3 is the target FAS and R4 is thetarget GPSG structure.
G: to G4 are context-freegrammars.
In the current phase of our project we aretaking the first steps towards the solution of textualphenomena, i.e.
the interpretation of anaphoricalrelations (see \[Schmi~ et al 91\]).
In order to achievethis, the source FAS is mapped onto a conceptualrepresentation for the text content, which is representedby the ABox (assertional knowledge) of the KL-ONElike representation language BACK.
The knowledgerepresentation system BACK has been developed byour neighbour project KIT-BACK (see lPeltason et al89\]).
The representation for the text content is used todetermine the discourse consistency of possibleantecedents for anaphoric pronouns.Currently sT1 and 4T 1. are realized by a GPSG parserand a morphological synthesis component, respective-ly.
The mappings :T 2 (semantic analysis), 2T3 (trans-fer), 3T4 (generation) and the mapping from R 2 (FASrepresentations) onto conceptual representations arerealized by one algorithm on the basis of term-rewriting.
The mapping sT1 (parsing) also is intendedto be implemented with a term-rewrite system.
A shortintroduction to term-rewriting is given in section 3.it seems reasonable to represent all different R~ withthe help of one data structure and to specify all iTi+lwith the help of the ~me formalism (including parsingand generation).
Some proposals in this direction havealready been made.
Two of these systems, namelyCAT2 and TFS, and their properties are outlined insection 2.
The following .sections present an alternativeapproach, which remedies some problems of thesesystems.
In Section 4 a term representation, which isgenerated by a signature for a term algebra, isintroduced with the help of which all R i can berepresented.
The representation of GPSG or FASderivational trees, feature structures and KL-ONE likeconceptual structures as terms is shown by example.The algorithm, i.e.
the termination condition and theapplication relations, which are automaticallycomputed from the rewrite rules by the examination ofthe interdependencies of the rules with the help ofKIT = Ktinsdiche lntelligenz und Textverstehen(artificial intelligence and text understanding), FAST =functor-argument-structure fo  translation.
The projectKIT-FAST constitutes the Berlin component of thecomplementary esearch of EUROTRA-D.
It receivesrants by the Federal Minister for Research andeehnology.The FAS is a semantic representation for sentences whichhas been developed in the preceding phase of our project.Among others it contains functor-argument-relations,information about the thematic stxucturing of sentencesanti semantic relations (argument roles) and semanticfeatures.
For a more detailed description see\[Hauercsclfild/Umbach 88\].
\[Busemann/Hauenschild 89\]and \[Busemann 90\].ACTES DE COLING-92, Nhr, rrEs, 23-28 AOt\]T 1992 7 7 7 PROC.
OF COLING-92, NANTEs, AUG. 23-28, 1992superposition, is given in section 5.
Section 6concludes the paper and gives an outlook for fartherresearch.2 Other approachesSeveral proposals in the direction of a uniformarchitecture of MT systems have teen made.
Withinthe EUROTRA-D project the CAT2 system wasdeveloped by \[Sharp 88\].
This approach uses deriva-tional trees as representations and is characterized bythe compositionality of the mapping rules according to\[Arnold et al 86\].
The Typed Feature Structure (TFS)system as presented in \[Emele/Zajac 89\] and \[Zajac89,90,91\] is outlined in subsection 2.
It uses typedfeature structures as representations.Another approach, which is similar to Emele andZajac's, is given in \[Russell et al 91\].2.1 The  CAT2 sys temThe representations Ri in the CAT2 system arederivational trees generated by context-free grammarsG i which are made up of a pair (Ci, Ai), where C is aset of Constructors (structural rules) and A a set ofAtoms (lexical rules).
The mappings from one tree toanother are called Translators, which are sets of t..rule,s.The translators sTt and nTT are realized by a parser anda Wee-to-string transducer, espe.ctively.
The interpre-ter for t-rules processes the input tree top-down bymatching the input tree with the left-hand side (Ihs) ofa rule and the subobjects are recursively mapped.
Onthe way bottom-up the subtrees are reordered accordingto rite right-hand side (rhs) of the given t-rule.
Theinterpreter terminates when the whole input structurehas been traversed and mapped.
The t-rules have theform lhs =:> rhs.
The Ihs and rhs are structuraldescriptions of the source and target structure,respectively, which are expressed by trees of the form(node).(subtrees).
The nodes are pairs (C, F), where Cis a distinguished feature and F is a set of feature-valuepairs.
The subtrees of the lhs and rhs can be combinedwith the help of conjunction or disjunction.
Eachsubtree can be labeled with a tag $N and can be markedas optional or with the Kleene-star operator.
When atag, which occurs on the lhs, is missing on the rhs, thecorresponding subtree is deleted, otherwise it isreplaced by its mapping (translation).
The t-rulesmaintain the partial compositionality 3 of the translator.An example of a t-rule for semantic analysis is themapping from the surlace eases of the English verbgenerate onto the corresponding deep eases:(s,{}).\[$1 :(np,{cas=nom}),(vp,{}).\[(v,{stem=generale}).\[\],$2:(np,{cas=acc})\]\](_,(}).\[(process,{lu=generate}),(agent,(}).\[$1\],(affected,{}).\[$2\]\]The advantages of CAT2 are its simplicity andThe translation of an expression consists of the trans-lation of its subexp*essions (see \[Arnold et al 86\]).efficiency.
Furthermore CAT2 is supposed to bereversible.
The efficiency is a consequence of the(partial) compositionality of the translators.
This leadsdirectly to an efficient slructure-driven 4 i terpreter.
Thedisadvantage is that it does not allow for directedacyclic graphs (DAGs) as representations.
Since thetranslators are compositional, the t-rules cannot expressthe fact that the translation of one constituent dependson the translation of other constituents.
For example ifa predicate (verb, noun or adjective) is to be translated,the translation typically depend.,; on the semantic rolesand featu~s (selectional restrictions) of its targetlanguage arguments.2.2 The  TFS  sys temThe TFS system uses typed feature structures (TFSes)as representations, which can be represented asDAGs.TFSes are defined recursively.
A TFS is an atomic orcomplex type.
An atomic type consists of a typesymbol and a complex type of a type symbol with a setof pairs of features and TFSes (values).
The featurestructures of PATR, LFG or HPSG are examples ofTFSes.
The set of type symbols P, which alwaysincludes the special type symbols T (top) and(bottom), is partially ordered and T _> T _>_ -L holds forall T E P. This partial ordering defines a latticestructure on P and can be extracted from the definitions(axioms).
Definitions have the form T = TFSt v ... vTFS m :- C, where T is a type symbol, the TFS~ areTVSes of type F i (T _> Fi) and C is a conditionalconstraint, which may be omitted and is expressed by alogical conjunction of TFSes.
The unification of twotype symbols is their greatest lower bound.
A "rewritestep "5 on an input TFS is performed by looking for asubTFS of type T of the input TFS and a definition ofthe form T = F :- C. In that case the subTFS of theinput TFS and the TFS F are unified, the conjunction Cof TFSes is solved and the result of the unification isinserted in place of the sub'l~'S, qlae TFS rule for thesemantic analysis rule of the previous ubsection is:SYN-S =SEM-S\[syn: S\[np: NP\[cas:NOM I X\],vp: VP\[v:GENERATE,np: NP\[cas:ACC IY\]\]sere: REL\[process: GENERATE,agent: X',affected: Y'\]\]:o SYN-NP\[syn: NP\[cas:NOMt X'\], sere: X'\]SYN-NP\[syn: NP\[cas:ACC IY\], sem: Y'\]The advantage ofTFS is that all different levels, i.e.
Ss,Rt to R, and ST, are accessible for all mappings iTi+l.The disadvantage is that the algorithm for theapplication of definitions is not complete.4 'Stxuctuse-driven' means that fire input structure is~ in a certain suategy (in this case top-down).
crate-driven processes are normally more efficientthan dataqlriven processes, which process the inputstructure according to the rules which manipulate it.s This is not 'rewriting' in the sense of this paper, but theinput TFS is extended by unification, wlfich is amonotonic operation, i.e.
it is "blown up" with additionalinformation.AcrEs DE COLING-92, NANTES, 23-28 AOfYI" 1992 7 7 8 PROC.
Or COLING-92, NANTES, AUG. 23-28, 1992Another problem of TFS can arise if the definitions arcapplied in the wrong order.
Let us for example assumethat a pr~icate has alternative translations dependingon the selection',d restrictions of its target languagearguments and the definition which gives the wrongtranslation is applied before the target languagearguments exist.
This would lead to a wrong or notranslation, even if the correct translation wonld bepossible.
This cat only be avoided if the alternativesare specified in one definition with the help ofdisjunction, which, however, may be very inefficient ifthe correct ranslation is the last alternative.3 Term-rewritingA term-rewrite system O'RS) 6 is a set of term-rewriterules (TR rules) ~ -4, p with left-hand side (Ills) ~ midright-hand side (rhs) p, in which cospecified variablesoccur.
The applicability of a TR rule to all input tenn tis checked by superposing t with X.Definition: SuperpositionThe term h is superposable with the term 12, iff asubterin q/u of h attd t 2 are unifiable with minimalunifier (or substitution) ~ ~: { }.
'rite elements of ~ are pairs of substitutions X <- t~,where the variable X is substituted by the correspond-ing term h. The substitution of variables occurring int/u and ~.
according to ~ (notation: (t/n)~ and ~,respectively) yields two identical terms ((t/u)~ = Lcr).If the term t is superpo~ble with ~L at the subterm t/uwith the substitution el, the TR rule is applied byreplacing t/u in t by p~ yielding the target erm t' = t\[up~\].
This is called a derivation step (notation: t -->t').Originally TRSes are used to prove rite equ',dity ofterms.
In this context file Knuth-Bendix algorithm hasbeen developed (.see \[Knuth/ Bendix 70\]), whichcomputes the norm.,d form of a given TRS, if the TRSis confluent and terminating.A TRS is confluent if the application of the rewriterules to an input term yields exactly one target ernl, notnatter in which sequence the rules are applied.In order 1o guarantee the termination of TRSes, anordering on the corresponding terms has to be definedand at least one minimal term exists.
Such an orderingguarantees the termination of a derivation .~.xluence h-~ t2 -~, ... -~ t~ l --> t,~ if and only if tl > tz > ... > t,4 >t~, where tl is the input term, t,~ the "target erm and t i ->ti+t a derivation step, in which the resulting term t~+ t isderived from the original term ti by the application ofone TR rule.In order to prove the temlination of a TRS,theoretically all possible derivation seqttences have tobe checked.
Another possibility is to define a totalordering on the teruls on the lhs and rhs of the '1~,rules, which guarantees that in a derivation step ti -4,ti+t the original term ti is reduced according to thisordering (ti > ti+t), then the TRS is terminating becausealier a finite number of derivation steps either aminimal term is rcatclted or no qR rule is applicable tothe resulting temLIn order to guarantee the termination of TRSes byconsidering each single "lq~ rule, some criteria have tobe defined for rite terms on the ihs and rhs of eachsingle TR rule so that its application reduces file inputterm according to the total ordering.
The ordering mayreduce the size of the inlart term after rite application ofa rule (a qnantitative ordering, i.e.
deleting a subterulon tile rhs) or substitute a snbtenn of the intmt term insuch a way that this substitution is never reversed byanother rewrite rule (a qualitative ordering, i.e.
naoperator precedence ordering).
For the use in MT weassume a qualitative ordering (see section 5.5).
Fordetails about the terufination of TRSes see \[Dershowitz82 and 85\].TRSes in normal form are complete attd coherent.
Theycan efficiendy be applied to deduce rite normal form ofan input tenn.
In order to prove the equality of twoterms, their normal forms are deduced and comparedhtr literal equality.In order to use TRSes for mappings between a sourceanti a target representation ill MT, the sourcerepresentation Call be viewed as an input term for aTRS and the target represenlatiou as its normal form.For this reason a term algebra liJr each representationR i tins to be dclined which generates the eotlcspondinglerms for the given representation.
The mapping rulesate considered as TR rides.
But using TRSes for thentappiugs in MT cau ls  a problem.
Normally analysis,transfer attd generation of natural languages in MTmay have ntore than one result, i.e.
TRSes used formappings ill MT usually are not confluent.
For thisreason an interpreter for +lRSes has been developed inour project (sec section 5, \[Weisweber 89\] and\[Weisweber/Hauensehild 901), which is complete anticohereal and applies terminating ,and non-continentTRSes in a very efficient way.4 The term representationill order to have one process for the interpretation ofthe mapping roles of file different ,,To+l, all structuresR,, have Io be represented with the help of one &atastracttwe.
The data structure used by the ~IRSinterpreter consist,'; of terms which represent directedacyclic graphs (DAGs) wilh complex categories asnode labels.
Derivational Irces are special instances ofDAGs in which no m-eutrancy of nodes is allowed andthe edges leaving one ntv..le arc ortlered.
The ternts aregenerated by the fltllowing signatureV:Signature for DAGsdag: CA7 L IST - )  DAGlist: DAG LIST ~ LIS1\[\]: --> LISTAt present his signatule is fixed for the interpreter, bntif more exlm'essive represenhqtions are necessary forIn the following a notation according to \[tluet/Oppen 80Iis used, which gives a detailed introduction to TRSez.Signatures are very simihtr to context-flee roles.
Theoperator definitions '()p': $1 ... S,, i -~ S,, can be viewed asthe context-tree rule S,, - ) 'op(' S t '.'
...'.'
S~4+)'.
where thesorts S i are interpreted as nt)l l-tellrl ina\]s.ACRES DE COLlNG-92, NANTES, 23-28 Ao~rr 1992 7 7 9 PROt:.
OF COLING+92, NANTES, AUO.
23-28, 1992MT, the interpreter can be adapted.
The sort CAT,which represents complex categories, is also generatedby a signature which has to be specified for theparticular representations.Scheme for signatures for complex categoriesC: LANG F1 ... Fn --~ CATg-gpsg, g-fas, e-las, e-gpsg, g-atl, ...: -~ LANGVi: .--4 F iThe C are the main categories (in the sense of thedistinguished features of \[Sharp 88\]).
LANG is aspecial sort which represents he language to which acategory belongs.
With the help of the instances of thissort the categories occurring in terms can bedistinguished to belong to the source or targetrepresentation.
This fact is used to allow the TRSinterpreter to process the input structure in a flexiblestrategy (see section 5.4) and to guarantee itstermiantion (see section 5.5).The sorts F i represent the features which are associatedto the main category.
The Vi are 0-ary operators(constants) which represent the values for the featuresrepresented by F i (Vi E Fi).
Nodes N of a DAG whichhave no oat-going edges (in trees terminal nodes) arerepresented by dag(N,~).Example signature for German ominal phrasesnp: LANG PER PLU GEN CAS --> CATg-gpsg: --~ LANG1,2,3: ---> PER+,-: ~ PLUfem,masc,neut: --> GENnom,gen,dat,acc: ~ CASAn example of a term for a German nominal phrase isnp(g-gpsg,3,-,fem,nom).The TRS interpreter uses the signature for DAGs totraverse the input representation i  order to find asubterm which is unifmble with the Ihs of a TR rule.Our TRS editor uses the signature for DAGs to produceterms from a graphical input and to perform consist-ency checks on the input.In order to show, for example, how conceptualstructures can be represented as temls, a smallfragment of the syntax of the ABox tell language(ATL) of the knowledge representation system BACK(see \[Peltason et at.
89\]), which is used in theexperimental MT system of our project, is given:Context-free rules for a fragment of the ATL:(abox-tell) --> (obj-ref) = (atl-conc)I (variable) = (atl-conc)obj-ref) --> uclatl-conc) ---> (concept)I (concept) with (all-role)(atl-role) ---> (role) : ((abox-tell))I (atl-role) anOwlth (all-role)The non-terminal (concept) represents the conceptsused in a discourse and (role) represents he semanticroles of the arguments of a predicative concept.
(variable) represents variables which are instantiatedwith a new unique discourse object reference ucl, ifthere is no object reference in the ABox for the givenconcept.In order to represent ATL expressions as terms thefollowing signature is used:Signature for ATL categories:equal: LANG OBJ-REF ~ CATwith: LANG ROLE ~ CATg-all: --~ LANGThe ATL expressions are represented by trees andsince terms represent DAGs, a context-free syntax isneeded to check whether the target terms of theconceptual analysis represent ATL trees or not.
Thecontext-free syntax of ATL trees is given in thefollowing.Context-free syntax for ATL treesatl(g-atl) --, equal(g-atl,_) with(g-all,_)"with(g-atl,_) ~ equal(g-atl,_) with(g-atl,_)"equal(g-all,_) ~ (concept) (lexical rules)For example the German ATL expression UCl =generate with agent : (uc2 = generator) andwithaffected : (uc3 = sentence) is represented by thefollowing ATL term:Example for an ATL termdag(atl(g-atl), Idag(equal(g-atl,ucl), \[dag(generate, \[\])1),dag(wit h(g-atl,agent), \[dag(equal(g-atl,uc2), \[dag(generator, \[\])\])\]),dag(with(g-atl,affected), \[dag(equal(g-atl,uc3), \[dag(sentence, \[\])\])\])\])At the end of this section we give the TR rule of thesemantic analysis which corresponds to the rules ofCAT2 and TFS presented in the sections 2.1 and 2,2,respectively:dag(s(e-gpsg), \[dag(v-pred(e-fas,nom-acc,active), \[dag(genetate, \[\])\]),dag(term(e-fas,nom), X),dag(term(e-fas,acc), Y)\])dag(clause(e-fas), \[dag(v-pred(e-fas,ag-at,active), \[dag(generate, \[\])\]),dag(term(e-fas,agent), X),dag(term(e-fas,affected), Y)\])The TR rule contains the cospecified variables X andY.
Additionally some conditions on variable featurevalues can be defined with the help of the operators =,?, < and _> which can be combined with the logicaloperators and or or.In order to handle for example the long distancedependencies of GPSG or LFG conveniently, theexpressive power of TR rules has been increased.
Thecategories occurring on the lhs and rhs of a rule may belabeled with the +-operator, which is similar to theKleene-star operator.
The occurrence of the categoryC ?
means that C is the root node of the correspondingsubDAG, which may dominate another category C,which again may dominate another category C and soACRES DE COLING-92, NANTES, 23-28 AOO'r 1992 7 8 0 PROC.
OF COLING-92, NANTES, AUG. 23-28, 1992on.
This is similar to functional uncertainty in LFG.5 In terpretat ion  o f  TRSesAs mentioned in section 3, the TRSes for the mappingsin NIT are not usually confluent.
For this reason theKnuth-Bendix algorithm cannot be used.
In order toapply non-confluent TRSes efficiently, the inter-dependencies between their TR rules have to bedetermined.
The rewrite process is data-driven and inorder to check each TR rule only once for application,an order is computed (subsection l).
The rewriteprocess should be complete and coherent.
Thereforemore general TR rules should be checked forapplication after more specific ones and sub~ction 2shows an order for some kind of default TR rules.
Asthe TRSes are not confluent, the interpreter has tocontrol the branching of the derivation sequence.
Thisis done with the help of alternative rules (subsection 3).The TRS interpreter is outlined in subsection 4.
Sincethe rewrite process is data-driven, the termination ofthe interpreter cannot be guaranteed by the interpreteritself.
Subsection 5 gives an adequate terminationcondition for TRSes used in MT systems.In the following subsections, the existence of two TRrules (nl, ~.1 --~ Pl) and (n2, 2%-2 --~ P2) in the TRS isassumed, where {n~, nz} C: R N (the set of numbers ofall TR rules), k~, 7% are the left-hand sides (lhs) and Pl,p~ are the right-hand sides (rhs) of the TR rules.5.1 The  app l i ca t ion  orderIn order to check each TR rule for application onlyonce, an order has to be computed.
Generally there arecycles in the application order and the TR roles of acycle have to be checked more than once.Definition: Application order elation >~,I f  pl is superposable with 2% orL~ is superposable with p~then n~ >,pp n 2, where >,~ (S R~ ?
R N.The relation >,pp is transitive and n~ :>lpp II2 means thatTR rule n t has to be applied before rule nz.
Thisrelation may have cycles n I >~pp .,.
>~pp n m >~pp n 1.
\[uorder to compute the cycles of >*w' the transitiveclosure >,+p~ is computed, which may contain anequivalence relation >~y~ (>?y~ is reflexive, symmetricand transitive, >?y~  >~+pp and >~y~ Rc ?
Pc, whereRc ~ RN is the set of numbers of cyclic TR rules).Definition: Cycles of >~,t,A cycle of >,+~ is an equivalence class \[n\] = {m \]n >~yom} and >~y~ is the greatest equivalence r lation in >,~.The cycles (equivalence classes) are either equal ordisjoint and constitute a partition of Re.
The efficiencyof the rewrite process crucially depends on the numberand size of the cycles.5.2 Defau l t  TR  ru lesIn some situations it is useful to have some kind ofdefault TR rule.
For example if there ate severaldifferent ranslations for one source language terminalwhich depend on certain (structural) conditions andthere is a "default" translation, if none of theseconditions holds, e.g.
if the German verb schwimmenhas an inanimate argument, it has to be translated intothe English float and if there is no informationavailable, it has to be translated into swim.These default TR rules can be computed bysuperposing the lhs of two TR rules and one lhs occurscompletely in the other lhs.
In that case the morespecial TR rule has to be checked for application firstand the more general one last.Definition: Default relation >dcfIf ~1 is superposable with ~z with substitution ff and~-1 and ~ are not identical andall variables X of (X ~ t) E ff occur in 2%then n I >da n2, where >da ~ RD ?
Ro.The relation >ca is reflexive, anti-symmetric andtransitive, i.e.
a (partial) order relation in R o (the set ofnumbers of default rules) and nl >an n2 means that thelhs of role n 1 is more special than the lhs of rule n2 andUl has to be checked for application before n2, even ifthey are part of a cycle.
If ~4 and ~ are identicalwithout the names for variables, the TR rules arealternatives ( ee next subsection).The set R O contains ubsets Ci ~ Ro, which are calledchains, because for every x,y ~ Ci either x >da Y or y>~ x.
Every chain has an infimum (the most specialTR rule) and a supremum (the most gemerul TR rule).5 .3  A l te rnat ive  TR  ru lesIn order to get alernative solutions the derivationsequence has to branch at certain points which can alsobe computed by superposing the lhs of two TR rules.This is just the situation, in which the Knuth-Bendixalgorithm computes a critical pair.Definigon: Alternative relation V,,~,If ~q is superposable with 2% at subterm ~/u  withsubstitution o andPl is not superposable with ~ andif ~.l/u = ~.1 then ~qis not unifiable with t32then {(n i, ~.lo --> p i t ) ,  (n~, ~1o -~' ~t\[u ~ p2t~\])} C"IRS and n~ v,l ~ n' 2, where v.l t ~ R A X R^.The relation v,I, is reflexive, symmetric and transitive,i.e.
an equivalence relation in R^ (the set of numbersof alternative rules), n~ v,lt n~ means that everytimcTR rule nl is applicable to an input term, then n?
isapplicable and vice versa and the derivation sequencebranches at this point.
The additional condition thatthe rhs Pl of one rule is not superposable with the lhsLz of the other is necessary to exclude brunches causedby rules in which the subterm ~,l/u is used us structuralcondition.
The other condition is needed for the samereason in the special case when k~ and Lz are unifiable.The rules ni or n~ may already exist in the TRS.
In thatcase either the lhs of n~ and n 2 have been identical andnl = nl and n~ = n 2 or nl >d~ n2 and n I = nl or n 2 >~ n 1and n~ = n2.If the rules n~ or n~ are not in the TRS, they are addedand all other relations are computed.
In most cases thenew lhs is more special than the two other ths and thecorresponding default relations hold.The lhs of the new TR rules n\[ and n~ is the"superposition" of lhs of the rules nl and n2.
The rhs ofn i is the rhs of hi, in which the variables are replacedaccording to the substitution o.
The rbs of n~ is the lhsof n l, in which the subterm ~,jhl is replaced by the rhsof n 2, the variables of which are replaced according toAcrEs DE COLING-92, NANTES, 23-28 Attar 1992 7 8 1 PROC.
OF COLING-92, NANTES.
AUG. 23-28, 1992the superposition.
The efficiency of the rewrite processcrucially depends on the number and size of theequivalence classes of RA.5.4 The  TRS in terpreterIn order to apply the TR rules in an efficient order, theordered set APP is precomputed:APP= RN-Re-Ro-RAU {nl\[n\] ~Re}LJ {hi n is inflmum of a chain C C: RD}k) {n\[\[n\] ~RA}The set APP is ordered in the way that the sequencedoes not contradict to >,pp.
The interpreter for TRSestakes an input term t and checks all TR rules (n, 7~ -~p} in the order of APP.If n ~ R c, then all TR rules m ~ \[hi ~ R c trove to bechecked for application in an arbitrary order as long asone rule of the cycle \[n\] is applicable, otherwise if t issuperposable with ~., then the corresponding TR rule isapplied else the next TR rule is checked forapplication.If the applicable TR rule n is a default rule (n ~ Ro),then the TR rules m (n ->ae~ m) of the chain C ~ R o areapplied in the order of >aa.If the applicable TR rale n is an alternative rule (n ER^), then all the TR rules m c In\] ~ R^ are appliedalternatively.
Every alternative is a new branch in thederivation sequence.If a TRS has a normal form, the algorithm interpretes itas efficiently as nomlalized TRSes.The interpreter strategy of processing the input term,which represents a DAG, is flexible, i.e.
the TR rulewriter determines whether to proceed top-down,bottom-up, from left to right or vice versa.
For exampleif the daughter categories of the lbs of the TR rules aretarget language (TL) categories and the mother catego-ry is a source language (SL) category which is to betranslated into a TL category by the corresponding rule,then the interpreter will process the input structurebottom-up (see example of the TR rule in section 4).5.5 Terminat ionFor the use in our TRSes a quantitative ordering hasbeen defined that guarantees the termination of all theTRSes used in our MT system.
This ordering uses thedifferent vocabularies of the SL and TL terms andrequires that the number of SL categories occurring inthe input term has to be reduced.
This means that eithera SL category has to be deleted or it has to be replacedby one or more TL categories.
The minimal terms areall terms in which no SL categories occur.
Thisordering guarantees the termination of that sequencebecause the number of SL categories occurring in theinput term is finite and after a finite number ofapplications there will be no SL categories left in theresulting term or no TR rule is applicable.In order to prove the termination ofa  TRS, every singleTR rule has to be checked.
The ths and rhs maycontain occurrences of variables for terms, i.e.
for(sub)DAGs, sets of (sub)DAGs, categories or featurevalues of categories.
If for example a variable for aterm representing a DAG is occurring once on the lhsand doubled on the rhs, then the number of SLcategories occurring in the input term may be increasedin the resulting term.
For this reason an additionalcondition has to be defined which has to be full'tiled bythe lhs and rhs of each TR rule.
Every variableoccurring on the rhs has to occur on the ths.
The tworestrictions on 'IR rules allow for checking each rulefor termination after it has been defined or modified sothat the termination of the TRS can be guaranteed,because in every derivation step the number of SLcategories i reduced.
The derivation ends successfullyif no SL category occurs in the resulting term and thecorresponding tree can be generated by the corltext-freeTL grammar.The given termination condition fulfils the threeconstraints for termination (the input representationmust be built in a well-behaved compositional way,recursive input representations have to be consideredand the input should not be extended) discussed in \[vanNoord 901.If the termination condition should prove to beinadequate for the use in MT, qualitative orderings orcombinations of quantitative and qualitative orderingsmay be defined.
Up to now the given quantitativeordering has proved to be adequate for the TRSes ofour MT system.6 Conc lus ionThe TRS interpreter and aal editor for TRSes areimplemented in Arity Prolog on an AT compatible PC.The editor allows for a graphical input in DAGnotation, performs consistency checks on TR rules,checks the termination condition on TR rules,generates the corresponding terms and computes theapplication order by the means of the definitions givenin section 5.
TRSes have successfully been used forsemantic analysis, transfer, generation and for themapping from sentence semantic representations toconceptual representations in the experimental MTsystem of our project.
TRSes are to be used toimplement parsing in the near filturc.
First experimentsiu that direction have been encouraging.In the future the possibility of merging all TRSesdefined for the translation of one language into anotherto form one single TRS is to be investigated.
Theadvantage would be that the analysis depth willbecome flexible in the way that if the translation of afragment of the source language syntactic representa-tion is unambiguous, it can be directly translated intothe target language syntactic representatiou, withoutthe detour via the semantic representation.
This wouldbe possible for all levels of representation.Another point will be to check the possibility ofextracting reversible ports from one TRS and to usethem for the other translation direction.The interpreter, which uses the basic unificationalgorithm of \[Eisele/DOrre 86\] to superpose the inputterm with the the lhs of the TR rules, is intended to beexpanded with disjunction according to \[l)Srre/Eisele90\].With these additional features, term-rewriting is apowerful, elegant, complete and coherent device todescribe the relations between all levels ofrepresentation in machine translation systems.ACRES DE COL1NG-92, NANTES, 23-28 AO~r 1992 7 8 2 PROC.
OF COLING-92, NANTES, AUG. 23-28.
19927 References\[Busemann 90\]: S. Busemann: "Generiernngnatiirlieher Sprache mit Generalisierteu Phrasen-struktar-Grammatiken", KIT-Report 87, TechnicalUniversity of Berlin 1990\[Arnold et al 86\]: D.J.
Araold, S. Krauwer, M. Rosner,L.
de Tombe, G.B.
Varile: "The (C,A),T Framework inEUROTRA: A Theoretic.ally Committed Notation forMT", in: Procs.
l l th COLING-86, Bonn 1986, pp.297-303\[Busemann/Hauenschild 88\]: S. Buseinann, Ch.Hauenschild: "A Constructive View of GPSG or Howto Make it Work", in: Procs.
12th COL1NG-88,Budapest 1988, pp.
77-82\[Busenlann/Hauenschihl 89\]: S. Busemann, Ch.Hauenschihl: "From FAS Representations to GPSGStructures", in: S. Busemann, Ch.
Haueuschild and C.Umbach (eds.
): "Views of the Syntax/SemanticsInterface", Procs.
of the Workshop "GPSG andSemantics", KIT-Report 74, Technical University ofBerlin 1989, pp.
17 - 43\[Dershowitz 82\]: N. Dershowitz: "Orderings for Term-Rewriting Systems".
Theoretical Computer Science 17(1982), North-Holland, pp.
279 - 301\[Dershowitz 85\]: N. Dershowi~: "Termination", in:G.GOOs.
J. Hartmanis (eds.
): "Rewriting Techniquesand Applications", LNCS 202, Dijon, France 1985, pp.180 - 224\[D6rre/Eisele 90\]: J. I)6rre, A. Eisele: "Feature Logicwith Disjunctive Unification", in: Procs.
13thCOLING-90 (Vol.
2), Helsinki 1990, pp.
100-105\[Eisele/D6rre 86\]: A. Eisele, J. D0rre: "A LexicalFunctional Grammar System in Protog", in: Procs.
l l thCOLING-86, Bonn 1986, pp.
551-553\[EmelefZajac 89\]: M. Emele, R. Zajac, "RETIF: ARewriting System lot Typed Feature Structures", ATRTechnical Report TR-I-0071 1989\[Gazdar et al 851: G. G~dar, E. Klein, G. Pullum andI.
Sag: "Generalized Phrase Structure Grammar",Oxford, Blackwell 1985lHauenschild/Bnsemann 88\]: Ch.
Hauen~hild, S.Busemann: "A constructive version of GPSG formachine translation", in: E. Steiner, P. Schmidt and C.Zellinsky-Wibbelt (eds.
): "From Syntax to Semantics -Insights From Machine Translation", London, FrancesPinter 1988, pp.
216-238lHauenschild/Umbach 88\]: Ch.
Hauenschild, C.Umbach: "Funktor-Argument-Stmktur, Diesatzseman~scheRepr~entations- und Transferebeneim Projekt KIT-FAST", in: J. Schiltz (ed.
): "WorkshopSemantik und Transfer", EUROTRA-D WorkingPapers No.6, Saarbrilcken 1988, pp.
16-35\[HuetK)ppen 80\]: G. Huet, D. Oppen: "Equations andRewrite Rules", in: R.V.
Book (ed.
): "FormalLanguage Theory, Perspectives and Open Problems",Academic Press 1980, pp.
349-405\[KnutldBendix 70\]: D. IOmth, P. Bendix: "SimpleWord Problems ill Universal Algebras", in: J.
Le~h(ed.
): "Computational Problems in Abstract Algebra",Pergamon Press 1970, pp.
263-297\[Peltasou et al 751: C. Peltason, A. Schmiedel, C.Kindermanu, J. Quan~, "The BACK SystemRevisited", KIT-Report 75, Technical University ofBerlin 1989\]Russell et al 91\]: G. Russell, A. Ballim, D. Estival, S.Warwick-Amstrong, "A Language for the Statement ofBinary Relations over Feature Structures", in: Preos.
ofthe 5th Con|erence of file European Chapter of theACL, Berlin 1991, pp.
287-292\[Schmi~ ct al.
91\]: B. Schmitz, S. Preufl, C.Hauenschild: "Textrepr'asentatiou und Hintergrand-wissen fiir die Anaphernresolutiou im MaschinelleuUbersetzungssystem KIT-FAST", KIT-Report 93,Technical University of Berlin 1991ISh~u-p 881: R. Sharp, "CAT2 - Implementing aFormalism for Multi-Lingu',d MT", in: Procs.
of the2ud International Conference on Theoretical andMethodological Issues in Machine Translation ofNatural Languages, CMU Pittsburg 1988\[vau Noord 90\]: G. vua Noord: "ReversibleUnification Based Machine Translation", in: Procs.13th COLING-90 (Vol.
2), Helsinki 1990, pp.
299-304IWeisweber 89\]: W. Weisweber: "Transfer in MachineTranslation by Non-Confltlent Term-Rewrite Systems",in: Pfocs.
tff the 13th Gernmn Workshop on ArtificialIntelligence (GWAI-89), Eringerfeld, September 1989,pp.
264 - 269\[Weisweber/Hauen~hihl 90\]: W, Weisweber, Ch.Hauenschild: "A model of Multi-Level Transfer forMachiue Translation and Its Partial Re~dization", KIT-Report 77, Technical University of Berliu 1990 and toappear in: Procs.
of the Seminar "Computers &Translation '89", Tbilisi 1989\[Zajac 891: R. Zajac, "A Transfer Model Using a TypedFeature Structure Rewriting System with Inhuritance",in: Plots.
of the 271h Annual Meeting of the ACL,Vancouver 1989\[Zajac 90\]: R. Zajac, "A relational approach totranslation", in: Procs.
of the 3nd InternationalConference on Theoretical and Methodological Issuesin Machine Translation of Natural Languages, Austin1990\[Zajac 911: R. Zajac, "A Uniform Architecture forParsing, Generation and Transfer", in: T.
Strzalkowski(ed.
), Procs.
of the Workshop on Reversible Grammarin Natural Language Processing, Berkeley 1991, pp.71-80AC1T~ DE COLING-92, NANTJ~, 23-28 Aol)r 1992 7 8 3 PR()c:.
OF COLING-92, NAIXrIES.
AUG. 23-28, 1992
