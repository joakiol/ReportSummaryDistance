Flexible Speech Act Based Dialogue ManagementEl i  Hagen and F red  PopowichSchool of Comput ing ScienceSimon Fraser UniversityCanada V5A 1S6{hagen, popowich}@cs, sfu.
caAbstractWe present an application independent dialogueengine that reasons on application dependentknowledge sources to calculate predictions abouthow a dialogue might continue.
Predictions arelanguage independent and are translated into lan-guage dependent structures for recognition andsynthesis.
Further, we discuss how the predic-tions account for different kinds of dialogue, e.g.,question-answer or mixed initiative.1 In t roduct ionThe computerized spoken information systems (orSpoken Dialogue System--SDS) that we will con-sider in this paper are systems where a computeracts as the operator of some service and inter-acts with a user in natural anguage, e.g., switchboard, directory assistance, or ticket service.
Be-fore an SDS can provide its information, it needsto acquire data from the user, e.g., customer nameand number, birth date, service location, or ser-vice date.
We call these parameter values.
In anSDS they are acquired orally and speech recogni-tion is used to decode the speech signal into words.A dialogue manager facilitates the negotiationof parameter values between a user and an SDS.We emphasize keeping our dialogue manager ap-plication and language independent, hus we fac-tored out the independent information into twocomponents.
A dialogue ngine calculates pre-dictions for how to continue a dialogue from de-pendent knowledge sources (e.g., dialogue gram-mar and history, application description).
A prag-matic interpreter maps syntactic/semantic inter-pretation results onto predictions.Our predictions are called dialogue primitives;GEN-primitives predict system utterances andREC-primitives predict user utterances.
They arelanguage independent and on both the recogni-tion and the generation side, other modules trans-late them into language dependent s ructures.
Inthis paper, we will discuss the kinds of primi-tives our dialogue manager calculates and howREC-primitivesREC- ~,SIDE I speech 1 \[ syntac./sem.
\]recognizer ~ interpreter/ \'telephone\] primitives pragm, int.microphone I ~o~eGEN I enginepr imi t iv~~ \[ response i applicati?nI generator description+ dialoguestrategiesGEN-SIDEFigure 1: System architecture of our SDS.
Thearcs indicate information flow.they account for different kinds of dialogue, e.g.,question-answer or mixed initiative.2 BackgroundFirst, we discuss our system architecture and dataflow between modules.
Second, we present the ap-plication description of a movie service, which wewill use for the examples in later sections.
Third,we present some of our current primitives, and fi-naUy, we describe the dialogue engine and how ituses the application description and other sourcesto calculate dialogue primitives.2.1 System ArchitectureOur system architecture is presented in Figure 1.The dialogue manager takes an application de-scription (Section 2.2) and a set of dialogue strate-gies (Sections 3and 4) as input--both provided bythe service designer.
The application descriptiondescribes the parameters needed by the serviceand is necessarily application dependent.
The di-alogue strategies contain directions for how the di-alogue shall proceed in certain situations.
For ex-ample, whether to ask for confirmation or spellingof a badly recognized parameter value or whether131to generate system or user directed dialogue.The output of our dialogue manager is a bagof abstract, language independent primitives.
Onthe generation side they encode the next sys-tem utterance and a response generator trans-lates the GEN-primitives into text, which is thensynthesized.
On the recognition side, the REC-primitives represent the dialogue manager's pre-dictions about the next user utterance.
REC-primitives are translated into (recognition) con-texts and grammars for speech recognition andthey may activate sub-components of a synsemgrammar.
After speech recognition has takenplace, the dialogue ngine must be told which pre-dictions came true, thus the pragmatic interpretermaps the output of synsem interpreter onto a sub-bag of REC-primitives, which is then returned tothe dialogue engine for further processing (Sec-tion 2.4).2.2 Appl icat ion Descr ipt ionThe application description (AD) specifies thetasks that a service can solve and the parame-ter values needed to solve them.
The AD for amovie service is presented in Figure 2.
Our repre-sentation is an extended version of and-or trees 1and in Figure 2, the U-shaped symbols representand-relations, while the V-shaped symbols repre-sent or-relations.
Thus, this movie service canperform three tasks: selling tickets or providingmovie or theatre information.
If the user wantsto buy tickets, the system needs to acquire six pa-rarneter values, e.g., the show time, the date, andthe name of the film.
Date and show time canbe acquired in several ways.
For example, a datecan be a simple date (e.g., "November 17th ~) ora combination of day of the week and week (e.g.,"Wednesday this week.
").The nodes keep state information.
Open nodeshave not yet been negotiated, topic nodes are be-ing negotiated, and closed nodes have been negoti-ated.
The currently active task has status active.Parameters can be retrieved through the func-tions activeTask(AD), openParams(AD), closed-Params(AD), and topicParams(AD).
Status(p)returns the status of parameter p. tasks(AD) andparams(AD) return the task and parameter nodes.Similar hierarchical domain descriptions havebeen suggested in (Young et al, 1990) for a navaldomain and in (Caminero-Gil et al, 1996) for ane-mall assistance domain.
A tree-like organiza-tion of the domain is sufficent for the informationretrieval domains, which we are currently consid-ering.
We expect, however, that in future work we1Extensions include has-a relations.movie servicemovieInfot buyTicketst theatreInfotTicketspTimep timep dat% k~_~we ewee kpDay PF igure 2: A description of a movie service.
No-tation: U and v represent and/or-relations.
Sub-scripts t and p denote tasks and parameters.will need to switch to a semantic network struc-ture or since our future research includes auto-matic generation of system utterances from ourdialogue primitives, we hope to be able to uti-lize the ontology and domain organization work,which has proven so useful for text generation(Bateman et al, 1994; Bateman et al, 1995), forboth dialogue management and text generation.2.3 Dialogue Pr imi t ivesFollowing the procedure outlined in Section 2.4,the dialogue manager calculates a bag of primi-tives for each turn and speaker.
Our current col-lection is motivated through our experience withseveral domains, e.g., movie service, horoscopeservice, and directory assistance.
The collectionis not exhaustive and we will add primitives aswider dialogue coverage is required.Notat ion:  A primitive is written prim-Name(p=v,n), where primName is its name; p Eparams(AD) U {aTask}; aTask is a special param-eter whose values E tasks(AD); v is the value of p;and n is an integer denoting the number of timesa primitive has been uttered.
If v is uninstanti-ated, it is left out for readability.
Unless otherwisestated, p E params(AD).2.3.1 GEN-Pr imi t ivesOur current GEN-primitives:salutation(p=v): system opens or closes the inter-action, p E {hello, goodbye}, v E {morning, day,evening}.requestValue(p): system requests a value for theparamter p. p E params(AD) U {aTask}.requestValue(p=v): system asks whether the valuev of parameter p is correct.
If this form is used, thesystem has a list of alternative values for p, and132v is not a recognition result (e.g., Frankfurt amMain or Frankfurt an der Oder where Frankfurtis the recognition result.
)requestValue(aTask=v), v E tasks(AD) U {repeat-PreServiceTask, useService, repeatService}: systemrequests a value for aTask.
I f  v E {repeatPre-ServiceTask, useService, repeatService}, the systemrequests whether the user wants the pre-servicetask repeated, the service started (first task afterpre-service task), or a new task started.requestConfirm(p=v): system asks whether thevalue v of parameter p is correct, v is a recog-nition result, p E params(AD) U {aTask}.
Am-bignous results not resulting from speech recog-nition, e.g., Frankfurt am Main vs. ~zauldurt ander Oder, would yield multiple requestValue(p=v)primitives.requestValueABC(p): system requests the spellingof the value of parameter p.requestParam(p=v): system asks whether thevalue v is a value for parameter p.evaluate(p=v) : system acknowledges value v ofparameter p.promise(p=v): system promises to attempt toanswer the user's request, p E params(AD) U{aTask}.
v E {pleaseWait}.
Only used after nav-igate(), requestParam 0 or requestAIternative 0 ifthe user has to wait long for a reply.inform(aTask=v): system informs about the ac-quired database results, v E aetiveTask(AD) U{tooMany, zero}.
If v = activeTask(AD), thereare several answers, if v = tooMany/zero, thereare either too many answers to be enumerated orzero answers.inform(aTask=n): system presents the n'th answerto the query t. n > 0inforrnAIternative(p): system informs that thereare several possible values for p. p E params(AD)U {aTask}.
v E {tooMany, null}.
If v = tooMany,there are too many alternatives to be enumerated.v = null, means that v is uninstantiated, not thatthere are zero alternatives.inforrnAIternative(p=v): system informs that apossible value of p is v. p E params(AD) U{aTask}.informNegative(p): system infolds that the usermisrecognized something, p E params(AD) U{aTask}.informPositive(p): system informs that the userrecognized something correctly, p E params(AD)U {aTask}.withdraw(p): system withdraws from dialogue forreason p E {error} before it has started negotia-tions.withdrawOffer(aTask=v): system withdraws an of-fer for reason v E {error}.withdrawPrornise(aTask=v): system withdraws apromise for reason v E {error}.In Section 3, we present several sample instan-tiations of the primitives.2.3.2 REC-Pr imit ivesOur current REC-primitives:requestParam(p): user requests which parameterthe system requested, p E params(AD) U {null}.requestAIternatives(p): user requests possible val-ues for parameter p.requestConffirm(aTask=n): user asks system toconfirm an answer that it has given, e.g., "Wasthe first answer $30?"
0 < n < no of query results.informValue(p=v): user provides value v for pa-rameter p. p was requested.
2informExtraValue(p=v): user provides value v forparameter p. p was not requested in the preceedingsystem utterance.informValueABC(p=v): user spells the value v ofparameter p. The spelling is expanded by synsemand expansions are presented to the dialogue man-ager.
2inforrnPositive(p=v): user confirms that the valueof parameter p is v. p E params(AD) U {aTask}.informNegative(p=v): user disconfirms that thevalue of parameter p is v. p E params(AD) U{aTask}.correctValue(p=v): user corrects a misrecognizedvalue.
Often used together with informNegative.For example, "Hamburg, not Homburg.
"2informGarbage(p): user says something but recog-nizer and/or  synsem could not make sense out ofit.changeValue(p=v): user changes the value of pa-rameter p to v instead of v'.
2repeatValue(p=v): user repeats the value v of pa-rameter p.2correctPararn(p=v): user corrects that v is thevalue of p, not p'.disambiguate(p=v): user chooses v as the value ofp when presented with a choice between severalvalues for p. p E params(AD) U {aTask}.2The pragmatic interpreter instantiates v.133rejectValue(p=v): the user has been given a se-ries of alternatives and chooses p=:v'.
Primitive iscombined with disambiguate(p=v').navigate(aTask=v): user navigates in the query re-sults, v E {forward, backward, repeat, n} where 0n < no of query results.
2rejectRequest(p=v): user ignores or does not hearthe system request, v E {null, didNotHear}.rejectOffer(aTask=v): user ignores or does nothear the system offer, v E tasks(AD) U {null, did-NotHear}.evaluate(t=v): user evaluates an answer she hasreceived, v E {positive, neutral, negative, cancel}.cancel is used to end the current dialogue after atleast one answer has been given ~md start a newone without calling again.promise(p): user promises to find a value for p.withdrawAccept(aTask=v): user ,mthdraws fromthe conversation for reason v E {cancel, hangup}.With cancel, the user ends the current dialoguebefore an answer has been given and starts a newtask Without calling again.
2withdrawPromise(p=v): user withd.raws a promiseto provide a value for reason v E {cancel,hangup}.
2withdrawRequest(p=v): user withdraws a request.p E params(AD) U {forward, backward, repeat, andn}.
2null(): returned to the dialogue manager if the,user does not say anything and is not ezpected tosay anything, e.g., after a greeting or promise.In Section 3, we present several sample instan-tiations of the primitives.2.4 D ia logue Eng ineThe dialogue engine (Hagen, 1999) consists of areasoning engine and several knowledge sources:An AD defines an application's data-needs, a di-alogue grammar defines how a dialogue may pro-ceed at the level of speech acts, and a dialoguehistory is a dynamically growing parse tree of anon-going dialogue with respect to the dialoguegrammar.
Other knowledge sources may be re-quired, for instance, recognition confidence or dis-ambiguation of city names.The dialogue ngine calculates the next turn byconsulting and combining information from theknowledge sources.
It consults with the dialoguehistory and the dialogue grammar in order to cal-culate which speech acts may continue a dialogue.Speech acts have no propositional content, thusin the context of the current dialogue history andthe state of the application description, they aretranslated into dialogue primitives, which havecontent, for example, the name of a parameterand a potential value for this parameter.
Here wewill walk through an example of how some prim-itives are calculated in a simple question-answerdialogue.Example :  For our example we will use the ADin Figure 2.
Assume that the task has alreadybeen negotiated and set to theatre information(i.e., activeTask(AD) = theatrelnfo), i.e., the sys-tem needs to acquire the name of the theatre andthe name of the city.
All other nodes in the ADare closed since they are not relevant o this task.The speech act  g rammar  used in our systemis presented in Appendix A but we will use atrivial grammar for the example.
It can accountfor simple question-answer dialogues where arequest from the system (sys) is followed by aninform from the user (usr).
The system canrespond to the inform with a sub-dialogue: sDialogue(sys)--~(request(sys) + Inform(usr))*Inform(usr)--+inform(usr) + \[Dialogue(sys)\]The d ia logue h i s to ry  reflects all previous ne-gotiations (here: task theatreinfo).Dialogue(sys)request(sys) ..
Inform(usr)requestValue(task)intprm.
(usr) .
.
,informValue(task=theatrelnto)The next turn can be rooted in either theInform(usr) after the inform(usr) or in the Dia-Iogue(sys) after Inform(usr).With all the above knowledge sources in place,the calculation of the next dialogue turn can start:1.
The last speech act in the dialogue historygives us a starting point in the grammar, thusmoving forward from inform(usr), the next atomicspeech act is request(sys)--either as a flat struc-ture (i.e., request(sys) off Dialogue(sys)) or in asub-dialogue (i.e., Dialogue(sys)-I-request(sys) offInform(usr)).2.
Knowing that  the system can request some-thing, the dialogue engine consults with the ADfor what the system can ask about.
The flatstrucutre (request(us)) represents negotiation ofthe task but since we assume that negotiation ofthe task is complete (i.e., Status(theatrelnfo) = ac-tive), this speech act is not interpreted into a prim-SThe star ( ')  means that a dialogue may containseveral request(sys) -I- Inform(usr) sequences.
Lower-case speech acts are atomic, while others are complex.The dialogue in square brackets (\[\]) is optional.134itive.
Next we consider the sub-diaJogue struc-ture.
Both children of theatrelnfo are open (i.e.,they have not been negotiatied yet) thus the sys-tem randomly chooses to pursue city whose stateis changed to topic.
The speech act and the pa-rameter are combined into the primitive request-Value(city)--request a value for the parameter city(e.g., "In which city is the theatre?").
We choseto use the sub-dialogue structure instead of theflat strucutre to represent negotiation of parame-ter values since they are subordinate to the taskin the sense that the task dictates which parame-ter values are needed.
This is also the case for thereal gammar (Appendix A).3.
The primitive requestValue(city) is added tothe dialogue history:Dialogue(sys)Jrequest(sys) I nform(usr)requestValue(task) jintorm(usr) Dialogue(sys)inform Value(task=theatrelnfo)request(sys) .requestValue(city)4.
Starting from request(sys), the grammarstates that inform(usr) (i.e., Inform(usr) + in-form(usr)) is the next speech act in the dialogue.requestValue(city) was the last primitive spoken.Reasoning that a user-inform in response to a sys-tem requestValue should involve the same parame-ter as the system's requestValue, the information iscombined to form the primitive informValue(city),i.e., the user should respond to the system requestwith a value for the parameter city.
Let's assumethat the user replied "Hong Kong", thus the dia-logue history is expanded:Dialogue(sys)request (sys) ., Inform(usr)req uestVa lue (task),...-.intorm(u.sr).
.
o .Dialogue(sys)in formValue(task=theatre lnto)  /request(sys) .
Inform(usr)requestValue(city)intorm(usr~informValue(city& Hohg Kong)5.
Starting ~om inform(usr), the grammar re-turns reques't(sys) and Dialogue(sys)-t-request(sys).Since a recogniton result is available from the pre-vious turn, the engine checks its recogution con-fidence.
If it is high, it would consider the nego-tiation of city finished, change its state to closed,and discard Dialogue(sys)+request(sys) since thereis nothing to be requested about a closed param-eter.
It would translate request(sys) into request-Value(theatre) since theatre is the only remainingopen parameter.If confidence is low, the dialogue enginemay decide to ask the user to confirmthe recognized value.
In which case, Dia-Iogue(sys)+request(sys) would be interpreted intorequestConfirm(city=Hong Kong).
Whether re-quest(sys) would be interpreted or not dependson the dialogue strategies chosen by the servicedesigner (see Sections 3 and 4).If confidence is extremely low, the dialogue n-gine may decide to repeat he question.
In whichcase, request(sys) would be interpreted into re-questValue(city, 2), while the sub-dialogue struc-ture would be discarded.6.
Any interpretation f the flat strucutre wouldresult in the following addition to the last Dia-Iogue(sys) in the dialogue history.IDialogue(sys)request(sys) .
Inform(usr) recluest(sys)requestValue(city) iinfgrm(u.sr) .
?informValue(city= Hong I~.ong)Our example shows how a speech act can resultin several primitives depending on the context andthus how the dialogue manager dynamically reactsto external events.
Although this brief descriptionmay not show it, our dialogue manager can handlemixed initiative dialogue (Hagen, 1999).
In (Ha-gen, 1999), we also present our theory of taking,keeping, and relinquishing the initiative.Heisterkamp and McGlashan (1996) presentedan approach that uses a similar division of func-tionality as we do: task (=application), contex-tual (=synsem + pragmatic), and pragmatic in-terpretation (=dialogue ngine).
They also useabstract parameterized units similar to ours, butthey do not use a speech act grammar to cal-culate the units.
Rather, they map contex-tual functions onto dialogue goals, e.g., the func-tion new_for_system(gaalcity:munich) ntroducesthe dialogue goal confirm(goalcity:munich).
Interms of our primitievs this could be expressed asrequestConfirm 0 follows informValue 0.
We choosenot to start our modelling at this level since wewant to be able to vary what follows informValue0,e.g., requestConfirmO, requestValueABCO, or eval-uate().3 Pr imi t ives  in  UseConceptually, GEN-primitives are calculated firstand then a bag of possible responses (REC-primitives).
One dialogue primitive correspondsto one information unit or communicative goal,135GEN-Pr imi t iverequestValue(film)requestConfi rm(theatre=Ridge)REC-Primit ivesinformValue(filrn)rejectRequest(film)withd rawAccept (aTask=hangup)withd rawAccept(aTask=cancel)inform Positive(theatre=Ridge)inform Negative(theatre=Ridge)rejectReq uest(theatre=Ridge)withdrawAccept(aTask=ha ngup)withdrawAccept(aTask=cancel)Table 1: REC-primitives calculated in responseto two GEN-primitives in Dialogue 1.e.g., in an information retrieval setting: provid-ing or requesting one piece of infi)rmation.
Prim-itives can be used individually or combined to ac-count for more complex dialogue.
Whether andhow they are combined epends on the dialoguestrategies specified by the service designer.
In thisand the following section, we will examine severalsuch strategies and show how the primitives arecombined to achieve them.3.1 Quest ion-Answer DialogueIn the simplest case, the service designer wants astrickt question-answer dialogue: 4Dia logue 1: Question-AnswerSys: "Which film do you want to see?
"req uest:Value(film)Usr: "The Matrix.
At the Ridge.
"Int: informValue(film= Matrix)Sys: "Which theatre?
"requestValue(theatre)Usr: "Ridge.
R I D G E."Int: "mformValue(theatre=Ridge).
,,Sys: "Did you say The Ridge?requestConfi rm(theatre= Ridge)Usr: ~Yes.
R I D G E."Int: inform Positive(theatre= Ridge.
)For this type of dialogue, only the REC-primitives representing direct answers, rejects,and withdraws are calculated.
In Table 1, wepresent those calculated in response to thefirst and the third system turn.
We see that,after requestValue(film), only iinformValue(film)is calculated and the pragmatic', interpreter hasno chance to detect "At the Ridge" (even ifsynsem parsed it correctly) since there is no in-formExtraValue(theatre) available to map it onto.Similarly, after requescConfirm(theatre=Ridge)only informPositive(theatre=Ridge) and in-formNegative(theatre=Ridge) are available and"R I D G E" cannot be detected since there is noinformValueABC(city) primitive present.41n the sample dialogues, 'Sys' means system turn,'Usr' means user turn, and 'Int' means primitives rec-ognized and sent back to the dialogue engine from thepragmatic interpreter.GEN-Primit iverequestValue(film)requestConfirm(theatre=Ridge)PdgC-PrimitivesinforrnValue(film)rejectReq uest(film)inform ExtraValueValue(time)informExtraValue(theatre)inforrn Ext raVal ue(city)inform ExtraValue(noOfTickets)inforrnExtraValue(date)withd rawAccept(aTask=v) =inform Positive(theatre= Ridge)inform Negative(theatre=Ridge)rejectReq uest(theatre=Ridge)inform Ext raVal ue(ti m e)inform ExtraValue(city)informExtraValue(noOfTickets)inform ExtraValue(date)withdrawAccept(aTask=v) a=Vv E {cancel, hangup}Table 2: REC-primitives calculated in responseto two GEN-primitives in Dialogue 2.3.2 Over -Answer ingIn our experience, users frequently provide moreinformation than explicitly asked for, thus a moreflexible dialogue strategy would be to allow over-answering and Dialogue 1 could have developed asfollows:Dia logue 2: Over-AnsweringSys: "Which film do you want to see?
"requestValue(film)Usr: =Matrix.
At the Ridge.
R I D G E."Int: informValue(film= Matrix)+ informExtraValue(theatre=The Ridge)Sys: "Did you say The Ridge?
"req uestConfi rrn (theatre= Ridge)Usr: "Yes, and I want the late show.
"Int: informPositive(theatre=Ridge)+ informExtraValue(time=9P M)In Table 2, we present he REC-primitives cal-culated in response to the same system turns asin Dialogue 1.
In Dialogue 2, only over-answeringof requestValue 0 primitives were allowed, thus"R I D G E" could still not be accounted for.3.3 Complex Mixed Init iativeHere we consider the most complex dialogue strat-egy that we can currently offer: The system is ableto account for complex mixed initiative dialogue(at least from a dialogue point of view), i.e., theuser can requst clarifications, over-answer, changevalues, repeat values, correct values, spell values,and reject requests as she pleases.D ia logue 3: Complex Mixed InitiativeSys: "Which ~Irn do you want to see?
"requestValue(film)Usr: =Sorry, did you ask for the time?
"Int: requestParam(time)Sys: =No.
Which film do you want to see?
"informNegative(time) + requestValue(film, 2)136Dia logue 3 cont 'd .Usr: "Matrix.
At the Ridge.
"Int: informValue(film= M atrix)+ informExtraValue(theatre=The Ridge)Sys: "Did you say The Ridge?
"requestConfirm (theatre=Ridge, 1)Usr: "Sorry, I didn't hear that.
"Int: rejectReq uest(theatre=didNotHear)Sys: "Did you say The Ridge?
"requestConfirm(theatre= Ridge, 2)Usr: "Yes, The Ridge.
R I D G E."Int: inform Positive(theatre= Ridge)+ repeatValue(theatre= Ridge)+ informValueABC(theatre=Ridge)Sys: "Ok. What time?
"evaluate(theatre=Ridge)+ requestValue(time)Usr: "I don't know.
What are the alternatives?
"Int: req uestAIternatives(time)Sys: "18:30 or 21:00.
"informAlternative(time=18:30)+ informAIternative(time=21:00)Usr: "Ok, two tickets for the late show tomorrow.
"Int: evaluate(time=neutral)-l.- inform ExtraValue(noOfTickets=2)+ informValue(time=21:00)+ informExtraValue(date=July 4)Sys: "Did you say two tickets?
"req uestConfirm(noOfTickets=2)?
Usr: "Yes, but I change to the early show.
"Int: inform Positive(noOfTickets=2)+ changeValue(time=18:30)In Table 3, we present he REC-primitives cal-culated in response to two system utterances.3.4 Mu l t i - Funct iona l  TurnsIt has been argued that speech act grammars can-not be used to describe dialogue since utterancescan be multi-functional or encode more than onespeech act; Speech act grammars can typically bein only one state at a time, thus they cannot cap-ture this phenomenon (Levinson, 1981).
In aninformation retrieval setting such situations oc-cur, for example, when users disregard the systemutterance and provide unrelated information orwhen a recogniton mistake occured and the sytemasks for confirmation.
Instead of answering yes orno, users frequently answer with the correct value,which implicitly disconfirms the previous value:D ia logue 4: Multi-Functional UtterancesSys: "How many tickets?
"req uestVal ue(noOfTickets)Usr: "I want tickets for July 4.
"I.ut: reject Request (noOf'l'ickets)+ informExtraValue(date-~July 3)Sys: "Did you say July 3?
"requestConfirm (date=July 3)Usr: "Tomorrow!
"Int: informNegative(date=July 3)-t- correctValue(date=July 4)In the first utterance, the user both ignores thesystem utterance and provides ome information.In the second one, she negated and correctd thesystem suggestion with a single word.GEN-Pr imit iverequestValue(film)requestConfirm(theatre=Ridge)REC-Primit ivesinformValue(film)informValueABC(film)requestAIternatives(film)promise(film)rejectRequest(film=v) =informGarbage(film)requestParam(p) binformExtraValue(p) binformValueABC(p) brepeatValue(p) ~changeValue(p) cwithdrawAccept(aTask=v) dinform Positive(theatre---- Ridge)repeatValue(theatre=Ridge)informNegative(theatre----Ridge)correctValue(theatre)informValueABC (theatre)rejectRequest(theatre=v) ainform Garbage(theatre)informExtraValue(p) binformValueABC(p) brepeatValue(p) ?changeValue(p) cwithd rawAccept(aTask=v) 'd=Vv E {null, didNotHear}~VpE openParams(AD)VpE closedParams(AD)~Vv E {cancel, hangup}Table 3: REC-primitives calculated in responseto two GEN-primitives in Dialogue 3.Since we are not using the speech act grammardirectly and instead interpret he speech acts intoa bag of primitives, we can assign as many prim-itives to an utterance as necessary and are notbound by the states dictated by a grammar.
Thisaspect of our approach becomes even more inter-esting when the system combines everal primi-tives in its utterance (Section 4).4 D ia logue  St ra teg iesAlthough, the procedure outlined in Section 2.4,only shows how to calculate one primitive per sys-tem turn, the approach is, of course, not limitedto this.
The service designer can decide to em-ploy mixed initiative dialogue strategies for thesystem utterances as well, for example, requestingor confirming several values at once or implicitlyconfirming values.
The dialogue strategies for sys-tem utterances include choosing nodes in the ap-plication description, dealing with speech recogni-tion results, or dealing with ambiguous data fromother knowledge sources.
Here we present a fewexamples of how the dialogue manager would com-bine hypotheses (for more information see (Hagen,2001)).1374.1 Conf i rmation StrategiesWe illustrate implicit and multiple confirmation,i.e., the system realizes requestValue and request-Confirm or multiple requestConfirm primitives inone utterance:Dialogue 5: Confirmation StrategiesSys: "Which showing of The Mal;rix do you want?
"requestValue(time)-I- requestConfi rm (film= Matrix)Usr: "(No.)
Buena Vista!
"Int: informNegative(film=The Mzttrix)+ correct:Value(film=Buena Vista)+ reject:Request(time)Sys: "Which showing of Buena Vista do you want?
"requestConfirm(film=Buena 'Vista)+ requestValue(time)Usr: =The late show.
Tomorrow.
:~Int: inforrnPositive(film=Buena Vista)informValue(time=21:00)+ infformExtraValue(date=8 October)Sys: "Did you say 21:00 today?
"requestConflrm (time=21:00) =requestConfirm(date=October 7)Usr: "No.
Tomorrow.
"Int: inform Positive(time=21:00)-I- informNegative(date= October 7)+ correctValue(date=October 8)For the first two utterances, the system has arecognition result for the parameter film with alow recognition score.
Consequently, it calculatesrequestConfirm(film=Matrix/Buena Vista).
Addi-tionally, there are still open parameter nodes inthe AD, thus the dialogue engine picks one (ei-ther at random or if the service designer hasordered them, the next one) and calculates arequestValue primitive, here requestValue(time).If the service designer allows implicit confirma-tion, the two primitives are combined and ut-tered together in one turn.
If the service de.signer does not allow implicit confirmation, thedialogue engine continues the dialogue with thetopic that has alread been introduced, i.e., re.questConfirm (film= Matrix/Buena Vista).
5For its last utterance, the system has two recog-nition results with a low recognition score, thusfor each one of them it calculates a requestConfirmprimitive.
If the service designer, allows multipleconfirmations, they are combined and realized asone utterance.
If not, the dialogue ngine choosesrequestConfirm(time=21:00), since this topic wasintroduces first.
If topics are introduced in thesame utterance, it pickes one at random.4.2 AD Based StrategiesWhen requesting parameter values from the user,the system consults the application description forSThis is a conceptual account.
In the implemen-tation, the requestValue primitive would not be cal-cualted at all, if the service designer does not allowimplicit confirmation.open nodes.
If there are several open nodes, thedialogue manager can decide to keep the initiativeand produce several primitives, which can be com-bined into one turn.
If the nodes are joined withan or-relation, the text generator would trans-late the primitives into an utterance offering al-ternative ways of entering the same information.For example, "Please tell me the show time orearly or late show."
(requestValue(time) + re-questValue(namedTime)).
If the nodes are joinedwith an and- or a has-a relation, the text gen-erator would translate the primitives into an ut-terances requesting several different pieces of in-formation.
For example, "What is the name ofthe city and the theatre?"
(requestValue(city) +requestValue(theatre)).As seen in the application descriptions theremay be several ways of acquiring aparticular valuee.g., date and time in Figure 2.
If a parametervalue is recognized with a low score, the servicedesigner can decide whether the system shall con-tinue processing the original parameter o  whetherit shall switch to one of the alternative ones.
Thusafter a bad recognition of date, the system canswitch strategy and request weekDay and week in-stead.Which strategies to follow is decided by the ser-vice designer through a set of switches in the dia-logue strategies specification file (Figure 1).5 P ragmat ic  In terpreterAfter synsem interpretation, the user utterancemust be mapped onto dialogue primitives.
A bagof REC-primitives is calculated for each user ut-terance and the pragmatic interpreter must assurethat the utterance is mapped onto primitives inthis bag.
There is always a mapping.
The rejectand withdraw primitives are always part of the bagthus in the worst case, the user utterance wouldbe mapped onto one of these.Since primitives in their uninstantiated form areapplication independent, we can develop genericrules for this mapping.
In other words, the rulesdefine how the dialogue strategies presented inSection 3 are mapped onto primitives and how weaccount for several primitives per utterance.A rule has the form: GEN-Primitives A user ut-terance =~- REC-primitives.
In Table 4, we presenttwo rules for implicit confirmation.
The first onecorresponds tothe first sys/usr pair in Dialogue 5.The user responds with a new value vs (BuenaVista) for P2 (film) in requestConfirm(p2=v2)and thereby disconfirms v2 (Matrix) and re-jects the request for a value for Pl (time) inrequestValue(pl).
The second rule corresponds to138GEN-PrimitivesrequestValue(p~)V1 < i _< maxireq uestConf.
(pj =vj )Vl < j < max#requestValue(pi)V1 < i < maxirequestConf.
(p# =vj)V1 _< j < max#I nput(no)pj~vt~vz ~ vj,Vjl< j _<k ~ ma.xjVil_<i_<k _< =axil~EC-Pr imit ivesinformNeg.
(pj =v./)Y j l< j<kcorrectVal.
(pj =vl)Y j l< j<kinformPos.
(pj =v# )W k < j < max jrejectRequest(pi)V1 < i _< maxlinformVal.
(pi=vi)Vi l< i<kinformPos.
(pj =vj)Vl _< j < maxjrejectRequest(pi)Vi k < i < maxiTable 4: Mapping of userprimitives, p=v means thatvalue v for param p.input onto REC-the user providedthe second sys/usr pair in Dialogue 5.
The userprovides value vx (the late show) for Pl (time)in requestValue(pl) and thus confirms v2 (BuenaVista) in requestConfirm(p2=v2).
For instanti-afion of the primitives, see Dialogue 5.
Here,we only presented two examples.
Similar ruleswere developed for all our primitives and dialoguestrategies (see (Hagen, 2001)).One reviewer asked whether we can modify theapproach such that expectations can be overrid-den if there is sufficently good information fromthe synsem module.
The short answer is that wecould (re-)calcnlate the primitives pretending thatthe service designer allowed mixed initiative re-gardless of the dialogue strategies actually chosen.W~, however, think it is important to give her theright to decide.
For example, if she has decidedthat over-answering is allowed, informExtraValue0primitives for all parameters whose status is stillopen would be calculated and thus there is noth-ing to override.
If, however, the service designerhas decided that over-answering is not allowed, weassume that she had good reasons for doing thatand the dialogue manager will not try to overrulethis decision.6 ConclusionWe have presented some results from our researchon spoken dialogue management.
We concen-trated on how to dynamically calculate a collec-tion of predictions for how to continue a dialogue(dialogue primitives), how to account for differ-ent dialogue strategies and utterances with sev-eral communicative goals through combinations ofprimitives, and how to map the user utterancesonto primitives.
The approach as been imple-mented and tested in several prototype systems,e.g., horoscope, movie, and telephone rate service(Feldes et al, 1998).Dialogue grammars have previously been usedto manage dialogue (Bunt, 1989; Bilange, 1991;Traum and Hinkelman, 1992; JSnsson, 1993; Mastet al, 1994; Novick and Sutton, 1994; Chino andTsuboi, 1996), but we are not aware of an ap-proach where speech acts are translated into acollection of primitives with propositional content.Previous grammar approaches use the speech actsdirectly or assume a one-to-one correspondencebetween utterance and speech act.Through the natural division of the knowledgeinto type and content, we have achieved a flex-ible dialogue manager that adapts to users' be-haviour.
We can take advantage of the predictivecapabilites of speech act grammars and still beable to account for multi-functional utterances.We have also demonstrated that our approachis flexible: 1. the dialogue engine, the pragmaticinterpreter, the primitives and the algorithm formapping user utterances onto predictions are ap-plication and language independent, which makesit easy to reuse our dialogue manager in new ap-plications, and 2. the dialogue manager can easilyaccount for several types of dialogue, e.g., strictquestion-answer or mixed initiative.
We give theservice designer the freedom to decide which kindof dialogue she wants---on a high level--and thedialogue manager combines the basic primitivesaccordingly.Future work includes empirical testing to ver-ify whether we are calculating appropriate predic-tions.
Also, several aspects of our dialogue gram-mar have not yet been translated into primitives,for example, the frequent use of assert in natu-ral dialogue.
As a wider dialogue coverage is re-quired, we will add primitives accordingly.
We arealso working on using the primities as input to amulti-lingual automatic text generation system.AcknowledgementsThe author thanks the three anonymous reviewersfor their helpful comments on the first draft ofthis paper.
Financial support from the NorwegianResearch Council, project number 116578/410 isgreatly appreciated.ReferencesJ.A.
Bateman, B. Magnini, and F. Rinaldi.
1994.The generalized {Italian, German, English} up-per model.
In Proe.
of the ECAI9J Workshop:Comparison of Implemented Ontologies, Ams-terdam, The Netherlands.139J.A.
Bateman, B. Maguini, and G. Fabris.1995.
The generalized upper model knowledgebase: Organization and use.
In Proc.
of theConf.
on Knowledge Representation a d Shar-ing, Twente, The Netherlands.E- Bilange.
1991.
A task independent oral dia-logue model.
In Proc.
of the Euro.
Conf.
of theACL, pages 83-87.H.C.
Bunt.
1989.
Information dialogues as com-municative action in relation to.
partner model-ing and information processing.
In M.M.
Tay-lor, F. Neel, and D.G.
BouwhLfis, editors, TheStructure of Multimodal Dialogue, pages 47-73.North-Holland, Amsterdam.J.
Caminero-Gil, J. Alvarez-Cercadillo, C. Crespo-Casas, and D. Tapias-Merino.
1996.
Data-driven discourse modeling for semantic in-terpretation.
In Proe.
of 1996 Intl.
Conf.on Acoustics, Speech, and Signal Processing(ICASSP'96), pages 401-404.T.
Chino and H. Tsuboi.
1996.
A new discoursemodel for spontaneous spoken dialogue.
In1021-1024, editor, Proc.
of the 1996 Intl.
Conf.on Spoken Language Processing {ICSLP'96).S.
Feldes, G. Fries, E. Hagen, and A. Wirth.
1998.A novel service creation enviromnent for speechenabled database access.
In Proc.
~th IEEEWorkshop on Interactive Voice Technology forTelecommunications Applications (IVTTA '98),29-30 Sept. 1998, Torino, Italy.E.
Hagen.
1999.
An approach to mixed ini-: tiative spoken information retrieval dialogue.User Modeling and User-Adapted Interaction,9(1/2):167-213.E.
Hagen.
2001.
Mixed Initiative Spoken DialogueManagement in Information Systems.
Ph.D.thesis, School of Computing Science, SimonFraser University, Burnaby, BC, Canada.
Jan.2001 expected.P.
Heisterkamp and S. McGlashan.
1996.
Unitsof dialogue management.
In Proc.
of the 1996Intl.
Conf.
on Spoken Language Processing (IC-SLP'96).A.
JSnsson.
1993.
A dialogue manager usinginitiative-response units and distributed con-trol.
In Proc.
of 6th Euro.
Conf.
of the A CL,pages 233-238.S.C.
Levinson.
1981.
Some pre-observations onthe modelling of dialogue.
Discourse Processes,4:93-116.M.
Mast, F. Kummert, U. Ehrlich, G.A.
Fink,T.
Kuhn, H. Niemann, and G. Sagerer.
1994.Prosody takes over: Towards a prosodicallyguided dialog system.
Speech Communication,15(1-2):155-167.D.G.
Novick and S. Sutton.
1994.
An empiricalmodel of acknowledgement for spoken-languagesystems.
In Proc.
of the 32nd Annual Meetingof the ACL, pages 96-101.S.
Sitter and A. Stein.
1992.
Modelling the il-locutionary aspects of information-seeking di-alogues.
Information Processing and Manage-ment, 8(2):165-180.D.
'I~aum and E. Hinkelman.
1992.
Conversationacts in task-oriented spoken dialogue.
Compu-tational Intelligence, 8(3):575-599.S.
Young, A. Hauptmann, W. Ward, E. Smith,and P. Werner.
1990.
High-level knowledgesources in usable speech recognition systems.In A. Walbel and K. Lee, editors, Readingsin Speech Recognition, pages 538-549.
MorganKaufman, San Mateo, CA.A .
The  Complete  D ia logue  GrammarThe complete grammar is a slightly modifiedversion of the grammar presented in (Sitter andStein, 1992).
Notat ion:  Complex dialoguemoves begin with an upper case (e.g., Request);atom/c dialogue acts are all lower case (e.g., re-quest).
S and K mean seeker and knower.
Squarebrackets (\[\]) mean optional.
X + means one ormore instances of X.
All moves except Inform andAssert are representated bythe abstraction Move.Subscript i means that move and act must be ofthe same type, e.g., Request and request.Dialogue(S) --+ (Cycle(S)) +Cycle(S) -).
Request(S), Promise(K), Inform(K),Evaluate(S).Cycle(S) ~ Request(S), \[Promise(K)\],WithdrawRequest(S).Cycle(S) ~ Request(S), Promise(K),WithdrawPromise(K).Cycle(S) ~ Request(S), RejectRequest(K).Cycle(S) ~ Offer(K), Accept(S), Inform(K), Evaluate(S),Cycle(S) ~ Offer(K), \[Accept(S)\], WithdrawOffer(K).Cycle(S) ---y Offer(K), Accept(S), WithdrawAccept(S).Cycle(S) -+ Offer(K), RejectOffer(S).Cycle(S) -+ Withdraw(usr).Cycle(S) ~ Withdraw(system).inform(K) .-.).
inform(K), \[Dialogue(S)\].Assert(S/K) ,-.
), assert(S/K), \[Dialogue(K/S)\].Movei(S/K).Movei(S/K) ~ act~(S/K), \[Dialogue(K/S)\].Movei(S/K) ~ acti(S/K), \[Assert(S/K)\].Mov~ (S/K) -+ Dialogue(K/S).Moves(S/K) ~ Assert(S/K), \[acti(S/K)\].Move~(S/K) --~.
Assert(S/K), \[Dialogue(K/S)\].140
