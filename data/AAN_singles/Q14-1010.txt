A Tabular Method for Dynamic Oracles in Transition-Based ParsingYoav GoldbergDepartment ofComputer ScienceBar Ilan University, Israelyoav.goldberg@gmail.comFrancesco SartorioDepartment ofInformation EngineeringUniversity of Padua, Italysartorio@dei.unipd.itGiorgio SattaDepartment ofInformation EngineeringUniversity of Padua, Italysatta@dei.unipd.itAbstractWe develop parsing oracles for two trans-ition-based dependency parsers, including thearc-standard parser, solving a problem thatwas left open in (Goldberg and Nivre, 2013).We experimentally show that using these or-acles during training yields superior parsingaccuracies on many languages.1 IntroductionGreedy transition-based dependency parsers (Nivre,2008) incrementally process an input sentence fromleft to right.
These parsers are very fast andprovide competitive parsing accuracies (Nivre et al.,2007).
However, greedy transition-based parsersstill fall behind search-based parsers (Zhang andClark, 2008; Huang and Sagae, 2010) with respectto accuracy.The training of transition-based parsers relies ona component called the parsing oracle, which mapsparser configurations to optimal transitions with re-spect to a gold tree.
A discriminative model is thentrained to simulate the oracle?s behavior.
A parsingoracle is deterministic if it returns a single canon-ical transition.
Furthermore, an oracle is partial if itis defined only for configurations that can reach thegold tree, that is, configurations representing pars-ing histories with no mistake.
Oracles that are bothdeterministic and partial are called static.
Tradition-ally, only static oracles have been exploited in train-ing of transition-based parsers.Recently, Goldberg and Nivre (2012; 2013)showed that the accuracy of greedy parsers can besubstantially improved without affecting their pars-ing speed.
This improvement relies on the intro-duction of novel oracles that are nondeterministicand complete.
An oracle is nondeterministic if it re-turns the set of all transitions that are optimal withrespect to the gold tree, and it is complete if it iswell-defined and correct for every configuration thatis reachable by the parser.
Oracles that are both non-deterministic and complete are called dynamic.Goldberg and Nivre (2013) develop dynamic or-acles for several transition-based parsers.
The con-struction of these oracles is based on a property oftransition-based parsers that they call arc decompos-ition.
They also prove that the popular arc-standardsystem (Nivre, 2004) is not arc-decomposable, andthey leave as an open research question the construc-tion of a dynamic oracle for the arc-standard system.In this article, we develop one such oracle (?4) andprove its correctness (?5).An extension to the arc-standard parser waspresented by Sartorio et al.
(2013), which relaxesthe bottom-up construction order and allows mixingof bottom-up and top-down strategies.
This parser,called here the LR-spine parser, achieves state-of-the-art results for greedy parsing.
Like the arc-stand-ard system, the LR-spine parser is not arc-decom-posable, and a dynamic oracle for this system wasnot known.
We extend our oracle for the arc-stand-ard system to work for the LR-spine system as well(?6).The dynamic oracles developed by Goldberg andNivre (2013) for arc-decomposable systems arebased on local properties of computations.
In con-trast, our novel dynamic oracle algorithms rely onarguably more complex structural properties of com-putations, which are computed through dynamicprogramming.
This leaves open the question ofwhether a machine-learning model can learn to ef-fectively simulate such complex processes: will the119Transactions of the Association for Computational Linguistics, 2 (2014) 119?130.
Action Editor: Ryan McDonald.Submitted 11/2013; Revised 2/2014; Published 4/2014.
c?2014 Association for Computational Linguistics.benefit of training with the dynamic oracle carryover to the arc-standard and LR-spine systems?
Weshow experimentally that this is indeed the case (?8),and that using the training-with-exploration methodof (Goldberg and Nivre, 2013) with our dynamicprogramming based oracles yields superior parsingaccuracies on many languages.2 Arc-Standard ParserIn this section we introduce the arc-standard parserof Nivre (2004), which is the model that we use inthis article.
To keep the notation at a simple level,we only discuss the unlabeled version of the parser;however, a labeled extension is used in ?8 for ourexperiments.2.1 Preliminaries and NotationThe set of non-negative integers is denoted as N0.For i, j ?
N0 with i ?
j, we write [i, j] to denotethe set {i, i + 1, .
.
.
, j}.
When i > j, [i, j] denotesthe empty set.We represent an input sentence as a string w =w0 ?
?
?wn, n ?
N0, where token w0 is a specialroot symbol, and each wi with i ?
[1, n] is a lex-ical token.
For i, j ?
[0, n] with i ?
j, we writew[i, j] to denote the substring wiwi+1 ?
?
?wj of w.We write i ?
j to denote a grammatical de-pendency of some unspecified type between lexicaltokens wi and wj , where wi is the head and wj is thedependent.
A dependency tree for w is a directed,ordered tree t = (Vw, A), such that Vw = [0, n] isthe set of nodes, A ?
Vw?Vw is the set of arcs, andnode 0 is the root.
Arc (i, j) encodes a dependencyi ?
j, and we will often use the latter notation todenote arcs.2.2 Transition-Based Dependency ParsingWe assume the reader is familiar with the formalframework of transition-based dependency parsingoriginally introduced by Nivre (2003); see Nivre(2008) for an introduction.
We only summarize hereour notation.Transition-based dependency parsers use a stackdata structure, where each stack element is associ-ated with a tree spanning (generating) some sub-string of the input w. The parser processes the in-put string incrementally, from left to right, applyingat each step a transition that updates the stack and/orconsumes one token from the input.
Transitions mayalso construct new dependencies, which are added tothe current configuration of the parser.We represent the stack data structure as anordered sequence ?
= [?d, .
.
.
, ?1], d ?
N0, ofnodes ?i ?
Vw, with the topmost element placedat the right.
When d = 0, we have the empty stack?
= [].
Sometimes we use the vertical bar to denotethe append operator for ?, and write ?
= ?
?|?1 toindicate that ?1 is the topmost element of ?.The parser also uses a buffer to store the portionof the input string still to be processed.
We representthe buffer as an ordered sequence ?
= [i, .
.
.
, n] ofnodes from Vw, with i the first element of the buf-fer.
In this way ?
always encodes a (non-necessarilyproper) suffix of w. We denote the empty buffer as?
= [].
Sometimes we use the vertical bar to denotethe append operator for ?, and write ?
= i|??
to in-dicate that i is the first token of ?
; consequently, wehave ??
= [i+ 1, .
.
.
, n].When processing w, the parser reaches severalstates, technically called configurations.
A config-uration of the parser relative to w is a triple c =(?, ?,A), where ?
and ?
are a stack and a buffer,respectively, and A ?
Vw ?
Vw is a set of arcs.
Theinitial configuration for w is ([], [0, .
.
.
, n], ?).
Forthe purpose of this article, a configuration is finalif it has the form ([0], [], A), and in a final config-uration arc set A always defines a dependency treefor w.The core of a transition-based parser is the set ofits transitions, which are specific to each family ofparsers.
A transition is a binary relation definedover the set of configurations of the parser.
We usesymbol ` to denote the union of all transition rela-tions of a parser.A computation of the parser on w is a sequencec0, .
.
.
, cm, m ?
N0, of configurations (defined rel-ative to w) such that ci?1 ` ci for each i ?
[1,m].We also use the reflexive and transitive closure rela-tion `?
to represent computations.
A computation iscalled complete whenever c0 is initial and cm is fi-nal.
In this way, a complete computation is uniquelyassociated with a dependency tree for w.2.3 Arc-Standard ParserThe arc-standard model uses the three types of trans-itions formally specified in Figure 1120(?, i|?,A) `sh (?|i, ?, A)(?|i|j, ?,A) `la (?|j, ?,A ?
{j ?
i})(?|i|j, ?,A) `ra (?|i, ?, A ?
{i?
j})Figure 1: Transitions in the arc-standard model.?
Shift (sh) removes the first node in the bufferand pushes it into the stack;?
Left-Arc (la) creates a new arc with the topmostnode on the stack as the head and the second-topmost node as the dependent, and removesthe second-topmost node from the stack;?
Right-Arc (ra) is symmetric to la in that it cre-ates an arc with the second-topmost node as thehead and the topmost node as the dependent,and removes the topmost node.Notation We sometimes use the functional nota-tion for a transition ?
?
{sh, la, ra}, and write?
(c) = c?
in place of c `?
c?.
Naturally, sh appliesonly when the buffer is not empty, and la,ra requiretwo elements on the stack.
We denote by valid(c)the set of valid transitions in a given configuration.2.4 Arc DecompositionGoldberg and Nivre (2013) show how to derive dy-namic oracles for any transition-based parser whichhas the arc decomposition property, defined below.They also show that the arc-standard parser is notarc-decomposable.For a configuration c, we write Ac to denote theassociated set of arcs.
A transition-based parser isarc-decomposable if, for every configuration c andfor every set of arcs A that can be extended to a pro-jective tree, we have?(i?
j) ?
A,?c?
[c `?
c?
?
(i?
j) ?
Ac?
]?
?c??
[c `?
c??
?A ?
Ac?? ]
.In words, if each arc in A is individually derivablefrom c, then the set A in its entirety can be derivedfrom c as well.
The arc decomposition propertyis useful for deriving dynamic oracles because it isrelatively easy to investigate derivability for singlearcs and then, using this property, draw conclusionsabout the number of gold-arcs that are simultan-eously derivable from the given configuration.Unfortunately, the arc-standard parser is not arc-decomposable.
To see why, consider a configura-tion with stack ?
= [i, j, k].
Consider also arc setA = {(i, j), (i, k)}.
The arc (i, j) can be derivedthrough the transition sequence ra, ra, and the arc(i, k) can be derived through the alternative trans-ition sequence la, ra.
Yet, it is easy to see that a con-figuration containing both arcs cannot be reached.As we cannot rely on the arc decomposition prop-erty, in order to derive a dynamic oracle for the arc-standard model we need to develop more sophistic-ated techniques which take into account the interac-tion among the applied transitions.3 Configuration Loss and Dynamic OraclesWe aim to derive a dynamic oracle for the arc-stand-ard (and related) system.
This is a function that takesa configuration c and a gold tree tG and returns a setof transitions that are ?optimal?
for c with respectto tG.
As already mentioned in the introduction, adynamic oracle can be used to improve training ofgreedy transition-based parsers.
In this section weprovide a formal definition for a dynamic oracle.Let t1 and t2 be two dependency trees over thesame stringw, with arc setsA1 andA2, respectively.We define the loss of t1 with respect to t2 asL(t1, t2) = |A1 \A2| .
(1)Note that L(t1, t2) = L(t2, t1), since |A1| =|A2|.
Furthermore L(t1, t2) = 0 if and only if t1and t2 are the same tree.Let c be a configuration of our parser relative toinput string w. We write D(c) to denote the set ofall dependency trees that can be obtained in a com-putation of the form c `?
cf , where cf is some finalconfiguration.
We extend the loss function in (1) toconfigurations by lettingL(c, t2) = mint1?D(c)L(t1, t2) .
(2)Assume some reference (desired) dependencytree tG for w, which we call the gold tree.
QuantityL(c, tG) can be used to compute a dynamic oraclerelating a parser configuration c to a set of optimalactions by settingoracle(c, tG) ={?
| L(?
(c), tG)?
L(c, tG) = 0} .
(3)121We therefore need to develop an algorithm for com-puting (2).
We will do this first for the arc-standardparser, and then for an extension of this model.Notation We also apply the loss function L(t, tG)in (1) when t is a dependency tree for a substringof w. In this case the nodes of t are a subset ofthe nodes of tG, and L(t, tG) provides a count ofthe nodes of t that are assigned a wrong head node,when tG is considered as the reference tree.4 Main AlgorithmThroughout this section we assume an arc-standardparser.
Our algorithm takes as input a projectivegold tree tG and a configuration c = (?L, ?, A).
Wecall ?L the left stack, in contrast with a right stackwhose construction is specified below.4.1 Basic IdeaThe algorithm consists of two steps.
Informally, inthe first step we compute the largest subtrees, calledhere tree fragments, of the gold tree tG that havetheir span entirely included in the buffer ?.
Theroot nodes of these tree fragments are then arrangedinto a stack data structure, according to the order inwhich they appear in ?
and with the leftmost root in?
being the topmost element of the stack.
We callthis structure the right stack ?R.
Intuitively, ?R canbe viewed as the result of pre-computing ?
by ap-plying all sequences of transitions that match tG andthat can be performed independently of the stack inthe input configuration c, that is, ?L.In the second step of the algorithm we use dy-namic programming techniques to simulate all com-putations of the arc-standard parser starting in a con-figuration with stack ?L and with a buffer consistingof ?R, with the topmost token of ?R being the firsttoken of the buffer.
As we will see later, the searchspace defined by these computations includes the de-pendency trees for w that are reachable from the in-put configuration c and that have minimum loss.
Wethen perform a Viterbi search to pick up such value.The second step is very similar to standard imple-mentations of the CKY parser for context-free gram-mars (Hopcroft and Ullman, 1979), running on aninput string obtained as the concatenation of ?L and?R.
The main difference is that we restrict ourselvesto parse only those constituents in ?L?R that dom-inate the topmost element of ?L (the rightmost ele-ment, if ?L is viewed as a string).
In this way, we ac-count for the additional constraint that we visit onlythose configurations of the arc-standard parser thatcan be reached from the input configuration c. Forinstance, this excludes the reduction of two nodes in?L that are not at the two topmost positions.
Thiswould also exclude the reduction of two nodes in?R: this is correct, since the associated tree frag-ments have been chosen as the largest such frag-ments in ?.The above intuitive explanation will be mademathematically precise in ?5, where the notion oflinear dependency tree is introduced.4.2 Construction of the Right StackIn the first step we process ?
and construct a stack?R, which we call the right stack associated with cand tG.
Each node of ?R is the root of a tree t whichsatisfies the following properties?
t is a tree fragment of the gold tree tG havingspan entirely included in the buffer ?;?
t is bottom-up complete for tG, meaning thatfor each node i of t different from t?s root, thedependents of i in tG cannot be in ?L;?
t is maximal for tG, meaning that every super-tree of t in tG violates the above conditions.The stack ?R is incrementally constructed by pro-cessig ?
from left to right.
Each node i is copied into?R if it satisfies any of the following conditions?
the parent node of i in tG is not in ?;?
some dependent of i in tG is in ?L or hasalready been inserted in ?R.It is not difficult to see that the nodes in ?R are theroots of tree fragments of tG that satisfy the condi-tion of bottom-up completeness and the condition ofmaximality defined above.4.3 Computation of Configuration LossWe start with some notation.
Let `L = |?L| and`R = |?R|.
We write ?L[i] to denote the i-th ele-ment of ?L and t(?L[i]) to denote the correspond-ing tree fragment; ?R[i] and t(?R[i]) have a similarmeaning.
In order to simplify the specification ofthe algorithm, we assume below that ?L[1] = ?R[1].122Algorithm 1 Computation of the loss function for the arc-standard parser1: T [1, 1](?L[1])?
L(t(?L[1]), tG)2: for d?
1 to `L + `R ?
1 do .
d is the index of a sub-anti-diagonal3: for j ?
max{1, d?
`L + 1} to min{d, `R} do .
j is the column index4: i?
d?
j + 1 .
i is the row index5: if i < `L then .
expand to the left6: for each h ?
?i,j do7: T [i+ 1, j](h)?
min{T [i+ 1, j](h), T [i, j](h) + ?G(h?
?L[i+ 1])}8: T [i+ 1, j](?L[i+ 1])?
min{T [i+ 1, j](?L[i+ 1]), T [i, j](h) + ?G(?L[i+ 1]?
h)}9: if j < `R then .
expand to the right10: for each h ?
?i,j do11: T [i, j + 1](h)?
min{T [i, j + 1](h), T [i, j](h) + ?G(h?
?R[j + 1])}12: T [i, j+1](?R[j + 1])?
min{T [i, j+1](?R[j + 1]), T [i, j](h)+?G(?R[j + 1]?
h)}13: return T [`L, `R](0) +?i?
[1,`L] L(t(?L[i]), tG)Therefore the elements of ?R which have been con-structed in ?4.2 are ?R[i], i ?
[2, `R].Algorithm 1 uses a two-dimensional array T ofsize `L ?
`R, where each entry T [i, j] is an as-sociation list from integers to integers.
An entryT [i, j](h) stores the minimum loss among depend-ency trees rooted at h that can be obtained by run-ning the parser on the first i elements of stack ?L andthe first j elements of buffer ?R.
More precisely, let?i,j = {?L[k] | k ?
[1, i]} ?
{?R[k] | k ?
[1, j]} .
(4)For each h ?
?i,j , the entry T [i, j](h) is theminimum loss among all dependency trees definedas above and with root h. We also assume thatT [i, j](h) is initialized to +?
(not reported in thealgorithm).Algorithm 1 starts at the top-left corner of T , vis-iting each individual sub-anti-diagonal of T in as-cending order, and eventually reaching the bottom-right corner of the array.
For each entry T [i, j], theleft expansion is considered (lines 5 to 8) by com-bining with tree fragment ?L[i+ 1], through a leftor a right arc reduction.
This results in the updateof T [i + 1, j](h), for each h ?
?i+1,j , whenever asmaller value of the loss is achieved for a tree withroot h. The Kronecker-like function used at line 8provides the contribution of each single arc to theloss of the current tree.
Denoting with AG the set ofarcs of tG, such a function is defined as?G(i?
j) ={0, if (i?
j) ?
AG;1, otherwise.
(5)A symmetrical process is implemented for theright expansion of T [i, j] through tree fragment?R[j + 1] (lines 9 to 12).As we will see in the next section, quantityT [`L, `R](0) is the minimal loss of a tree composedonly by arcs that connect nodes in ?L and ?R.
Bysumming the loss of all tree fragments t(?L[i]) tothe loss in T [`L, `R](0), at line 13, we obtain thedesired result, since the loss of each tree fragmentt(?R[j]) is zero.5 Formal PropertiesThroughout this section we let w, tG, ?L, ?R andc = (?L, ?, A) be defined as in ?4, but we no longerassume that ?L[1] = ?R[1].
To simplify the present-ation, we sometimes identify the tokens in w withthe associated nodes in a dependency tree for w.5.1 Linear TreesAlgorithm 1 explores all dependency trees that canbe reached by an arc-standard parser from configur-ation c, under the condition that (i) the nodes in thebuffer ?
are pre-computed into tree fragments andcollapsed into their root nodes in the right stack ?R,and (ii) nodes in ?R cannot be combined togetherprior to their combination with other nodes in theleft stack ?L.
This set of dependency trees is char-123j4i6 i5 i3 j5i4 i1 j3i2 j1 j2?R?LFigure 2: A possible linear tree for string pair (?L, ?R),where ?L = i6i5i4i3i2i1 and ?R = j1j2j3j4j5.
Thespine of the tree consists of nodes j4, i3 and i1.acterized here using the notion of linear tree, to beused later in the correctness proof.Consider two nodes ?L[i] and ?L[j] with j >i > 1.
An arc-standard parser can construct an arcbetween ?L[i] and ?L[j], in any direction, only afterreaching a configuration in which ?L[i] is at the topof the stack and ?L[j] is at the second topmost posi-tion.
In such configuration we have that ?L[i] dom-inates ?L[1].
Furthermore, consider nodes ?R[i] and?R[j] with j > i ?
1.
Since we are assuming thattree fragments t(?R[i]) and t(?R[j]) are bottom-upcomplete and maximal, as defined in ?4.2, we allowthe construction of an arc between ?R[i] and ?R[j],in any direction, only after reaching a configurationin which ?R[i] dominates node ?L[1].The dependency trees satisfying the restrictionsabove are captured by the following definition.
Alinear tree over (?L, ?R) is a projective dependencytree t for string ?L?R satisfying both of the addi-tional conditions reported below.
The path from t?sroot to node ?L[1] is called the spine of t.?
Every node of t not in the spine is a dependentof some node in the spine.?
For each arc i ?
j in t with j in the spine, nodependent of i can be placed in between i andj within string ?L?R.An example of a linear tree is depicted in Figure 2.Observe that the second condition above forbids thereduction of two nodes i and j, in case none of thesedominates node ?L[1].
For instance, the ra reduc-tion of nodes i3 and i2 would result in arc i3 ?
i2replacing arc i1 ?
i2 in Figure 2.
The new depend-ency tree is not linear, because of a violation of thesecond condition above.
Similarly, the la reductionof nodes j3 and j4 would result in arc j4 ?
j3 re-placing arc i3 ?
j3 in Figure 2, again a violation ofthe second condition above.Lemma 1 Any tree t ?
D(c) can be decomposedinto trees t(?L[i]), i ?
[1, `L], trees tj , j ?
[1, q] andq ?
1, and a linear tree tl over (?L, ?R,t), where?R,t = r1 ?
?
?
rq and each rj is the root node of tj .
2PROOF (SKETCH) Trees t(?L[i]) are common toevery tree in D(c), since the arc-standard model cannot undo the arcs already built in the current con-figuration c. Similar to the construction in ?4.2 ofthe right stack ?R from tG, we let tj , j ?
[1, q], betree fragments of t that cover only nodes associatedwith the tokens in the buffer ?
and that are bottom-up complete and maximal for t. These trees are in-dexed according to their left to right order in ?.
Fi-nally, tl is implicitly defined by all arcs of t that arenot in trees t(?L[i]) and tj .
It is not difficult to seethat tl has a spine ending with node ?L[1] and is alinear tree over (?L, ?R,t).
5.2 CorrectnessOur proof of correctness for Algorithm 1 is based ona specific dependency tree t?
for w, which we definebelow.
Let SL = {?L[i] | i ?
[1, `L]} and letDL bethe set of nodes that are descendants of some nodein SL.
Similarly, let SR = {?R[i] | i ?
[1, `R]}and let DR be the set of descendants of nodes inSR.
Note that sets SL, SR, DL and DR provide apartition of Vw.We choose any linear tree t?l over (?L, ?R) havingroot 0, such that L(t?l , tG) = mint L(t, tG), wheret ranges over all possible linear trees over (?L, ?R)with root 0.
Tree t?
consists of the set of nodes Vwand the set of arcs obtained as the union of the setof arcs of t?l and the set of arcs of all trees t(?L[i]),i ?
[1, `L], and t(?R[j]), j ?
[1, `R].Lemma 2 t?
?
D(c).
2PROOF (SKETCH) All tree fragments t(?L[i]) havealready been parsed and are available in the stackassociated with c. Each tree fragment t(?R[j]) canlater be constructed in the computation, when a con-figuration c?
is reached with the relevant segment ofw at the start of the buffer.
Note also that parsing oft(?R[j]) can be done in a way that does not dependon the content of the stack in c?.124Finally, the parsing of the tree fragments t(?R[j])is interleaved with the construction of the arcs fromthe linear tree t?l , which are all of the form (i ?
j)with i, j ?
(SL ?
SR).
More precisely, if (i ?
j)is an arc from t?l , at some point in the computationnodes i and j will become available at the two top-most positions in the stack.
This follows from thesecond condition in the definition of linear tree.
We now show that tree t?
is ?optimal?
within theset D(c) and with respect to tG.Lemma 3 L(t?, tG) = L(c, tG).
2PROOF Consider an arbitrary tree t ?
D(c).
As-sume the decomposition of t defined in the proof ofLemma 1, through trees t(?L[i]), i ?
[1, `L], treestj , j ?
[1, q], and linear tree tl over (?L, ?R,t).Recall that an arc i ?
j denotes an ordered pair(i, j).
Let us consider the following partition for theset of arcs of any dependency tree for wA1 = (SL ?DL)?DL ,A2 = (SR ?DR)?DR ,A3 = (Vw ?
Vw) \ (A1 ?A2) .In what follows, we compare the losses L(t, tG) andL(t?, tG) by separately looking into the contributionto such quantities due to the arcs in A1, A2 and A3.Note that the arcs of trees t(?L[i]) are all in A1,the arcs of trees t(?R[j]) are all in A2, and the arcsof tree t?l are all in A3.
Since t and t?
share treest(?L[i]), when restricted to arcs in A1 quantitiesL(t, tG) and L(t?, tG) are the same.
When restric-ted to arcs in A2, quantity L(t?, tG) is zero, by con-struction of the trees t(?R[j]).
Thus L(t, tG) can notbe smaller thanL(t?, tG) for these arcs.
The difficultpart is the comparison of the contribution to L(t, tG)and L(t?, tG) due to the arcs in A3.
We deal withthis below.LetAS,G be the set of all arcs from tG that are alsoin set (SL ?
SR) ?
(SR ?
SL).
In words, AS,G rep-resents gold arcs connecting nodes in SL and nodesin SR, in any direction.
Within tree t, these arcs canonly be found in the tl component, since nodes inSL are all placed within the spine of tl, or else at theleft of that spine.Let us consider an arc (j ?
i) ?
AS,G with j ?SL and i ?
SR, and let us assume that (j ?
i) is int?l .
If token ai does not occur in ?R,t, node i is notin tl and (j ?
i) can not be an arc of t. We thenhave that (j ?
i) contributes one unit to L(t, tG)but does not contribute to L(t?, tG).
Similarly, let(i ?
j) ?
AS,G be such that i ?
SR and j ?
SL,and assume that (i?
j) is in t?l .
If token ai does notoccur in ?R,t, arc (i ?
j) can not be in t. We thenhave that (i ?
j) contributes one unit to L(t, tG)but does not contribute to L(t?, tG).Intuitively, the above observations mean that thewinning strategy for trees in D(c) is to move nodesfrom SR as much as possible into the linear treecomponent tl, in order to make it possible for thesenodes to connect to nodes in SL, in any direction.
Inthis case, arcs fromA3 will also move into the lineartree component of a tree inD(c), as it happens in thecase of t?.
We thus conclude that, when restricted tothe set of arcs in A3, quantity L(t, tG) is not smal-ler than L(t?, tG), because stack ?R has at least asmany tokens corresponding to nodes in SR as stack?R,t, and because t?l has the minimum loss amongall the linear trees over (?L, ?R).Putting all of the above observations together,we conclude that L(t, tG) can not be smaller thanL(t?, tG).
This concludes the proof, since t has beenarbitrarily chosen in D(c).
Theorem 1 Algorithm 1 computes L(c, tG).
2PROOF (SKETCH) Algorithm 1 implements a Vi-terbi search for trees with smallest loss among alllinear trees over (?L, ?R).
Thus T [`L, `R](0) =L(t?l , tG).
The loss of the tree fragments t(?R[j])is 0 and the loss of the tree fragments t(?L[i]) is ad-ded at line 13 in the algorithm.
Thus the algorithmreturns L(t?, tG), and the statement follows fromLemma 2 and Lemma 3.
5.3 Computational AnalysisFollowing ?4.2, the right stack ?R can be easilyconstructed in time O(n), n the length of the in-put string.
We now analyze Algorithm 1.
For eachentry T [i, j] and for each h ?
?i,j , we updateT [i, j](h) a number of times bounded by a con-stant which does not depend on the input.
Each up-dating can be computed in constant time as well.We thus conclude that Algorithm 1 runs in timeO(`L ?
`R ?
(`L + `R)).
Quantity `L+`R is boundedby n, but in practice the former is significantly smal-ler.
When measured over the sentences in the Penn125Treebank, the average value of `L+`Rn is 0.29.
Interms of runtime, training is 2.3 times slower whenusing our oracle instead of a static oracle.6 Extension to the LR-Spine ParserIn this section we consider the transition-basedparser proposed by Sartorio et al.
(2013), calledhere the LR-spine parser.
This parser is not arc-decomposable: the same example reported in ?2.4can be used to show this fact.
We therefore extend tothe LR-spine parser the algorithm developed in ?4.6.1 The LR-Spine ParserLet t be a dependency tree.
The left spine of t isan ordered sequence ?i1, .
.
.
, ip?, p ?
1, consistingof all nodes in a descending path from the root oft taking the leftmost child node at each step.
Theright spine of t is defined symmetrically.
We use ?to denote sequence concatenation.In the LR-spine parser each stack element ?
[i] de-notes a partially built subtree t(?
[i]) and is represen-ted by a pair (lsi, rsi), with lsi and rsi the left and theright spine, respectively, of t(?[i]).
We write lsi[k](rsi[k]) to represent the k-th element of lsi (rsi, re-spectively).
We also write r(?
[i]) to denote the rootof t(?
[i]), so that r(?
[i]) = lsi[1] = rsi[1].Informally, the LR-spine parser uses the sametransition typologies as the arc-standard parser.However, an arc (h ?
d) can now be created withthe head node h chosen from any node in the spineof the involved tree.
The transition types of the LR-spine parser are defined as follows.?
Shift (sh) removes the first node from the buf-fer and pushes into the stack a new element,consisting of the left and right spines of the as-sociated tree(?, i|?,A) `sh (?|(?i?, ?i?
), ?, A) .?
Left-Arc k (lak) creates a new arc h ?
d fromthe k-th node in the left spine of the topmosttree in the stack to the head of the second ele-ment in the stack.
Furthermore, the two top-most stack elements are replaced by a new ele-ment associated with the resulting tree(??|?[2]|?
[1], ?, A) `lak (?
?|?lak , ?, A ?
{h?
d})where we have set h = ls1[k], d = r(?
[2]) and?lak = (?ls1[1], .
.
.
, ls1[k]?
?
ls2, rs1).?
Right-Arc k (rak for short) is defined symmet-rically with respect to lak(??|?[2]|?
[1], ?, A) `rak (?
?|?rak , ?, A ?
{h?
d})where we have set h = rs2[k], d = r(?
[1]) and?rak = (ls2, ?rs2[1], .
.
.
, rs2[k]?
?
rs1).Note that, at each configuration in the LR-spineparser, there are |ls1| possible lak transitions, one foreach choice of a node in the left spine of t(?
[1]);similarly, there are |rs2| possible rak transitions,one for each choice of a node in the right spine oft(?
[2]).6.2 Configuration LossWe only provide an informal description of the ex-tended algorithm here, since it is very similar to thealgorithm in ?4.In the first phase we use the procedure of ?4.2 forthe construction of the right stack ?R, consideringonly the roots of elements in ?L and ignoring therest of the spines.
The only difference is that eachelement ?R[j] is now a pair of spines (lsR,j , rsR,j).Since tree fragment t(?R[j]) is bottom-up complete(see ?4.1), we now restrict the search space in sucha way that only the root node r(?R[j]) can take de-pendents.
This is done by setting lsR,j = rsR,j =?r(?R[j])?
for each j ?
[1, `R].
In order to simplifythe presentation we also assume ?R[1] = ?L[1], asdone in ?4.3.In the second phase we compute the loss of an in-put configuration using a two-dimensional array T ,defined as in ?4.3.
However, because of the waytransitions are defined in the LR-spine parser, wenow need to distinguish tree fragments not only onthe basis of their roots, but also on the basis of theirleft and right spines.
Accordingly, we define eachentry T [i, j] as an association list with keys of theform (ls, rs).
More specifically, T [i, j](ls, rs) is theminimum loss of a tree with left and right spines lsand rs, respectively, that can be obtained by runningthe parser on the first i elements of stack ?L and thefirst j elements of buffer ?R.We follow the main idea of Algorithm 1 and ex-pand each tree in T [i, j] at its left side, by combin-ing with tree fragment t(?L[i+ 1]), and at its rightside, by combining with tree fragment t(?R[j + 1]).126Tree combination deserves some more detailed dis-cussion, reported below.We consider the combination of a tree ta fromT [i, j] and tree t(?L[i+ 1]) by means of a left-arctransition.
All other cases are treated symmetric-ally.
Let (lsa, rsa) be the spine pair of ta, so thatthe loss of ta is stored in T [i, j](lsa, rsa).
Let also(lsb, rsb) be the spine pair of t(?L[i+ 1]).
In casethere exists a gold arc in tG connecting a node fromlsa to r(?L[i+ 1]), we choose the transition lak,k ?
[1, |lsa|], that creates such arc.
In case such goldarc does not exists, we choose the transition lak withthe maximum possible value of k, that is, k = |lsa|.We therefore explore only one of the several pos-sible ways of combining these two trees by meansof a left-arc transition.We remark that the above strategy is safe.
In fact,in case the gold arc exists, no other gold arc can everinvolve the nodes of lsa eliminated by lak (see thedefinition in ?6.1), because arcs can not cross eachother.
In case the gold arc does not exist, our choiceof k = |lsa| guarantees that we do not eliminate anyelement from lsa.Once a transition lak is chosen, as describedabove, the reduction is performed and the spinepair (ls, rs) for the resulting tree is computed from(lsa, rsa) and (lsb, rsb), as defined in ?6.1.
At thesame time, the loss of the resulting tree is com-puted, on the basis of the loss T [i, j](lsa, rsa), theloss of tree t(?L[i+ 1]), and a Kronecker-like func-tion defined below.
This loss is then used to updateT [i+ 1, j](ls, rs).Let ta and tb be two trees that must be combinedin such a way that tb becomes the dependent ofsome node in one of the two spines of ta.
Let alsopa = (lsa, rsa) and pb = (lsb, rsb) be spine pairs forta and tb, respectively.
Recall that AG is the set ofarcs of tG.
The new Kronecker-like function for thecomputation of the loss is defined as?G(pa, pb) =??????????
?0, if r(ta) < r(tb)?
?k[(rska ?
r(tb)) ?
AG];0, if r(ta) > r(tb)?
?k[(lska ?
r(tb)) ?
AG];1, otherwise.6.3 Efficiency ImprovementThe algorithm in ?6.2 has an exponential behaviour.To see why, consider trees in T [i, j].
These trees areproduced by the combination of trees in T [i ?
1, j]with tree t(?L[i]), or by the combination of trees inT [i, j ?
1] with tree t(?R[j]).
Since each combin-ation involves either a left-arc or a right-arc trans-ition, we obtain a recursive relation that resolves intoa number of trees in T [i, j] bounded by 4i+j?2.We introduce now two restrictions to the searchspace of our extended algorithm that result in a hugecomputational saving.
For a spine s, we write N (s)to denote the set of all nodes in s. We also let ?i,j bethe set of all pairs (ls, rs) such that T [i, j](ls, rs) 6=+?.?
Every time a new pair (ls, rs) is created in?
[i, j], we remove from ls all nodes differentfrom the root that do not have gold dependentsin {r(?L[k]) | k < i}, and we remove fromrs all nodes different from the root that do nothave gold dependents in {r(?R[k]) | k > j}.?
A pair pa = (lsa, rsa) is removed from?
[i, j] if there exists a pair pb = (lsb, rsb)in ?
[i, j] with the same root node as pa andwith (lsa, rsa) 6= (lsb, rsb), such that N (lsa) ?N (lsb), N (rsa) ?
N (rsb), and T [i, j](pa) ?T [i, j](pb).The first restriction above reduces the size of a spineby eliminating a node if it is irrelevant for the com-putation of the loss of the associated tree.
Thesecond restriction eliminates a tree ta if there is atree tb with smaller loss than ta, such that in thecomputations of the parser tb provides exactly thesame context as ta.
It is not difficult to see thatthe above restrictions do not affect the correctness ofthe algorithm, since they always leave in our searchspace some tree that has optimal loss.A mathematical analysis of the computationalcomplexity of the extended algorithm is quite in-volved.
In Figure 3, we plot the worst case sizeof T [i, j] for each value of j + i ?
1, computedover all configurations visited in the training phase(see ?7).
We see that |T [i, j]| grows linearly withj + i?
1, leading to the same space requirements ofAlgorithm 1.
Empirically, training with the dynamic1270 10 20 30 40 5001020304050i+ j ?
1maxnumberofelementsFigure 3: Empirical worst case size of T [i, j] for eachvalue of i + j ?
1 as measured on the Penn Treebankcorpus.Algorithm 2 Online training for greedy transition-based parsers1: w?
02: for k iterations do3: shuffle(corpus)4: for sentencew and gold tree tG in corpus do5: c?
INITIAL(w)6: while not FINAL(c) do7: ?p ?
argmax?
?valid(c)w ?
?
(c, ?
)8: ?o ?
argmax??oracle(c,tG)w??
(c, ?
)9: if ?p 6?
oracle(c, tG) then10: w?
w + ?
(c, ?o)?
?
(c, ?p)11: ?
?
{?p if EXPLORE?o otherwise12: c?
?
(c)return averaged(w)oracle is only about 8 times slower than training withthe oracle of Sartorio et al.
(2013) without exploringincorrect configurations.7 TrainingWe follow the training procedure suggested byGoldberg and Nivre (2013), as described in Al-gorithm 2.
The algorithm performs online learningusing the averaged perceptron algorithm.
A weightvector w (initialized to 0) is used to score the validtransitions in each configuration based on a featurerepresentation ?, and the highest scoring transition?p is predicted.
If the predicted transition is notoptimal according to the oracle, the weights w areupdated away from the predicted transition and to-wards the highest scoring oracle transition ?o.
Theparser then moves to the next configuration, by tak-ing either the predicted or the oracle transition.
Inthe ?error exploration?
mode (EXPLORE is true), theparser follows the predicted transition, and other-wise the parser follows the oracle transition.
Notethat the error exploration mode requires the com-pleteness property of a dynamic oracle.We consider three training conditions: static, inwhich the oracle is deterministic (returning a singlecanonical transition for each configuration) and noerror exploration is performed; nondet, in which weuse a nondeterministic partial oracle (Sartorio et al.,2013), but do not perform error exploration; and ex-plore in which we use the dynamic oracle and per-form error exploration.
The static setup mirrors theway greedy parsers are traditionally trained.
Thenondet setup allows the training procedure to choosewhich transition to take in case of spurious ambigu-ities.
The explore setup increases the configurationspace explored by the parser during training, by ex-posing the training procedure to non-optimal con-figurations that are likely to occur during parsing,together with the optimal transitions to take in theseconfigurations.
It was shown by Goldberg and Nivre(2012; 2013) that the nondet setup outperforms thestatic setup, and that the explore setup outperformsthe nondet setup.8 Experimental EvaluationDatasets Performance evaluation is carried out onCoNLL 2007 multilingual dataset, as well as on thePenn Treebank (PTB) (Marcus et al., 1993) conver-ted to Stanford basic dependencies (De Marneffeet al., 2006).
For the CoNLL datasets we use goldpart-of-speech tags, while for the PTB we use auto-matically assigned tags.
As usual, the PTB parser istrained on sections 2-21 and tested on section 23.Setup We train labeled versions of the arc-stand-ard (std) and LR-spine (lrs) parsers under the static,nondet and explore setups, as defined in ?7.
Inthe nondet setup we use a nondeterministic partialoracle and in the explore setup we use the non-deterministic complete oracles we present in this pa-per.
In the static setup we resolve oracle ambiguitiesand choose a canonic transition sequence by attach-ing arcs as soon as possible.
In the explore setup,128parser:train Arabic Basque Catalan Chinese Czech English Greek Hungarian Italian Turkish PTBUASstd:static 81.39 75.37 90.32 85.17 78.90 85.69 79.90 77.67 82.98 77.04 89.86std:nondet 81.33 74.82 90.75 84.80 79.92 86.89 81.19 77.51 84.15 76.85 90.56std:explore 82.56 74.39 90.95 85.65 81.01 87.70 81.85 78.72 84.37 77.21 90.92lrs:static 81.67 76.07 91.47 84.24 77.93 86.36 79.43 76.56 84.64 77.00 90.33lrs:nondet 83.14 75.53 91.31 84.98 80.03 88.38 81.12 76.98 85.29 77.63 91.18lrs:explore 84.54 75.82 91.92 86.72 81.19 89.37 81.78 77.48 85.38 78.61 91.77LASstd:static 71.93 65.64 84.90 80.35 71.39 84.60 72.25 67.66 78.77 65.90 87.56std:nondet 71.09 65.28 85.36 80.06 71.47 85.91 73.40 67.77 80.06 65.81 88.30std:explore 72.89 65.27 85.82 81.28 72.92 86.79 74.22 69.57 80.25 66.71 88.72lrs:static 72.24 66.21 86.02 79.36 70.48 85.38 72.36 66.79 80.38 66.02 88.07lrs:nondet 72.94 65.66 86.03 80.47 71.32 87.45 73.09 67.70 81.32 67.02 88.96lrs:explore 74.54 66.91 86.83 82.38 72.72 88.44 74.04 68.76 81.50 68.06 89.53Table 1: Scores on the CoNLL 2007 dataset (including punctuation, gold parts of speech) and on Penn Tree Bank(excluding punctuation, predicted parts of speech).
Label ?std?
refers to the arc-standard parser, and ?lrs?
refers to theLR-spine parser.
Each number is an average over 5 runs with different randomization seeds.from the first round of training onward, we alwaysfollow the predicted transition (EXPLORE is true).For all languages, we deal with non-projectivity byskipping the non-projective sentences during train-ing but not during test.
For each parsing system,we use the same feature templates across all lan-guages.1 The arc-standard models are trained for 15iterations and the LR-spine models for 30 iterations,after which all the models seem to have converged.Results In Table 1 we report the labeled (LAS)and unlabeled (UAS) attachment scores.
As expec-ted, the LR-spine parsers outperform the arc-stand-ard parsers trained under the same setup.
Trainingwith the dynamic oracles is also beneficial: despitethe arguable complexity of our proposed oracles, thetrends are consistent with those reported by Gold-berg and Nivre (2012; 2013).
For the arc-standardmodel we observe that the move from a static toa nondeterministic oracle during training improvesthe accuracy for most of languages.
Making use ofthe completeness of the dynamic oracle and movingto the error exploring setup further improve results.The only exceptions are Basque, that has a smalldataset with more than 20% of non-projective sen-tences, and Chinese.
For Chinese we observe a re-duction of accuracy in the nondet setup, but an in-crease in the explore setup.For the LR-spine parser we observe a practicallyconstant increase of performance by moving from1Our complete code, together with the description of the fea-ture templates, is available on the second author?s homepage.the static to the nondeterministic and then to the er-ror exploring setups.9 ConclusionsWe presented dynamic oracles, based on dynamicprogramming, for the arc-standard and the LR-spine parsers.
Empirical evaluation on 10 languagesshowed that, despite the apparent complexity of theoracle calculation procedure, the oracles are stilllearnable, in the sense that using these oracles inthe error exploration training algorithm presented in(Goldberg and Nivre, 2012) considerably improvesthe accuracy of the trained parsers.Our algorithm computes a dynamic oracle usingdynamic programming to explore a forest of depend-ency trees that can be reached from a given parserconfiguration.
For the arc-standard parser, the com-putation takes cubic time in the size of the largest ofthe left and right input stacks.
Dynamic program-ming for the simulation of arc-standard parsers havebeen proposed by Kuhlmann et al.
(2011).
That al-gorithm could be adapted to compute minimum lossfor a given configuration, but the running time isO(n4), n the size of the input string: besides beingasymptotically slower by one order of magnitude, inpractice n is also larger than the stack size above.Acknowledgments We wish to thank the anonym-ous reviewers.
In particular, we are indebted to oneof them for two important technical remarks.
Thethird author has been partially supported by MIURunder project PRIN No.
2010LYA9RH 006.129ReferencesMarie-Catherine De Marneffe, Bill MacCartney, andChristopher D. Manning.
2006.
Generating typed de-pendency parses from phrase structure parses.
In Pro-ceedings of the 5th International Conference on Lan-guage Resources and Evaluation (LREC), volume 6,pages 449?454.Yoav Goldberg and Joakim Nivre.
2012.
A dynamic or-acle for arc-eager dependency parsing.
In Proc.
of the24th COLING, Mumbai, India.Yoav Goldberg and Joakim Nivre.
2013.
Trainingdeterministic parsers with non-deterministic oracles.Transactions of the association for ComputationalLinguistics, 1.John E. Hopcroft and Jeffrey D. Ullman.
1979.
Intro-duction to Automata Theory, Languages and Compu-tation.
Addison-Wesley, Reading, MA.Liang Huang and Kenji Sagae.
2010.
Dynamic program-ming for linear-time incremental parsing.
In Proceed-ings of the 48th Annual Meeting of the Association forComputational Linguistics, July.Marco Kuhlmann, Carlos Go?mez-Rodr?
?guez, and Gior-gio Satta.
2011.
Dynamic programming algorithmsfor transition-based dependency parsers.
In Proceed-ings of the 49th Annual Meeting of the Association forComputational Linguistics: Human Language Techno-logies, pages 673?682, Portland, Oregon, USA, June.Association for Computational Linguistics.Mitchell P. Marcus, Beatrice Santorini, and Mary AnnMarcinkiewicz.
1993.
Building a large annotated cor-pus of english: The penn treebank.
ComputationalLinguistics, 19(2):313?330.Joakim Nivre, Johan Hall, Sandra Ku?bler, Ryan McDon-ald, Jens Nilsson, Sebastian Riedel, and Deniz Yuret.2007.
The CoNLL 2007 shared task on dependencyparsing.
In Proceedings of EMNLP-CoNLL.Joakim Nivre.
2003.
An efficient algorithm for pro-jective dependency parsing.
In Proceedings of theEighth International Workshop on Parsing Technolo-gies (IWPT), pages 149?160, Nancy, France.Joakim Nivre.
2004.
Incrementality in deterministic de-pendency parsing.
In Workshop on Incremental Pars-ing: Bringing Engineering and Cognition Together,pages 50?57, Barcelona, Spain.Joakim Nivre.
2008.
Algorithms for deterministic incre-mental dependency parsing.
Computational Linguist-ics, 34(4):513?553.Francesco Sartorio, Giorgio Satta, and Joakim Nivre.2013.
A transition-based dependency parser using adynamic parsing strategy.
In Proceedings of the 51stAnnual Meeting of the Association for ComputationalLinguistics (Volume 1: Long Papers), pages 135?144,Sofia, Bulgaria, August.
Association for Computa-tional Linguistics.Yue Zhang and Stephen Clark.
2008.
A tale of twoparsers: Investigating and combining graph-based andtransition-based dependency parsing.
In Proceedingsof EMNLP.130
