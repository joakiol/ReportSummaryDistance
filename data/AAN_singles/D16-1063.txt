Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 658?668,Austin, Texas, November 1-5, 2016. c?2016 Association for Computational LinguisticsWordRank: Learning Word Embeddings via Robust RankingShihao JiParallel Computing Lab, Intelshihao.ji@intel.comHyokun YunAmazonyunhyoku@amazon.comPinar YanardagPurdue Universityypinar@purdue.eduShin MatsushimaUniversity of Tokyoshin matsushima@mist.i.u-tokyo.ac.jpS.
V. N. VishwanathanUniv.
of California, Santa Cruzvishy@ucsc.eduAbstractEmbedding words in a vector space has gaineda lot of attention in recent years.
While state-of-the-art methods provide efficient computa-tion of word similarities via a low-dimensionalmatrix embedding, their motivation is oftenleft unclear.
In this paper, we argue that wordembedding can be naturally viewed as a rank-ing problem due to the ranking nature of theevaluation metrics.
Then, based on this in-sight, we propose a novel framework Wor-dRank that efficiently estimates word repre-sentations via robust ranking, in which theattention mechanism and robustness to noiseare readily achieved via the DCG-like rank-ing losses.
The performance of WordRank ismeasured in word similarity and word anal-ogy benchmarks, and the results are com-pared to the state-of-the-art word embeddingtechniques.
Our algorithm is very competi-tive to the state-of-the- arts on large corpora,while outperforms them by a significant mar-gin when the training set is limited (i.e., sparseand noisy).
With 17 million tokens, WordRankperforms almost as well as existing methodsusing 7.2 billion tokens on a popular wordsimilarity benchmark.
Our multi-node dis-tributed implementation of WordRank is pub-licly available for general usage.1 IntroductionEmbedding words into a vector space, such that se-mantic and syntactic regularities between words arepreserved, is an important sub-task for many appli-cations of natural language processing.
Mikolov etal.
(2013a) generated considerable excitement in themachine learning and natural language processingcommunities by introducing a neural network basedmodel, which they call word2vec.
It was shown thatword2vec produces state-of-the-art performance onboth word similarity as well as word analogy tasks.The word similarity task is to retrieve words thatare similar to a given word.
On the other hand,word analogy requires answering queries of the forma:b;c:?, where a, b, and c are words from the vocab-ulary, and the answer to the query must be semanti-cally related to c in the same way as b is related toa.
This is best illustrated with a concrete example:Given the query king:queen;man:?
we expect themodel to output woman.The impressive performance of word2vec led toa flurry of papers, which tried to explain and im-prove the performance of word2vec both theoreti-cally (Arora et al, 2015) and empirically (Levy andGoldberg, 2014).
One interpretation of word2vecis that it is approximately maximizing the positivepointwise mutual information (PMI), and Levy andGoldberg (2014) showed that directly optimizingthis gives good results.
On the other hand, Penning-ton et al (2014) showed performance comparable toword2vec by using a modified matrix factorizationmodel, which optimizes a log loss.Somewhat surprisingly, Levy et al (2015) showedthat much of the performance gains of these newword embedding methods are due to certain hyper-parameter optimizations and system-design choices.In other words, if one sets up careful experiments,then existing word embedding models more or lessperform comparably to each other.
We conjecturethat this is because, at a high level, all these methods658are based on the following template: From a largetext corpus eliminate infrequent words, and computea |W| ?
|C| word-context co-occurrence count ma-trix; a context is a word which appears less than ddistance away from a given word in the text, whered is a tunable parameter.
Let w ?
W be a wordand c ?
C be a context, and let Xw,c be the (poten-tially normalized) co-occurrence count.
One learns afunction f(w, c) which approximates a transformedversion ofXw,c.
Different methods differ essentiallyin the transformation function they use and the para-metric form of f (Levy et al, 2015).
For exam-ple, GloVe (Pennington et al, 2014) uses f (w, c) =?uw,vc?
where uw and vc are k dimensional vec-tors, ?
?, ??
denotes the Euclidean dot product, andone approximates f (w, c) ?
logXw,c.
On the otherhand, as Levy and Goldberg (2014) show, word2veccan be seen as using the same f(w, c) as GloVebut trying to approximate f (w, c) ?
PMI(Xw,c) ?log n, where PMI(?)
is the pairwise mutual informa-tion (Cover and Thomas, 1991) and n is the numberof negative samples.In this paper, we approach the word embeddingtask from a different perspective by formulatingit as a ranking problem.
That is, given a wordw, we aim to output an ordered list (c1, c2, ?
?
?
)of context words from C such that words that co-occur with w appear at the top of the list.
Ifrank(w, c) denotes the rank of c in the list, then typ-ical ranking losses optimize the following objective:?(w,c)??
?
(rank(w, c)), where ?
?
W ?
C is theset of word-context pairs that co-occur in the corpus,and ?(?)
is a ranking loss function that is monotoni-cally increasing and concave (see Sec.
2 for a justi-fication).Casting word embedding as ranking has two dis-tinctive advantages.
First, our method is discrimina-tive rather than generative; in other words, insteadof modeling (a transformation of) Xw,c directly, weonly aim to model the relative order of Xw,?
val-ues in each row.
This formulation fits naturally topopular word embedding tasks such as word simi-larity/analogy since instead of the likelihood of eachword, we are interested in finding the most relevantwords in a given context1.
Second, casting word1Roughly speaking, this difference in viewpoint is analo-gous to the difference between pointwise loss function vs list-embedding as a ranking problem enables us to de-sign models robust to noise (Yun et al, 2014) andfocusing more on differentiating top relevant words,a kind of attention mechanism that has been provedvery useful in deep learning (Larochelle and Hin-ton, 2010; Mnih et al, 2014; Bahdanau et al, 2015).Both issues are very critical in the domain of wordembedding since (1) the co-occurrence matrix mightbe noisy due to grammatical errors or unconven-tional use of language, i.e., certain words might co-occur purely by chance, a phenomenon more acutein smaller document corpora collected from diversesources; and (2) it?s very challenging to sort out afew most relevant words from a very large vocabu-lary, thus some kind of attention mechanism that cantrade off the resolution on most relevant words withthe resolution on less relevant words is needed.
Wewill show in the experiments that our method canmitigate some of these issues; with 17 million to-kens our method performs almost as well as existingmethods using 7.2 billion tokens on a popular wordsimilarity benchmark.2 Word Embedding via Ranking2.1 NotationWe use w to denote a word and c to denote a con-text.
The set of all words, that is, the vocabularyis denoted as W and the set of all context words isdenoted C. We will use ?
?
W ?
C to denote theset of all word-context pairs that were observed inthe data, ?w to denote the set of contexts that co-occured with a given word w, and similarly ?c todenote the words that co-occurred with a given con-text c. The size of a set is denoted as |?|.
The innerproduct between vectors is denoted as ?
?, ?
?.2.2 Ranking ModelLet uw denote the k-dimensional embedding of aword w, and vc denote that of a context c. Forconvenience, we collect embedding parameters forwords and contexts as U := {uw}w?W , and V :={vc}c?C .We aim to capture the relevance of context c forword w by the inner product between their embed-ding vectors, ?uw,vc?
; the more relevant a contextis, the larger we want their inner product to be.wise loss function used in ranking (Lee and Lin, 2013).659We achieve this by learning a ranking model that isparametrized by U and V. If we sort the set of con-texts C for a given word w in terms of each context?sinner product score with the word, the rank of a spe-cific context c in this list can be written as (Usunieret al, 2009):rank (w, c) =?c?
?C\{c}I (?uw,vc?
?
?uw,vc??
?
0)=?c?
?C\{c}I (?uw,vc ?
vc??
?
0) , (1)where I(x ?
0) is a 0-1 loss function which is 1 ifx ?
0 and 0 otherwise.
Since I(x ?
0) is a dis-continuous function, we follow the popular strategyin machine learning which replaces the 0-1 loss byits convex upper bound `(?
), where `(?)
can be anypopular loss function for binary classification suchas the hinge loss `(x) = max (0, 1?
x) or the lo-gistic loss `(x) = log2 (1 + 2?x) (Bartlett et al,2006).
This enables us to construct the followingconvex upper bound on the rank:rank (w, c)?rank (w, c)=?c??C\{c}`(?uw,vc?vc??)
(2)It is certainly desirable that the ranking model po-sitions relevant contexts at the top of the list; thismotivates us to write the objective function to mini-mize as:J (U,V):=?w?W?c?
?wrw,c ??
(rank (w, c)+??
)(3)where rw,c is the weight between word w and con-text c quantifying the association between them, ?(?
)is a monotonically increasing and concave rankingloss function that measures goodness of a rank, and?
> 0, ?
> 0 are the hyperparameters of the modelwhose role will be discussed later.
Following Pen-nington et al (2014), we userw,c ={(Xw,c/xmax) if Xw,c < xmax1 otherwise, (4)where we set xmax = 100 and  = 0.75 in our ex-periments.
That is, we assign larger weights (with asaturation) to contexts that appear more often withthe word of interest, and vice-versa.
For the rankingloss function ?(?
), on the other hand, we considerthe class of monotonically increasing and concavefunctions.
While monotonicity is a natural require-ment, we argue that concavity is also important sothat the derivative of ?
is always non-increasing; thisimplies that the ranking loss to be the most sensitiveat the top of the list (where the rank is small) andbecomes less sensitive at the lower end of the list(where the rank is high).
Intuitively this is desir-able, because we are interested in a small number ofrelevant contexts which frequently co-occur with agiven word, and thus are willing to tolerate errors oninfrequent contexts2.
Meanwhile, this insensitivityat the bottom of the list makes the model robust tonoise in the data either due to grammatical errors orunconventional use of language.
Therefore, a sin-gle ranking loss function ?(?)
serves two differentpurposes at two ends of the curve (see the exampleplots of ?
in Figure 1); while the left hand side ofthe curve encourages ?high resolution?
on most rel-evant words, the right hand side becomes less sen-sitive (with ?low resolution?)
to infrequent and pos-sibly noisy words3.
As we will demonstrate in ourexperiments, this is a fundamental attribute (in addi-tion to the ranking nature) of our method that con-tributes its superior performance as compared to thestate-of-the-arts when the training set is limited (i.e.,sparse and noisy).What are interesting loss functions that can beused for ?
(?)?
Here are four possible alternatives,all of which have a natural interpretation (see theplots of all four ?
functions in Figure 1(a) and therelated work in Sec.
3 for a discussion).
?0 (x) := x (identity) (5)?1 (x) := log2 (1 + x) (logarithm) (6)?2 (x) := 1?1log2(2 + x)(negative DCG) (7)?3 (x) :=x1?t ?
11?
t (logt with t 6= 1) (8)2This is similar to the attention mechanism found in humanvisual system that is able to focus on a certain region of an im-age with ?high resolution?
while perceiving the surrounding im-age in ?low resolution?
(Larochelle and Hinton, 2010; Mnih etal., 2014).3Due to the linearity of ?0(x)=x, this ranking loss doesn?thave the benefit of attention mechanism and robustness to noisesince it treats all ranking errors uniformly.6600 0.5 1 1.5 2?1?0.500.511.52x?
(x)?0(x)?1(x)?2(x)?3(x) with t=1.50 20 40 60 80 10001234567x?
1((x+?)/?
)?0?1 with (?=1,   ?=0)?1 with (?=10, ?=9)?1 with (?=100,?=99)Figure 1: (a) Visualizing different ranking loss functions ?
(x) as defined in Eqs.
(5?8); the lower part of ?3(x) is truncated inorder to visualize the other functions better.
(b) Visualizing ?1((x + ?)/?)
with different ?
and ?
; ?0 is included to illustrate thedramatic scale differences between ?0 and ?1.We will explore the performance of each of thesevariants in our experiments.
For now, we turn ourattention to efficient stochastic optimization of theobjective function (3).2.3 Stochastic OptimizationPlugging (2) into (3), and replacing ?w?W?c??wby?(w,c)?
?, the objective function becomes:J (U,V) =?(w,c)??rw,c??(?c?
?C\{c}` (?uw,vc?vc??)+??).
(9)This function contains summations over ?
and C,both of which are expensive to compute for a largecorpus.
Although stochastic gradient descent (SGD)(Bottou and Bousquet, 2011) can be used to re-place the summation over ?
by random sampling,the summation over C cannot be avoided unless ?(?
)is a linear function.
To work around this problem,we propose to optimize a linearized upper bound ofthe objective function obtained through a first-orderTaylor approximation.
Observe that due to the con-cavity of ?(?
), we have?
(x) ?
?(?
?1)+ ??(??1)?(x?
?
?1) (10)for any x and ?
6= 0.
Moreover, the bound is tightwhen ?
= x?1.
This motivates us to introduce aset of auxiliary parameters ?
:= {?w,c}(w,c)??
anddefine the following upper bound of J (U,V):J (U,V,?)
:=?(w,c)?
?rw,c ?{?(?
?1wc ) + ??(?
?1wc ) ?(??1?+??1?c?
?C\{c}` (?uw,vc?vc??)???1w,c)}.
(11)Note that J (U,V) ?
J (U,V,?)
for any ?, dueto (10)4.
Also, minimizing (11) yields the same Uand V as minimizing (9).
To see this, suppose U?
:={u?w}w?W and V?
:= {v?c}c?C minimizes (9).
Then,by letting ??
:={??w,c}(w,c)??where?
?w,c =??c?
?C\{c} ` (?u?w, v?c ?
v?c??)
+ ?, (12)we have J(U?, V?, ??
)= J(U?, V?).
Therefore,it suffices to optimize (11).
However, unlike (9),(11) admits an efficient SGD algorithm.
To see this,rewrite (11) asJ(U,V,?)=?(w,c,c?)rw,c?(?(??1w,c)+??(??1w,c)?(??1???
?1w,c)|C| ?
1+ 1???(?
?1w,c) ?
` (?uw,vc ?
vc??
)), (13)where (w, c, c?)
?
?
?
(C \ {c}).
Then, it can beseen that if we sample uniformly from (w, c) ?
?and c?
?
C \ {c}, then j(w, c, c?)
:=|?|?
(|C|?1) ?
rw,c ?(?(??1w,c)+??(??1w,c)?(??1???
?1w,c)|C| ?
1+ 1???(?
?1w,c)?` (?uw,vc ?
vc??
)), (14)which does not contain any expensive summa-tions and is an unbiased estimator of (13), i.e.,E [j(w, c, c?)]
= J (U,V,?).
On the other hand,one can optimize ?w,c exactly by using (12).
Putting4When ?
= ?0, one can simply set the auxiliary variables?w,c=1 because ?0 is already a linear function.661everything together yields a stochastic optimiza-tion algorithm WordRank, which can be special-ized to a variety of ranking loss functions ?(?)
withweights rw,c (e.g., DCG (Discounted CumulativeGain) (Manning et al, 2008) is one of many pos-sible instantiations).
Algorithm 1 contains detailedpseudo-code.
It can be seen that the algorithm is di-vided into two stages: a stage that updates (U,V)and another that updates ?.
Note that the time com-plexity of the first stage is O(|?|) since the cost ofeach update in Lines 8?10 is independent of the sizeof the corpus.
On the other hand, the time complex-ity of updating ?
in Line 15 is O(|?| |C|), whichcan be expensive.
To amortize this cost, we em-ploy two tricks: we only update ?
after a few it-erations of U and V update, and we exploit the factthat the most computationally expensive operationin (12) involves a matrix and matrix multiplicationwhich can be calculated efficiently via the SGEMMroutine in BLAS (Dongarra et al, 1990).Algorithm 1 WordRank algorithm.1: ?
: step size2: repeat3: // Stage 1: Update U and V4: repeat5: Sample (w, c) uniformly from ?6: Sample c?
uniformly from C \ {c}7: // following three updatesare executed simultaneously8: uw ?
uw ?
?
?
rw,c ?
??(?
?1w,c) ?`?
(?uw,vc?vc??)
?
(vc?vc?
)9: vc ?
vc ?
?
?
rw,c ?
??(?
?1w,c) ?`?
(?uw,vc?vc??)
?
uw10: vc?
?
vc?
+ ?
?
rw,c ?
??(?
?1w,c) ?`?
(?uw,vc?vc??)
?
uw11: until U and V are converged12: // Stage 2: Update ?13: for w ?
W do14: for c ?
C do15: ?w,c=?/(?c?
?C\{c} ` (?uw,vc?vc??)+?
)16: end for17: end for18: until U, V and ?
are converged2.4 ParallelizationThe updates in Lines 8?10 have one remarkableproperty: To update uw, vc and vc?
, we only needto read the variables uw, vc, vc?
and ?w,c.
What thismeans is that updates to another triplet of variablesuw?, vc?
and vc??
can be performed independently.This observation is the key to developing a paralleloptimization strategy, by distributing the computa-tion of the updates among multiple processors.
Dueto lack of space, details including pseudo-code arerelegated to the supplementary material.2.5 Interpreting of ?
and ?The update (12) indicates that ?
?1w,c is proportionalto rank (w, c).
On the other hand, one can observethat the loss function ` (?)
in (14) is weighted by a??(?
?1w,c) term.
Since ?
(?)
is concave, its gradient??
(?)
is monotonically non-increasing (Rockafellar,1970).
Consequently, when rank (w, c) and hence?
?1w,c is large, ??(?
?1w,c) is small.
In other words, theloss function ?gives up?
on contexts with high ranksin order to focus its attention on top of the list.
Therate at which the algorithm gives up is determinedby the hyperparameters ?
and ?.
For the illustrationof this effect, see the example plots of ?1 with dif-ferent ?
and ?
in Figure 1(b).
Intuitively, ?
can beviewed as a scale parameter while ?
can be viewedas an offset parameter.
An equivalent interpretationis that by choosing different values of ?
and ?
onecan modify the behavior of the ranking loss ?
(?)
in aproblem dependent fashion.
In our experiments, wefound that a common setting of ?= 1 and ?= 0 of-ten yields uncompetitive performance, while setting?=100 and ?=99 generally gives good results.3 Related WorkOur work sits at the intersection of word embed-ding and ranking optimization.
As we discussed inSec.
2.2 and Sec.
2.5, it?s also related to the atten-tion mechanism widely used in deep learning.
Wetherefore review the related work along these threeaxes.Word Embedding.
We already discussed somerelated work (word2vec and GloVe) on word em-bedding in the introduction.
Essentially, word2vecand GloVe derive word representations by modelinga transformation (PMI or log) ofXw,c directly, while662WordRank learns word representations via robustranking.
Besides these state-of-the-art techniques, afew ranking-based approaches have been proposedfor word embedding recently, e.g., (Collobert andWeston, 2008; Vilnis and McCallum, 2015; Liu etal., 2015).
However, all of them adopt a pair-wisebinary classification approach with a linear rank-ing loss ?0.
For example, (Collobert and Weston,2008; Vilnis and McCallum, 2015) employ a hingeloss on positive/negative word pairs to learn wordrepresentations and ?0 is used implicitly to evaluateranking losses.
As we discussed in Sec.
2.2, ?0 hasno benefit of the attention mechanism and robust-ness to noise since its linearity treats all the rank-ing errors uniformly; empirically, sub-optimal per-formances are often observed with ?0 in our exper-iments.
More recently, by extending the Skip-Grammodel of word2vec, Liu et al (2015) incorporatesadditional pair-wise constraints induced from 3rd-party knowledge bases, such as WordNet, and learnsword representations jointly.
In contrast, WordRankis a fully ranking-based approach without using anyadditional data source for training.Robust Ranking.
The second line of work that isvery relevant to WordRank is that of ranking objec-tive (3).
The use of score functions ?uw,vc?
forranking is inspired by the latent collaborative re-trieval framework of Weston et al (2012).
Writingthe rank as a sum of indicator functions (1), andupper bounding it via a convex loss (2) is due toUsunier et al (2009).
Using ?0 (?)
(5) correspondsto the well-known pairwise ranking loss (see e.g.,(Lee and Lin, 2013)).
On the other hand, Yun etal.
(2014) observed that if they set ?
= ?2 as in(7), then ?J (U,V) corresponds to the DCG (Dis-counted Cumulative Gain), one of the most popularranking metrics used in web search ranking (Man-ning et al, 2008).
In their RobiRank algorithm theyproposed the use of ?
= ?1 (6), which they consid-ered to be a special function for which one can de-rive an efficient stochastic optimization procedure.However, as we showed in this paper, the generalclass of monotonically increasing concave functionscan be handled efficiently.
Another important differ-ence of our approach is the hyperparameters ?
and?, which we use to modify the behavior of ?, andwhich we find are critical to achieve good empiricalresults.
Ding and Vishwanathan (2010) proposed theuse of ?=logt in the context of robust binary classi-fication, while here we are concerned with ranking,and our formulation is very general and applies to avariety of ranking losses ?
(?)
with weights rw,c.
Op-timizing over U and V by distributing the computa-tion across processors is inspired by work on dis-tributed stochastic gradient for matrix factorization(Gemulla et al, 2011).Attention.
Attention is one of the most impor-tant advancements in deep learning in recent years(Larochelle and Hinton, 2010), and is now widelyused in state-of-the-art image recognition and ma-chine translation systems (Mnih et al, 2014; Bah-danau et al, 2015).
Recently, attention has also beenapplied to the domain of word embedding.
For ex-ample, under the intuition that not all contexts arecreated equal, Wang et al (2015) assign an impor-tance weight to each word type at each context po-sition and learn an attention-based Continuous Bag-Of-Words (CBOW) model.
Similarly, within a rank-ing framework, WordRank expresses the context im-portance by introducing the auxiliary variable ?w,c,which ?gives up?
on contexts with high ranks in or-der to focus its attention on top of the list.4 ExperimentsIn our experiments, we first evaluate the impact ofthe weight rw,c and the ranking loss function ?(?
)on the test performance using a small dataset.
Wethen pick the best performing model and compare itagainst word2vec (Mikolov et al, 2013b) and GloVe(Pennington et al, 2014).
We closely follow theframework of Levy et al (2015) to set up a carefuland fair comparison of the three methods.
Our codeis publicly available at https://bitbucket.org/shihaoji/wordrank.Training Corpus Models are trained on a com-bined corpus of 7.2 billion tokens, which consistsof the 2015 Wikipedia dump with 1.6 billion tokens,the WMT14 News Crawl5 with 1.7 billion tokens,the ?One Billion Word Language Modeling Bench-mark?6 with almost 1 billion tokens, and UMBC5http://www.statmt.org/wmt14/translation-task.html6http://www.statmt.org/lm-benchmark663Corpus Size 17M?
32M 64M 128M 256M 512M 1.0B 1.6B 7.2BVocabulary Size |W| 71K 100K 100K 200K 200K 300K 300K 400K 620KWindow Size win 15 15 15 10 10 10 10 10 10Dimension k 100 100 100 200 200 300 300 300 300* This is the Text8 dataset from http://mattmahoney.net/dc/text8.zip, which is widely used for word embedding demo.Table 1: Parameter settings used in the experiments.Task Robi ?0 ?1 ?2 ?3off on off on off on off onSimilarity 41.2 69.0 71.0 66.7 70.4 66.8 70.8 68.1 68.0Analogy 22.7 24.9 31.9 34.3 44.5 32.3 40.4 33.6 42.9Table 2: Performance of different ?
functions on Text8 dataset with 17M tokens.webbase corpus7 with around 3 billion tokens.
Thepre-processing pipeline breaks the paragraphs intosentences, tokenizes and lowercases each corpuswith the Stanford tokenizer.
We further clean upthe dataset by removing non-ASCII characters andpunctuation, and discard sentences that are shorterthan 3 tokens or longer than 500 tokens.
In the end,we obtain a dataset of 7.2 billion tokens, with thefirst 1.6 billion tokens from Wikipedia.
When wewant to experiment with a smaller corpus, we ex-tract a subset which contains the specified numberof tokens.Co-occurrence matrix construction We use theGloVe code to construct the co-occurrence matrixX , and the same matrix is used to train GloVe andWordRank models.
When constructing X , we mustchoose the size of the vocabulary, the context win-dow and whether to distinguish left context fromright context.
We follow the findings and designchoices of GloVe and use a symmetric window ofsize win with a decreasing weighting function, sothat word pairs that are d words apart contribute 1/dto the total count.
Specifically, when the corpus issmall (e.g., 17M, 32M, 64M) we let win = 15 andfor larger corpora we let win= 10.
The larger win-dow size alleviates the data sparsity issue for smallcorpus at the expense of adding more noise to X .The parameter settings used in our experiments aresummarized in Table 1.Using the trained model It has been shown byPennington et al (2014) that combining the uw andvc vectors with equal weights gives a small boost7http://ebiquity.umbc.edu/resource/html/id/351in performance.
This vector combination was origi-nally motivated as an ensemble method (Penningtonet al, 2014), and later Levy et al (2015) provideda different interpretation of its effect on the cosinesimilarity function, and show that adding contextvectors effectively adds first-order similarity termsto the second-order similarity function.
In our ex-periments, we find that vector combination booststhe performance in word analogy task when trainingset is small, but when dataset is large enough (e.g.,7.2 billion tokens), vector combination doesn?t helpanymore.
More interestingly, for the word similaritytask, we find that vector combination is detrimen-tal in all the cases, sometimes even substantially8.Therefore, we will always use uw on word similaritytask, and use uw + vc on word analogy task unlessotherwise noted.4.1 EvaluationWord Similarity We use six datasets to evaluateword similarity: WS-353 (Finkelstein et al, 2002)partitioned into two subsets: WordSim Similarityand WordSim Relatedness (Agirre et al, 2009);MEN (Bruni et al, 2012); Mechanical Turk (Radin-sky et al, 2011); Rare words (Luong et al, 2013);and SimLex-999 (Hill et al, 2014).
They containword pairs together with human-assigned similarityjudgments.
The word representations are evaluatedby ranking the pairs according to their cosine simi-larities, and measuring the Spearman?s rank correla-tion coefficient with the human judgments.8This is possible since we optimize a ranking loss: the ab-solute scores don?t matter as long as they yield an ordered listcorrectly.
Thus, WordRank?s uw and vc are less comparableto each other than those generated by GloVe, which employs apoint-wise L2 loss.664Word Analogies For this task, we use the Googleanalogy dataset (Mikolov et al, 2013a).
It contains19544 word analogy questions, partitioned into 8869semantic and 10675 syntactic questions.
A questionis correctly answered only if the algorithm selectsthe word that is exactly the same as the correct wordin the question: synonyms are thus counted as mis-takes.
There are two ways to answer these questions,namely, by using 3CosAdd or 3CosMul (see (Levyand Goldberg, 2014) for details).
We will reportscores by using 3CosAdd by default, and indicatewhen 3CosMul gives better performance.4.2 The impact of rw,c and ?(?
)In Sec.
2.2 we argued the need for adding weightrw,c to ranking objective (3), and we also presentedour framework which can deal with a variety ofranking loss functions ?.
We now study the utilityof these two ideas.
We report results on the 17 mil-lion token dataset in Table 2.
For the similarity task,we use the WS-353 test set and for the analogy taskwe use the Google analogy test set.
The best scoresfor each task are underlined.
We set t= 1.5 for ?3.?Off?
means that we used uniform weight rw,c = 1,and ?on?
means that rw,c was set as in (4).
For com-parison, we also include the results using RobiRank(Yun et al, 2014)9.It can be seen from Table 2 that adding the weightrw,c improves performance in all the cases, espe-cially on the word analogy task.
Among the four?
functions, ?0 performs the best on the word simi-larity task but suffers notably on the analogy task,while ?1 = log performs the best overall.
Giventhese observations, which are consistent with the re-sults on large scale datasets, in the experiments thatfollow we only report WordRank with the best con-figuration, i.e., using ?1 with the weight rw,c as de-fined in (4).4.3 Comparison to state-of-the-artsIn this section we compare the performance of Wor-dRank with word2vec10 and GloVe11, by using the9We used the code provided by the authors at https://bitbucket.org/d_ijk_stra/robirank.
Althoughrelated to RobiRank, we attribute the superior performance ofWordRank to the use of weight rw,c (4), introduction of hyper-parameters ?
and ?, and many implementation details.10https://code.google.com/p/word2vec/11http://nlp.stanford.edu/projects/glovecode provided by the respective authors.
For a faircomparison, GloVe and WordRank are given as in-put the same co-occurrence matrix X; this elimi-nates differences in performance due to window sizeand other such artifacts, and the same parametersare used to word2vec.
Moreover, the embedding di-mensions used for each of the three methods is thesame (see Table 1).
With word2vec, we train theSkip-Gram with Negative Sampling (SGNS) modelsince it produces state-of-the-art performance, andis widely used in the NLP community (Mikolov etal., 2013b).
For GloVe, we use the default parame-ters as suggested by (Pennington et al, 2014).
Theresults are provided in Figure 2 (also see Table 4 inthe supplementary material for additional details).As can be seen, when the size of corpus increases,in general all three algorithms improve their predic-tion accuracy on both tasks.
This is to be expectedsince a larger corpus typically produces better statis-tics and less noise in the co-occurrence matrix X .When the corpus size is small (e.g., 17M, 32M,64M, 128M), WordRank yields the best performancewith significant margins among three, followed byword2vec and GloVe; when the size of corpus in-creases further, on the word analogy task word2vecand GloVe become very competitive to WordRank,and eventually perform neck-to-neck to each other(Figure 2(b)).
This is consistent with the findings of(Levy et al, 2015) indicating that when the numberof tokens is large even simple algorithms can per-form well.
On the other hand, WordRank is dom-inant on the word similarity task for all the cases(Figure 2(a)) since it optimizes a ranking loss explic-itly, which aligns more naturally with the objectiveof word similarity than the other methods; with 17million tokens our method performs almost as wellas existing methods using 7.2 billion tokens on theword similarity benchmark.To further evaluate the model performance on theword similarity/analogy tasks, we use the best per-forming models trained on the 7.2-billion-token cor-pus to predict on the six word similarity datasets de-scribed in Sec.
4.1.
Moreover, we breakdown theperformance of the models on the Google word anal-ogy dataset into the semantic and syntactic subtasks.Results are listed in Table 3.
As can be seen, Wor-dRank outperforms word2vec and GloVe on 5 of 6similarity tasks, and 1 of 2 Google analogy subtasks.66517M 32M 64M 128M 256M 512M 1B 1.6B 7.2B4550556065707580Number of TokensAccuracy [%]Word2VecGloVeWordRank17M 32M 64M 128M 256M 512M 1B 1.6B 7.2B3035404550556065707580Number of TokensAccuracy [%]Word2VecGloVeWordRankFigure 2: Performance evolution as a function of corpus size (a) on WS-353 word similarity benchmark; (b) on Google wordanalogy benchmark.Word Similarity Word AnalogyModel WordSim WordSim Bruni et Radinsky Luong et Hill et al Goog GoogSimilarity Relatedness al.
MEN et al MT al.
RW SimLex Sem.
Syn.word2vec 73.9 60.9 75.4 66.4 45.5 36.6 78.8 72.0GloVe 75.7 67.5 78.8 69.7 43.6 41.6 80.9 71.1WordRank 79.4 70.5 78.1 73.5 47.4 43.5 78.4 74.7Table 3: Performance of the best word2vec, GloVe and WordRank models, learned from 7.2 billion tokens, on six similarity tasksand Google semantic and syntactic subtasks.5 Visualizing the resultsTo understand whether WordRank produces syntat-ically and semantically meaningful vector space,we did the following experiment: we use the bestperforming model produced using 7.2 billion to-kens, and compute the nearest neighbors of the word?cat?.
We then visualize the words in two dimen-sions by using t-SNE (Maaten and Hinton, 2008).As can be seen in Figure 3, our ranking-based modelis indeed capable of capturing both semantic (e.g.,cat, feline, kitten, tabby) and syntactic (e.g., leash,leashes, leashed) regularities of the English lan-guage.6 ConclusionWe proposed WordRank, a ranking-based approach,to learn word representations from large scale tex-tual corpora.
The most prominent difference be-tween our method and the state-of-the-art tech-niques, such as word2vec and GloVe, is that Wor-dRank learns word representations via a robust rank-ing model, while word2vec and GloVe typicallymodel a transformation of co-occurrence countXw,cdirectly.
Moreover, by a ranking loss function ?(?
),WordRank achieves its attention mechanism and ro-bustness to noise naturally, which are usually lack-25 30 35 40 45 50?6?4?202468101214catsfelinekittenfelinesdogpetdogskittenspetstabbypawscaninepuppyuppiespoochdoggie caninespupskittiespuppawleashedferalpawprintszoodo gypoochesaspcazooscubmuttspettingstrayzookeepersgroomersleashpandagroomerpandasleashesmuttcatFigure 3: Nearest neighbors of ?cat?
found by projecting a300d word embedding learned from WordRank onto a 2d space.ing in other ranking-based approaches.
These at-tributes significantly boost the performance of Wor-dRank in the cases where training data are sparse andnoisy.
Our multi-node distributed implementation ofWordRank is publicly available for general usage.AcknowledgmentsWe?d like to thank Omer Levy for sharing his scriptfor preprocessing the corpora used in the paper.
Wealso thank the anonymous reviewers for their valu-able comments and suggestions.666ReferencesEneko Agirre, Enrique Alfonseca, Keith Hall, JanaKravalova, Marius Pasca, and Aitor Soroa.
2009.
Astudy on similarity and relatedness using distributionaland wordnet-based approaches.
Proceedings of Hu-man Language Technologies, pages 19?27.Sanjeev Arora, Yuanzhi Li, Yingyu Liang, Tengyu Ma,and Andrej Risteski.
2015.
Random walks on contextspaces: Towards an explanation of the mysteries of se-mantic word embeddings.
Technical report, ArXiV.http://arxiv.org/pdf/1502.03520.pdf.Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Ben-gio.
2015.
Neural machine translation by jointlylearning to align and translate.
In Proceedings ofthe International Conference on Learning Represen-tations (ICLR).Peter L. Bartlett, Michael I. Jordan, and Jon D.McAuliffe.
2006.
Convexity, classification, and riskbounds.
Journal of the American Statistical Associa-tion, 101(473):138?156.Le?on Bottou and Olivier Bousquet.
2011.
The trade-offs of large-scale learning.
Optimization for MachineLearning, page 351.Elia Bruni, Gemma Boleda, Marco Baroni, andNam Khanh Tran.
2012.
Distributional semanticsin technicolor.
Proceedings of the 50th Annual Meet-ing of the Association for Computational Linguistics,pages 136?145.Ronan Collobert and Jason Weston.
2008.
A unified ar-chitecture for natural language processing: Deep neu-ral networks with multitask learning.
In Proceedingsof the 25th international conference onMachine learn-ing, pages 160?167.
ACM.T.
M. Cover and J.
A. Thomas.
1991.
Elements of Infor-mation Theory.
John Wiley and Sons, New York.Nan Ding and S. V. N. Vishwanathan.
2010. t-logistic re-gression.
In Richard Zemel, John Shawe-Taylor, JohnLafferty, Chris Williams, and Alan Culota, editors, Ad-vances in Neural Information Processing Systems 23.J.
J. Dongarra, J.
Du Croz, S. Duff, and S. Hammarling.1990.
A set of level 3 basic linear algebra subpro-grams.
ACM Transactions on Mathematical Software,16:1?17.Lev Finkelstein, Evgeniy Gabrilovich, Yossi Matias,Ehud Rivlin, Zach Solan, Gadi Wolfman, and EytanRuppin.
2002.
Placing search in context: The conceptrevisited.
ACM Transactions on Information Systems,20:116?131.R.
Gemulla, E. Nijkamp, P. J. Haas, and Y. Sisma-nis.
2011.
Large-scale matrix factorization with dis-tributed stochastic gradient descent.
In Conference onKnowledge Discovery and Data Mining, pages 69?77.Felix Hill, Roi Reichart, and Anna Korhonen.
2014.Simlex-999: Evaluating semantic models with (gen-uine) similarity estimation.
Proceedings of the Sev-enteenth Conference on Computational Natural Lan-guage Learning.Hugo Larochelle and Geoffrey E. Hinton.
2010.
Learn-ing to combine foveal glimpses with a third-orderboltzmann machine.
In Advances in Neural Informa-tion Processing Systems (NIPS) 23, pages 1243?1251.Ching-Pei Lee and Chih-Jen Lin.
2013.
Large-scale lin-ear ranksvm.
Neural Computation.
To Appear.Omer Levy and Yoav Goldberg.
2014.
Neural wordembedding as implicit matrix factorization.
In MaxWelling, Zoubin Ghahramani, Corinna Cortes, NeilLawrence, and Kilian Weinberger, editors, Advancesin Neural Information Processing Systems 27, pages2177?2185.Omer Levy, Yoav Goldberg, and Ido Dagan.
2015.
Im-proving distributional similarity with lessons learnedfrom word embeddings.
Transactions of the Associa-tion for Computational Linguistics, 3:211?225.Quan Liu, Hui Jiang, Si Wei, Zhen-Hua Ling, and Yu Hu.2015.
Learning semantic word embeddings based onordinal knowledge constraints.
In Proceedings of theAnnual Meeting of the Association for ComputationalLinguistics (ACL), pages 1501?1511.Minh-Thang Luong, Richard Socher, and Christopher D.Manning.
2013.
Better word representations with re-cursive neural networks for morphology.
Proceedingsof the Seventeenth Conference on Computational Nat-ural Language Learning, pages 104?113.L.
van der Maaten and G.E.
Hinton.
2008.
Visualizinghigh-dimensional data using t-sne.
jmlr, 9:2579?2605.C.
D. Manning, P. Raghavan, and H. Schu?tze.
2008.
In-troduction to Information Retrieval.
Cambridge Uni-versity Press.Tomas Mikolov, Kai Chen, Greg Corrado, and JeffreyDean.
2013a.
Efficient estimation of word representa-tions in vector space.
arXiv preprint arXiv:1301.3781.Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Cor-rado, and Jeffrey Dean.
2013b.
Distributed represen-tations of words and phrases and their composition-ality.
In Chris Burges, Leon Bottou, Max Welling,Zoubin Ghahramani, and Kilian Weinberger, editors,Advances in Neural Information Processing Systems26.Volodymyr Mnih, Nicolas Heess, Alex Graves, and Ko-ray Kavukcuoglu.
2014.
Recurrent models of visualattention.
In Advances in Neural Information Process-ing Systems (NIPS) 27, pages 2204?2212.Jeffrey Pennington, Richard Socher, and Christopher DManning.
2014.
Glove: Global vectors for word rep-resentation.
Proceedings of the Empiricial Methods inNatural Language Processing (EMNLP 2014), 12.667Kira Radinsky, Eugene Agichtein, Evgeniy Gabrilovich,and Shaul Markovitch.
2011.
A word at a time: Com-puting word relatedness using temporal semantic anal-ysis.
Proceedings of the 20th international conferenceon World Wide Web, pages 337?346.R.
T. Rockafellar.
1970.
Convex Analysis, volume 28 ofPrinceton Mathematics Series.
Princeton UniversityPress, Princeton, NJ.Nicolas Usunier, David Buffoni, and Patrick Gallinari.2009.
Ranking with ordered weighted pairwise clas-sification.
In Proceedings of the International Confer-ence on Machine Learning.Luke Vilnis and Andrew McCallum.
2015.
Word repre-sentations via gaussian embedding.
In Proceedings ofthe International Conference on Learning Representa-tions (ICLR).Ling Wang, Chu-Cheng Lin, Yulia Tsvetkov, Silvio Amir,Ramon Fernandez Astudillo, Chris Dyer, Alan Black,and Isabel Trancoso.
2015.
Not all contexts are cre-ated equal: Better word representations with variableattention.
In EMNLP.Jason Weston, Chong Wang, Ron Weiss, and AdamBerenzweig.
2012.
Latent collaborative retrieval.arXiv preprint arXiv:1206.4603.Hyokun Yun, Parameswaran Raman, and S. V. N. Vish-wanathan.
2014.
Ranking via robust binary classifi-cation and parallel parameter estimation in large-scaledata.
In nips.668
