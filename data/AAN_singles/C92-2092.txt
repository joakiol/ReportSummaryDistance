LE ' IT ING THE CAT OUT OF THE BAG:GENERATION FOR SHAKE-AND-BAKE MTCHRIS BREWSharp Laboratories of Europe Ltd.OxfordMon, May 11, 1992chr isbrOprg,  ac.
ox.
uk1 .
Introduct ionThis paper discusses an implementation f thesentence generation component of a Shake-and-Bake Machine Translation system..
Since the taskitself is NP-complete, and therefore almostcertainly intractable our algorithm is a heuristicmethod based on constraint propagation.
Wepresent preliminary evidence that this is likelyto offer greater efficiency than previousalgorithms.In SLE's approach to multilingual machinetranslation.
\[Whitelock, 1991, this conference\] weenvisage the process of sentence generation asbeginning from a multiset or bag of richlystructured lexical signs rather than from aconventional logical form or other underlyingstructure.
The translation equivalences are statedbetween sets of lexical signs, with thesuperstructure of non-terminal symbols being nomore than the means by which monolingualgrammars are implementedThe work described here was motivated by adesire to improve on a correct but inefficientalgorithm provided by Whitelock \[Whitelock,1991, this conference\].
We begin by introducing theproblem, proceed by investigating its worst-casebehaviour, and conclude by describing newalgorithms for Shake-and-Bake generation.Since the linear order of the source language is nottransferred into the bag, it is the business of themonolingual grammar writer to ensure that theword-order requirements of the target languageare suitably encoded, and the business of thealgorithm designer to ensure that this encoding isexploited as efficiently as possible.
For anexample of the grammar writer's responsibility,the difference between "Mary likes Frances" and"Frances likes Mary" can be encoded in thesharing of index variables between the propernouns and the verb.
For an example of thealgorithm designer's responsibility, it would be amistake (as Whitelock has noted) to provide atranslation or generation algorithm whichunintentionally unified the two index variables,leading to a reading in which "Mary" and"Frances" are alternative names for the sameperson.2.Shake-and-Bake Generat ion2.1 Complexity results2.1.1 SpecificationShake-and-Bake generation has more in commonwith a parsing algorithm than with conventionalgeneration from logical form or other underlyingstructure.
The input to the task consists of thefollowing elements:?
A set (B) of lexical signs havingcardinality IB I.?
A grammar (G) against which to parsethis input string.and a solution to the problem consists of?
A parse of any sequence (S) such that Scontains all the elements of B.The unordered nature of B is the differencebetween Shake-and-Bake generation andconventional CFG parsing.
Although we arereally interested in more expressive grammarframeworks, it will for the moment be convenientto assume that G is a simple context-free grammar.Since it is always possible to re-implement a CFGin the more expressive formalisms, the Shake-and-Bake generation problem for theseformalisms is certainly at least as hard as theequivalent problem for CFGs2.1.2.Upper boundSimply stating the Shake-and-Bake problem inthese terms yields a naive generation algorithmand a minor technical result.
The algorithm,which we shall call generate -and- tes t ,is simply to feed the results of permuting the inputbag to a standard context-free parser.
The minortechnical result, which will used to establish acomplexity result in ?2.1.4., is that Shake-and-Bake generation is in NP.
Once we note that?
Context-free parsing is a polynomialprocess.?
The "magical" non-determinism whichNP allows is enough to permute the inputstring using no more than polynomial timeand space.ACRES DE COLING-92.
NANTES, 23-28 AOOT 1992 6 I 0 PROC.
OF COLING-92.
NANTES, AUG. 23-28, 1992it becomes obvious that Shake-and-Bakegeneration falls within the definition of NP givenby Garey and Johnson \[Garey and Johnson, 1979, p321.
This provides an upper bound on thecomplexity of Shake-and-Bake generation byshowing it to be in NP (rather than being, forexample, PSPACE hard or worse).
All thatremains to be shown is whether it also satisfiesthe definition of NP-completeness given on p38 ofthe same work.2.1.3 Lower  BoundThe purpose of this section is to establish a lowerbound on the complexity of Shake-and-Bakegeneration.
We do this by demonstrating thatShake-and-Bake generation is equivalent o theproblem which Garey and Johnson \[Garey andJohnson, 1979, pp 50-53\] call THREE-DIMENSIONAL MATCHING, but which we preferto refer to as the MENAGE A TROIS PROBLEM.This is a generalization tothree dimensions of thewell-known MARRIAGE PROBLEM.
In theMARRIAGE PROBLEM the task is a constrainedpairwise matching of elements from two disjointsets, while in the MENAGE A TROIS PROBLEM,the task is the construction of triples based onelements from three disjoint sets.
While theoriginal two-dimensional problem is soluble inpolynomial time, the three-dimensional analogueis NP-complete.
It is therefore of interest todemonstrate a reduction from MENAGE A TROIS tothe Shake-and-Bake generation problem, sincethis serves to establish the complexity class ofthe latter problem.2__.1.4The MENAGE A TROIS in the bagThe MENAGE A TROIS problem involves three setsA, B, C of identical cardinality n, havingelements which we shall refer to as al...an, bl...bnand Cl...Cn, along with a set M of constraints eachof which is a triple which represents a mutuallyacceptable mdnage ?~ trois .
The overall goal is to2.2 .Conc lus ionIt is highly unlikely that we will be able to findalgorithms for Shake-and-Bake generationwhich are efficient in the general case: while itmight conceivably turn out that NP-completeproblems are, after all, soluble in polynomialtime, they must for the moment be assumedintractable.
We therefore proceed to thediscussion of algorithms which are exponential inthe worst case, but which do not necessarilyexhibit the exponential behaviour unless thegrammar isextremely unusual.3.Improved Generation algorithmsIt may not be possible to find algorithms whichcome with a useful theoretical upper bound on run-find a set of three-way marriages selected from Msuch that every member of A, B and C participatein exactly one triple.
Garey and Johnson provide aproof, after Karp, that the MENAGE A TROISproblem is equivalent to the standard problem of3SAT.
We now provide a polynomial-timereduction from an arbitrary instance of MENAGE ATROIS to an instance of Shake-and-Bakegeneration, which allows the same conclusion tobe drawn for this problem.We start by forming an input string S containingall the elements of the three sets A,B,C, in anyorder.
We then construct a contextofree gramnmr Gfrom M, such that each constraint of the form{ai,bj,ck} corresponds to a distinct ternaryproduction i  G, with the formx --> a i ,b J , c  k.To complete the grammar we need a finalproduction of the formThe role of this production is to ensure that aparse can be achieved if and only if there is away of covering the inpnt string withconstraints.
The construction of the grammar antithe input string is clearly a polynomial process.Context-free parsing has the property that aleaf node of the input string can only be directlydominated by one node of the final analysis tree,and by the definition of Shake-and-Bakegeneration given above the Shake-and-Bakeprocess for G and S must succeed if and only if Gadmits, under the standard node-admissibilityinterpretation f context-free grammars, a strings l  which is a permutation of 8.
By combiningthe preparation described above with Shake-and-Bake generation, we obtain a solution ofMENAGE A TROIS.
Taken together with theresult from ?2.l,this constitutes a demonstrationthat Shake-and-Bake generation is NP-complete.time cost, but it is still worth looking for oneswhich will provide acceptable behaviour forrealistic inputs.
This makes the assessment of suchalgorithms an empirical matter.3.1.Whitelock's a lgor i thmWhitelock's algorithm is a generalisation ofShift-Reduce parsing.
It is an improvement on thenaive generate-and-test outlined above, bntexhibits exponential behaviour even on the sort ofinputs which our MT system is likely to encounter.A case in point is found in the analysis of Englishadjectives.
We shall be using the phrase "Thefierce little brown cat" as our main example.ACRES DE COLING-92.
NANTES.
23-28 AOtrr 1992 6 1 1 PROC.
OF COLING-92.
NANTES, AUG. 23-28.
1992The fierce brown little catThe brown fierce little catThe brown little fierce catThe little brown fierce catFigure IFor the sake of argument suppose that we need torule out the questionable versions of the phrase inFigure 1.
It is not clear that these phrases arecompletely ungrammatical, but they serve thepresent purpose of providing an illustration, andmost English speakers agree that they would onlybe produced in highly unusual circumstances.In order to cover this data in a unificationgrammar, we adopt the encoding shown in Figure2.
This states that "fierce" must precede "little"or "brown" if either of these are present, that"little" must precede "brown" if both are present.
(The type assignments are based on the systematicencoding of a finite-state machine.
)Item Remainder Active Partthe np / n(_)fierce n(\[\]) / n(\[1 I i )Ilittle n(\[1\]) / n(\[1,1 I_ J)I brown n(\[1,11)/ n(ll,l,1 I_\]) cat n(_) <none>Figure 2This set of type assignments prevents the dubiousphrases listed in Figure 1, but still allowssyntactically acceptable phrases such as 'Thefierce cat", "I'he little cat" and '~I'he little browncat".
In principle, this means that generation froma bag produced by analysis of "La petite chattefOroce et brune" will eventually ield the correctoutcome.
Unfortunately, for phrases like this oneWhitelock's algorithm displays spectacularinefficiency.The fierce brown catThe fierce catThe brown catThe little catThe catFigure 3For example, the algorithm will construct heintermediate phrases shown in Figure 3, all ofwhich eventually lead to an impasse because it isimpossible to incorporate the remaining adjectiveswhile respecting the prescribed ordering.Thereason for this behaviour is that Whitelock'salgorithm makes reductions on the basis of merepossibility, rather than taking account of the factthat all elements of the input bag must eventuallybe consumed.3 .2 .Const ra in t  p ropagat ionWe are looking for a global property of the inputbag which can be exploited to prune the searchspace involved in the generation process, and wewish to exploit the completeness property whichWhitelock's algorithm neglects Van Benthem's\[1986\] observation that categorial grammarsdisplay a count invariant, while promising,cannot be directly applied to unification basedgrammars.
As an alternative we develop anapproach to Shake-and-Bake generation inwhich the basic generator is augmented with asimple constraint propagation algorithm \[Waltz,19721.
The augmented generator is potentiallymore efficient than Whitelock's, since theconstraint propagation component helps to directthe generator's search for solutions.Ac~f.s DE COLING-92, NANTES.
23-28 Ao~'r 1992 6 l 2 Paoc.
OF COLING-92, NAtCrES, AUG. 23-28, 19924.The  a lgor i thm4 .1 .Descr ip t ion  o f  the  a lgor i thmOur new algorithm relies on the abil ity to break abag of signs into its component basic signs, andarranges these signs according to their nest inglevel.
Nesting level is defined to be zero for thefunctor of a categorial sign, one for the functors ofits direct arguments, two for the functors of anyarguments which form part of these arguments,and so on.
Thus the category a/(blc)ld has an awith nesting level 0, a b and a d with nesting level1, and a c with nesting level 2.
We organize thebasic signs of the input bag into a graph in whichtwo nodes are l inked if and only if?
Their nesting levels differ by exactly one.?
They arise from different lexical items.These are necessary but not sufficient conditionsfor two basic signs to undergo unification in thecourse of a completed erivation.Node _?,atCCU~0 np1 np2 nC)3 n(\[\])4 n(\[1 I \ ] )5 n(\[1\])6 n(II,1 13)7 n(ll,t\])8 n(11,1,11 _\])9 n(\[1,1,11)Lexical I tem: <dummy> 1: the 0: the 1: fierce 0: fierce 1: little 0: little 1: brown 0: brown 1: cat oFigure 4In the example of the fierce brown cat we obtainconnections listed in Figure 4 and the graph shownin Figure 5Figure 5It s impl i f ies the a lgor i thm to hal luc inate adummy node corresponding to the "inverse" of thetarget category of the derivation ; this is node 0.The node numbers hown in Figure 5ff.
correspondto those l isted in Figure 4 .The structure is adirected graph, in which elements are l inked ifand only if they may stand in a functor/argumentre lat ionship.Figure 6The results of doing this are shown in Figure 6.The task of parsing is reinterpreted as a search fora particular sort of spanning tree for the graph.Our  new a lgor i thm is an inter leav ing ofWhitelock's hift reduce parsing algorithm witha constraint propagation component designed tofacilitate early detection of s ituations in whichno suitable spanning tree can be built.
This helpsto prune the search space, reducing the amount ofunnecessary work carried out during generation.ACRES DE COLING-92, NAN-X~S, 23-28 AO~l' 1992 6 1 3 PROC.
or COLING-92, NxrcrEs, AO6.23-28.
1992Figure 7We know that each node of the structure mustparticipate in exactly one functor/argumentrelationship, but in order to distinguish betweenthose elements which may stand in such arelationship and those which actually form partof a complete solution, it is necessary to propagateconstraints hrough the graph.
In order to do thisit is convenient to add construction lines linkingsigns in functor position to the corresponding signswhich occur in their argument positions.In Figure 6 we can immediately see that node 3must be connected to node 2, since there are noother links leading away from node 3.
Similarlythe link from 9 to 8 must be present in any spanningtree, since there is no other way of reaching node8.
Node I must be connected to node 0 for analogousreasons.Once these links have been established, we candelete alternative links which they preclude.This results in the deletion of the lines from node 9to nodes 6, 4 and 2, and that of the line from 7 to 2.This produces Figure 7.The resulting system canonce again be simplified by deleting the line fromnode 7 to node 4, yielding a unique circuit throughthe graph.
This corresponds tothe correct analysisof the phrase in question.
In this example theconstraints encoded in the graph are sufficient todrive the analysis to a unique conclusion, withoutfurther search, but this will not always happen.We need a combination of constraint propagationwith a facility for making (reasonablyintelligent) guesses when confronted with a choiceof alternatives.
This is described in the nextsection.4.2.The codeWe combine the constraint propagationmechanism with Whitelock's original shift-reduce parser, propagating constraints after everyreduction step.
The parser has the role ofsystematically choosing between alternativereductions, while the constraint propagationmechanism tills in the consequences of a particularset of choices.Listing 1 provides a schematic Prologimplementation f the algorithm described in thissection.
The code is essentially that of a shift-reduce parser, with the following modifications?
One of the elements in a reduction is taken fromthe top of the stack, while the other is taken fromanywhere in the tail of the stack.
This idea, dueto Whitelock and Reape, ensures that the input istreated as a bag rather than a string.?
At initialization a constraint graph isconstructed.
Every time a reduction is proposed theconstraint propagation component is informed,allowing it to (reversibly) update the graph bypropagating constraints.
Constraint propagationmay fail if the constraint mechanism is able toshow that there will be no way of completing asuitable spanning tree given the choices whichhave been made by the shift-reduce component.In this algorithm it is the role of the shift-reducecomponent to make guesses, and the role of theconstraint solver to follow through theconsequences of these guesses.
In the limit thiswill clearly reduce to an inefficientimplementation of exhausitive search, but thisshould not be a surprise given the NP-completeness of the task.4.3.ResultsWe have conducted an experiment to show therelative performance of the two algorithms.Figure 8 shows the number of reductions whichwere carried out by each algorithm in dealingwith a range of sentences about fierce cats andtame foxes (The talk of cats and bags is because weare trying to get a CATegory out of a BAG.
Theconstraint propagation algorithm attemptssubstantially fewer reductions than the originalin all cases, with an increasing performanceadvantage for longer sentences.
This remains trueeven when real-time measurements are used,although the difference is less marked because ofthe overhead of the constraint propagationalgorithm.ACTES DE COLING-92.
NArcn~S, 23-28 AOI~T 1992 6 l 4 PRoc.
OF COLING-92.
NANTES, AUG. 23-28.
1992generate(Bagln,Result) : -new const ra in t_graph(BagXn,G) ,newshakenbake(\[\],Result,Bagln,\[\],G).shake and bake(\[Sign\],Sign,\[\], \[\],_) % terminationshake and bake(P0,Sign, \[NextlBag0\], Bag,G):- % shiftpush(Next, P0, P)shake and bake(P,Sign,Bag0,Bag,G).shake and bake(P0,Sign, Bag0,Bag, G) :- % reducepop(P0, PI),delete(Second, Pi,P2), % treat input "string" as a bagunordered_rule(Mom, First,Second, Info), % 4th arg is info for the% constraint propagation.update(Xnfo ,G) ,  % constraint propagationpush(Mom, P2, P),shake and bake(\[P,Sign, Bag0, Bag,G).Listing 1Example1 a fox2 a ve-llow foxIBm3 a tame yellow fox4 a bi~ tame yellow fox5 the cat likes a fox6 the' fierce cat likes a foxLength2Constraint Propagation13 24 35 45 66 9the fierce cat likes a tame fox 7' 19 ......8 the little brown cat iikes a yellow 8 16fox20 9 the fierce little brown cat lilies a""9' '-yellow fox10 the fierce little brow" cat likes a 10tame ,yellow fox11 the fierce little brown cat likes a 11bi n tame yellow fox12 the little brown cat'likes a'bigyellow foxWhitelock13715 ~ - '132755 .
.
.
.111223447111Figure 8253O205.ConclusionsThese preliminary results must obviously beinterpreted with some caution, since the exampleswere specially constructed.
Further work is inhand to test the performance of the algorithms onlarger grammars and more realistic sentences.Because the problem is NP-complete, it is mostunlikely that there is an algorithm which willprove efficient in all cases, but the algorithmdescribed here already provides worthwhileimprovements in practice, and there isconsiderable scope for further improvement.
Forexample, for grammars related to HPSG it seemsprobable that considerable benefit would begained from adding a constraint propagationcomponent to an unordered version of a head-corner parsing algorithm, as described by VanNoord \[Van Noord, 1991\].
Alternatively, it maybe that constraint graphs, like the LR parsingtables described by Briscoe and Carroll \[Briscoeand Carroll, 1991\], are suitable locations for thestorage of probabilistic information derived fromthe analysis of corporaBibliography\[van Bemhem, 1986\] J. van Benthem CategorialGrammar Chapter 7 in Essays in LogicalSemantics, Reidel, Dordrecht, pp123-50, 1986\[Briscoe and Carroll, 1991\] E.Briscoe and J.CarrollGeneralised Probabilistic Parsing of NaturalLanguage (Corpora) with Unification-BasedGrammars University of Cambridge ComputerLaboratory Technical Report No.
224, June 1991.\[Garey and Johnson, 1979\] M.R.Garey andD.S .
Johnson  COMPUTERS ANDAcrEs DE COLlNG-92.
NANTES.
23-28 AOU~I" 1992 6 1 5 PROC.
OV COLING-92, NAm'ES, AUG. 23-28, 1992INTRACTABILITY: A Guide to the Theory of NP-Completeness W.H.Freeman and Co., New York,1979\[Van Noord, 1991\] G. van Noord Head ComerParsing In Proceedings of the InternationalWorkshop on Constraint Propagation andLinguistic Description,lDSIA, Lugano, 1, edsC.J.Rupp, R.Johnson, M.Rosner, IDSIA WorkingPaper No 5., November 1991\[Waltz, 1972\] D.Waltz Generating semanticdescriptions from drawings of scenes withshadows, AI-TR-271, Project MAC, MassachussetsInstitute of Technology (reprinted in P.Winston(Ed.)
1975, The Psychology of Computer Vision,McGraw-Hill, New York, 19-92)\[Whitelock, 1991\] P.J.Whitelock Shake-and-Bake translation.
In Proceedings of theInternational Workshop on ConstraintPropagation and Linguistic Description,lDSIA,Lugano, 1, ecls C.J.Rupp, R.Johnson, M.Rosner,IDSIA Working Paper No 5, November 1991\[Whitelock, this conference\] P .
J .Whi te lockShake-and-Bake translation.
Paper submitted toCOLING-92.AcknowledgementsThe idea of Shake-and-Bake machine translationis the result of collaboration between Mike Reapeand Pete Whitelock.
I am grateful to all mycolleagues at SLE for providing encouragement a dsupport, but particularly to Pete Whitelock,Andrew Kay, Ian Johnson and Olivier Laurens,who took the trouble to provide detailedcommentary.
Thanks are also due to twoanonymous COLING referees whose commentsproduced major revisions.AC~ES DE COLING-92, NANTEs.
23-28 AOU'r 1992 6 I 6 PRO?.
OF COLING-92.
NANTES.
AUG. 23-28, 1992
