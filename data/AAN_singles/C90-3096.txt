SIMPLE PARSER FOR AN HPSG-STYLE GRAMMAR IMPLEMENTED IN PROLOGKarel oliva*Lingust ic Model l ing Laboratory,Coordinat ion Centrefor Computer Science and Computer Technology,Bulgarian Academy of Sciences,acad.
G. Bonchev st. bl.
25A,BG - 1113 Sofia,BulgariaAbstract:This paper describes basic ideas of a parser forHPSG style grammars without LP component.
The parserworks bottom-up using the left corner method and achart for improving efficiency.
Attent ion is paid tothe format of grammar ru~es as required by the parser,to the possibi l i t ies of direct implementat ion of prin-ciples of the grammar as well as to solutions of prob-lems connected with storing partly specif ied catego-ries in the chart.i.
Kapremmntation of Grammar Rulam for the ParserThe Head-driven Phrase Structure Grammar (HPSG)blurrs the dist inct ion between rules of the grammarand the structures they generate.
Put shortly, thematter is that "structures" and "rules" in HPSG differsolely in the level of abstraction over the l lnguistJcmaterial  they describe.
A "structure" describes somevery concrete piece of this material  (e.g., a sen-tence) and, hence, embodies no abstraction; a "rule",on the other hand, presents by itself a prototype of aset of structures.
Since in HPSG categories are under-stood as bundles of features ("attribute"="value"pairs) , the "structure"/"rule" dichotomy is ref lectedby the fact that the rules can contain variables asvalues of attr ibutes of some features while the struc-tures must be always fully specif ied or that the rulescan miss some (otherwise possibly obligatory) featuresaltogether.
Constraints restr ict ing or binding to-gether permitted values of the attributes can be asso-ciated with the rules.
Naturally, different levels ofabstract ion can be introduced among the rules as well,which al lows for capturing different levels of genera-l ization over the l inguistic data described.On the highest level of abstraction, the parsercan deal with two types of rules: in the first type,the values of var iables occurr ing in the rules arebound by constraints, in the second type no con-straints occur.
In order to support s imultaneously aneasi ly legible notation and a reasonable computerimplementat ion of these two types of rules, two Prologoperators are defined, each describing one rule type.
:- op(1200,xfx, is a rule if) .
:- op(1200,xf, is a rule)The first of the two is an infix operator descr ibingthe rules containing addit ional constraints; the ruleitself should stand in front of the operator, the con-straints should follow it, separated from each otherby commas ",".
The second one is a postf ix operatordescr ibing the rules without any constraints.The inventory of types of rules may be arbitra-rily broadened.
All that is necessary for this purposeis just adding operator declarat ions and, possibly,also implementing feature inheritance pr inciples cor-responding to the newly introduced rule type(s).
Thisis important because it provides for bounding the ap-pl icat ion of the pr inciples to the whole rule typesand makes thus obsolete the expl ic it  st ipulat ion offeature sharing among respective categories in eachrule, which is still the case in many current parsers.TWO examples of the rule format for the parserare shown in the following: it is to be rememberedthat in HPSG, as well as in all other theories accept-ing the X-bar convention, a central role among thedaughters in a rule is played by the head-daughter -because of this, the head-daughter is special ly mark-ed, which provides, e.g., for appl icat ion of the HeadFeature Principle.Ex.l: - the standard "S ---> NP VP" rule can appearin the fol lowing form (with obvious meanings of thepredicates "concatenation" and "agreement"):\ [phonology=SPhonology,d t r s=\ [d t r=\ [cat=n,bar=two,phonology=NP_Phenology,morphology=NP_Morphology \],head_d_tr=\[cat=v,bar=two~phono logy=VPPhcno logy ,morpho logy=VPMorpho logy \ ] i \ ]is a rule ifconeatenat ion(NPPhono logy ,VPPhono logy ,  S Phonology),agreement (NPMorpho logy ,VPMorpho logy)Ex.2: - the rule "NP ---> Dot NP": note the fact thatthe phonology of the mother can be expressed withoutinvocation of the "concatenation" predicate (sincedeterminers eonsist of one word only) and the agree-ment is expressed direct ly in the rule by coinde?ingthe features "number" in both daughters\[bar=two,phonology=\[Det_Phonology!NP_Phonology\] ,d t r s=\ [d t r=\ [cat=det ,bar=zero,phono logy=\ [DetPhono!ogy \ ] ,morphology=\[number=Number\] i ,head d_tr=\[cat:n,bar=one,phono logy=NPPhono loqy ,morphology=\[hum bar=Number I\]\]is a rule .2.
Repreeantation of Categories in the ParserAS follows from the examples, the notation adopt Zed for categories in rules is the one describing themas (Prolog) lists of features.
Keeping such kind ofrepresentat ion also in the underlying mechanism of theparser would be, however, quite unfel ic i tous a deci-sion.
The main problem consists in the fact that theparser working bottom-up may discover certain featuresof already parsed (sub)structures only later in theparsing process (so to say, only when it gets "higherin the tree", with regard to the way the parsing pro-ceeds).
These features are to be, then, incorporatedinto the already parsed structures.
An elegant solu-t ion of this problem was proposed in (Eisele andD~rre,1986) and adopted in the parser described.Syntactic categories are represented in the parser in-ternal ly  in a way sl ightly different from their repre-sentation in the grammar: all categories (including434 1those used as values of features of other categories)are represented as "open-ended lists": each internalrepresentat ion of a category is a list having a cer-tain number of instantiated elements at its beginning.and an uninstantiated "tail".
The main idea standingbehind this kind of representat ion is that any featureto be dlscovered (and added to the category) only la-ter in the parsing process can be now added as the"first member" of the uninstant iated "tail", whichtask is easy to perform provided that the "tail" isstill accessible (e.g., if the free "tails" of catego-ries subject to feature inheritance principles areshared logical variables).
Convert ing categories fromone kind of representat ion to the other one isperformed by a two-argument predicate "perestroika"(used below).The representat ion descr ibed also supports asimple implementat ion of uni f icat ion of categories(see Eisele and D~rre, op.
cit.
for more detail); inthe folowing, uni f icat ion of two categories is presup-posed to be performed by a two-argument predicate"unify".3.
The  ParsQrThe main idea of the parsing method used in theBUP par~er (Matsumoto et ai,1983) being the startingpoint of the system descr ibed is that a rule is to betr iggered only after its left corner has been found(i.e.
it has been supplied by lexical scan, in thecase of iexical categories, or it has been properlyparsed).
The left corner of a rewrit ing rule is theleftmost symbol on its r lght-hand side - the namestems from depict ing the rule as a local tree it gene-rates.
After a category is parsed or supplied by lexi-cal scan, one of the grammar rules having this ca-tegory as its left -corner is s@lected, the sisters ofthe left corner in this rule are tried, and if all ofthem are succesfuly parsed, the mother category of therule is declared to be parsed and the whole process,using the mother as a left corner, is repeated "on ahigher level".
If any fai lure occurs, backtracking isinvoked.
Thus, the parsing process is data-dr iven -the rules of the grammar are selected in accordancewith the symbols scanned in the input.
From the view-point of efficiency, this is important mainly for theso-cal led "free-word-order" languages.
Ment ioningthis, it should be further recalled that the perfor-mance of BUP is further improved by storing all theinformation about all subtasks that have been alreadytried (successfully or unsuccessfully), which avofdsrepet i t ive computat ions of the parses that have beenperformed or that have been proved impossible to per-form in the preceding steps of the analysis.For the purposes of the implementat ion of theparsing process, it is necessary to extend the notionof the "left corner" to its ref lexive and transit iveclosure.
The transit ive closure inductively statesthat for all tr iples of categories X,Y,Z such that Xis a left corner of Y and Y is a left corner of Z , Xis also a left corner of Zo The ref lexive closure fi-nishes the picture by saying that any category is aleft corner of itself.Given the previously descr ibed basic phi losophyof parsing, the process can be implemented in Prologby means of two predicates performing the two tasksinformal ly ment ioned in the preceding paragraphs:- the predicate "parse", parsing a given (expected)category from (a pref ix of) the input string- the predicate " i sa le f t _corner" ,  l inking the leftcorner category with the goal (expected) category inthe parsing process.However, before these predicates can be explainedin more detail, it is necessary to make several re-marks explaining the way the processing of complex ca-tegories has been built into the system.First, the usual equal ity ("=") of two categorieswas replaced by their unif ication, i.e.
on all spotswhere equal ity of two categories - expressed eitherdirectly, in the form of an equation, or indirectly,by variable sharing or otherwise - occured in the ori-ginal BUP, it had to be replaced by a call of the pre-dicate "unify".Second, in the predicates storing or retrievingthe information about the (un)successful ly performedparsing subtasks, the categories must be "frozen"exactly in the state when this subtask was started:problems would occur if the "stored" categoriesinclude free variables ("\]n\[ormation holes") as valuesof some features, which variables might be matched byany real values in the moment of search for the infor-mat ion about previously performed parsing tasks - sucha matching, however, would be incorrect, since what isrequired is a real identity of the subtasks.
(The sameholds also the other way round, i.e.
problems ofexactly the same nature would occur also if the storedvalue were instant!ated and the current one were afree variable.
)The aforementioned identity of subtasks, however,requires the identity of (some of) the stored catego-ries only, not the identity of the lists representingthem, i.e.
what really matters is the identity of fea-tures, but not of their order.
This identity of"frozen" categories (represented as "usual" Prologlists) is checked by the predicate " identical_catego-ries".Now at last, the def init ions of the predicates"parse" and "is a left corner" cao be given; the sup- .
.
.
.
.
.port ing predicates are either elucidated in ti~e pre-ceding text or are given (hepefully) self-expla!ni:Ignames, which should hold also for the arguments.
Thedi f ference between the "frozen" categories representedas usual Prolog lists and those represented as "open-ended" lists is ref lected in the variable names stand-ing for the respective types: the "open-ended" ca-tegories are always marked as "ReaL" categories, theother ones never bear such marking.% PARSE(% "Frozen"_Goa l_Cat,% \[Real_Goal Cat,Structure\],% Input_Str ing,Rest String )/* Checking whether parsing the current Real Goal Ca-tegory from some pref ix of the Input String has beentr ied (either successful ly  or not) in the precedingsteps of the parsing process.
*/parse(GoalCategory,\[RealGoal_Category,Structtlre\],Input_String, Rest_Str ing )( a l ready_parsed(Asserted_Goal  Category , ,Input Str\]ng, ),ident ica l_categor ies (Goa iCategory ,Asser tedGoa iCategory)  ;cannot_beparsed(Asser tedGea iCategory ,Input String ),ident ica l_categor ies{GoaICategory ,Asserted_Goal_Category)!, fail ),I, ia l ready_parsed(Asser tedGoa l_Category ,\[Real_Goal Category, Structure\],InputSt r lng ,Rest_St r ingidentical categorles(Goal Category,Asserted_Goal Category) .
),2 435/ *  The following clause describes parsing of a cate-gory with no daughters (category immediately dominat-ing an empty string) */parse(Goal_Category,\[Real_Goal_Category,dtrs=\[\]\],String,String )/* rule having no daughters is to be found in thegrammar */find_rule to be used(Realgoal_Category,Constraints Of Rule),call(Constralnts Of Rule),assertz(already_parsed(Goal_Category,\[Real_Goal_Category,d_trs=\[\]\],String, String )) ./* The following clause describes parsing of a cate-gory dominating a non-empty terminal string */parse(Goal_Category,\[Real_GoalCategory,Structure\],\[Word_FormIRest Input_Strlng\],Rest_String )lex icon(WordForm,WordFormCategory) ,perestroika(Word_Form_Category,Real Word_Form_Category),is a left corner(\[Real_WordFormCategory, d trs=\[\]\],\[Real_Goal Category,Structure},Rest_Input_String, Rest_String ),assertz(already_parsed(Goal Category,\[Real_Goal Category,Structure\],\[Word_FormlRest_Input_String\],Rest_String )) ./* Asserting information about the impossibility ofparsing certain categories from certain strings */parse(Goa l_Category , , InputSt r lng , )(a l ready_parsed(GoalCategory, , Input_Str ing,_)  ;assertz(cannot_be_parsed(Goal Category,Input String)) },!
, fail .IS_A_LEFT_CORNER(\[Real_Left Corner Cat,Structure\],\[Real GoalCat,Structurel,Input Str ing,RestStr ing/* reflexive closure of the relation "being a leftcorne r" * /is_a_leftcorner(\ [Rea iLe f tCornerCategory ,Rea lLe f tCornerCategory_St ructure \ ] ,\[Real GoalCategory,RealGoal_Category_Structure\] ,String,String )uni fy(RealLeftCorner_Category,Real_Goal_Category ) ./* transitive closure of the relation "being a leftcorner" */is_a_left_corner(\[Real Lef~_Corner_Category,RealLeft_CornerCategory_Structure\] ,\[Real Goal_Category,RealGoal_Category_Structure\],InputStr ing,  RestSt r ing  ):-/* a rule having the current left corner categoryas its left corner is to be found */f indru le tobeused(Real_Left_Corner_Category\],Left_Daughter._Marking,Right_Sisters_ListFromCurrent_Rule,Mother_Category_From_Current Rule,Constraints Of Rule,Type Of Rule ),/* all the right sisters have to be parsed */parse_right_sisters(Right S i s te rs_L i s tF romCurrentRu le ,Real_RightSisters_List,InputStr ing,  IntermediaryString,Type Of Rule ),call(Constraints Of Rule),/* the mother category from the rule must complywith the feature inheritance principles relevant forthe Type Of Rule */feature inher i tancepr inc lp lesconcern ing_mother(\ [Rea lLe f tCornerCategoryIReal_RightSistersL ist \ ] ,Mother Category_From_CurrentRule,Real Mother_Category,Type Of Rule ),/* the mother itself (?herself?)
is used as a leftcorner, which repeats the process on a higher level */is a le r t  corner(\[RealMother_Category,d trs={LeftDaughter__Marking =\[Real Left Corner Category,Real LeftCorner_Category_Structure\],IReal_Right_Slsters List \]\],\[Real GoalCategory ,RealGoalCategory_Structure},Intermediary Str ing,RestStr lng ).The whole parsing process is started by asking theconjunction of goals?- parse(TOPMOSTCATEGORY, Intermediary Result,INPUT,\[\] ),perestroika(RESULT, Intermediary Result) .where the "RESULT" is the only output argument, na-mely, the resulting structure of the parse, theTOPMOST CATEGORY Is a skeleton category (representedas a "usual" Prolog llst) of the expected result (mostoften, something l ike "\[cat=sentence\] " or"\[cat=v,bar=two\]" etc.
), i.e.
a category which is ex-pected to unify with any result of the parse, theINPUT STRING is the input string represented as a Pro-log list of wordforms and the empty string "\[\]" is theexpected rest of the input string after the parsingprocess finished.Eilele A. and J. D6rre: A Lexical Functional GrammarSystem in Prolog, in: Proceedings of Coling ~86, BonnM~tlumQto ?.
et al: BUP - A Bottom-Up Parser Embeddedin Prolog, in: New Generation Computing vol.l, 1983Pollard C. and I.Sag: Information Based Syntax and Se-mantics, vol.l: Fundamentals, CSLI Lecture Notes No.13, CSLI, Stanford, California 1987Wsince Ist April 1990:Lehrstuhl fur ComputerlinguistlkUniversit~t des SaarlandesIm StadtwaldD-6600 Saarbr~cken(West) Germany436 3
