DETERMINISTIC LEFT TO RIGHT PARSING OFTREE ADJOINING LANGUAGES*Yves SchabesDept.
of Computer & Information ScienceUniversity of PennsylvaniaPhiladelphia, PA 19104-6389, USAschabes@linc.cis.upenn.eduK.
Vijay-ShankerDept.
of Computer & Information ScienceUniversity of DelawareNewark, DE 19716, USAvijay@udel.eduAbstractWe define a set of deterministic bottom-up left to rightparsers which analyze a subset of Tree Adjoining Lan-guages.
The LR parsing strategy for Context FreeGrammars is extended to Tree Adjoining Grammars(TAGs).
We use a machine, called Bottom-up Embed-tied Push Down Automaton (BEPDA), that recognizesin a bottom-up fashion the set of Tree Adjoining Lan-guages (and exactly this se0.
Each parser consists of afinite state control that drives the moves of a Bottom-upEmbedded Pushdown Automaton.
The parsers handledeterministically some context-sensitive Tree AdjoiningLanguages.In this paper, we informally describe the BEPDA thengiven a parsing table, we explain the LR parsing algo-rithm.
We then show how to construct an LR(0) parsingtable (no lookahead).
An example of a context-sensitivelanguage recognized eterministically is given.
Then,we explain informally the construction of SLR(1) pars-ing tables for BEPDA.
We conclude with a discussionof our parsing method and current work.1 IntroductionLR(k) parsers for Context Free Grammars (Knuth, 1965)consist of a finite state control (constructed given a CFG)that drives deterministically with k lookahead symbolsa push down stack, while scanning the input from leftto right.
It has been shown that they recognize xactlythe set of languages recognized by deterministic pushdown automata.
LR(k) parsers for CFGs have beenproven useful for compilers as well as recently for nat-ural language processing.
For natural language process-ing, although LR(k) parsers are not powerful enough,*The first author is partially supported by Darpa grant N0014-85-K0018, ARO grant DAAL03-89-C-003iPRI NSF grant-IRIS4-10413A02.
We are extremely grateful to Bernard Lang and David Weir fortheir valuable suggestions.276conflicts between multiple choices are solved by pseudo-parallelism (Lang, 1974, Tomita, 1987).
This gives riseto a class of powerful yet efficient parsers for naturallanguages.
It is in this context that we study determin-istic (LR(k)-style) parsing of TAGs.The set of Tree Adjoining Languages i a strict su-perset of the set of Context Free Languages (CFLs).For example, the cross serial dependency constmctionin Dutch can be generated by a TAG.
1 Waiters (1970),R~v6sz (1971), Turnbull and Lee (1979) investigateddeterministic parsing of the class of context-sensitivelanguages.
However they used Turing machines whichrecognize languages much more powerful than Tree Ad-joining Languages.
So far no deterministic bottom-upparser has been proposed for any member of the classof the so-called "mildly context sensitive" formalisms(Joshi, 1985) in which Tree Adjoining Grammars fall.
2Since the set of Tree Adjoining Languages (TALs) is astrict superset of the set of Context Free Languages, inorder to define LR-type parsers for TAGs, we need touse a more powerful configuration then a finite state au-tomaton driving a push down stack.
We investigate thedesign of deterministic left to right bottom up parsers forTAGs in which a finite state control drives the movesof a Bottom-up Embedded Push Down Stack.
The classof corresponding on-deterministic automata recognizesexactly the set of TALs.We focus our attention on showing how a bottom-up embedded pushdown automaton is deterministicallydriven given a parsing table.
To illustrate the buildingof a parsing table, we consider the simplest case, i.e.building of LR(0) items and the corresponding LR(0)1The parsers that we develop in this paper can parse these con-structions deterministically (see Figure 5).2Tree Adjoining Grammars, Modified Head Grammars, Linear In-dexed Grammars and Categorial Grammars (all of which generatethe same subclass of context-sensitive languages) fall in the class ofthe so-called "mildly context sensitive" formalisms.
The EmbeddedPush Down Automaton recognizes exactly this set of languages (Vijay-Shanker 1987).parsing table for a given TAG.
An example for a TAGgenerating a context-sensitive language is given in Fig-ure 5.
Finally, we consider the construction of SLR(1)parsing tables.We assume that the reader is familiar with TAGs.
Werefer the reader to Joshi (1987) for an introduction toTAGs.
We will assume that the trees can be combinedby adjunction only.2 Automata Models of TagsBefore we discuss the Bottom-up Embedded Push-down Automaton (BEPDA) which we use in our parser,we will introduce the Embedded Pushdown Automaton(EPDA).
An EPDA is similar to a pushdown automaton(PDA) except hat the storage of an EPDA is a sequenceof pushdown stores.
A move of an EPDA (see Figure 1)allows for the introduction of bounded pushdowns aboveand below the current op pushdown.
Informally, thismove can be thought of as corresponding tothe adjoin-ing operation move in TAGs with the pushdowns intro-duced above and below the current pushdown reflectingthe tree structure to the left and right of the foot node ofan auxiliary being adjoined.
The spine (path from rootto foot node) is left on the previous tack.The generalization f a PDA to an EPDA whose stor-age is a sequence of pushdowns captures the generaliza-tion of the nature of the derived trees of a CFG to thenature of derived trees of a TAG.
From Thatcher (1971),we can observe that the path set of a CFG (i.e.
the setof all paths from root to leaves in trees derived by aCFG) is a regular set.
On the other hand, the path setof a TAG is a CFL.
This follows from the nature of theadjoining operation of TAGs, which suggests tackingalong the path from root to a leaf.
For example, as wetraverse down a path in a tree 3' (in Figure 1), if ad-junction, say by/~, occurs then the spine of/~ has to betraversed before we can resume the path in 7.~ e ~ -gQeft of foot d \[~ ~ .,~splne ofI~ i~ f ight  d foot of ~Figure 1: Embedded Pushdown Automaton2773 Bottom-up Embedded Push-down Automaton 3For any TAG G, an EPDA can be designed such thatits moves correspond to a top-down parse of a stringgenerated by G (EPDA characterizes xactly the set ofTree Adjoining Languages, Vijay- Shanker, 1987).
Ifwe wish to design a bottom-up arser, say by adoptinga shift reduce parsing strategy, we have to consider thenature of a reduce move of such a parser (i.e.
usingEPDA storage).
This reduce move, for example appliedafter completely considering an auxiliary tree, must beallowed to 'remove' some bounded pushdowns aboveand below some (not necessarily bounded) pushdown.Thus (see Figure 2), the reduce move is like the dual ofthe wrapping move performed by an EPDA.Therefore, we introduce Bottom-up Embedded Push-down Automaton (BEPDA), whose moves are dual ofan EPDA.
The two moves of a BEPDA are the unwrapmove depicted in Figure 2 - which is an inverse ofthe wrap move of an EPDA - and the introduction ofnew pnshdowns on top of the previous pushdown (pushmove).
In an EPDA, when the top pnshdown is emp-tied, the next pushdown automatically becomes the newtop pushdown.
The inverse of this step is to allow forthe introduction of new pushdowns above the previoustop pushdown.
These are the two moves allowed in aBEPDA, the various steps in our parsers are sequencesof one or more such moves.Due to space constraints, we do not show the equiva-lence between BEPDA and EPDA apart from noting thatthe moves of the two machines are dual of each other.4 LR Parsing AlgorithmAn LR parser consists of an input, an output, a sequenceof stacks, a driver program, and a parsing table that hasthree parts (ACTION, GOTOright and GOTO.foot).
Theparsing program is the same for all LR parsers, onlythe parsing tables change from one grammar to another.The parsing program reads characters from the input onecharacter at a time.
The program uses the sequence ofstacks to store states.The parsing table consists of three parts, a pars-ing action function ACTION and two goto functionsGOTOright and GOTOloot.
The program driving theLR parser first determines the state i currently on topof the top stack and the current input token at.
Then itconsults the ACTION table entry for state i and token3The need to use bottom-up version of an EPDA in LR style pars-ing of TAGs was suggested to us by Bernard Lang and David Weir.Also their susgestions played all insU~llaK~\[ v01e in the definition ofBBPDA, for example restriction on the moves allowed.read only input tapeustack of aac~BEPDABounded number \ [1of stacks I Iof bounded size1 Bounded number \[~of stack elementsUnbounded number (1of stack elements ~.JBounded numberof stacks I Iof bounded size ~,1A~AllalBI7"BnEPDAl noveUNWRAP move\[\]PUSH moveFigure 2: Bottom-up Embedded Pushdown Automatonat.
The entry in the action table can have one of thefollowing five values:?
Shift j (s j), where j is a state;?
Resume Right of 6 at address dot (rs6@dot)),where 6 is an elementary tree and dot is the ad-dress of a node in 6;?
Reduce Root of the auxiliary tree/5 in which thelast adjunction on the spine was performed at ad-dress star (rd/3@star);?
Accept (acc);?
Error, no action applies, the parsers rejects the in-put string (errors are associated with empty tableentries).The function GOTOright and GOTOfoo, take a statei and an auxiliary tree # and produce a state j.An example of a parsing table for a grammar gener-ating L = {anbnecndnln > 0} is given in Figure 5.We denote an instantaneous description of theBEPDA by a pair whose first component is the sequenceof pushdowns and whose second component is the un-expanded input:( l ltm'' "till" "-Ilsl" "sw, a~a~+l...a,$)In the above sequence of pushdowns, the stacks arepiled up from left to right.
II stands for the bottom of astack, s~ is the top element of the top stack, Sx is thebottom element of the top stack, tl is the top elementof the bottom stack and tm is the bottom element of thebottom stack.The initial configuration of the parser is set to:(110, a l - .
.an$)where 0 is the start state and ax ?
.. a ,$ is the input stringto be read with an end marker ($).278Suppose the parser eaches the configuration:( l i t , , , "  "till" "IIi~""" ill, arar+l.., an$)The next move of the parser is determined by readingat, the current input token and the state i on top of thesequence of stacks, and then consulting the parsing tableentry for ACTION\[i, a,\].
The parser keeps applying themove associated with ACTION\[i, at\] until acceptance orerror occurs.
The following moves are possible:(i)(ii)ACTION\[/, at\] = shift state j (, j).
The parser exe-cutes a push move, entering the configuration:( l l tm' ' '  tx I I"" IIi~o ?
?
?
ilillJ, at+l"'" an$)ACTION\[/, at\] = resume right of 6 at address dot(rs6@doO.
The parser is coming to the right andbelow of the node at address dot in 6, say ri, on whichan auxiliary tree has been adjoined.
The informationidentifying the auxiliary tree is in the sequence ofstacks and must be recovered.
There are two eases:Case 1:71 does not subsume a foot node.
Let kbe the number of terminal symbols subsumed by r/.Before applying this move, the current configurationlooks like:( l l " "  Ilikll ""  IIi111i, a, .
.
"an$)The k top first stacks are merged into one stackand the stack IIm is pushed on top of it, wherem = GOTOfoo,\[ik, #\] for some auxiliary tree # thatcan be adjoined in 6 at 71, and the parser enters theconfiguration:(11""" I l i k l l i t - t  "'" ix illm, at"" a,$)Case 2:~7 subsumes the foot node of 6.
Let k (resp.k') be the number of terminal symbols to the right(resp.
to the left) of the foot node subsumed by r/.Before applying this move, the configuration lookslike:(ll" "" Ilnv+tll""" Ilnxllsl" "" szllik" "" Iii111i, a , - - .
a .$)The k' stacks below the k + 2 *h stack from the topas well as the k + 1 top stacks are rewritten onto thek + 2 th stack and the stack lira is pushed on top of it,where m = GOTO/oot\[nk,+ x,/3\] for some auxiliarytree ~ that can be adjoined in 6 at ,7, and the parserenters the configuration:(11"" Ilnv+lllsl "" .sink .
.
.
.
n l ik .
.
,  ixil\]m, a~.. .
an$)(iii) ACTION\[/, at\] = reduce root of an auxiliary tree/3in which the last adjunction on the spine was per-formed at address tar (rdfl@star).
The parser hasfinished the recognition of the auxiliary tree/L Itmust remove all information about/3 and continuethe recognition of the tree in which/3 was adjoined.The parser executes an unwrap move.
Let k (resp.k') be the number of terminal symbols to the left(resp.
to the righO of the foot node of B.
Let ff bethe node at address tar in/3 (ff = nil if star is notset).
Let p be the number of terminal symbols tothe left of the foot node subsumed by ~ (p = 0 if= nil).
p + k' + 1 symbols from the top of thesequence of stacks popped.
Then k - p single ele-ment stacks below the new top stack are unwrapped.Let j be the new top element of the top stack.
Letra = GOTOriaht~, t~\].
j is popped and the singleelement stack lira is pushed on top of  the top stack.By keeping track of the auxiliary trees being reduced,it is possible to output a parse instead of acceptance oran error.The parser ecognizes the derived tree inside out: itextracts recursively the innermost auxiliary tree that hasno adjunction performed in it.5 LR(0) Parsing TablesThis section explain how to construct an LR(0) parsingtable given a TAG.
The construction is an extensionof the one used for CFGs.
Similarly to Schabes andJoshi (1988), we extend the notion of dotted rules totrees.
We define the closure operations that correspondto adjunction.
Then we explain how transitions betweenstates are defined.
We give in Figure 5 an example ofa finite state automaton used to build the parsing tablefor a TAG (see Figure 5) generating a context-sensitivelanguage.We first explain preliminary concepts (originally de-fined to construct an Earley-type parser for TAGs) thatwill be used by the algorithm.
Dotted rules are extendedto trees.
Then we recall a tree traversal that the algo-rithm will mimic in order to scan the input from left toright.A dotted symbol is defined as a symbol associatedwith a dot above or below and either to the left or to279the right of it.
The four positions of the dot are anno-tated by ia, ib, ra, rb (resp.
left above, left below, rightabove, right below): taa,~ In practice, only two dotI b .L .
rb  ?positions can be used (to the left and to the fight ofa node).
However, for sake of simplicity, we will usefour different dot positions.
A dotted tree is definedas a tree with exactly one dotted symbol.
Furthermore,some nodes in the dotted tree can be marked with a star.A star on a node expresses the fact that an adjunctionhas been performed on the corresponding node.
A dot-ted tree is referred as \[c~, dot, pos, stars\], where o~ is atree, dot is the address of the dot, pos is the position ofthe dot (la, lb, ra or rb) and stars is a list of nodes ina annotated by a star.Given a dotted tree with the dot above and to the leftof the root, we define a tree traversal of a dotted tree (asshown in the Figure 3) that will enable us to scan thefrontier of an elementary tree from left to right while try-ing to recognize possible adjunctions between the aboveand below positions of the dot of interior nodes.STAa  :.ao?E F G H I2.1 2.2 2.3 3.1 3.2Figure 3: Left to Right Tree TraversalA state in the finite state automaton is defined to bea set of dotted trees closed under the following opera-tions: Adjunction Prediction, Left Completion, MoveDot Down, Move Dot Up and Skip Node (See Fig-tire 4).
4Adjunction Prediction predicts all possible auxiliarytrees that can be adjoining at a given node.
Left Com-pletion occurs when an auxiliary tree is recognized upto its foot node.
All trees in which that tree can beadjoined are pulled back with the node on which ad-junction has been performed added to the list of stars.Move Dot Down moves the dot down the links.
MoveDot Up moves the dot up the links.
Skip Node movesthe dot up on the right hand side of a node on which noadjunction has been performed.All the states in the finite state automaton (FSA) mustbe closed under the closure operations.
The FSA is4These operations correspond to proeesson in the Eadey-typeparser for TAGs./%/%"AAdjunction Prediction Move Dot Up Move Dot DownALeft Completion stap nodeFigure 4: Closure Operationsbuild as follows.
In states et 0, we put all initial treeswith a dot to the left and above the root.
The state isthen closed.
Then recursively we build new states withthe following transitions (we refer to Figure 5 for anexample of such a construction).?
A transition on a (where a is a terminal symbol)from Si to Sj occurs if and only if in Si there is adotted tree \[6, dot, la, stars\] in which the dot is tothe left and above a terminal symbol a; Sj consistsof the closure of the set of dotted trees of the form\[6, dot, ra, stars\].?
A transition on/3~ight from Si to Sj occurs iff inSi there is a dotted tree \[8, dot, rb, stars\] such thatthe dot is to the right and below a node on which/3 can he adjoined; Sj consists of the closure of theset of dotted trees of the form \[8, dot, ra, stars'\].If the dotted node of \[8, dot, rb, stars\] is not on thespine 5 of 8, star' consists of all the nodes in starthat strictly dominate the dotted node.
When thedotted node is on the spine, stars' consists of allthe nodes in star that strictly dominate the dottednode, ff there are some, otherwise stars' = {dot}.?
A Skip foot of \[/3, dot, lb, stars\] transition fromSi to Sj occurs iff in S~ there is a dotted tree\[/3, dot, lb, stars\] such that the dot is to the leftand below the foot node of the auxiliary tree/3; Sjconsists of the closure of the set of dotted trees ofthe form \[/3, dot, rb, stars\].The parsing table is constructed from the FSA built asabove.
In the following, we write trans(i, z) for set ofstates in the FSA reached from state i on the transitionlabeled by z.The actions for ACTION( i ,  a) are:?
Shift j (sc(j)).
It applies fff j E trans(i, a).5Nodes on the path from root node to foot node.
280?
Resume Right of /6, dot, rb, stars\] (rsS@dot).It applies iff in state i there is a dotted tree\[8, dot, rb, stars\], where dot E stars.?
Reduce Root of /3  (rd/3@star).
It applies iff instate i there is a dotted tree \[/3, O, ra, {star}\], where/3 is an auxiliary tree.
6?
Accept occurs iff a is the end marker (a = $) andthere is a dotted tree \[~, O, ra, {star}\], where a isan initial tree and the dot is to the right and abovethe root node.?
Error, if none of the above applies.The GOTO table encodes the transitions in theFSA on non-terminal symbols.
It is indexed bya state and by /3right or /31oot, for all auxiliarytrees /3: j G GOTO(i, label) iff there is a tran-sition from i to j on the given label (label E{/3riaht,/3/oot I/3 is an auxiliary tree}.If more than one action is possible in an entry of the ac-tion table, the grammar is not LR(0): there is a conflictof action, the grammar cannot be parsed deterministi-tally without lookahead.An example of a finite state automaton used for theconstruction of the LR(0) table for a TAG (trees cq,/31in Figure 5) generating 7 L = {anbneendnln >_ O}, itscorresponding parsing table is given and an example ofsequences of moves are given in Figure 5.60 is the address of the root node.t in the given TAG (trees ~1 and/31), if we omit a and c, we obtaina TAG that is similar to the one for the Dutch cross-serial construction.This grammar can still bc handled by an LR(0) parser.In the trees c~ and /3, na  stand for null adjuncfion constraint (i.e.no anxifiary tree can be adjoined on a node with null adjunctionconstraint).TAG for L = {a"b~ec"d }SeaA',,a Sd(~) / /~b S~a ea S db S~"~ ?
bS .o?
,' S db S~s(~) le'~  S~d -~ b S d a'$ d It a ?/ t , ,  /1",, /r',, b 'Sc  b Snac b Suc b Sna?Ia/~d "a S d a .~ ?
Sd .,.S*d/~  .
/~  \[b -S~ cb Suc b Suc b S~,a?
b S~a?
"Ae Ae, Ae?
S* d a S*d ?
S* daSd aSdb S~c b.Snaca S* d e *e. /1~ bScaSdbS, cI0 I' ~ ~ 7o/rN.
"bS~b S c b Sine81~ '~*C~ ~ 12( Jl~u ~ 3  ( ~ ?
~ v  b ~*~ :~t  I~\]a S d a S*~l\[~ dl a S*d " S ?b F---I Z n ,? '
,cTa S*d/'I',,, bS?b Snac b S~a~)\[ PARSING ACTION II GOTOI II fcot \[\[ rightFinite State Aatomaton for a BEPDA Recognizing L = { a " b " ecn d" }a b c d e $ /5' /3Parser configuration Next move(llo, aabbeccdd$)(lloll2, abbeccdd$)<110112112, bbeccdd$)(110112112113, b~ccdd$)(110112112113119, eccdd$)(110112112ll3ll9ll4, ccdd$)(I\]0112112\[\[3\[\[9\[\[4\[\[10, ccdd$)(110112112\[\[3\[\[9114\[\[101111, cdd$)(110112112113114 9 0 11116, cdd$)(110112112113114 9 0 11116117, dd$)(110H2H2H3H4 9 10 11\[\[6117\[\[8, d$)(110\[\[2ll4 9 101112, d$)(lloll2114 9 lO1\[121113, $)<110\[15, *)s2s2s3s9s4rsa@Osl lrs~@2s7s8rd~@ -s13rd/3~2aceExample of LR(O) Parsing Table Example of sequences ofmovessj _---- Shift j; rs6~dot -- Resume Right of 6 at dot; rd~star  ---- Reduce Root of/~ with star at address tar; $ -- end of input.Figure 5: Example of the construction of an LR(0) parser for a TAG recognizing L = {a'~bnec"d" }2816 SLR(1) Parsing TablesThe tables that we have constructed are LR(0) tables.The Resume Right and Reduce Root moves are per-formed regardless of the next input token.
The accu-racy of the parsing table can be improved by comput-ing lookaheads.
FIRST and FOLLOW can be extendedto dotted trees,  FIRST of a dotted tree corresponds tothe set of left most symbols appearing below the subtreedominated by the dotted node.
FOLLOW of a dotted treedefines the set of tokens that can appear in a derivationimmediately following the dotted node.
Once FIRSTand FOLLOW computed, the LR(0) parsing table canbe improved to an SLR(1) table: Resume Right and Re-duce Root are applicable only on the input tokens in thefollow set of the dotted tree.For example, the SLR(1) table for the TAG built withtrees oq and ~1 is given in Figure 6.I PARSING AC'TION II GOTO\[I I1 foot II right II I ' l b l  'c I a le l  S I1~11 ~16Figure 6: Example of SLR(1) Parsing TableBy associating dotted trees with lookaheads, one canalso compute LR(k) items in the finite state automatonin order to build LR(k) parsing tables.7 Current ResearchThe deterministic parsers we have developed do not sat-isfy an important property satisfied by LR parsers forCFG.
This property is often described as the viable pre-fix property which states that as long as the portion ofthe input considered so far leads to some stack configu-ration (i.e.
does not lead to error), it is always possibleto find a suffix to obtain a string in the language.Our parsers do not satisfy this property because theleft completion move is not a 'reduce" move.
This moveaDue to the lack of space, we do not define FIRST and FOLLOW.How?ver, we explain the basic principles used for the computafi~m ofFIRST and FOLI?)W.
282applies when we have reached a bottom-left end (to theleft of the foot node) of an auxiliary tree, say/3.
If wehad considered this move to be a reduce move, then bypopping appropriate amount of elements off the storagewould allow us to figure out which tree (into which/3was adjoined), say a, to proceed with.
Rather than us-ing this information (that is available in the storage ofthe BEPDA), by putting left completion in the closureoperations, we apply a move that is akin to the predictmove of Earley parser.
That is we continue by consider-ing every possible nodes/3 could have been adjoined at,which could include nodes in trees that were not usedso far.
However, we do not accept incorrect strings, weonly lose the prefix property (for an example see Fig-ure 7).
As a consequence, errors are always detected butnot as soon as possible.Parser configuration Next move(\[10, aabeccdd$)?11o112, abeccdd$)(liO\[\[2U2, beccdd$)(llo112ll2113, ,c dd$)(Iio1\[21121131\[4, ccdd$)(11o1121121131141\[6, ccdd$)(11o112112113114116117, ~dd*)s2s2s3s4rsa@Os7?ITOrFigure 7: Example of error detectingThe reason why we did not consider the left comple-tion move to be a reduce move is related to the restric-tions on moves of BEPDA which is weakly equivalentto TAGs (perhaps also due to the fact that left to rightparsing may not be most natural for parsing TAGs whichproduce trees with context-free path sets).
In CFGs,where there is only horizontal stacking, a single reduc-tion step is used to account for the application of rulein left to right parsing.
On the other hand, with TAGs,if a tree is used successfully, it appears that a predictionmove and more than one reduction move are necessaryfor auxiliary tree.
In left to right parsing, a prediction ismade to start an auxiliary tree/3 at top left end; a reduc-tion is appropriate o recover the node/3 was adjoined atthe left completion stage; a reduction is needed again atresume right state to resume the right end of t ;  finally areduction is needed at the right completion stage.
In ouralgorithm, reductions are used at right resume stage andreduce right state.
Even if a reduction step is applied atleft completion stage, an encoding of the fact that leftpart of/3 (as well as the left part of trees adjoined onthe spine of/~) has been completed has to be restored inthe storage (note in a reduction move of any shift reduceparser for CFGs, any information about he rule used isdiscarded once reduction step applied).
So far we havenot been able to apply a reduction step at the left com-pletion stage, reinsert the left part of fl and yet maintainthe correct sequence in the storage so that the right partof/3 can be recovered at the resume right stage.
We areconsidering alternative strategies for shift reduce parsingwith BEPDA as well as considering whether there areother automata models equivalent to TAGs better suitedfor deterministic left to right parsing of tree-adjoininglanguages.ConclusionWe have introduced a bottom-up machine (Bottom-upEmbedded Push Down Automaton) that enabled us todefine LR-like parsers for TAGs.
The machine recog-nizes in a bottom-up fashion exactly the set of Tree Ad-joining Languages.We described the LR parsing algorithm and a methodfor computing LR(0) parsing tables.
We also men-tioned the possibility of building SLR(k) parsing tablesby defining the notions of FIRST and FOLLOW sets forTAGs.As shown for the example, no lookaheads are nee-essary to parse deterministically the language L ={anbnec"d"ln >_ O}.
If instead of using e, we had theempty string e in the initial tree, LR(0)-like parser willnot be enough.
On the other hand SLR(1)-like parserwill suffice.We have noted that our parsers do not satisfy the validprefix property.
As a consequence, rrors are alwaysdetected but not as soon as possible.Similar to the work of Lang (1974) and Tomita (1987)extending LR parsers for arbitrary CFGs, the LR parsersfor TAGs can be extended to solve by pseudo-parallelismthe conflicts of moves.Lang, Bernard, 1974.
Deterministic Techniques for Eff?-cient Non-Deterministic Parsers.
In Loeckx, Jacques(editor), Automata, Languages and Programming,2rid Colloquium, University of Saarbri~cken.
LectureNotes in Computer Science, Springer Verlag.R6v6sz, G., 1971.
Unilateral context sensitive gram-mars and left to fight parsing.
J. Comput.
System Sci.5:337-352.Schabes, Yves and Joshi, Aravind K., June 1988.
AnEarley-Type Parsing Algorithm for Tree AdjoiningGrammars.
In 26 th Meeting of the Association forComputational Linguistics (A CL' 88 ).
Buffalo.Thatcher, J. W., 1971.
Characterizing Derivations Treesof Context Free Grammars through a Generalizationof Finite Automata Theory.
J. Comput.
Syst.
Sci.5:365-396.Tomita, Masaru, 1987.
An Efficient Augmented-Context-Free Parsing Algorithm.
Computational Lin-guistics 13:31--46.Turnbull, C. J. M. and Lee, E. S., 1979.
GeneralizedDeterministic Left to Right Parsing.
Acta lnformatica12:187-207.Vijay-Shanker, K., 1987.
A Study of Tree AdjoiningGrammars.
Phi) thesis, Department ofComputer andInformation Science, University of Pennsylvania.Waiters, D.A., 1970.
Deterministic Context-SensitiveLanguages.
Inf.
Control 17:14--40.ReferencesJoshi, Aravind IC, 1985.
How Much Context-Sensitivity is Necessary for Characterizing Struc-tural Descriptions---Tree Adjoining Grammars.
InDowry, D., Karttunen, L., and Zwicky, A.
(editors),Natural Language Processing--Theoretical, Compu-tational and Psychological Perspectives.
CambridgeUniversity Press, New York.
Originally presented ina Workshop on Natural Language Parsing at OhioState University, Columbus, Ohio, May 1983.Joshi, Aravind K., 1987.
An Inmxluction to Tree Ad-joining Grammars.
In Manaster-Ramer, A.
(editor),Mathematics ofLanguage.
John Benjamins, Amster-dam.Knuth, D. E., 1965.
On the translation of languagesfrom left to right.
Inf.
Control 8:607-639.
283
