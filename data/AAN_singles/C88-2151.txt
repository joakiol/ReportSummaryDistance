Using Constraints in aConstructive Version of GPSGWilhelm WEISWEBERTechnical University of BerlinInstitute for Software and Theoretical Computer ScienceProject Group KITSekr.
FR 5-12Franklinstr.
28/29D-1000 Berlin 10Email: weisweb@db0tuil 1.bitnetAbstractComplex categories are caracteristic of unification grammars as forexample GPSG \[Shieber86a\].
They are sets of pairs of feature.s andvalues.
The unification, which can be applied to two or morecategories, is the essential operation.The papers of \[Shieber85\], \[Barton85\] and \[Ristad86\] deal with theinfluence of complex categories on the efficiency of the parsingalgorithm.
This is one problem from using complex categories,another one arises when using a constructive version of GPSG (see\[Busemann/Hanensehild88\] in thisvolume).
Namely that the appli-cation of admissibility conditions, e.g.
LP statements and FCRs 1, toa local tree t is prevented because particular feature values of eat-egories in t are not yet specified, but they will be instantiated latersomewhere else in the complete tree.
Similar problems are described?
in \[Karttunen86\] for D-PATR.This work describes the latter problem and will present a solutionworking with computation, evaluation and propagation ofconstraints within local trees (depth 1).
The constraint evaluationwill reject local trees if the constraints of the subtrees of thedaughters are violated.1 IntroductionFirst of all some fundamentals of a constructive version of GPSGwhich has been developed within the projects K1T-NASEV and itssuccessor KIT-FAST 2 will be described (for details see \[Hanen-1 LP = Linear Precedence; FCR = Feature Co-oecmenee R strictionKIT-FAST (FAST = Functor-Argument Structure for Translation; KIT =Kilnstliche Intelligenz Lind Textvexsteben = Artificial Intelligence and TextUnderstanding) as well as ils predecessor KIT-NASEV (NASEV = NeueAnalyse-und Syntheseveffahrm zur masehinellea 0bersetzang = NewMetheds of Analysis and Synthesis fc~ Machine Translation) constitute heBerlin component of the complementary ~ h  project of EUROTRA-D,which reeeive~ gnmts by the Federal Minister for Research and Technologyunder eontra~t 1013211.738schild/Busemann88\], \[Keller87\], \[Busemann87\] and \[Weis-weber87\]).
The reader's familarity with the fundamental knowledgeof GPSG as presented in \[GKPS85\] will be assumed.1.1 The Grammar FormatThe ID/LP format of the grammar allows the explicit formulation ofgeneralizations about the partial order of the daughters of the IDrules via LP statements.
ID rules are tuples of the form ((mother) ---)(daughters)), for example (S ~ {NP, VP}), where (daughters) is amulti-set of categories which can be dominated by the category(mother).
Lexical rules are of the form ((mother) ---?
(wordform)).LP statements are of the form '(categoryt) < (categorY2)', forexample the LP statement NP < VP requires that the category NPmust precede the category VP in a sequence of daughters of anylocal tree licensed by an ID rule of the grammar.For every grammar a set F = {f~, f2 ..... fn} of syntactic featuresexists with I FI = n. The number 'n' of features can vary fromgrammar to grammar, but for a particular grammar it is constant.Each feature fi has its domain D(fi).
A complex category C is an n-tuple with C ~ D(f 1) x D(f2) x ... x D(fn) and the position T of thetuple represents he value of the feature fi.Example : F = {N, Vr BAR, PER, PLU, GEN}position i feature fi domain D(f l)1 N {+,-}2 v {+,-}3 BAR 10,1,2}4 PER { 1,2,3 }5 PLU {+,-}6 CAS { nom,gen,dat, ec }The category C = \[+N,-V,BAR 2,nom\] will be represented as(+,-,2,X,_,nom).
C is the category traditionally called a nominativeNP.
If a feature Value of,a ea/tegory is not specified, like PER a~d/ /11 ?
/ PLU in C, it will be noted as ~ variable 3.
~e  value of ~ feature fl of3 A variable f ature value will be noted as a capital letter (e.g.
X, Y, Z) when thesame variable value is needed atanother place, otherwise it will be noted as '..the category C can be expressed with C(fl), e.g.
C(CAS) =nom orC(PER) = X.
It is possible that a feature can have a category as itsvalue, e.g.
SLASH.In the following some predicates on feature values are used.
Theyare 'spec', 'atom' and 'cat'.
The semantics of them is as follows:spec(C(f)) ?~ C(f) is specified either with an atom or a categoryatom(C(t)) ?~ C(f) is specified with an atomcat(C(f)) ?
:~ C(f) is specified with a category1.2 Feature lnstant iat ionThe Feature Instantiation Principles 4 are not the subject of thispaper.
Only one thing needs to be said at this point, that is that theFIPs are not only regarded as filters for local trees as in \[GKPS85\],but in the constructive version of GPSG they propagate values offeatures within a local tree from the mother to the daughters andvice versa, or from one daughter to another if this feature value isaffected by one of the FIPs (i.e.
it is a HEAD, FOOT or agreementfeature; a brief outline of the work which is done by the AP is givenin section 2.1).
In this case the FIPs are construction principleswhich propagate information from one point of a local tree topossibly many other points which require this information.
In caseswhere a value is not specified (i.e.
it is a variable), the variable ispropagated.
The FIPs are also filters for local trees and will rejectlocal trees which have categories where the values of one of thefeatures are not consistent.Before discussing the Feature Co-occurrence Restrictions (FCRs)two definitions are necessary to be able to define legal categories.Definition: extensionA category E is the extension of a category C (C ~ E) iff(i) V f e F: atom(C(f)) ~ atom(E(f)) A C(f) = E(f) 5 and(ii) V f e F: cat(C(f)) ::?.
cat(E(f)) ^  C(f) ~_ E(f)Definition: unifiableTwo categories A and B are unifiable (A II B) ?
:~V f ~ F: ~spec(A(f)) v ~spec(B(f)) v((atom(A(f)) A atom(B(t))) ~ (Aft) = B(f))) v((cat(A(f)) A cat(B(f))) ~ (Aft) ld B(f)))The FCRs in the constructive version of GPSG are not onlypredicates on categories, they are also modified to become morefunctional by instantiating variable feature values if necessary.
FCRsare implications of the form (n, A D B).
'n' is the number of thisFCR, 'A' is the condition category for the application of this FCR4 Ia the following they.are called FIPs.
1"he FIPs are the Foot Feature Principle(FFP), the Agreement,Principle (AP) and the Head Feature Convention (I-IFC).For detailed discussion of the FIPs see \[Busemanng7\], \[Hauenschild/Busemann881 and \[Weisweber87\].5 ',,', 'v'.
'-4, '~' and '~' are the logical operators 'and', 'or', 'not', 'equivalence'and 'implicatioff, respectively,and 'B' is the consequence category.
This FCR is applicable to acategory C if C is an extension of A and, if so, C has to be unifiablewith B.
If C and B are not unifiable the category C is not legal.Definition: legalA category C is legal ?
:~V (n,A ~ B) E FCR: (A ~ C) v (A _E C A B 13 C)If the FCRs are applied to the category C and an FCR (n, A D B) isapplicable to C and the consequence category B is unifiable with Cand at least one feature f exists where ~spec(C(f)) and spec(B(f))(B ~ C), then all those values C(f) are instantiated with B(f)(C(f) := B(f)).
The FCRs have to be applied to a category C until nofeature values of C are instantiated by them any longer, because theinstantiation may cause other FCRs to be applicable.1.3 The Admissibility of TreesTo generate syntactic structures (trees) during analysis or synthesis,ID rules are mapped into local trees in which all categories are legal.This mapping is called a projection.Definition: projectionThe projection ?
~ ID ?
LT is a relation from the set ID of ID rulesto the set LT of local trees.
A tuple (r,t) is an element of ?
((r,t) e~)  where r = (r', C0 --> {Cl ..... Cn}) and_/?\iff it meets the condition ~(C i) = ~ with 0 _< i,j ~ n where the totalone-to-one, onto function ~ maps the set {C o ..... C,~} of categoriesof the ID rule r' into the set {C~ ..... C, t} of categories of the localtree t:0: {Co ..... c .}
-~{C6 ..... c~}The function ?p meets the following conditions:?
(C0) = C~ A ?p(Ct) = q A 1 < i,j < n AV ~(Ck): 0 < k < n A ?~(C k) is legal a (C k E_ O(Ck) )When a local tree has been proved to be a projection of an ID rule,the FIPs are applied to it.
Despite the fact that the projection alreadyincludes the application of the FCRs to the categories of a local tree,they still have to be applied everytime one of the FIPs (FFP, AP,HFC) has been applied to the local tree, because ach of them mayinstantiate a feature value of a category of the local tree andtherefore another FCR may be applicable to that category.
The las tcheck for admissibility is the application of the LP statements.
Thesequence of the daughters of the local tree must not conflict withany LP statement of the grammar (it has to be LP-consistent).Before 'LP-consistency' can be defined, the transitive LP-relation(LP +) has to be defined.Definition: transitive LP.relation1) (Ci < Ca) ?
LP =~ (121 ~ C2) E LP +2) (C 1 ~ C2) ?
LP + A (C~ ~ C~) E LP ?
A C~ ~_ C2 =*(C1 t C3) ?
LP +739With the help of this definition we are able to define LP-consistenc~'.Deflnitloni LP.consistencyA local tree t is LP-consistent with respect o a grammar with thetransitive LP-relation ~ iffV CI,C\]: 1 < ij < n ^ ~ precedes ~-~3 C\[,Cj: C i ~ C\[ A Cj ~_ q A (Cj ~: C I) e LP +In other words, when a category C\[ precedes a category Oj in a localtree t, they must not conflict with the transitive LP-relation (C\], andmust not be extensions of two categories C I and Cj, respectively,where Cj must precede CI).Now the definition of the admissibility of trees can be given.Definition: admissibility oftreesA tree is admissible iff all of its local trees are admissible.
A localtree is admissible iff it is a projection of a lexical rule or iff it- is the projection of an ID rule and- satisfies all of the FIPs and- is LP-consistent.2 LP-Consistency and LegalityThe first chapter of this paper illustrates how to build up thesyntactic structure (a tree) in the constructive version of GPSG, butit also sketches roughly the way this can generally be done in, unification grammars.
First of all complex categories are assembledto form a local tree and subsequently the feature values of thecategories are instantiated by different procedures (for example inGPSG by the FIPs and in the Lexical Functional Grammar (LFG)described in \[Bresnan/Kaplan82\] by the evaluation of the f-descriptions).
The admissibility of those local trees is determined bysome predicates (in GPSG by the LP statements and the FCRs andin LFG by existential constraints with the operator '=c' and thenegative xistential constraints with the special value 'none').
Thesepredicates can only be applied when particular feature values arespecified.
But when the admissibility of a local tree is to be proved,it cannot be guaranteed that all feature values have been locallyinstantiated.
In some cases it is possible that.
a feature value is notlocally instantiated rather that it is instantiated somewhere lse inanother local tree belonging to the complete tree and therefore theadmissibility of a local tree is not a local matter anymore.In this chapter the problems which arise from checking the LP-consistency and the legality in the constructive version of GPSG aredescribed in the sections 2.2 and 2.3 respectively.
Section 2.4 brieflyoutlines the two possible solutions proposed by \[Keller87\].
But firstof all a sample grammar is given to be used for examples.2.1 A Sample GrammarTo illustrate the problems arising from checking the LP-consistencyof a sequence of complex daughter categories and from ehecldng thelegality of complex categories of a local tree, a sample grammar isgiven here.740The set of syntactic features is F = {fl, f2, f3}.
A category is a tripleC e D(f I) x D(f2) x D(f3).Features: f, D(f,) = {a,b,c,d,e}f2 D(f2) = {+'"* }f3 D(f3) = { 1,2,3}ID = { ((a,X,l) --~ {Co,Y,1), (c,Z,2)}), (I)((b,X,_) ~ {(d,Y,3), (e,*,1)}) } (2)Lexical rules: { ((e,_,_) --~ e), ((d~_,_) --~ d),((c,-,_) --~ cm), ((e,+J --~ cp) }LP = { (_,*,_) < (_,+,_), LP + = { (--,*,-) ~ (-,+~),.
(1)(_,-,_3 < (_:,_) } (_,-,_) ~ C,*,-3, (2)C,-,_) ~ C,+,_) } (3)FCR = { (1, Co,-,_.)
D (_,_,l)), (2, (d,+,_) D (_,_,2)) }Suppose that the feature f2 is an agreement feature and that a localtree t which is a projection of this ID rule has been constructed, thenthe Agreement Principle (AP) forces X = Y = Z and therefore theAP has to consider three cases 6:1) If at least two values are instantiated with different values thenthe AP has to reject (thepredicative iew of the F1Ps which isstill preserved in the constructive rsion of GPSG).2) If at least one value is instantiated then the other variable valuesare instantiated with that value by the AP (propagation ofinstantiated feature values).3) If all values are not specified, i.e.
they are variables, then the APwill identify all values with one variable (propagation of variablefeature values).Whenever an admissible local tree t is a projection of ID rule (1), thevalues of the feature f2 (X, Y, Z) have to be identical and we canapply case (3) to the local tree t.2.2 ID/LP Specific ProblemsIn this section only LP-consistency is considered and the legality ofcategories i  ignored.
In some cases there are categories of localtrees which have feature values not yet specified when the LP-consistency has to be checked, and this possibly means that one ormore (transitive) LP statements cannot be applied to the givensequence of daughters.There axe two strategies for processing natural language with ID/LPgrammars ODLPG):1) The indirect method, where an IDLPG is translated into an equiv-alent context-free grammar (CFG) (see \[Kilbury84\]).2) The direct method, where the ID rules and LP statements are useddirectly during processing (see \[Shieber84\], \[Kilbury84\], [Dtrre/Momma85\], \[Busemann87\] and \[Weisweber87\]).No matter which method is used some problems arise.
Firstly the6 For the sake of simplicity the AP of the constructive version of GPSG is notdescribed in detail here (see footnote 4),problems in using the indirect method are described.
Suppose IDrule (2) is to be translated into equivalent context-free rules.
In orderto do that, all permutations of the daughters have to be computedand the LP-consisteney of the resulting sequences has to be proved.Tiros the possible candidates for context-free rules are the following:(2a) ((b,X,_) ---> (e,*,l)(d,X,3)) and (2b) ((b,X,_) ---) (d,X,3)(e,*,l))To prove the LP-consisteucy of (2a), (C 1 ~ Ca) must not be anelement of LP +, where C1 ~ (d,X,3) and C a E (e,*,l).
If such anelement exists, the sequence of daughters in (2a) is not LP-consistent and has to be rejected.
The only candidate from LP + is(2), but it cannot be applied because (_,~,_) ~ (d,X,3), and so (2a) isa valid context-free rule.
But when X is instantiated with '-' later onduring processing, the local tree tl which is licensed by (2a) has tobe rejected because itviolates the transitive LP statement (2).tl: /(b,-,_)....>..(e,\]el) (d=3)The same problem arises when the direct method is used.
Supposethe string 'e d cm' is to be analysed, After the terminal symbol 'e' hasbeen read, it .is reduced to (e,~,_).
This category can be dominated inID rule (2) b~canse (e,_,_) and (e,*,l) are unifiable.
Then 'd' is readand reduced to (d,_,_) which can also be dominated in ID role (2)and it is unifiable with (d,X,3).
Now tile daughters of ID rule (2) arecomplete and before they can be reduced to the mother category(b,X,1), the l,P-consistency of the sequence '(e,*,l)(d,X~) ' as abovehas to be proved.
For the above mentioned reason ",his sequence isLP-consistent and is reduced to (b,X,1).
This category can bedominated in ID rule (1) and up to this point the following partialtree t2 can be constructed.t'2: / (b ,X ,~(  a'X' 1) (c--~c,X,2) (d ,ld,3)Every local tree in the partial tree t 2 is LP-consistent.
Now thetelxninal symbol 'era' is read and reduced to (c,-,_).
This category isunifiable with (c,X,2) in t 2 and the local tree licensed by a lexicalrule can be added to t a. Wlmn the two categories are unified 7 thevariable X is instantiated with '-' everywhere in t 2.
The result is thatthe sequence of daughters '(e,*,l)(d,-,3)' is not LP-eonsistentanymore, beeanse now it violates the transitive LP statement (2).
Ifinstead the next input symbol after the string 'e d' is 'cp', noproblems with the LP-consistency arise.2?3 FCR Specific ProblemsSimilar problems like those with the LP..consistency appear whenthe FCRs are applied to the categories of a local tree.
Suppose thatIn the constructive rsion of GPSG, unification is used for tree formation.
Inthe version of \[GKPS85\] the root category R of a subtree has to be identicalwith a &mghter category C of a local tree (i.e.
R __.
C and C ~ R).the partial tree t 2 has already teen constructed.
All of its categoriesare legal.Suppose that the next input symbol after the string 'e d' is 'cp'.
Thisterminal symbol is reduced to (c,+,_) which can be unified with(c,X,2) in t. 2 and the variable X is instantiated with '+'.
Thus allvariables X in t~ have to be replaced by '+' and the category (d,X,3)becomes (d,+,3).
Now FCR 2 is applicable because (d,+,3) is anextension of the condition category (d,+,_) ((d,+,_) c (d,+,3)), but itis not unifiable with the consequence ategory (_,_,2) (-~((d,+,3) \[J( .
.
.
.
2))) and thus it is not legal and has to be rejected.2.4 Two Possible SolutionsAccording to \[Keller87\], the problems described in the sections 2.2and 2.3 can be solved in two ways.
One way would be to check theLP-consistency of all local trees and the legality of all categoriesafter the entire tree for the input string has been constructed.
Theother way would be to restrict he grammar format and/or the FIPs.The disadvantage of the former solution is its inefficency.
Thechecks have to be done in addition after the processing of the inputstring is terminated because some trees have not already beenrejected, although it would have been possible to do so.The disadvantage of the latter solution is made obvious by twoexamples.
The format of the categories, for example, can berestricted by assuring that the mother category in a local tree is fullyspecified, i.e.
a feature must not have a variable as its value.
Thiswould involve a loss of the grammar's descriptive power.
Anotherway would be to restrict the FIPs by assuring that they don'tpropagate variable feature values, which would involve GPSGlosing some of its generality.3 ConstraintsIn both cases (LP-consistency and legality) the problems are causedby categories of local trees which are not extensions of tilecategories in the LP statements o1" of the condition categories in theFCRs, but which have been unifiable with them.
This is the casewhen a feature of a category of the local tree has a variable as itsvalue and the same feature value is specified in the correspondingcategory of the LP statements or the FCRs.This fact means that the LP statements or the FCRs are not locallyapplicable in some cases, and so the admissibility of the local treescan only be assured with certain constraints which can be fulfilledlater on, when the variable is instantiated during processing.3.1 Computing Constraints from LPTo compute the constraints resulting from the LP statements, theabove mentioned cases have to be first identified.
Suppose that thesequence 'A B' of categories i to be checked for LP-consisteney andan LP statement B":< A' exists where B \[J B' and B' \[~ B and A' ~_ A.This LP statement is not applicable to 'A B' because B' ~ B, thoughB' H B.
This means that at least one feature f exists, wherespec(B'(f))and --,spec(B(f)).
Thus the sequence 'A B' is LP-741consistent under the constraint that B( f i ) ,  B'(fi) for all features fiwith the above mentioned condition, and since all values B(fl) forthose features fl are variables (~spec(B(fi))) , they must not beinstantiated with the values B'(fi) which are already specified.
Whenthe values B(fi) are instantiated by the FIPs or by the FCRs in thelocal tree, there is no problem in determining the admissibility.
Butwhen the variable feature values B(fi) are propagated to the motherby the FIPs, they can possibly be instantiated in another local treeand those variable values B(fi) have to be constrained.Computing the set of constrqints LP cWhen the LP-consistency of a sequence of daughters in a local tree tis checked for every pair of daughters Q, q ,  where 1 < i < j < n, theset LPc(i, j) of LP constraints i computed as follows:1) ~ (Cj ~ Ci) E LP+: Cj ~ ~jj A C i ~ C\[ ~ t is not LP-consistent2) V (Cj ~: C i) ~ LP+: (CjLJ q A Cj ~ q) v (C~L\] o, ^ c~ ~ Cl)t is LP-consistent with the LP constraints:LPc(i,j) = { (Oj(f),Cj(f))l spec(Cj(f)) and ~spec(Oj(f)) } u{(Q(0,Ci(f))l spec(Ci(f)) and ~spec(~(f))}3) --~=I (Cj ~: C) ELF+: (Cj L\] C} ^  C~ IJ q)t is LP-consistent with LPc(i,j) = { }LPc(i,j) is a set of tuples (Vt,Vp) of feature values.
V t is the variablefeature ~,alue of a category of  a local tree.
Vp is the specified featurevalue of the LP statement which will become applicable to thecorresponding daughters of the subtree if the values V t of all tuplesin LPc(id) are specified and equal to their corresponding values Vp.In this case the subtree has to be rejected.The set of all LP constraints LPc(0) for the'local tree in which C~ isthe mother category is ?1LPc(0) = {LPc(i,j)\[ 1 < i < j < n} u ;L.) 4eval_lp(LPc(i))where eval_lp(LPc(i)) is the evaluation of the LP constraints of thesubtree in which the daughter ~ is the root category.
The set of LPconstraints o f  a projection of a lexical rule is LPc(0) = {}, sincelexical rules have only one daughter (a wordform).The evaluation 'eval_lp'The evaluation 'eval lp' is either defined or undefined (.1.).
If it isundefined, the corresponding local tree is rejected, because one ofthe subtrees of the daughters of that local tree is not LP-consistent.1) eval_lp(LPc(i)) = .L ?
:~3 C ?
LPc(i): (V (Vt,V2) E C: spec(V 1) A spec(V 2) ^  V 1 = V2)2) eval_lp(LPc(i)) = LPc(i) -{C ~ LPc(i)l 3(V1,V 2) ~ C: spec(V 0 A spec(V2) A V 1 ~ V2}3) eval lp(LPc(i)) = {CI (C = C' - M) ^ C" ~ LPc(i) ^  C ?
{ } }where M = {(Vl,V2) \[ spec(V 1) ^  spec(V 2) A V 1 = V2}The first case (1) means that if one set C of tuples exists in the setLPc(i) of one daughter of the local tree, where all values of all tuplesare specified and equal, then an LP statement will be applicablesomewhere in the subtree of this daughter, and it will reject thesubtree because some sister categories in the subtree are not LP-consistent anymore.742The second case (2) removes all sets S of tuples from LPc(i ) of onedaughter which include one tuple with two different specifiedvalues.
This means that the LP statement which has caused thecomputation of S will not be applicable anymore.The third case (3) removes all tuples with two equally specifiedvalues from all sets of tuples in LPc(i) of one daughter, because theyneed not be evaluated for a second time.3.2 Computing Constraints from FCRsTo compute constraints resulting from FCRs, the categories have tobe identified which are not an extension of a condition category ofan FCR, but unifiable with it.
Suppose that the FCRs are to beapplied to the category C, and that an FCR (n, A ~ B) existswhere A \[3 C and A ~ C. The FCR 'n' is not applicable to C. Thismay change if a feature value is instantiated.
It is the same situationas in section 3.1, but here the computing of constraints i somewhatdifferent, because the application of an FCR to a category may causethat another FCR will become applicable to that category.
FCRconstaaints only have to be computed when ~(B L\] C), or B l_J C andB ~ C (the case ~(B H C) means that if the FCR will be applicableto C, it will reject C, and the second case means that if the FCR willbecome applicable to C, it will instantiate one or more features in C,but the category always remains legal with respect to this FCR).
Thecase ~(B II C) is the crucial one, because the legality of the categoryC can only be assured with the constraint that the set of possiblyapplicable FCRs, with the above mentioned conditions on theconsequence ategory, still have to be checked for applicability.Computing the set of constraints FCR cFor all categories C\[ where 0 < i < n in a local tree t the set APP(i) ofall numbers of FCRs which may still be applicable to Q is computedas follows:1) 3 (k,A D B) ~ FCR: A E Q A -~(B \[3 C D =~ C I not legal2~V (k)A ~ B) ~ FCR: AL Jq  ^ A~ qA(-~(B L\] q )  v ((B LJ CD ^  (B ~ q))) ~ q legal and k ~ AFP(i)3) V (k,A ~ B) ~ FCR: ~(A LJ q )  v (A _E C) ^  B II q )q is legal and APP(i) = { }The set of all FCR constraints FCRc(0) for the local tree in which C8is the mother category is11FCRc(0) = { (C8) APP(0)) } u .L) eval fcr(FCRc(i))where eval fcr(FCRc(1)) is the evaluation of the FCR constraintsfrom the subtree in which the daughter q is the root category.FCRc(0) is a set of tuples (Ci, APP(i)).
Ci is a copy of a category ofthe subtree in which C 8 is the root category and APP(i) includes thenumbers of all FCRs which may still be applied to C i if particularfeature values of this category are going to be instantiated.
The onlynew set APP in a local tree is computed from the mother) becausethe evaluation of the FCR constraints on the subtre~s of thedaughters includes the application of the applicable FCRs to thedaughter categories (because they are the root categories of thesubtrees).
Thus the remaining tuples of the daughters and theirsubtrees will be computed by the evaluation.
The set of FCRconstraints on a projection of a lexical rule is FCRc(0 ) = {(C~,APP(O))}.The evaluatim~ 'evaljcr'The evaluation 'eval for' is either defined or undefined (.L).
If it isundefined, the con'esponding local tree is rejected, because one ormore categories of the subtrees of the daughters of that local tree arenot legal.1) eval fcr(FCRc(i)) = .L ?=:, 3 (C,APP) ~ FCRc(i): k e APP ^(k,A ~ B) e FCR ^ A c C ^ -,(B \[J C)2) eval fcr(FCRc(i)) = {(C,M) I (M = APP - S) ^(C,APP) e FCRc(i ) ^ M e { } } whereS = {k\[ (k,A ~ B) e FCR ^ (-~(AH C) v (A  c_ C ^ B \[J C))}The first case (1) means that if the set FCRc(i) of a subtree of onedaughter C\[ includes one tuple (C,APP) in which the category C isnot legal with respect o the FCR (k,A ~ B) where 'k' is in the setAPP of numbers of FCRs, then the subtree has to be rejected,because the category C in this subtree is no longer legal.The second case (2) removes all the numbers 'k' of  FCRs from theset APP of all tuples in FCRc(i), where the FCR (k,A D B) is nolonger applicable to the category C or where it has been successfullyapplied to the corresponding category.3.3 Evaluation and PropagationAfter a local nee t has been proved to be a projection of an ID rule,all F1Ps are applied to t, the FCRs to its mother, and the set APP(0)of the numbers of all FCRs which possibly will be applicable to themother, is computed.
After that the FCR constraints on the subtreesof the daughters are evaluated, which means that all applicableFCRs are applied to the daughters and to all other categories of theirstthtrecs.
The remaining FCR constraints from the evaluation, andthe FCR con:;traint (C~, APP(0)) on the mother, will then becombined to form the new FCR constraint set FCRc(0) on thegubtree in which C~ is the root category.
The new FCR constraint setis propagated tothe mother.Next the LP-.consistency of the daughters has to be checked, andduring this check the new LP constraints on the daughters arecomputed.
These constraints are combined with the LP constraintsresulting fl'om the evaluation of the LP constraints on the subtrees ofthe daughters, to form the entire set of LP constraints LPc(0) on thesubtree in which C/~ is the root category which is then alsopropagated tothe mother.4 ConclusionWith this method of constraint computation, evaluation andpropagation," a new definition of the admissibility of trees isnecessary.Definition: admissibility of treesA tree is adndssible iff all of its local trees are admissible and theevaluations 'eval fcr' and 'eval lp' of constraints of theroot categoryare defined and both are the empty set {}.
A local tree t isadmissible iff it is a projection of a lexical rule or iff it- is a projection of an ID rule with the FCR constraint (C~, APP(0))on the mother C/~ and- satisfies all of the FlPs and- is LP-consistent with the LP constraints LPc(i,j) on all daughters C\[and ~ which ,are propagated tothe mother where 1 _< i < j < n and- the evaluation 'eval_fcr(FCRc(i))' of every daughter C\[ isdef inedwhere 1 ~ i < n and their results are propagated tothe mother and- the evaluation 'eval_lp(LPc(i))' of every daughter C i is definedwhere 1 ~ i ~ n and their results are propagated tothe mother.The consequence for the root category R of an entire tree of oneinput string of a natural anguage will be the fact that all features fiof R, where ~spec(R(fi)), and where fl is needed for the evaluationof the constraints of the tree, have to be instantiated according totheir domain D(fi) because such a tree represents a class ofambiguous olutions.
After that the constraints on every tree of thisclass are evaluated and only the trees where FCRc(0 ) and LPc(0 ) aredefined and their evaluation is { } are admissible.References\[Barton85\] : G.E.
Barton Jr.; "The Computational Difficulty of ID/LP Parsing";23rd Ann.
Meet.
of the ACL at University of Chicago; Chicago 1985\[Bresnau/Kaplan82\] : J. Bresnun, R.M.
Kaplan; "Lexical Functional Grmnmar: AFormal System of Grammatical Representation"; i : MIT Press Series onCognitive Theory and Mental Repr.
pp.173-28 I; Cambridge 1982\[Busemann87\] : S. Busemann; "Generierung mit GPSG"; in: K.
Morik(ed.
)Proceedings of the llth German Workshop on Artifical Intelligencepp.355-364; Springer-Verlag; Geseke 1987\[Busemann/Hauensehild88\] : S. Busemann, C. Hauenschild; "A ConstructiveView of GPSG or How To Make It Work"; 12th InternationalConference on Computational Linguistics, Budapest 1988\[DSrre/Momma851 : J. D~rre, S. Momma; "Modifikationen des Earley-Algorithmus und ihre Verwendung flit ID/LP-Grammatiken"; Manuscriptof the Department for Linguistics/ Romanistics at the University ofStuttgart 1985\[GKPS85\] : G. Gazdar, E. Klein, G. Pullum, I.
Sag; "Generalized Phrase StructureGrammar"; Oxford; Blackwell 1985\[Hanenschild/Buse,nann88\] : C. Hanenschild, S. Busemann; "A ConstructiveVersion of GPSG for Maschine Translation" in Steiner, Schmidt,Zelinsky-Wibbelt (eds.)
"From Syntax to Semantics-Insights fromMaschina Translation", Frances Pinter\[Karttunen84\] : L. Karttunen; "D-PATR: A Development Environment forUnification-Based Grammars"; llth International Conference onComputational Linguistics, Bonn 1986\[Keller87\] : W. Keller; "An Overview of the Project NASEV Parser"; Manuscript,University of Sussex 1987\[Kilbury84\] : J. Kilbury; "Earley-basierte Algorithmen filr direktes Parsen mitID/LP-Grammatiken"; KIT-Report 16; T(.I Berlin 1984\[Ristad86\] : E.S.
Ristad; "Computational Complexity of Current GPSG Theory";24th Ann.
Meet.
of the ACL at Columbia University; New York 1986\[Shieber84\] : S.M.
Shieber; "Direct Parsing of ID/LP Grammars"; Linguistics andPhilosophy 7 1984 pp.135-154\[Shieber86al : S.M.
Shieber; "An Introduction toUnification-based Approaches toGrammar"; CSLI Lecture Notes Number 4, Ventura Hall, StanfordUniversity, Stanford 1986lShieber86b\] : S.M.
Shieber; "A Simple Reconstruction f GPSG"; Proceedings ofthe llth International Conference on Computational Linguistics; Bonn1986 pp.211-215?
\[Weisweber87\] : W. Weisweber; "Ein Dominanz-Chart-Parser fiir genemlisiertePhrasenstrukturgrammatiken"; KiT-Report 45, TU Berlin743
