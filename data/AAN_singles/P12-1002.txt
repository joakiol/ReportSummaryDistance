Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 11?21,Jeju, Republic of Korea, 8-14 July 2012. c?2012 Association for Computational LinguisticsJoint Feature Selection in Distributed Stochastic Learningfor Large-Scale Discriminative Training in SMTPatrick Simianer and Stefan RiezlerDepartment of Computational LinguisticsHeidelberg University69120 Heidelberg, Germany{simianer,riezler}@cl.uni-heidelberg.deChris DyerLanguage Technologies InstituteCarnegie Mellon UniversityPittsburgh, PA, 15213, USAcdyer@cs.cmu.eduAbstractWith a few exceptions, discriminative train-ing in statistical machine translation (SMT)has been content with tuning weights for largefeature sets on small development data.
Ev-idence from machine learning indicates thatincreasing the training sample size results inbetter prediction.
The goal of this paper is toshow that this common wisdom can also bebrought to bear upon SMT.
We deploy localfeatures for SCFG-based SMT that can be readoff from rules at runtime, and present a learn-ing algorithm that applies `1/`2 regulariza-tion for joint feature selection over distributedstochastic learning processes.
We present ex-periments on learning on 1.5 million trainingsentences, and show significant improvementsover tuning discriminative models on smalldevelopment sets.1 IntroductionThe standard SMT training pipeline combinesscores from large count-based translation modelsand language models with a few other features andtunes these using the well-understood line-searchtechnique for error minimization of Och (2003).
Ifonly a handful of dense features need to be tuned,minimum error rate training can be done on smalltuning sets and is hard to beat in terms of accuracyand efficiency.
In contrast, the promise of large-scale discriminative training for SMT is to scale toarbitrary types and numbers of features and to pro-vide sufficient statistical support by parameter esti-mation on large sample sizes.
Features may be lex-icalized and sparse, non-local and overlapping, orbe designed to generalize beyond surface statisticsby incorporating part-of-speech or syntactic labels.The modeler?s goals might be to identify complexproperties of translations, or to counter errors of pre-trained translation models and language models byexplicitly down-weighting translations that exhibitcertain undesired properties.
Various approaches tofeature engineering for discriminative models havebeen presented (see Section 2), however, with a fewexceptions, discriminative learning in SMT has beenconfined to training on small tuning sets of a fewthousand examples.
This contradicts theoretical andpractical evidence from machine learning that sug-gests that larger training samples should be benefi-cial to improve prediction also in SMT.
Why is this?One possible reason why discriminative SMT hasmostly been content with small tuning sets lies inthe particular design of the features themselves.
Forexample, the features introduced by Chiang et al(2008) and Chiang et al (2009) for an SCFG modelfor Chinese/English translation are of two types:The first type explicitly counters overestimates ofrule counts, or rules with bad overlap points, badrewrites, or with undesired insertions of target-sideterminals.
These features are specified in hand-crafted lists based on a thorough analysis of a tuningset.
Such finely hand-crafted features will find suf-ficient statistical support on a few thousand exam-ples and thus do not benefit from larger training sets.The second type of features deploys external infor-mation such as syntactic parses or word alignmentsto penalize bad reorderings or undesired translationsof phrases that cross syntactic constraints.
At largescale, extraction of such features quickly becomes11(1) X ?
X1 hat X2 versprochen, X1 promised X2(2) X ?
X1 hat mir X2 versprochen,X1 promised me X2(3) X ?
X1 versprach X2, X1 promised X2Figure 1: SCFG rules for translation.infeasible because of costly generation and storageof linguistic annotations.
Another possible reasonwhy large training data did not yet show the ex-pected improvements in discriminative SMT is aspecial overfitting problem of current popular onlinelearning techniques.
This is due to stochastic learn-ing on a per-example basis where a weight update ona misclassified example may apply only to a smallfraction of data that have been seen before.
Thusmany features will not generalize well beyond thetraining examples on which they were introduced.The goal of this paper is to investigate if andhow it is possible to benefit from scaling discrimi-native training for SMT to large training sets.
Wedeploy generic features for SCFG-based SMT thatcan efficiently be read off from rules at runtime.Such features include rule ids, rule-local n-grams,or types of rule shapes.
Another crucial ingredi-ent of our approach is a combination of parallelizedstochastic learning with feature selection inspiredby multi-task learning.
The simple but effectiveidea is to randomly divide training data into evenlysized shards, use stochastic learning on each shardin parallel, while performing `1/`2 regularizationfor joint feature selection on the shards after eachepoch, before starting a new epoch with a reducedfeature vector averaged across shards.
Iterative fea-ture selection procedure is the key to both efficiencyand improved prediction: Without interleaving par-allelized stochastic learning with feature selectionour largest experiments would not be feasible.
Se-lecting features jointly across shards and averagingdoes counter the overfitting effect that is inherentto stochastic updating.
Our resulting models arelearned on large data sets, but they are small andoutperform models that tune feature sets of varioussizes on small development sets.
Our software isfreely available as a part of the cdec1 framework.1https://github.com/redpony/cdec2 Related WorkThe great promise of discriminative training forSMT is the possibility to design arbitrarily expres-sive, complex, or overlapping features in great num-bers.
The focus of many approaches thus has beenon feature engineering and on adaptations of ma-chine learning algorithms to the special case of SMT(where gold standard rankings have to be createdautomatically).
Examples for adapted algorithmsinclude Maximum-Entropy Models (Och and Ney,2002; Blunsom et al, 2008), Pairwise Ranking Per-ceptrons (Shen et al, 2004; Watanabe et al, 2006;Hopkins and May, 2011), Structured Perceptrons(Liang et al, 2006a), Boosting (Duh and Kirchhoff,2008; Wellington et al, 2009), Structured SVMs(Tillmann and Zhang, 2006; Hayashi et al, 2009),MIRA (Watanabe et al, 2007; Chiang et al, 2008;Chiang et al, 2009), and others.
Adaptations of theloss functions underlying such algorithms to SMThave recently been described as particular formsof ramp loss optimization (McAllester and Keshet,2011; Gimpel and Smith, 2012).All approaches have been shown to scale to largefeature sets and all include some kind of regulariza-tion method.
However, most approaches have beenconfined to training on small tuning sets.
Exceptionswhere discriminative SMT has been used on largetraining data are Liang et al (2006a) who trained 1.5million features on 67,000 sentences, Blunsom etal.
(2008) who trained 7.8 million rules on 100,000sentences, or Tillmann and Zhang (2006) who used230,000 sentences for training.Our approach is inspired by Duh et al (2010)who applied multi-task learning for improved gen-eralization in n-best reranking.
In contrast to ourwork, Duh et al (2010) did not incorporate multi-task learning into distributed learning, but definedtasks as n-best lists, nor did they develop new algo-rithms, but used off-the-shelf multi-task tools.3 Local Features for Synchronous CFGsThe work described in this paper is based on theSMT framework of hierarchical phrase-based trans-lation (Chiang, 2005; Chiang, 2007).
Transla-tion rules are extracted from word-aligned paral-lel sentences and can be seen as productions of asynchronous CFG.
Examples are rules like (1)-(3)12shown in Figure 1.
Local features are designed to bereadable directly off the rule at decoding time.
Weuse three rule templates in our work:Rule identifiers: These features identify each ruleby a unique identifier.
Such features corre-spond to the relative frequencies of rewritesrules used in standard models.Rule n-grams: These features identify n-grams ofconsecutive items in a rule.
We use bigramson source-sides of rules.
Such features identifypossible source side phrases and thus can givepreference to rules including them.2Rule shape: These features are indicators that ab-stract away from lexical items to templates thatidentify the location of sequences of terminalsymbols in relation to non-terminal symbols,on both the source- and target-sides of eachrule used.
For example, both rules (1) and (2)map to the same indicator, namely that a ruleis being used that consists of a (NT, term*, NT,term*) pattern on its source side, and an (NT,term*, NT) pattern on its target side.
Rule (3)maps to a different template, that of (NT, term*,NT) on source and target sides.4 Joint Feature Selection in DistributedStochastic LearningThe following discussion of learning methods isbased on pairwise ranking in a Stochastic Gradi-ent Descent (SGD) framework.
The resulting al-gorithms can be seen as variants of the perceptronalgorithm.
Let each translation candidate be repre-sented by a feature vector x ?
IRD where preferencepairs for training are prepared by sorting translationsaccording to smoothed sentence-wise BLEU score(Liang et al, 2006a) against the reference.
For apreference pair xj = (x(1)j ,x(2)j ) where x(1)j is pre-ferred over x(2)j , and x?j = x(1)j ?
x(2)j , we considerthe following hinge loss-type objective function:lj(w) = (?
?w, x?j ?
)+where (a)+ = max(0, a) , w ?
IRD is a weight vec-tor, and ?
?, ??
denotes the standard vector dot prod-uct.
Instantiating SGD to the following stochastic2Similar ?monolingual parse features?
have been used inDyer et al (2011).subgradient leads to the perceptron algorithm forpairwise ranking3 (Shen and Joshi, 2005):?lj(w) ={?x?j if ?w, x?j?
?
0,0 else.Our baseline algorithm 1 (SDG) scales pairwiseranking to large scale scenarios.
The algorithm takesan average over the final weight updates of eachepoch instead of keeping a record of all weight up-dates for final averaging (Collins, 2002) or for voting(Freund and Schapire, 1999).Algorithm 1 SGD: int I, T , float ?Initialize w0,0,0 ?
0.for epochs t?
0 .
.
.
T ?
1: dofor all i ?
{0 .
.
.
I ?
1}: doDecode ith input with wt,i,0.for all pairs xj , j ?
{0 .
.
.
P ?
1}: dowt,i,j+1 ?
wt,i,j ?
?
?lj(wt,i,j)end forwt,i+1,0 ?
wt,i,Pend forwt+1,0,0 ?
wt,I,0end forreturn 1TT?t=1wt,0,0While stochastic learning exhibits a runtime be-havior that is linear in sample size (Bottou, 2004),very large datasets can make sequential process-ing infeasible.
Algorithm 2 (MixSGD) addressesthis problem by parallelization in the framework ofMapReduce (Dean and Ghemawat, 2004).Algorithm 2 MixSGD: int I, T, Z, float ?Partition data into Z shards, each of size S ?
I/Z;distribute to machines.for all shards z ?
{1 .
.
.
Z}: parallel doInitialize wz,0,0,0 ?
0.for epochs t?
0 .
.
.
T ?
1: dofor all i ?
{0 .
.
.
S ?
1}: doDecode ith input with wz,t,i,0.for all pairs xj , j ?
{0 .
.
.
P ?
1}: dowz,t,i,j+1 ?
wz,t,i,j ?
?
?lj(wz,t,i,j)end forwz,t,i+1,0 ?
wz,t,i,Pend forwz,t+1,0,0 ?
wz,t,S,0end forend forCollect final weights from each machine,return 1ZZ?z=1(1TT?t=1wz,t,0,0).3Other loss functions lead to stochastic versions of SVMs(Collobert and Bengio, 2004; Shalev-Shwartz et al, 2007;Chapelle and Keerthi, 2010).13Algorithm 2 is a variant of the SimuParallelSGDalgorithm of Zinkevich et al (2010) or equivalentlyof the parameter mixing algorithm of McDonald etal.
(2010).
The key idea of algorithm 2 is to parti-tion the data into disjoint shards, then train SGD oneach shard in parallel, and after training mix the finalparameters from each shard by averaging.
The algo-rithm requires no communication between machinesuntil the end.McDonald et al (2010) also present an iterativemixing algorithm where weights are mixed fromeach shard after training a single epoch of the per-ceptron in parallel on each shard.
The mixed weightvector is re-sent to each shard to start another epochof training in parallel on each shard.
This algorithmcorresponds to our algorithm 3 (IterMixSGD).Algorithm 3 IterMixSGD: int I, T, Z, float ?Partition data into Z shards, each of size S ?
I/Z;distribute to machines.Initialize v?
0.for epochs t?
0 .
.
.
T ?
1: dofor all shards z ?
{1 .
.
.
Z}: parallel dowz,t,0,0 ?
vfor all i ?
{0 .
.
.
S ?
1}: doDecode ith input with wz,t,i,0.for all pairs xj , j ?
{0 .
.
.
P ?
1}: dowz,t,i,j+1 ?
wz,t,i,j ?
?
?lj(wz,t,i,j)end forwz,t,i+1,0 ?
wz,t,i,Pend forend forCollect weights v?
1ZZ?z=1wz,t,S,0.end forreturn vParameter mixing by averaging will help to easethe feature sparsity problem, however, keeping fea-ture vectors on the scale of several million featuresin memory can be prohibitive.
If network latencyis a bottleneck, the increased amount of informationsent across the network after each epoch may be afurther problem.Our algorithm 4 (IterSelSGD) introduces featureselection into distributed learning for increased effi-ciency and as a more radical measure against over-fitting.
The key idea is to view shards as tasks, andto apply methods for joint feature selection frommulti-task learning to achieve small sets of featuresthat are useful across all tasks or shards.
Our algo-rithm represents weights in a Z-by-D matrix W =[wz1 | .
.
.
|wzZ ]T of stacked D-dimensional weightvectors across Z shards.
We compute the `2 norm ofthe weights in each feature column, sort features bythis value, and keep K features in the model.
Thisfeature selection procedure is done after each epoch.Reduced weight vectors are mixed and the result isre-sent to each shard to start another epoch of paral-lel training on each shard.Algorithm 4 IterSelSGD: int I, T, Z,K, float ?Partition data into Z shards, each of size S = I/Z;distribute to machines.Initialize v?
0.for epochs t?
0 .
.
.
T ?
1: dofor all shards z ?
{1 .
.
.
Z}: parallel dowz,t,0,0 ?
vfor all i ?
{0 .
.
.
S ?
1}: doDecode ith input with wz,t,i,0.for all pairs xj , j ?
{0 .
.
.
P ?
1}: dowz,t,i,j+1 ?
wz,t,i,j ?
?
?lj(wz,t,i,j)end forwz,t,i+1,0 ?
wz,t,i,Pend forend forCollect/stack weights W?
[w1,t,S,0| .
.
.
|wZ,t,S,0]TSelect top K feature columns of W by `2 norm andfor k ?
1 .
.
.K dov[k] = 1ZZ?z=1W[z][k].end forend forreturn vThis algorithm can be seen as an instance of `1/`2regularization as follows: Let wd be the dth columnvector of W, representing the weights for the dthfeature across tasks/shards.
`1/`2 regularization pe-nalizes weights W by the weighted `1/`2 norm?||W||1,2 = ?D?d=1||wd||2.Each `2 norm of a weight column representsthe relevance of the corresponding feature acrosstasks/shards.
The `1 sum of the `2 norms en-forces a selection among features based on thesenorms.
Consider for example the two 5-feature, 3-task weight matrices in Figure 2.
Assuming thesame loss for both matrices, the right-hand side ma-trix is preferred because of a smaller `1/`2 norm(12 instead of 18).
This matrix shares featuresacross tasks which leads to larger `2 norms for somecolumns (here ||w1||2 and ||w2||2) and forces othercolumns to zero.
This results in shrinking the ma-trix to those features that are useful across all tasks.14w1 w2 w3 w4 w5 w1 w2 w3 w4 w5wz1 [ 6 4 0 0 0 ] [ 6 4 0 0 0 ]wz2 [ 0 0 3 0 0 ] [ 3 0 0 0 0 ]wz3 [ 0 0 0 2 3 ] [ 2 3 0 0 0 ]column `2 norm: 6 4 3 2 3 7 5 0 0 0`1 sum: ?
18 ?
12Figure 2: `1/`2 regularization enforcing feature selection.Our algorithm is related to Obozinski et al(2010)?s approach to `1/`2 regularization where fea-ture columns are incrementally selected based on the`2 norms of the gradient vectors corresponding tofeature columns.
Their algorithm is itself an exten-sion of gradient-based feature selection based on the`1 norm, e.g., Perkins et al (2003).4 In contrast tothese approaches we approximate the gradient by us-ing the weights given by the ranking algorithm itself.This relates our work to weight-based recursive fea-ture elimination (RFE) (Lal et al, 2006).
Further-more, algorithm 4 performs feature selection basedon a choice of meta-parameter of K features insteadof by thresholding a regularization meta-parameter?, however, these techniques are equivalent and canbe transformed into each other.5 Experiments5.1 Data, Systems, Experiment SettingsThe datasets used in our experiments are versionsof the News Commentary (nc), News Crawl (crawl)and Europarl (ep) corpora described in Table 1.
Thetranslation direction is German-to-English.The SMT framework used in our experimentsis hierarchical phrase-based translation (Chiang,2007).
We use the cdec decoder5 (Dyer et al,2010) and induce SCFG grammars from two sets ofsymmetrized alignments using the method describedby Chiang (2007).
All data was tokenized andlowercased; German compounds were split (Dyer,2009).
For word alignment of the news-commentarydata, we used GIZA++ (Och and Ney, 2000); foraligning the Europarl data, we used the Berke-ley aligner (Liang et al, 2006b).
Before train-ing, we collect all the grammar rules necessary to4Note that by definition of ||W||1,2, standard `1 regulariza-tion is a special case of `1/`2 regularization for a single task.5cdec metaparameters were set to a non-terminal span limitof 15 and standard cube pruning with a pop limit of 200.translate each individual sentence into separate files(so-called per-sentence grammars) (Lopez, 2007).When decoding, cdec loads the appropriate file im-mediately prior to translation of the sentence.
Thecomputational overhead is minimal compared to theexpense of decoding.
Also, deploying disk spaceinstead of memory fits perfectly into the MapRe-duce framework we are working in.
Furthermore,the extraction of grammars for training is done ina leave-one-out fashion (Zollmann and Sima?an,2005) where rules are extracted for a parallel sen-tence pair only if the same rules are found in othersentences of the corpus as well.3-gram (news-commentary) and 5-gram (Eu-roparl) language models are trained on the data de-scribed in Table 1, using the SRILM toolkit (Stol-cke, 2002) and binarized for efficient querying usingkenlm (Heafield, 2011).
For the 5-gram languagemodels, we replaced every word in the lm trainingdata with <unk> that did not appear in the Englishpart of the parallel training data to build an open vo-cabulary language model.HIMIDLOWFigure 3: Multipartite pairwise ranking.Training data for discriminative learning are pre-pared by comparing a 100-best list of transla-tions against a single reference using smoothed per-sentence BLEU (Liang et al, 2006a).
From theBLEU-reordered n-best list, translations were putinto sets for the top 10% level (HI), the middle80% level (MID), and the bottom 10% level (LOW).These level sets are used for multipartite ranking15News Commentary(nc)train-nc lm-train-nc dev-nc devtest-nc test-ncSentences 132,753 180,657 1057 1064 2007Tokens de 3,530,907 ?
27,782 28,415 53,989Tokens en 3,293,363 4,394,428 26,098 26,219 50,443Rule Count 14,350,552 (1G) ?
2,322,912 2,320,264 3,274,771Europarl(ep)train-ep lm-train-ep dev-ep devtest-ep test-epSentences 1,655,238 2,015,440 2000 2000 2000Tokens de 45,293,925 ?
57,723 56,783 59,297Tokens en 45,374,649 54,728,786 58,825 58,100 60,240Rule Count 203,552,525 (31.5G) ?
17,738,763 17,682,176 18,273,078News Crawl(crawl)dev-crawl test-crawl10 test-crawl11Sentences 2051 2489 3003Tokens de 49,848 64,301 76,193Tokens en 49,767 61,925 74,753Rule Count 9,404,339 11,307,304 12,561,636Table 1: Overview of data used for train/dev/test.
News Commentary (nc) and Europarl (ep) training data andalso News Crawl (crawl) dev/test data were taken from the WMT11 translation task (http://statmt.org/wmt11/translation-task.html).
The dev/test data of nc are the sets provided with the WMT07 sharedtask (http://statmt.org/wmt07/shared-task.html).
Ep dev/test data is from WMT08 shared task(http://statmt.org/wmt08/shared-task.html).
The numbers in brackets for the rule counts of ep/nctraining data are total counts of rules in the per-sentence grammars.where translation pairs are built between the ele-ments in HI-MID, HI-LOW, and MID-LOW, but notbetween translations inside sets on the same level.This idea is depicted graphically in Figure 3.
Theintuition is to ensure that good translations are pre-ferred over bad translations without teasing apartsmall differences.For evaluation, we used the mteval-v11b.plscript to compute lowercased BLEU-4 scores (Pa-pineni et al, 2001).
Statistical significance wasmeasured using an Approximate Randomization test(Noreen, 1989; Riezler and Maxwell, 2005).All experiments for training on dev sets were car-ried out on a single computer.
For grammar extrac-tion and training of the full data set we used a 30node hadoop Map/Reduce cluster that can handle300 jobs at once.
We split the data into 2290 shardsfor the ep runs and 141 shards for the nc runs, eachshard holding about 1,000 sentences, which corre-sponds to the dev set size of the nc data set.5.2 Experimental ResultsThe baseline learner in our experiments is a pairwiseranking perceptron that is used on various featuresand training data and plugged into various meta-Mx?BLEU[%] 23.0 25.0 27.0 29.0Figure 4: Boxplot of BLEU-4 results for 100 runs ofMIRA on news commentary data, depicting median (M),mean (x?
), interquartile range (box), standard deviation(whiskers), outliers (end points).algorithms for distributed processing.
The percep-tron algorithm itself compares favorably to relatedlearning techniques such as the MIRA adaptation ofChiang et al (2008).
Figure 4 gives a boxplot depict-ing BLEU-4 results for 100 runs of the MIRA imple-mentation of the cdec package, tuned on dev-nc,and evaluated on the respective test set test-nc.6 Wesee a high variance (whiskers denote standard devi-ations) around a median of 27.2 BLEU and a meanof 27.1 BLEU.
The fluctuation of results is due tosampling training examples from the translation hy-6MIRA was used with default meta parameters: 250 hypoth-esis list to search for oracles, regularization strength C = 0.01and using 15 passes over the input.
It optimized IBM BLEU-4.The initial weight vector was 0.16Algorithm Tuning set Features #Features devtest-nc test-ncMIRA dev-nc default 12 ?
27.101dev-nc default 12 25.88 28.0dev-nc +id 137k 25.53 27.6?23dev-nc +ng 29k 25.82 27.42?234dev-nc +shape 51 25.91 28.1dev-nc +id,ng,shape 180k 25.71 28.15342train-nc default 12 25.73 27.86train-nc +id 4.1M 25.13 27.19?134train-nc +ng 354k 26.09 28.03134train-nc +shape 51 26.07 27.913train-nc +id,ng,shape 4.7M 26.08 27.86343train-nc default 12 26.09 @2 27.94?train-nc +id 3.4M 26.1 @4 27.97?12train-nc +ng 330k 26.33 @4 28.3412train-nc +shape 51 26.39 @9 28.312train-nc +id,ng,shape 4.7M 26.42 @9 28.551244train-nc +id 100k 25.91 @7 27.82?2train-nc +ng 100k 26.42 @4 28.37?12train-nc +id,ng,shape 100k 26.8 @8 28.81123Table 2: BLEU-4 results for algorithms 1 (SGD), 2 (MixSGD), 3 (IterMixSDG), and 4 (IterSelSGD) on news-commentary (nc) data.
Feature groups are 12 dense features (default), rule identifiers (id), rule n-gram (ng), andrule shape (shape).
Statistical significance at p-level < 0.05 of a result difference on the test set to a different algo-rithm applied to the same feature group is indicated by raised algorithm number.
?
indicates statistically significantdifferences to best result across features groups for same algorithm, indicated in bold face.
@ indicates the optimalnumber of epochs chosen on the devtest set.pergraph as is done in the cdec implementation ofMIRA.
We found similar fluctuations for the cdecimplementations of PRO (Hopkins and May, 2011)or hypergraph-MERT (Kumar et al, 2009) both ofwhich depend on hypergraph sampling.
In contrast,the perceptron is deterministic when started from azero-vector of weights and achieves favorable 28.0BLEU on the news-commentary test set.
Since weare interested in relative improvements over a stablebaseline, we restrict our attention in all following ex-periments to the perceptron.7Table 2 shows the results of the experimentalcomparison of the 4 algorithms of Section 4.
The7Absolute improvements would be possible, e.g., by usinglarger language models or by adding news data to the ep train-ing set when evaluating on crawl test sets (see, e.g., Dyer et al(2011)), however, this is not the focus of this paper.default features include 12 dense models defined onSCFG rules;8 The sparse features are the 3 templatesdescribed in Section 3.
All feature weights weretuned together using algorithms 1-4.
If not indicatedotherwise, the perceptron was run for 10 epochs withlearning rate ?
= 0.0001, started at zero weight vec-tor, using deduplicated 100-best lists.The results on the news-commentary (nc) datashow that training on the development set does notbenefit from adding large feature sets ?
BLEU re-sult differences between tuning 12 default features8negative log relative frequency p(e|f); log count(f ); logcount(e, f ); lexical translation probability p(f |e) and p(e|f)(Koehn et al, 2003); indicator variable on singleton phrase e;indicator variable on singleton phrase pair f, e; word penalty;language model weight; OOV count of language model; num-ber of untranslated words; Hiero glue rules (Chiang, 2007).17Alg.
Tuning set Features #Feats devtest-ep test-ep Tuning set test-crawl10 test-crawl111dev-ep default 12 25.62 26.42?
dev-crawl 15.39?
14.43?dev-ep +id,ng,shape 300k 27.84 28.37 dev-crawl 17.84 16.8344 train-ep +id,ng,shape 100k 28.0 @9 28.62 train-ep 19.121 17.331Table 3: BLEU-4 results for algorithms 1 (SGD) and 4 (IterSelSGD) on Europarl (ep) and news crawl (crawl) testdata.
Feature groups are 12 dense features (default), rule identifiers (id), rule n-gram (ng), and rule shape (shape).Statistical significance at p-level < 0.05 of a result difference on the test set to a different algorithm applied to thesame feature group is indicated by raised algorithm number.
?
indicates statistically significant differences to bestresult across features groups for same algorithm, indicated in bold face.
@ indicates the optimal number of epochschosen on the devtest set.and tuning the full set of 180,000 features are notsignificant.
However, scaling all features to the fulltraining set shows significant improvements for al-gorithm 3, and especially for algorithm 4, whichgains 0.8 BLEU points over tuning 12 features onthe development set.
The number of features risesto 4.7 million without feature selection, which iter-atively selects 100,000 features with best `2 normvalues across shards.
Feature templates such as rulen-grams and rule shapes only work if iterative mix-ing (algorithm 3) or feature selection (algorithm 4)are used.
Adding rule id features works in combina-tion with other sparse features.Table 3 shows results for algorithms 1 and 4 onthe Europarl data (ep) for different devtest and testsets.
Europarl data were used in all runs for train-ing and for setting the meta-parameter of numberof epochs.
Testing was done on the Europarl testset and news crawl test data from the years 2010and 2011.
Here tuning large feature sets on therespective dev sets yields significant improvementsof around 2 BLEU points over tuning the 12 de-fault features on the dev sets.
Another 0.5 BLEUpoints (test-crawl11) or even 1.3 BLEU points (test-crawl10) are gained when scaling to the full trainingset using iterative features selection.
Result differ-ences on the Europarl test set were not significantfor moving from dev to full train set.
Algorithms 2and 3 were infeasible to run on Europarl data beyondone epoch because features vectors grew too large tobe kept in memory.6 DiscussionWe presented an approach to scaling discrimina-tive learning for SMT not only to large featuresets but also to large sets of parallel training data.Since inference for SMT (unlike many other learn-ing problems) is very expensive, especially on largetraining sets, good parallelization is key.
Our ap-proach is made feasible and effective by applyingjoint feature selection across distributed stochasticlearning processes.
Furthermore, our local featuresare efficiently computable at runtime.
Our algo-rithms and features are generic and can easily be re-implemented and make our results relevant acrossdatasets and language pairs.In future work, we would like to investigate moresophisticated features, better learners, and in gen-eral improve the components of our system that havebeen neglected in the current investigation of rela-tive improvements by scaling the size of data andfeature sets.
Ultimately, since our algorithms are in-spired by multi-task learning, we would like to applythem to scenarios where a natural definition of tasksis given.
For example, patent data can be charac-terized along the dimensions of patent classes andpatent text fields (Wa?schle and Riezler, 2012) andthus are well suited for multi-task translation.AcknowledgmentsStefan Riezler and Patrick Simianer were supportedin part by DFG grant ?Cross-language Learning-to-Rank for Patent Retrieval?.
Chris Dyer was sup-ported in part by a MURI grant ?The linguistic-core approach to structured translation and analysisof low-resource languages?
from the US Army Re-search Office and a grant ?Unsupervised Inductionof Multi-Nonterminal Grammars for SMT?
fromGoogle, Inc.18ReferencesPhil Blunsom, Trevor Cohn, and Miles Osborne.
2008.A discriminative latent variable models for statisticalmachine translation.
In Proceedings of the 46th An-nual Meeting of the Association for ComputationalLinguistics: Human Language Technologies (ACL-HLT?08), Columbus, OH.Le?on Bottou.
2004.
Stochastic learning.
In OlivierBousquet, Ulrike von Luxburg, and Gunnar Ra?tsch,editors, Advanced Lectures on Machine Learning,pages 146?168.
Springer, Berlin.Olivier Chapelle and S. Sathiya Keerthi.
2010.
Efficientalgorithms for ranking with SVMs.
Information Re-trieval Journal.David Chiang, Yuval Marton, and Philip Resnik.
2008.Online large-margin training of syntactic and struc-tural translation features.
In Proceedings of the 2008Conference on Empirical Methods in Natural Lan-guage Processing (EMNLP?08), Waikiki, Honolulu,Hawaii.David Chiang, Kevin Knight, and Wei Wang.
2009.11,001 new features for statistical machine transla-tion.
In Proceedings of the 2009 Annual Confer-ence of the North American Chapter of the Associa-tion for Computational Linguistics (NAACL-HLT?09),Boulder, CO.David Chiang.
2005.
A hierarchical phrase-based modelfor statistical machine translation.
In Proceedings ofthe 43rd Annual Meeting of the Association for Com-putational Linguistics (ACL?05), Ann Arbor, MI.David Chiang.
2007.
Hierarchical phrase-based transla-tion.
Computational Linguistics, 33(2).Michael Collins.
2002.
Discriminative training methodsfor hidden markov models: theory and experimentswith perceptron algorithms.
In Proceedings of the con-ference on Empirical Methods in Natural LanguageProcessing (EMNLP?02), Philadelphia, PA.Ronan Collobert and Samy Bengio.
2004.
Links be-tween perceptrons, MLPs, and SVMs.
In Proceed-ings of the 21st International Conference on MachineLearning (ICML?04), Banff, Canada.Jeffrey Dean and Sanjay Ghemawat.
2004.
Mapre-duce: Simplified data processing on large clusters.
InProceedings of the 6th Symposium on Operating Sys-tem Design and Implementation (OSDI?04), San Fran-cisco, CA.Kevin Duh and Katrin Kirchhoff.
2008.
Beyond log-linear models: Boosted minimum error rate trainingfor n-best ranking.
In Proceedings of the 46th AnnualMeeting of the Association for Computational Linguis-tics (ACL?08), Short Paper Track, Columbus, OH.Kevin Duh, Katsuhito Sudoh, Hajime Tsukada, HidekiIsozaki, and Masaaki Nagata.
2010.
N-best rerankingby multitask learning.
In Proceedings of the 5th JointWorkshop on Statistical Machine Translation and Met-ricsMATR, Uppsala, Sweden.Chris Dyer, Adam Lopez, Juri Ganitkevitch, JonathanWeese, Ferhan Ture, Phil Blunsom, Hendra Setiawan,Vladimir Eidelman, and Philip Resnik.
2010. cdec: Adecoder, alignment, and learning framework for finite-state and context-free translation models.
In Proceed-ings of the ACL 2010 System Demonstrations, Upp-sala, Sweden.Chris Dyer, Kevin Gimpel, Jonathan H. Clark, andNoah A. Smith.
2011.
The CMU-ARK german-english translation system.
In Proceedings of the 6thWorkshop on Machine Translation (WMT11), Edin-burgh, UK.Chris Dyer.
2009.
Using a maximum entropy model tobuild segmentation lattices for MT.
In Proceedingsof the Conference of the North American Chapter ofthe Association for Computational Linguistics - Hu-man Language Technologies (NAACL-HLT?09), Boul-der, CO.Yoav Freund and Robert E. Schapire.
1999.
Largemargin classification using the perceptron algorithm.Journal of Machine Learning Research, 37:277?296.Kevin Gimpel and Noah A. Smith.
2012.
Structuredramp loss minimization for machine translation.
InProceedings of 2012 Conference of the North Amer-ican Chapter of the Association for ComputationalLinguistics: Human Language Technologies (NAACL-HLT 2012), Montreal, Canada.Katsuhiko Hayashi, Taro Watanabe, Hajime Tsukada,and Hideki Isozaki.
2009.
Structural support vectormachines for log-linear approach in statistical machinetranslation.
In Proceedings of IWSLT, Tokyo, Japan.Kenneth Heafield.
2011.
KenLM: faster and smaller lan-guage model queries.
In Proceedings of the EMNLP2011 Sixth Workshop on Statistical Machine Transla-tion (WMT?11), Edinburgh, UK.Mark Hopkins and Jonathan May.
2011.
Tuning asranking.
In Proceedings of 2011 Conference onEmpirical Methods in Natural Language Processing(EMNLP?11), Edinburgh, Scotland.Philipp Koehn, Franz Josef Och, and Daniel Marcu.2003.
Statistical phrase-based translation.
In Proceed-ings of the Human Language Technology Conferenceand the 3rd Meeting of the North American Chapter ofthe Association for Computational Linguistics (HLT-NAACL?03), Edmonton, Cananda.Shankar Kumar, Wolfgang Macherey, Chris Dyer, andFranz Och.
2009.
Efficient minimum error rate train-ing and minimum Bayes-risk decoding for translationhypergraphs and lattices.
In Proceedings of the 47thAnnual Meeting of the Association for Computational19Linguistics and the 4th IJCNLP of the AFNLP (ACL-IJCNLP?09, Suntec, Singapore.Thomas Navin Lal, Olivier Chapelle, Jason Weston, andAndre?
Elisseeff.
2006.
Embedded methods.
In I.M.Guyon, S.R.
Gunn, M. Nikravesh, and L. Zadeh, ed-itors, Feature Extraction: Foundations and Applica-tions.
Springer.Percy Liang, Alexandre Bouchard-Co?te?, Dan Klein, andBen Taskar.
2006a.
An end-to-end discriminativeapproach to machine translation.
In Proceedings ofthe joint conference of the International Committeeon Computational Linguistics and the Association forComputational Linguistics (COLING-ACL?06), Syd-ney, Australia.Percy Liang, Ben Taskar, and Dan Klein.
2006b.
Align-ment by agreement.
In Proceedings of the HumanLanguage Technology Conference - North AmericanChapter of the Association for Computational Linguis-tics annual meeting (HLT-NAACL?06), New York, NY.Adam Lopez.
2007.
Hierarchical phrase-based transla-tion with suffix arrays.
In Proceedings of EMNLP-CoNLL, Prague, Czech Republic.David McAllester and Joseph Keshet.
2011.
Generaliza-tion bounds and consistency for latent structural pro-bit and ramp loss.
In Proceedings of the 25th AnnualConference on Neural Information Processing Sytems(NIPS 2011), Granada, Spain.Ryan McDonald, Keith Hall, and Gideon Mann.
2010.Distributed training strategies for the structured per-ceptron.
In Proceedings of Human Language Tech-nologies: The 11th Annual Conference of the NorthAmerican Chapter of the Association for Compu-tational Linguistics (NAACL-HLT?10), Los Angeles,CA.Eric W. Noreen.
1989.
Computer Intensive Methodsfor Testing Hypotheses.
An Introduction.
Wiley, NewYork.Guillaume Obozinski, Ben Taskar, and Michael I. Jordan.2010.
Joint covariate selection and joint subspace se-lection for multiple classification problems.
Statisticsand Computing, 20:231?252.Franz Josef Och and Hermann Ney.
2000.
Improved sta-tistical alignment models.
In Proceedings of the 38thAnnual Meeting of the Association for ComputationalLinguistics (ACL?00), Hongkong, China.Franz Josef Och and Hermann Ney.
2002.
Discrimina-tive training and maximum entropy models for statis-tical machine translation.
In Proceedings of the 40thAnnual Meeting of the Association for ComputationalLinguistics (ACL?02), Philadelphia, PA.Franz Josef Och.
2003.
Minimum error rate train-ing in statistical machine translation.
In Proceedingsof the Human Language Technology Conference andthe 3rd Meeting of the North American Chapter ofthe Association for Computational Linguistics (HLT-NAACL?03), Edmonton, Cananda.Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu.
2001.
Bleu: a method for automaticevaluation of machine translation.
Technical ReportIBM Research Division Technical Report, RC22176(W0190-022), Yorktown Heights, N.Y.Simon Perkins, Kevin Lacker, and James Theiler.
2003.Grafting: Fast, incremental feature selection by gra-dient descent in function space.
Journal of MachineLearning Research, 3:1333?1356.Stefan Riezler and John Maxwell.
2005.
On some pit-falls in automatic evaluation and significance testingfor MT.
In Proceedings of the ACL-05 Workshop onIntrinsic and Extrinsic Evaluation Measures for MTand/or Summarization, Ann Arbor, MI.Shai Shalev-Shwartz, Yoram Singer, and Nathan Sre-bro.
2007.
Pegasos: Primal Estimated sub-GrAdientSOlver for SVM.
In Proceedings of the 24th Inter-national Conference on Machine Learning (ICML?07),Corvallis, OR.Libin Shen and Aravind K. Joshi.
2005.
Ranking andreranking with perceptron.
Journal of Machine Learn-ing Research, 60(1-3):73?96.Libin Shen, Anoop Sarkar, and Franz Josef Och.
2004.Discriminative reranking for machine translation.
InProceedings of the Human Language Technology con-ference / North American chapter of the Associa-tion for Computational Linguistics annual meeting(HLT/NAACL?04), Boston, MA.Andreas Stolcke.
2002.
SRILM - an extensible languagemodeling toolkit.
In Proceedings of the InternationalConference on Spoken Language Processing, Denver,CO.Christoph Tillmann and Tong Zhang.
2006.
A dis-criminatie global training algorithm for statistical MT.In Proceedings of the joint conference of the In-ternational Committee on Computational Linguisticsand the Association for Computational Linguistics(COLING-ACL?06), Sydney, Australia.Katharina Wa?schle and Stefan Riezler.
2012.
Structuraland topical dimensions in multi-task patent translation.In Proceedings of the 13th Conference of the EuropeanChapter of the Association for Computational Linguis-tics, Avignon, France.Taro Watanabe, Jun Suzuki, Hajime Tsukada, and HidekiIsozaki.
2006.
NTT statistical machine translationfor IWSLT 2006.
In Proceedings of the InternationalWorkshop on Spoken Language Translation (IWSLT),Kyoto, Japan.Taro Watanabe, Jun Suzuki, Hajime Tsukada, and HidekiIsozaki.
2007.
Online large-margin training for statis-tical machine translation.
In Proceedings of the 200720Joint Conference on Empirical Mehtods in NaturalLanguage Processing and Computational LanguageLearning (EMNLP?07), Prague, Czech Republic.Benjamin Wellington, Joseph Turian, and Dan Melamed.2009.
Toward purely discriminative training for tree-structured translation models.
In Cyril Goutte, NicolaCancedda, and Marc Dymetman, editors, LearningMachine Translation, pages 132?149, Cambridge,MA.
The MIT Press.Martin A. Zinkevich, Markus Weimer, Alex Smola, andLihong Li.
2010.
Parallelized stochastic gradient de-scent.
In Proceedings of the 24th Annual Conferenceon Neural Information Processing Sytems (NIPS?10),Vancouver, Canada.Andreas Zollmann and Khalil Sima?an.
2005.
A consis-tent and efficient estimator for data-oriented parsing.Journal of Automata, Languages and Combinatorics,10(2/3):367?388.21
