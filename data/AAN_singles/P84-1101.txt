ROBUST PROCESSING IN MACHINE TRANSLATIONDoug Arnold, Rod Johnson,Centre for Cognitive Studies,University of Essex,Colchester, CO4 3SQ, U.K.Centre for Computational LinguisticsUMIST, Manchester,M60 8QD, U.K.ABSTRACTIn this paper  we prov ide  an abst rac tcharacter i sa t ion  of d i f ferent kinds of robustprocess ing in Mach ine Trans lat ion  and NaturalLanguage Processing systems in terms of the kindsof problem they are supposed to solve.
We focuson one problem which is typically exacerbated byrobust processing, and for which we know of noexist ing solutions.
We discuss two possibleapproaches to this, emphas is ing  the need tocorrect or repair processing malfunctions.ROBUST PROCESSING IN MACHINE TRANSLATIONThis paper is an at tempt  to provide partof the basis for a general theory of robustprocess ing in Machine Trans lat ion  (MT) wi threlevance to other areas of Natural  LanguageProcess ing (NLP).
That is, process ing which isresistant to ma l funct ion ing  however  caused.
Thebackground to the paper is work on a generalpurpose fully automatic mul t i - l lngua l  MT systemwi th in  a highly decentra l i sed organ isat iona lframework (specifically, the Eurotra system underdeve lopment  by the EEC).
This inf luences us in anumber of ways.Decentra l i sed development,  and the factthat the system is to be general purpose motivatethe fo rmulat ion  of a senera l  theory ,  wh ichabstracts away from matters of purely localrelevance, and does not e.g.
depend on explo i t ingspecial properties of a part icular  subject f ield(compare \[7\], e.g.
).The fact that we consider  robustness atall can be seen as a result of the d i f f icu l ty  ofMT, and the aim of full automation is reflected inour concentrat ion  on a theory of robust process-ins, rather than "developmental  robustness'.
Wewil l  not be concerned here with problems thatarise in des igning systems so that they arecapable of extension and repair (e.g.
not beingprone  to un forseen  "r ipp le  e f fec ts"  undermodif icat ion).
Deve lopmenta l  robustness  isclearly essential, and such problems are serious,but no system which relies on this kind of robust-ness can ever be fully automatic.
For the samereason,  we w i l l  not cons ider  the use of"interactive" approaches to robustness such asthat of \[I0\].F inal ly,  the fact that we are concernedwith t rans lat ion mi l i ta tes  against the kind ofdisregard for input that is characteristic of somerobust systems (PARRY \[4\] is an extreme example),and mot ivates  a concern  w i th  the repa i r  orcorrect ion of errors.
It is not enough that at rans la t ion  sys tem produces  super f i c ia l l yacceptable output for a wide class of inputs, itshould aim to produce outputs which represent asnearly as possible translations of the inputs.
Ifit cannot do this, then in some cases it wi l l  bebetter if it indicates as much, so that otheraction can be taken.From the point of view we adopt, it ispossible to regard MT and NLP systems generally assets of processes implementing relations betweenrepresentat ions  ( texts  can be cons ideredrepresentat ions  of themselves).
It is importantto distinguish:(i) R: the correct, or intended relation thatholds between representat ions  (e.g.
the re lat ion"is a (cor rec t )  t rans la t ion  of', or "is t~esurface const i tuent  structure of'): we have onlyfair ly vague, pre- theoret ica l  ideas about Rs, invirtue of being bi - l ingual  speakers, or havingsome in tu i t i ve  grasp  of the semant ics  ofartificial representations;(ii) T: a theoret ica l  construct  which issupposed to embody R;( i i i )  P: a p rocess  or p rogram that issupposed to implementBy a robust process P, we mean one whichoperates error free for all inputs.
Clearly, thenotion of error or correctness of P depends on theindependent standard provided by T and R. If, forthe sake of simplicity we ignore the possibilityof ambiguous  inputs  here,  we can de f inecorrectness thus:(1) Given P(x)=y, and a set W such that ~orall w in W, R(w)=y, then y is correct with respectto R and w iff x is a member of W.Intuitively, W is the set of items for whichy is the correct representat ion  accord ing to R.One possible source of errors in P would be if Pcorrect ly  imp lemented  T, but T did not embody R.Clearly, in this case, the only sensible solutionis to modify T. Since we can imagine no automaticway of finding such errors and doing this, we will472ignore this possibi l i ty,  end assume that T is awe11-defined, correct and complete embodiment ofR.
We can thus replace R by T in (I), and treat Tas the standard of correctness below.There appear to be two possible sources oferror in P:Problem (1):  where P is not a correctimp lementat ion  of T. One would expect this to becommon where (as often in MT and NLP) T is verycomplex, and serious problems arise in devis ingimplementations for them.P rob lem (i i):  where  P is a cor rec timp lementat ion  so far as it goes, but is incom-plete, so that the domain of P is a proper-subsetof the domain of T. This will also be very common:in reality processes are often faced with inputsthat violate the expectat ions impl ic i t  in animplementation.If we disregard hardware errors, low levelbugs and such malfunctions as non-termlnatlon ofP (for which there are we l l -known solutions),there are three poss ib le  man i fes ta t ions  ofmalfunction.
We will discuss them in tur~case (a): P(x)=@, where T(x)~@i.e.
P halts producing ~ output for input x, wherethis is not the intended output.
This would be atypical response to unforseen or illformed input,and is the case of process fragility that is mosto f ten  dea l t  with.There are two obvious solutions: (1) tomanipu late  the input so that it conforms to theexpectat ions impl ic i t  in P (cf.
the LIFER \[8\]approach to ell ipsis), or to change P Itself,modi fy ing (general ly relaxing) its expectat ions(cf.
e.g.
the approaches of \[7\], \[9\], \[10\] and\[Ii\]).
If successful,  these guarantee that Pproduces some output for input x.
However, thereis of course no guarantee that it is correct withrespect to T. It may be that P plus the inputmanipulation process, or P with relaxed expectat-ions is simply a more correct or complete implem-entat ion of T, but this wil l  be fortuitous.
It ismore llkely that making P robust in these wayswill lead to errors of another kind:case (b): P(x)=z where z is not a legaloutput for P according to T (i.e.
z is not in therange of T.Typically, such an error will show itself bymalfunctioning in a process that P feeds.
Detec-tion of such errors is s t ra ight forward:  a wel l -formedness check on the output of P is sufficient.By i tse l f ,  of course ,  this w i l l  lead to apro l i ferat ion of case-(a) errors in P. These canbe avoided by a number of methods, in particular:(1) introducing some process to manipu late  theoutput of P to make it well-formed according to T,or (ii) a t tempt ing to set up processes that feedon P so that they can use 'abnormal" or "non-standard" output from P (e.g.
partial representat-ions, or complete in termediate  representat ionsproduced within P, or alternative representationsconstructed wi th in  P which can be more rel iablycomputed than the "normal" intended output of P(the representational theories of GETA and Eurotraare designed with this in mind: cf.
\[2\], \[3\], \[5\],\[6\], and references there, and see \[i\] for fullerd i scuss ion  of these issues) .
Aga in ,  it isconceivable that the result of this may be toproduce a robust P that implements T more correct-ly or completely, but again this will be fortuit-ous.
The most likely result will he robust P willnow produce errors of the third type:case (c): P(x)=y, where y is a legal outputfor P according to T, but is not the intendedoutput according to T. i.e.
y is in the range ofT, but yqT(x).Suppose both input x and output y of someprocess are legal objects, it nevertheless doesnot follow that they have been correctly paired bythe process: e.g.in the case of a parsing process,x may be some sentence and y some representatiomObviously, the fact that x and y are legal objectsfor the parsing process and that y is the outputof the parser for input x does not guarantee thaty is a correct representat ion of x.
Of course,robust processing should be resistant to this kindof malfunctloning also.Case-(c) errors are by far the most seriousand resistant to solut ion because they are thehardest to detect, and because in many cases nooutput  is p re ferab le  to super f l c la l l y(mis leadingly)  we l l - fo rmed but incorrect output.Notice also that while any process may be subjectto this kind of error, making a system robust inresponse to case-(a) and case-(b) errors will makethis class of errors more widespread:  we havesuggested that the likely result of changing P tomake it robust wil l  be that it no longer pairsrespresentatlons in the manner required by T, butsince any process that takes the output of Pshould be set up so as to expect inputs thatconform to T ( s ince  this is the "correct"embod iment  of R, we have assumed), we can expectthat in general making a process robust will leadto cascades of errors.
If we assume that a systemis resistant to case-(a) and case-(b) errors, thenit follows that inputs for which the system has toresort to robust processing will be likely to leadto case-(c) errors.Moreover, we can expect that making P robustwill have made case-(c) errors more difficult todeal with.
The l ikely result of mak ing P robustis that it no longer imp lements  T, but some T"which is dist inct from T, and for which assump-tlons about correctness in relatlon to R no longerhold.
It is obvious that the poss ib i l i ty  ofdetect ing  case- (c )  e r ro rs  depends  on theposs ib i l i ty  of d i s t ingu ish ing  T f rom T'.Theoretically, this is unproblematlc.
However, ina domain such as MT it will be rather unusual forT and T" to exist separate ly  from the processesthat implement them.
Thus, if we are to have anychance of detect ing case-(c) errors, we must beable to c lear ly d is t inguish those aspects of aprocess that relate to "normal' process ing from473those that relate to robust processing.
Thisdistinction is not one that is made in most robustsystems,We know of no existing solutions to case-(c)mal funct ions.
Here we wil l  out l ine two poss ib leapproaches.To begin wi th we might consider  a part ialsolut ion der ived from a we l l -known technique insystems theory: insur ing against the effect offaulty components in crucial parts of a system bycomputing the result for a given input by a numberof different routes.
For our purposes, the methodwould consist essentially in implementing the sametheory  T as a number  of d i s t inc t  p rocessesP1,...Pn, etc.
to be run in parallel,  compar ingoutputs  and us ing  s ta t i s t i ca l  c r i te r ia  todetermine the correctness of processing.
We willcall this the "statistical solution'.
(Notice thatcerta in kinds of system arch i tecture  make thisquite feasible, even given real time constraints).Clearly, whi le  this should s ign i f i cant lyimprove the chances that output will be correct,it can provide no guarantee.
Moreover,  the kindof s i tuat ion we are cons ider ing is more complexthan that ar is ing given fai lure of re lat ivelysimple pieces of hardware.
In particular, to makethis worthwhi le ,  we must be able to ensure thatthe different Ps are genuinely distinct, and thatthey are reasonab ly  complete  and cor rec timp lementat ions  of T, at the very  leastsuf f ic ient ly  complete  and correct that theiroutputs can be sensibly compared.Unfortunately, this will be very difficult toensure, particularly in a field such as MT, whereTs are genera l ly  very complex,  and (as we havenoted) are often not stated separate ly  from theprocesses that implement them.The stat ist ica l  approach is at t ract ivebecause it seems to provide a simultaneous solut-ion to both the detect ion and repair of case-(c)e r ro rs ,  and we cons ider  such so lu t ions  arecertain ly worth further considerat ion.
However,realistically, we expect the normal situation tobe that it is d i f f icult  to produce reasonablycorrect and compelete distinct implementations, sothat we are forced to look for an a l ternat iveapproach to the detection of case-(c) errors.It is obvious that reliable detection of (e)-type errors requires ~he imp lementat ion  of arelation that pairs representations in exactly thesame way as T: the obvious candidate is a processp-l, implementing T -I, the inverse of T.The basic method here would be to compute anenumerat ion  of the set of all possible inputs Wthat could have y ie lded the actual output, g ivenT, and some hypothetical ideal P which correctlyimp lements  it.
(Again, this is not unreal ist ic ;certain system architectures would allow forwardcomputat ion  to procede  wh i le  this inverseprocessing is carried out).To make this wor thwh i le  would involve twoassumptions:(1) That p-I te rminates  in reasonable  time.This cannot be guaranteed, but the assumption canbe rendered  more  reasonab le  by observ ingcharacteristics of the input, and thus restrictingW (e.g.
restricting the members of W in relationto the length of the input to p-I).
(ii) That construction of p-1 is somehow morestraightforward than construction of P, so thatp-i is l ikely to be more re l iable (correct andcomplete) than P. In fact this is not implausiblefor some appl icat ions  (e.g.
consider  the casewhere P is a parser: it is a widely held idea thatgenerators are easier to build than parsers).Granted these assumptions, detection of case-(c) errors is straightforward given this "inversemapp ing"  approach:  one s imp ly  examines  theenumeration for the actual input if it  is present.If it is present, then given that p-i is likely tobe more re l iab le  than P, then it is l ikely thatthe output of P was T-correct,  and hence did notconst i tu te  a ease- (c )  error .
At least ,  thechances of the output of P being correct have beenincreased.
If the input is not present, then itis l ikely that P has produced a case-(c) error.The response to this will depend on the domain andapp l icat ion  -- e.g.
on whether  incorrect butsuperficially well-formed output is preferable tono output at all.In the nature of things, we wil l  u l t imate lybe lead to the original  problems of robustness,but now in connect ion  with p-l. For this reasonwe cannot forsee any complete solution to problemsof robustness general ly.
What we have seen isthat solut ions to one sort of f ragi l i ty  arenormally only partly successful, leading to errorsof another kind elsewhere.
Clearly, what we haveto hope is that each attempt to eliminate a sourceof error nevertheless  leads to a net decrease inthe overall number of errors.On the one hand, this hope is reasonable,since somet imes  the faults that give rise toprocess ing errors are actual ly  fixed.
But therecan be no general  guarantee of this, so that itseems c lear  that  mere ly  mak ing  sys tems orprocesses robust in the ways descr ibed provideson ly  a par t ia l  so lu t ion  to the prob lem ofprocessing errors.This should not be surprising.
Because ourprimary, concern is with automatic error detectionand repair, we have assumed throughout that Tcou ld  be cons idered  a cor rec t  and completeembodiment of ~ Of course, this is unrealistic,and in fact it is p robab le  that for manyprocesses, at least as many processing errors willarise from the inadequacy of T with respect to Ras arise from the inadequacy of P with respect toT.
Our pre- theoret ica l  and intuit ive abi l i ty  torelate representations far exceeds our ability toformulate clear theoretical statements about theserelations.
Given this, it would seem that errorfree process ing depends at least as much on thecorrectness of theoretical models as the capacity474of a system to take advantage of the techniquesdescribed above.We shou ld  emphas ise  th is  because  itsomet imes  appears  as though techn iques  forensur ing process robustness might  have a widerimportance.
We assumed above that T was to beregarded as a correct embod iment  of R. Supposethis assumpt ion  is relaxed, and in addi t ion that(as we have argued is l ikely to be the case) therobust version of P implements a relation T" whichis d ist inct  f rom T. Now, it could, in pr inciple,turn out that T' is a better embod iment  of R thanT.
It is worth  saying that this poss ib l i l i ty  isremote, because it is a possibility that seems tobe taken ser iously elsewhere: a lmost  all thestrategies we have mentioned as enhancing processrobustness were originally proposed as theoreticaldevices to increase the adequacy of Ts in relationto Rs (e.g.
by prov id ing  an account  ofmetaphorical or other "problematic" usage).
Therecan be no question that apart from improvements ofT, such theoretical developments can have the sideeffect of increasing robustness.
But notice thatthe i r  jus t i f i ca t ion  is then not to do w i throbustness,  but wi th  theoretical adequacy.
Whatmust be emphas ised is that the chances that amod i f i ca t ion  of a process to enhance robustness(and improve rel iabi l i ty)  wi l l  also have theeffect of improving the quality of its performanceare ext remely  slim.
We cannot expect robustprocessing to produce results which are as good asthose that would result from 'ideal" (optimal/non-robust) processing.
In fact, we have suggestedthat exist ing techniques for ensur ing processrobustness typical ly  have the effect of changingthe theory the process implements ,  changing there l i t ionship  between representat ions that thesystem defines in ways which do not preserve therelationship relationship between representationsthat the designers intended, so that processesthat have been made robust by existing methods canbe expected to produce output of lower thanintended quality.These remarks are intended to emphas isethe importance of clear, complete,  and correcttheoret i ca l  mode ls  of the pre - theoret l ca lrelationships between the representations involvedin systems for which error free 'robust' operationimpor tant ,  and to emphas ise  the need forapproaches to robustness (such as the two we haveout l ined above) that make it more l ikely thatrobust processes wi l l  ma inta in  the re lat ionsh ipbetween representations that the designers of the"normal /opt lmal"  processes intended.
That is,to emphas lse  the need to detect  and repa i rmalfunctions, so as to promote correct processing.of the ideas in this paper were first aired inEurot ra  repor t  ETL -3  (\[4\]), and in a paperpresented at the Cranf ie ld conference on MTearlier this year.
We would like to thank all ourfr iends and col leagues in the project and ourinstitutions.
The views (and, in particular, theerrors) in this paper are our own responsibility,and shou ld  not be in terpreted  as "o f f i c ia l 'Eurotra doctrine.REFE RENCE Si.
ARNOLD, D.J.
& JOHNSON, R. (1984) "Approachesto Robust Process ing in Machine Translat ion"Cognitive Studies Memo, University of Essex.2.
BOITET, CH.
(1984) "Research and Development onMT and Related Techniques at Grenoble University'paper presented at Lugano MT tutorial April 1984.3.
BOITET, CH.
& NEDOBEJKINE,  N. (1980) "Russ ian-F rench  at GETA:  an out l ine  of method and adetailed example" RR 219, GETA, Grenoble.4.
COLBY, K. (1975) Ar t i f i c ia l  Parano ia  PergamonPress, Oxford.5.
ETL- I -NL/B "Transfer  (Taxonomy, Safety Nets,Strategy), Report  by the Belgo-Dutch EurotraGroup, August 1983.6.
ETL -3  F ina l  'Trio' Repor t  by the Eurot raCentral  L inguis t ics  Team (Arnold, Jaspaert,  DesTombe), February 1984.7.
HAYES, P.J .
and MOURADIAN,  G.V.
(1981):"Flexible parsing", AJCL 7, 4:232-242.8.
HENDRIX, G.G.
(1977) "Human Eng ineer ing  forAppl ied Natura l  Language Process ing" Proc.
5thIJCAI, 183-191, MIT Press.9.
KWASNY,  S.C. and SONDHEIMER,  N.K.
(1981):"Relaxat ion Techniques for Parsing GrammaticallyIll-formed Input in Natural Language UnderstandingSystems".
AJCL 7, 2:99-108.I0.
WEISCHEDEL,  R.M, and BLACK,  J.
(1980)'Responding In te l l igent ly  to Unparsab le  Inputs"AJCL 6.2: 97-109.II.
WILKS, Y.
(1975): "A Preferent ia l  Pat ternMatch ing  Semant ics  for Natura l  Language".
A.I.6:53-74.AKNOWLEDGEMENTSOur debt to the Eurotra project is great:collaboration on this paper developed out of workon Eurotra and has only been poss ib le because ofopportunities made available by the project.
Some475
