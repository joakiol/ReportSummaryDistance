Fragment Processing in the DELPHI SystemDavid Stallard, Robert BobrowBBN Systems and Technologies10 Moulton St. Calnbfidge, MA 02138ABSTRACTThis paper presents the fallback understanding component ofBBN's DELPHI NL sysystem.
This component is invoked whenthe core DELPHI system is unable to understand an input.
Itincorporates both syntax- and frame-based fragment combinationsub-components, in an attempt o provide a smoother path fromaccurate but fragile conventional parsers on the one hand to therobust but less accurate schema-based methods on the other.
Theframe-based sub-component is fully integrated with the DELPHI'score grammar and parser, and represents an advance over previousproposals.The complete fallback understanding component, incorporatingboth sub-components, was used in the February 1992 NL and SLSevaluations of the DELPHI system and we report on its contribu-tion to these results, and those of its two separate sub-components.For SLS, use of the frame-based sub-component alone resulted in afigure 39.2% Weighted Error--signifigantly lower than our lowestofficial score of 43.7% Weighted Error.1.
INTRODUCTIONWe describe the fallback understanding component of theDELPHI Natural Language component of BBN's SpokenLanguage System.
This component is invoked when DEL-PHI's regular chart-based unification grammar parser is un-able to parse an input; it attempts to come up with aparse and semantic interpretation, or a semantic interpre-tation alone, based on a fragmentary analysis of  the input.The fallback understanding component consists of three sep-arate stages, which are invoked successively.
First, the Frag-ment Generator produces a sequence of fragmentary sub-parses from the chart state left over from the unsuccess-ful parse.
Next, two different combination modules---theSyntactic Combiner and Frame Combiner - employ alterna-tive and complementary strategies for combining these frag-ments.The Syntactic Combiner uses extended grammar ules thatcan sldp over intervening material to combine constituentsin an attempt o re-construct a plausible parse of the input.This parse can be a clause or some other useful constituentsuch as an imperative VP.
A semantic interpretation for thisreconstructed parse is automatically provided through the305action of the grammar rules.The Frame Combiner is invoked when the Syntactic Com-biner is unsuccessful.
It utilizes a set of pragmatic slot-fillingschemata that embody the goals that ATIS users most com-monly have, such as finding a flight or fare that satisfiessome set of  constraints, or asking about ground transporta-tion between an airport or a city.
As such, it detenninesonly a semantic interpretation and not a parse.The intent of  this multi-step approach to fallback process-ing is to provide a smoother path between the accuracy butfragility of regular parsing on the one hand, and the robust-ness but possible inaccuracy of  schemata-based methods onthe other.The remainder of the paper is taken up with detailed de-scription of each component.
The next section, Section 2,describes the Fragment Generator.
Section 3 describes theSyntactic Combiner and Section 4 the Frame Combiner.
Fi-nally Section 5 gives the February 1992 NL and SLS eval-uation test results for these components, eparate and com-bined, and our conclusions based on these results.2.
THE FRAGMENT GENERATORThe core DELPHI system consists of a unification-basedgrammar, an agenda-driven chart parser, a discourse compo-nent and a question-answering back-end.
DELPHI 's gram-mar roles incorporate semantic onstraint and interpretationcomponents by associating with each element of the fight-hand side a grammatical relation label which keys into anassociated system of semantic rules.
This feature means thatany term which is inserted into the chart is guaranteed to besemantically well-formed and to be annotated with one ormore semantic interpretations.The fragment generator generates a set of  such semanticallyannotated fragments from the chart state left over after anunsuccessful parse.
The algorithm for generating fragmentsfrom the chart extracts the most probable terms associatedwith longest sub-strings of the input, using probabilities as-sociated with the producing rules \[2\].For example, the utterance:I want a flight uhh that arrives in Boston let's say at 3 pm to make the new VP:is conventionally unparseable due to the interpositions "uhh"and "let's say".
The Fragment Generator produces the fol-lowing set of four fragments:S\[I want a flight\]NO-XNTERP \ [uhh\]REL-S\[that arr ives in Boston\]NO-INTERP \[let' s say\]~P \[at 3 pro\]3.
THE SYNTACTIC  COMBINERThe Syntactic Combiner uses a special set of grammar rules,called fragment rules, to combine these fragments into a sin-gle parse.
These rules have the same form as rules of the reg-ular DELPHI gammar  and incorporate semantic onstraintsand interpretation rules in the same way.
But the methodfor applying the fragment rules differs in that it allows themto combine constituents even when these constituents areseparated by intervening portions of the input, or when theyoccur in a reversed order.Each fragment rule is adjunction oriented, in the followingform:X -~ :head X, :other-relat ion CThe following is an example, from which unification featureshave been omitted:VP -~ :head VP, :pp-comp PPThis rule says that an existing Verb Phrase fragment andan existing Prepositional Phrase fragment can be combinedtogether to make a new Verb Phrase with the original VP ashead and the original PP as pp complement, provided theysatisfy the semantic onstraints associated with ":head" and":pp-comp".The central operation of the Syntactic Combiner is adjunc-tion.
The example rule licenses the Syntactic Combiner to"adjoin" one fragment tree into another--that is to replace anode of the first tree with a new node whose head daughteris the old node and whose other daughter is second tree.
Anexample, using the rule above, would be the combination ofthe two fragments:PP \[at 3 pro\]VP\[arr ives in Boston\]306VP\[arr ives in Boston at 3 pm\]Note that the adjunction ode does not have to be the top ofthe first fragment tree: it can be any non-terminal node, asin the following pair of fragments:PP \[at 3 pro\]StNP\[I\]VP \[wantNP \[NP \[a flight\]REL-S \[thatVP \[ arr ive s in Boston\]\]The algorithm that applies these rules first scans right to lefttaking each successive fragment and looking for fragmentsto its left to adjoin the first fragment into.
The search for anattachment point within a fragment is fight-to-left, bottom-up first, and deterministic.The reason for the directional priority is to enforce the pref-erence of fragment rules that the sub-term of the adjunctionbe to the right of the head.
The algorithm then reverses di-rection, attempting to adjoin any remaining fragments intoother fragments on their right.
It oscillates back and forthin this fashion until no more fragments can be combined.At the end of this process the largest fragment (possiblynow containing other fxagments which it has absorbed) isreturned as the reconstructed parse, subject to cnt-off re-strictions which we discuss below.
More than one fragmentis returned in the case of multiple clausal fragments, and thediscourse module is invoked to construct the interpretationof the whole.As a simple example, let us return to the example of theprevious ection:I want a flight uhh that arrives in Boston let's say at 3 pmwhich generates the fragments:S\[I want a flight\]NO-INTERP \[uhh\]REL-S\[that arr ives in Boston\]NO-INTERP \[let' s say\]PP \[at 3 pm\]The rules that enable combination of these fragments are:VP-~ :head VP, :pp-comp PPNP-~ :head NP, :tel-clause REL-SThe first rule above licenses the attachment of "at 3 pm" to"arrives" inside the existing REL-S structure "that arrives"and the second the attachment of the combined REL-S struc-ture to the NP "a flight" inside the clause "I want a flight".After this combination, we are left with two fragments: aclause and an unanalyzable portion of the string.
Since allgrammar rules in DELPHI include a semantic interpretationcomponent\[3,4\], a semantic interpretation of the clause isalso available.The other fragment rules combine NPs and their variousmodifiers and VPs and their NP complements:NP-~ :head NP, :pp-comp PPNP-~ :head NP, :post-nom NPNP-~ :head NP, :whiz-tel VPVP-~ :head VP, :direct-object NPThe Syntactic Combiner uses a cut-off (currently .8) for theratio of the number of words included in the final recon-structed parse to the number of words of the original inputto determine whether or not to accept he final analysis asplausible.
The computation of this ratio is adjusted to ignorecertain words that carry little meaning ("does" me" "could"etc.)
and to block intepretations which exclude other wordswhich do tend to change the meaning ("first", "most" etc.).4.
THE FRAME COMBINER4.1 Overv iewThe Frame Combiner seeks to combine together not frag-ments but the semantic interpretations of fragments, and doesso based not on grammar rules but on pragmatic schematawhich have various "slots" to fill.
It works primarily withsemantic intepretations of fragments at the NP and PP level.Its approach is similar in spirit to SRI's Template Matcher\[1\] but it differs from that work in a number of importantways.Most importantly, it is fully integrated with a conventionalNLU system including grammar and parser.
This makes itpossible for it to work from recursive tree fragment struc-tures instead of sub-strings of input.
AS a result, the slot-filling process is not limited to simple phrases uch as "toBWI" but can also handle more syntactically and seman-tically complex phrases uch as "to the airport closest toWashington DC".
All the complex modifier structure inter-nal to NPs which a conventional parser normally uncoverscan be incorporated into slot-filling.Moreover, while the system does not use larger constituentssuch as VPs and clauses to frill slots directly, it does makeuse of a candidate NP or PP's occurence inside such a largerphrase to determine which slot the candidate should frill.
Thisenables the Frame Combiner to cope with such cases as thePP "before 3 pro", which means entirely different things,and therefore constraints entirely different slots, dependingon whether it modifies the verb "arrive" or "depart".A final difference is that the Frame Combiner attempts todetermine the actual items of information that the user wantsto have presented to him---that is, what slots in the frame arebeing asked about, as opposed to filled or constrained.
Thislast has practical importance within the context of the ATIStask domain because it enables only what is asked about tobe displayed to the user.
Formerly it was sufficient simplyto provide the entire extension of a suitably frame as theanswer, but given the MIN/MAX scoring procedure, such atactic is likely to result in numerous wrong answers.The basic operation of the Frame Combiner is to input asequence of semantically annotated fragment rees and tooutput a logical form as a proposed interpretation of the ut-terance.
As intermediate steps it generates alternative sets ofattribute-value "triples" and filters these according to plan-sibility criteria before generating a final interpretation fromthe chosen set.
We next describe ach of these steps.4.2 Representat iona l  T r ip lesAs intermediate output, the frame combiner first produces aset of attribute-value triples with the following structure:<OPERATOR, ATTRIBUTE, VALUE>The ATIRIBUTE is a single or multi-valued function.
TheVALUE is an element or set of elements from this function'srange.
The OPERATOR is a binary relation over elementsof the range.
In the following example:<EQUAL, ORIGIN-CITY, BOSTON>The operator is the relation EQUAL.
The attribute in thisexample is the function ORIGIN-CITY, whose domain isthe class FLIGHT and whose range is the class CITY.
Thevalue in the example is the individual city BOSTON.Other typical operators are relations like TIME-BEFOREand GREATER-THAN.
There is a special operator, HAS-PROPERTY, which is combined with a truth-valued (i.e.one-place predicate) attribute and the value TRUE for ad-jectival meanings like "non-stop".Currently there are three classes which can serve as thedomain of an attribute FLIGHT, FARE and GROUND-TRANSPORTATION.
We refer to these as the "core" classes307of the ATIS task.
These core classes are associated, respec-tively, with the distinguished attributes FLIGHT-OF, FARE-OF and TRANS-OF, which we term the "explicit" attributeof the core class, Explicit attributes are neccesary to in-corporate well-formed,parsed NP fragments whose semantictype is one of the core classes, such as "the USAir flightfrom Boston to Denver", without having to break them upinto their component modifiers.
Explicit attributes are al-ways combined with the EQUAL operator and an elementof the domain, and effectively correspond to the identityfunction for the domain.An attribute-value triple can be formally viewed as a spec-ification of a subset of the domain of the attribute of thetriple.
While they have a clear relationship to the notion ofa template or frame, they are perhaps better thought of asdisembodied "slot-constraints".
Note in particular that a setof such triples is a more flexible representation than a singletemplate in that it can uniformly combine triples whose at-tributes have different domains.
This is important when thequestion itself concerns more than domain--such as bothFLIGHTs and FAREs.4.3 Generating TriplesTriples are produced from fragment trees using a recursive-descent algorithm that applies a set of pattern rules thatmatch against fragment rees and their attached semanticinterpretations.
Rules can produce disjunctions of triples incase of ambiguity.
The rules primarily match against NPand PP constituents, associating the semantic intepretationof the NP constituents with the value element of a triple.The algorithm mainly recurses through other types of con-stituents, though it does note and pass down certain items ofinformation associated with them, such as the head-predicateof a VP.Rules consist of a syntactic pattern component followed byoptional extra constraints and an attribute assignment com-ponent.
For example the rule:(PP :pp FROM :object)(SORT :object CITY)(RESTRICT-SLOT EQUAL(:OR ORIGIN-CITYTRANS-TO-CITY):object)applies to PPs whose preposition is "from".
It requires thatthe NP object of the PP be of the semantic lass CITY.It restricts either the ORIGIN-CITY or TRANS-TO-CITYattributes to be EQUAL to the semantics of the NP object.When applied to the fragment:308\[PP from\[NP boston\]\]it generates the following two alternative triples:<EQUAL, ORIGIN-CITY, BOSTON><EQUAL, TRANS-TO-CITY, BOSTON>corresponding to the two altematives possible in a situationwhere "from Boston" is uttered: either the user wants to flyfrom Boston to some different city or he wants to get fromBoston to its airport.Rules have a slightly more complicated form when they in-volve an important feature of the Frame Combiner's triple-generation process: its use of syntactic structure and con-text.
For example, in the ATIS domain the PP "at 3 pm"means omething very different when attached to a verb like"arrive".
This phenomenon tends to pose a problem for con-ventional non-integrated template matching system, as hasbeen noted in earlier work \[1\].In the Frame Combiner this is handled by passing down thepredicate representing a verb's meaning as an extra argu-ment to the recursive descent algorithm.
If  a constituentwas attached to a VP with a particular meaning, the slot-filling process knows this when it reaches the constituent.Slot-filling rules can be written in such a way as to behavedifferently depending on whether the constituent under con-sideration is in the context of a particular verbal predicate.For example, in order to deal with the above phenomenon,the following rule applies to PP fragments where the NP:OBJECT is of type TIME-OF-DAY, and :PREP is anypreposition from which a temporal relation can be derived.This temporal relation restricts whatever slot is determinedappropriate by the ATI'RIBUTES component of the rule:(PP :PP :PREP :OBJECT)(SORT :OBJECT TIME-OF-DAY)(TEMPORAL-RELATION : PREP : REL)( RE STRICT- SLOT: REL(ATTRIBUTES(CONTEXT ARRIVE ARRIVAL-TIME)(DEFAULT DEPARTURE-TIME)(GENERAL ARRIVAL-TIMEDEPARTURE-TIME) ): OBJECT )The A'VI'RIBUTES expression delivers zero or more at-tributes as a disjunction the specific attributes dependingupon which of its evidence clauses is satisfied.
CONTEXTevidence is the strongest.
NON-LOCAL evidence is next,and it includes situations where a particular verb is merelypresent elsewhere in the input, without dominating the con-stituent.
DEFAULT evidence is the assignment preferredwhereas GENERAL evidence is all the assignments allowed.4.4 Filtering Sets of Tr ip lesWhen all fragments have been analyzed through recursivedescent, the system takes the cartesian product of all dis-junctive interpretations to obtain the set of all alternativesets of triples.
These are then filtered to leave only the mostplausible sets of triples.There are several criteria for plausibility.
The most obviousis that two or more triples on the same attribute not specifycontradictory values for the attribute.
Another is that a setnot contain any two triples with clashing attribute domains.For example, in the ATIS task one never sees queries thatcombine flights and ground transportation (even though suchare certainly expressible, e.g.
"Show me USAir flights toairports that have limousine service").
Thus FLIGHT andGROUND-TRANSPORTATION are clashing domains.
Onthe other hand, queries concerning both flights and fares dofrequently occur ("Show flights to Boston and their fares")so FLIGHT and FARE are not clashing domains.Another criterion is that the set of triples have the com-monly seen linguistic form for the domain.
Thus, while"the airport" and "the city" are plausible fillers for TRANS-TO-AIRPORT and TRANS-TO-CITY in the GROUND-TRANSPORTATION domain they are much less plausiblefillers for FLIGHT domain attributes, imply because propernoun fillers are fare more common for these.Criteria such as non-clashing domains are hard criteria, andtherefore any triple set which violates them is discarded.Other criteria, like the plausiblity of linguistic domain, aresofter, and the system merely prefers not to violate them.If there is more than one plausible set of triples, the FrameCombiner will, depending on switch setting, either give up orappeal to extrasentential discourse to resolve the ambiguity(much as the core DELPHI system will do).4.5 Choosing the Information to DisplayAt each turn in dialogue, any system performing an infor-marion retrieval task, such as ATIS, is essentially requiredto display a set of objects.
This holds for WH questions("which flights... "), imperatives ("show me"), and existen-tial yes-no questions ("are there any flights...").
On thisperspective, the different sets of objects and relationshipsbetween them are one part of the meaning of the query, andare represented by the sets of triples.
The other part of the309meaning is the question of which of these sets to display.We refer to as the "topic" of the query.To choose one (or more) of the triples as the topic means todisplay its value set, as it relates to all other value sets ofthe other triples.
Several different heuristics are used, andare ranked in priority.
Each is tried in succession until atopic is chosen.Most obvious is whether the filler of the triple is a WH nounphrase.
If  it is, it definitely must be the topic.Next are any "priority" domains that are not normally usedmerely to constrain other sets.
An example is GROUND-TRANSPORTATION--the typical ATIS user does notask to see cities that have a particular type of groundtransportation--the user wants to see the ground transporta-tion itself.
"Unconstrained" triples are another likely topic.
A triple is"unconstrained" if its filler is a bare common ominal, suchas "airline", and its attribute is a total function.
Since everyFLIGHT has an AIRLINE, the user is most unlikely to beimposing the vacuous constraint that the flight is on someairline (even though this is again expressible).
Rather, theuser is much more likley to be interested in seeing the airlineof the flight.4.6 Generating the Final InterpretationThe Frame Combiner generates a final logical form froma chosen set of triples by first associating a variable witheach triple filler ("value" slot) and a variable with each ofthe core classes present, in the set, whether through explicitattributes on the class or impficitly as the domain of an-other attributes.
It generates a matrix formula in which allthe attributes present are binary relations and the generatedvariables are the arguments o these binary relations.
Quan-tificational structure, corresponding tothe fillers of triples, isthen generated.
The quantifiers for topic triples are treatedas though they were WH quantifiers, and appropriate displaycommands generated.5.
RESULTS AND DISCUSSIONThis system was mn with the DELPI-I/ NL system in theFebruary 1992 official evaluation.
Using the same constantexecutable Lisp image ("disksave") run for the official re-suits, the test was run using a number of different switchsettings, and scored with the version of the NIST comparatorused for the official results.
The switch conditions were: nofallback processing at all (which is simply the core DELPHIsystem), Syntactic Combiner only, Frame Combiner only,and both Syntactic Combiner and Frame Combiner work-ing together (which was the condition used in the officialresults).
The figures for NL only are reported in Table 1.%T %F %NA %WEno fallback 69.3 7.4 23.3 38.1syn only 73.1 8.9 18.0 35.8frame only 78.3 9.6 12.1 31.3both(official) 76.7 10.6 12.7 33.9Table 1: NL ResultsNote the flame-only condition is actually better than resultofficially reported, in which both fallback sub-componentswere used.For the SLS test, the output ofBBN's  BYBLOS N-best rec-ognizer was used, with N = 5.
The core DELPHI system(without fragments) was first tested against he five theo-ries.
I f  an intepretation was found for one of them, it wasreturned.
Otherwise, the fallback methods were applied.Results for three of the four conditions are seen in Table 2(results for the no-fallback = core DELPHI condition wereunavailable as of this writing).
The figure for the combina-tion of both fragment modules (the configuration used in theofficial test) reflects an slight downward adjustment from theoriginal value of 43.7 that corrects apurely procedural errorcommitted uring our running the test (the file that specifies"todays's date" for each query was not loaded, leading to asmall increase in the number of wrong answers).
This prob-lem was fixed in obtaining the results in Table 2.
As in theregular NL test, the SLS results how an noticeable improve-ment over the official results when the Frame Combiner isused alone.These results tend to undercut a central premise of our orig-inal strategy: namely that using both fragment combinationmethods together would improve the result over the use ofeither alone.
Our tentative hypothesis is that the Syntac-tic Combiner, when failing and passing to the Frame Com-biner the best results of its combination attempt, is pass-ing wrongly combined fragments which mislead the FrameCombiner.On the other hand, these results do show the utility of theFrame Combiner when used alone.
For NL only, it reducedthe No Answer rate by 11.2 percentage points, and WeightedError by 4.2 percentage points.
For SLS, it reduced theWeighted Error from the adjusted official value of 43.2% tothe signifigantly lower value of 39.2%.ACKNOWLEDGEMENTSThe work reported here was supported by the Advanced Re-search Projects Agency and was monitored by the Officeof Naval Research under Contract No.
N00014-89-C-0008.The views and conclusions contained in this document arethose of the authors and should not be interpreted as neces-sarily kepresenting the official policies, either expressed orimplied, of the Defense Advanced Research Projects Agencyor the United States Government.REFERENCES1.
Jackson, E., Appelt, D., Bear, l., Moore, R. and Podlozny,A.
A Template Matcher for Robust NL Interpretation, in Pro-ceedings Speech and Natural Language Workshop February19912.
Bobrow, R.L Statistical Agenda Parsing in ProceedingsSpeech and Natural Language Workshop February 19913.
Bobrow, R.L, Ingria, R. and Stallard, D. Syntactic~SemanticCoupling in the DELPHI System to appear in ProceedingsSpeech and Natural Language Workshop February 19924.
Bobrow, Ingna, R. and Stallard, D. The Mapping Unit Ap-proach to Subcategorization in Proceedings Speech and Nat-ural Language Workshop February 1991%T %F %NA %WEno fallback 65.2 10.5 24.3 45.6syn only 68.9 11.5 19.7 42.6frame only 73.8 13.0 13.2 39.2both(official) 71.8 15.4 12.8 43.7both(adjusted) 71.9 15.1 13.0 43.2Table 2: SLS Results310
