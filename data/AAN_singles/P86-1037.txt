Some Uses  o f  H igher -Order  Log icin  Computat iona l  L ingu is t i csDale A. Miller and Gopalan NadathurComputer and Information ScienceUniversity of PennsylvaniaPhiladelphia, PA 19104 - 3897Abst ractConsideration of the question of meaning in the frame-work of linguistics often requires an allusion to sets andother higher-order notions.
The traditional approach torepresenting and reasoning about meaning in a computa-tional setting has been to use knowledge representation sys 7tems that are either based on first-order logic or that usemechanisms whose formal justifications are to be providedafter the fact.
In this paper we shall consider the use ofa higher-order logic for this task.
We first present a ver-sion of definite clauses (positive Horn clauses) that is basedon this logic.
Predicate and function variables may oc-cur in such clauses and the terms in the language are thetyped h-terms.
Such term structures have a richness thatmay be exploited in representing meanings.
We also de-scribe a higher-order logic programming language, called~Prolog, which represents programs as higher-order defi-nite clauses and interprets them using a depth-first inter-preter.
A virtue of this language is that it is possible towrite programs in it that integrate syntactic and seman-tic analyses into one computational paradigm.
This is tobe contrasted with the more common practice of using twoentirely different computation paradigms, uch as DCGs orATNs for parsing and frames or semantic nets for semanticprocessing.
We illustrate such an integration in this lan-guage by considering a simple example, and we claim thatits use makes the task of providing formal justifications forthe computations specified much more direct.1.
In t roduct ionThe representation f meaning, and the use of such arepresentation to draw inferences, is an issue of central con-cern in natural anguage understanding systems.
A theoret-ical understanding of meaning is generally based on logic,and it has been recognized that a higher-order logic is par-ticularly well suited to this task.
Montague, for example,used such a logic to provide a compositional semantics forsimple English sentences.
In the computational framework,knowledge representation systems are given the task of rep-resenting the semantical notions that are needed in naturalThis work has been supported by NSF grants MCS-82-19196-CER, MCS-82-07294, AI Center grants MCS-83-05221, US Army Research Office grant ARO-DAA29-84-9-0027, and DARPA N000-14-85-K-0018.language understanding programs.
While the formal justi-fications that are provided for such systems is usually log-ical, the actual formalisms used are often distantly relatedto logic.
Our approach in this paper is to represent mean-ings directly by using logical expressions, and to describethe process of inference by specifying manipulations on suchexpressions.
As it turns out, most programming languagesare poorly suited for an  approach such as ours.
Prolog,for instance, permits the representation and the examina-tion of the structure of first-order terms, but it is not easyto use such terms to represent first-order formulas whichcontain quantification.
Lisp on the other hand allows theconstruction of lambda expressions which could encode thebinding operations of quantifiers, but does not provide log-ical primitives for studying the internal structure of suchexpressions.
A language that is based on a higher-orderlogic seems to be the most natural vehicle for an approachsuch as ours, and in the first part of this paper we shall de-scribe such a language.
We shall then use this language todescribe computations of a kind that is needed in a naturallanguage understanding system.Before we embark on this task, however, we need toconsider the arguments that are often made against thecomputational use of a higher-order logic.
Indeed, severalauthors in the current l iterature on computational linguis-tics and knowledge representation have presented reasonsfor preferring first-order logic over higher-order logic in nat-ural language understanding systems, and amongst hesethe following three appear frequently.
(1} GSdel showed that second-order logic is essentially in-complete, i.e.
true second-order logic statements arenot recursively enumerable.
Hence, theorem proversfor this logic cannot be, even theoretically, complete.
(2) Higher-order objects like functions and predicates canthemselves be considered to be first-order objects ofsome sort.
Hence, a sorted first-order logic can be usedto encode higher-order objects.
(3) Little research on theorem proving in higher-order log-ics has been done.
Moreover, there is reason to believethat theorem proving in such a logic is extremely dif-ficult.These facts are often used to conclude that a higher-order logic should not be used to formalize systems ifsuch formalizations are to be computationally meaningful.While there is some truth in each of these observations, wefeel that they do not warrant the conclusion that is drawnfrom it.
We discuss our reasons for this belief below.247The point regarding the essential undecidability ofsecond-order logic has actually little import on the com-putational uses of higher-order logic.
This is because thesecond-order logic as it is construed in this observation, isnot a proof system but rather a truth system of a very par-ticular kind.
Roughly put, the second-order logic in ques-tion is not so much a logic as it is a branch of mathematicswhich is interested in properties about the integers.
Thereare higher-order logics that have been provided which con-tain the formulas of second-order logic but which do notassume the same notion of models (i.e.
the integers).
Theselogics, in fact, have general models, including the standard,integer model, as well as other non-standard models, andwith respect o this semantics, the logic has a sound andcomplete proof system.From a theoretical point-of-view, the second observa-tions is important.
Indeed, any system which could not beencoded into first-order logic would be more powerful thanTuring machines and, hence, would be a rather unsatisfac-tory computationally!
The existence of such an encodinghas little significance, however, with regard to the appro-priateness of one language over another for a given set ofcomputational tasks.
Clearly, all general purpose program-ming languages can be encoded onto first-order logic, butthis has little significance with regard to the suitability ofa given programming language for certain applications.Although less work has been done on theorem provingin higher-order logic than in first-order logic as claimed inthe last point, the nature of proofs in higher-order logic isfar from mysterious.
For example, higher-order resolution\[1\] and unification \[8\] has been developed, and based onthese principles, several theorem provers for various higher-order logics (see \[2\] and its references) have been built and?
/tested.
The experience with such systems hows that the-orem proving in such a logic is difficult.
It is not clear,however, that the difficulty is inherent in the language cho-sen to express a theorem rather than in the theorem itself.In fact, expressing a higher-order theorem (as we will claimmany statements about meaning are) in a higher-order logicmakes its logical structure more explicit than an encodinginto first-order logic does.
Consequently, it is reasonableto expect that the higher-order representation should ac-tually simplify the process of finding proofs.
In a morespecific sense, there are sublogics of a higher-order logic inwhich the process of constructing proofs is not much morecomplicated than in similar sublogics of first-order logic.An example of such a case is the higher-order version ofdefinite clauses that we shall consider shortly.In this paper, we present a higher-order version of def-inite clauses that may be used to specify computations,and we describe a logic programming language, ,~Prolog,that is based on this specification language.
We claim that~Prolog has several inguistically meaningful applications.To bolster this claim we shall show how the syntactic andsemantic processing used within a simple parser of natu-ral language can be smoothly integrated into one logicaland computational process.
We shall first present a defi-nite clause grammar that analyses the syntactic structure ofsimple English sentences to produce logical forms in muchthe same way as is done in the Montague framework.
Weshall then show how semantic analyses may be specifiedvia operations on such logical forms.
Finally, we shall illus-trate interactions between these two kinds of analyses byconsidering an example of determining pronoun reference.2.
H igher -Order  LogicThe higher-order logic we study here, called T, can bethought of as being a subsystem of either Church's SimpleTheory of Types \[5\] or of Montague's intensional logic IL\[6\]?
Unlike Church's or Montague's logics, T is very weakbecause it assumes no axioms regarding extensionality, def-inite descriptions, infinity, choice, or possible worlds.
Tencompasses only the most primitive logical notions, andgeneralizes first-order logic by introducing stronger notionsof variables and substitutions.
Our use of T is not drivenby a desire to capture of the meaning of linguistic objects,as was the hope of Montague.
It is our hope that programswritten in T will do that.The language of T is a typed language.
The typingmechanism provides for the usual notion of sorts often usedin first-order logic and also for the notion of functionaltypes.
We take as primitive types (i.e.
sorts) o for booleansand i for (first-order) individuals, adding others as needed.Functional types are written as a -* fl, where o~ and fl aretypes.
This type is intended to denote the type of func-tions whose domains are a and whose codomains are /3.For example, i --~ i denotes the type of functions whichmap individuals to individuals, and (i --* i) --* o denotesthe type of functions from that domain to the booleans.
Inreading such expressions we use the convention that --* isright associative, i.e.
we read a --* fl --~ -y as ol --~ (fl --~ -~).The terms or formulas of T are specified along withtheir respective types by the following simple rules: Westart with denumerable s ts of constants and variables ateach type.
A constant or variable in any of these sets isconsidered to be a formula of the corresponding type.
Then,if A is of type a --* fl and B is of type a, the functionapplication (AB) is a formula of type ft.
Finally, if x is avariable of type a and C is a term of type fl, the functionabstraction )~xC is a formula of type a -~ ft.We assume that the following symbols, called the log-ical constants, are included in the set of constants of thecorresponding type: true of type o, ~ of type o --* o, A,V, and D each of type o --~ o --~ o and II and ~ of type(A --~ o) --~ o for each type A.
All these symbols exceptthe last two correspond to the normal propositional connec-tives.
The symbols II and Y:, are used in conjunction withthe abstraction operation to represent universal and exis-tential quantification: Vx P is an abbreviation for H(Ax P)and 3x P is an abbreviation for G(Ax P).
H and E areexamples of what are often called generalized quantifiers.The type o has a special role in this language.
A for-mula with a function type of the form tt --* ...  --~ t~ --~ ois called a predicate of n arguments.
The i th argument ofsuch a predicate is of type ti.
Predicates are to be thoughtof as representing sets and relations.
Thus a predicate oftype f --* o represents a set of individuals, a predicate oftype (i --~ o) --~ o represents a set of sets of individuals,248and a predicate of type i --~ (i --* o) ~ o represents a bi-nary relation between individuals and sets of individuals.Formulas of type o are called propositions.
Although pred-icates are essentially functions, we shall generally use theterm function to denote a formula that does not have thetype of a predicate.Derivability in T, denoted by ~-T, is defined in the fol-lowing (simplified) fashion.
The axioms of T are the propo-sitional tautologies, the formula Vx Bx D Bt, and the for-mula Vx (PxAQ) D Vx PxAQ.
The rules of inference of thesystem are Modus Ponens, Universal Generalization, Sub-stitution, and A-conversion.
The rules of A-conversion thatwe assume here are a-conversion (change of bound vari-ables), fl-conversion (contraction), and r/-conversion (re-place A with Az(Az) and vice versa if A has type a --* fl, zhas type a, and z is not free in A).
A-conversion is essen-tially the only rule in T that is not in first-order logic, butcombined with the richer syntax of formulas in T it makesmore complex inferences possible.In general, we shall consider two terms to be equal ifthey are each convertible to the other; further distinctionscan be made between formulas in this sense by omitting therule for rl-conversion, but we feel that such distinctions arenot important in our context.
We say that a formula is aA-normal formula if it has the formAxi...Ax, (h tl ... tin) wheren, m>0,where h is a constant or variable, (h tl .
.
.
t,,) has a prim-itive type, and, for 1 < i < m, t~ also has the same form.We call the list of variables xl,.
.
.
,x,~ the binder, h thehead, and the formulas t l , .
.
.
, tm the arguments of such aformula.
It is well known that every formula, A, can beconverted to a A-normal formula that is unique up to a-conversions.
We call such a formula a A-normal form of Aand we use Anorrn(A) to denote any of these alphabeticvariants.
Notice that a proposition in A-normal form musthave an empty binder and contai9 either a constant or freevariable as its head.
A proposition in A-normal form whichhas a non-logical constant as its head is called atomic.Our purpose in this paper is not merely to use a logic asa representational device, but also to think of it as a devicefor specifying computations.
It turns out that T is toocomplex for the latter purpose.
We shall therefore restrictour attention to what may be thought of as a higher-orderanalogue of positive Horn clauses.
We define these below.We shall henceforth assume that we have a fixed setof nonlogical constants.
The positive Herbrand Universe isidentified in this context o be the set of all the A-normalformulas that can be constructed via function applicationand abstraction using the nonlogical constants and the log-ical constants true, A, V and ~; the omission here is of thesymbols ~, D, and II.
We shall use the symbol )4+ to denotethis set of terms.
Propositions in this set are of special inter-est to us.
Let G and A be propositions in ~/+ such that A isatomic.
A (higher-order) definite clause then is the univer-sal closure of a formula of the form G D A, i.e.
the formulaVe (G D A) where ?
is an arbitrary listing of all the freevariables in G and A, some of which may be function andpredicate variables.
These formulas are our generalizationof positive Horn clauses for first-order logic.
The formulaon the left of the D in a higher-order definite clause maycontain nested disjunctions and existential quantification.This generalization may be dispensed within the first-ordercase because of the existence of appropriate normal forms.For the higher-order case, it is more natural to retain theembedded isjunctions and existential quantifications sincesubstitutions for predicate variables have the potential forre-introducing them.
Illustrations of this aspect appear inSection 4.Deductions from higher-order definite clauses are verysimilar to deductions from positive Horn clauses in first-order logic.
Substitution, unification, and backchaining canbe combined to build a theorem prover in either case.
How-ever, unification in the higher-order setting is complicatedby the presence of A-conversion: two terms t and 8 are unifi-able if there exists some substitution ~ such that Us and~t are equal modulo A-conversions.
Since fl-conversion isa very complex process, determining this kind of equalityis difficult.
The unification of typed A-terms is, in general,not decidable, and when unifiers do exist, there need notexist a single most general unifier.
Nevertheless, it is pos-sible to systematically search for unifiers in this setting \[8\]and an interpreter for higher-order definite clauses can bebuilt around this procedure.
The resulting interpreter canbe made to resemble Prolog except that it must accountfor the extra degree of nondeterminism which arises fromhigher-order unification.
Although there are several impor-tant issues regarding the search for higher-order unifiers,we shall ignore them here since all the unification problemswhich arise in this paper can be solved by even a simple-minded implementation f the procedure described in \[8\].3.
APrologWe have used higher-order definite clauses and adepth-first interpreter to describe a logic programming lan-guage called AProlog.
We present below a brief expositionof the higher-order features of this language that we shalluse in the examples in the later sections.
A fuller descrip-tion of the language and of the logical considerations un-derlying it may be found in \[9\].Programs in AProlog are essentially higher-order defi-nite clauses.
The following set of clauses that define certainstandard list operations serve to illustrate some of the syn-tactic features of our language.append nil K K.append (cons X L) K (cons X M) :- append L K M.member X (cons X L).member X (cons Y L) :- member X L.As should be apparent from these clauses, the syntax ofAProlog borrows a great deal from that of Prolog.
Sym-bols that begin with capital etters represent variables.
Allother symbols represent constants.
Clauses are writtenbackwards and the symbol :- is used for C. There are,however, some differences.
We have adopted a curried no-tation for terms, rather than the notation ormally used ina first-order language.
Since the language is a typed one,types must be associated with each term.
This is done by249either explicitly defining the type of a constant or a vari-able, or by inferring such a type by a process very similarto that used in the language ML \[7\].
The type expressionsthat are attached to symbols may contain variables whichprovide a form of polymorphism.
As an example cons andn i l  above are assumed to have the types A -> ( l i s t  A)-> ( l i s t  A) and ( l i s t  A) respectively; they serve to de-fine lists of different kinds, but each list being such that allits elements have a common type.
(For the convenience ofexpression, we shall actually use Prolog's notation for listsin the remainder of this paper, i.e.
we shall write (cons XL) as \[XIL\]).
In the examples in this paper, we shall occa-sionally provide type associations, but in general we shallassume that the reader can infer them from context whenit is important.
We need to represent A-abstraction i  ourlanguage, and we use the symbol \ for this purpose; i.e.AX A is written in AProlog as X \ A.The following program, which defines the operation ofmapping a function over a list, illustrates a use of functionvariables in our language.mapfun F \[XIL\] \[(F X)IK\] : -  mapfun F L K.mapfun F \[\] \ [ \ ] .Given these clauses, (mapfun F L1 L2) is provable only ifL2 is a list that results from applying F to each element ofL1.
The interpreter for AProlog would therefore valuatethe goal (mapfun (X\(g X X)) \[a. b\])  L) by returningthe value \[(g a a ) .
(g b b)\]  for L.The logical considerations underlying the languagepermit functions to be treated as first-class, logic program-ming variables.
In other words, the values of such variablescan be computed through unification.
For example, con-sider the query(mapfun F \ [a .
b\] \[(g a a ) ,  (g a b ) \ ] ) .There is exactly one substitution for F, namely X\(g aX), that makes the above query provable.
In searching forsuch higher-order substitutions, the interpreter for APrologwould need to backtrack over choices of substitutions.
Forexample, if the interpreter attempted to prove the abovegoal by attempting to unify (F a) with (g a a),  it wouldneed to consider the following four possible substitutionsfor F:X\(g X X) Xk(g a X) X\(g X a) X\(g a a).If it chooses any of these other than the second, the inter-preter would fail in unifying (F b) with (g a b),  and wouldtherefore have to backtrack over that choice.It is important o notice that the set of functions thatare representable using the typed A-terms of AProlog is notthe set of all computable functions.
The set of functionsthat are so representable are in fact much weaker than thoserepresentable in, for example, a functional programminglanguage like Lisp.
Consider the goal(mapfun F \[a. b\] \[c, d\]).There is clearly a Lisp function which maps a to c and bto d, namely,(lambda (x) ( i f  (eq x 'a) 'b(if (eq x 'c) 'd 'e)))Such a function is, however, not representable using ourtyped A-terms since these donot contain any constants rep-resenting conditionals {or fixed point operators needed forrecursive definitions).
It is actually this restriction to ourterm structures that makes the determination of functionvalues through unification a reasonable computational op-eration.The provision of function variables and higher-orderunification has several uses, some of which we shall exam-ine in later sections.
Before doing that we consider brieflycertain kinds of function terms that have a special statusin the logic programming context, namely predicate terms.4.
Predicates as ValuesFrom a logical point of view, predicates are not muchdifferent from other functions; essentially they are func-tions that have a type of the form ai --~ ... --* ~ --~ o. Ina logic programming language, however, variables of thistype may play a different and more interesting role thannon-predicate variables.
This is because such variables mayappear inside the terms of a goal as well as the head of agoal.
In a sense, they can be used intensionally and exten-sionally (or nominally and saturated).
When they appearintensionally, predicates can be determined through unifi-cation just as functions.
When they appear extensionally,they are essentially "executed.
"An  example of these mixed uses of predicate variablesis provided by the following set of clauses; the logical con-nectives A and V are represented in AProlog by the symbols?
and ;, true is represented by true and Z is representedby the symbol sigma that has the polymorphic type (A ->O) -> O.sublist P \[XIL\] \[XlK\] :- P X. sublist P L Z.sublist P \[XIL\] K :- sublist P L K.sublist P \[\] \[\].have_age L K :- sublist Z\(sigma Xk(ags Z X)) L K.name_age L K :- sublist Z\(age Z A) L K.age bob 9.3.age sue 24.age ned 23.The first three clauses define the predicate sublist whosefirst argument is a predicate and  is such that ( sub l i s t  PL K) is provable if K is some sublist of L and all the mem-bers in K satisfy the property expressed by the predicateP.
The fourth clause uses sub l i s t  to define the predicatehave_age which is such that (have_age L K) is provableif K is a sublist of the objects in L which have an age.
Inthe definition of have_age a predicate term that containsan explicit quantifier is used to instantiate the predicateargument of sublist; the predicate (Z\ (sigma X\ (age ZX))), which may be written in logic as Az 3z age(z,z), istrue of an individual if that individual has an age.
Thispredicate term needs to be executed in the course of eval-uating, for example, the query (have_age \[bob.
sue ,ned\]K).
The predicate name_age whose definition is obtained bydropping the quantifier from the predicate term defines adifferent property; (same_age L K) is true only when theobjects in K have the same age.250Another example is provided by the following set ofclauses that define the operation of mapping a predicateover a list.mappred P \[X\[L\] \[Y\[K\] :- P X Y. mappred P L K.mappred P \[\] \[\].This set of clauses may be used, for example, to evaluatethe following query:mappred (X\Y\(age Y X)) \[23.24\] L.This query essentially asks for a list of two people, the firstof which is 23 years old while the second is 24 years old.Given the clauses that appear in the previous example, thisquery has two different answers: \[bob.
sue\] and \[ned.sue\].
Clearly the mapping operation defined here is muchstronger than a similar operation considered earlier, namelythat of,napping a function over a list.
In evaluating a querythat uses this set of clauses a new goal, i.e.
(P X Y), isformed whose evaluation may require arbitrary computa-tions to be performed.
As opposed to this, in the earliercase only A-reductions are performed.
Thus, mappred ismore like the mapping operations found in Lisp than map-fun is.In the cases considered above, predicate variables thatappeared as the heads of goals were fully iustantiated be-fore the goal was invoked.
This kind of use of predicatevariables is similar to the use of apply and lambda termsin Lisp: A-contraction followed by the goal invocation sim-ulates the apply operation in the Prolog context.
However,the variable head of a goal may not always be fully instanti-ated when the goal has to be evaluated.
In such cases thereis a question as to what substitutions should be attempted.Consider, for example, the query (P bob 23).
One valuethat may be returned for P is XkY\ (age X Y), and this mayseem to be the most "natural" value.
There are, however,many more substitutions for P which also satisfy this goal:XkY\(X = bob, Y = 23), XkY\(Y = 23), XkY\(age sue24), etc.
are all terms that could be picked, since if theywere substituted for P in the query they would result in aprovable goal.
There are, clearly, too many substitutions topick from and perhaps backtrack over.
Furthermore severalof these may have little to do with the original intention ofthe query.
A better strategy may be to pick the one sub-stitution that has the largest "extension" in such cases; inthe case considered here, such a substitution for P wouldbe the term XkY\true.
It is possible to make such a choicewithout adding to the incompleteness of an interpreter.Picking such a substitution does not necessarily triv-ialize the use of predicate variables.
If a predicate occursintensionally as well as extensionally in a goal, this kind ofa trivial substitution may not be possible.
To illustrate thislet us consider the following set of clauses:pr imre l  fa ther ,p r imre l  mother.primrel wife.primrel husband.tel R :- primrel R.rel XkYk(sigma Zk(R X Z, S Z Y)) :-prlmrel R. prlmrel S.The first four clauses identify four primitive relations be-tween individuals (pr imre l  has type ( i  -> i -> o) -> o).These are then used to define other relations that are a re-sult of "joining" primitive relations.
Now if (mother Janemary) and (wife john jane)  are provided as additionalclauses, then the query ( re l  R. R john mary) would yieldthe substitution X\Y\(sigma Zk(wife X Z. mother Z Y))for R. This query asks for a relation (in the sense of te l )between john and mary.
The answer substitution providesthe relation mother-in-law.We have been able to show (Theorem 1 \[9\]) that anyproof in T of a goal formula from a set of definite clauseswhich uses a predicate term containing the logical connec-tives ~, D, or V, can be converted into another proof inwhich only predicate terms from ~/+ are used.
Thus, it isnot possible for a term such asAx (person(x) ^ Vy (child(x,y) D doctor(y)))to be specified by a AProlog program, i.e.
be the uniquesubstitution which makes some goal provable from someset of definite clauses.
This is because a consequence ofour theorem is that if this term is an answer substitutionthen there is also another A-term that does not use im-plications or universal quantification that can be used tosatisy the given goal.
If an understanding of a richer setof predicate constructions i desired, then one course is toleave definite clause logic for a stronger logic.
An alterna-tive approach, which we use in Section 6, is to representpredicates as function terms whose types do not involve o.This, of course, means that such predicate constructionscould not be the head of goals.
Hence, additional definiteclauses would be needed to interpret he meaning of theseencoded predicates.5.
A S imple  Pars ing  ExampleThe enriched term structure of  AProlog provides twofacilities that are useful in certain contexts.
The notion ofA-abstraction allows the representation of binding a vari-able over a certain expression, and the notion of appli-cation together with A-contraction captures the idea ofsubstitution.
A situation where this might be useful isin representing expressions in first-order logic as terms,and in describing logical manipulations on them.
Con-sider, for example, the task of representing the formulaVxBy(P(x,y) D Q(y,x)) as a term.
Fragments of this for-mula may be encoded into first-order terms, but there is agenuine problem with representing the quantification.
Weneed to represent he variable being quantified as a gen-uine variable, since, for instance, instantiating the quanti-fier involves ubstituting for the variable.
At the same timewe desire to distinguish between occurences of a variablewithin the scope of the quantifier from occurences outsideof it.
The mechanism of A-abstraction provides the toolneeded to make such distinctions.
To illustrate this let usconsider how the formula above may be encoded as a A-term.
Let the primitive type b be the type of terms thatrepresent first-order formulas.
Further let us assume wehave the constants & and => of type b -> b -> b, and a l l251and some of type ( i  -> b) -> b.
These latter two constantshave the type of generalized quantifiers and are in fact usedto represent quantifiers.
The A-term (a l l  X\ (some Y\ (p XY => q Y X) ) ) may be used to represent the above formula.The type b should be thought of as a term-level encodingof the boolean type o.A more complete illustration of the facilities alluded toabove may be provided by considering the task of translat-ing simple English sentences into logical forms.
As an ex-ample, consider translating the sentence "Every man lovesa woman" to the logical formVx(man(x) D qy(woman(y) A loves(x, y)))which in our context will be represented by the A-term(a l l  X\(man X =>(some Y\(woman Y ~ loves X Y))))A higher-order version of a DCG \[10\] for performing thistask is provided below.
This DCG draws on the spirit ofMontague Grammars.
(See \[11\] for a similar example.
)sentence (P1 P2)np (P1 P2)lapPnom Pnom X\(P1 X & P2 X)vp X\(P2 (P1 X))vp Prelcl P--> np P1, vp P2, \[.\].--> determ Pl, hem P2.--> propernoun P.--> noun P.--> noun Pl, re lc l~2.--> transverb Pl, np P2.--> intransverb P.--> \[that\], vp P.determ P l \P2 \ (a l l  X\ (P1X => P2 X)) -->\ [every\] .determ PlkP2k(P2 (iota P1)) --> \[the\].determ Pl\P2\(some xk(PI X & P2 X)) --> \[a\].noun mannoun womanpropernoun johnpropernoun marytransverb lovestransverb likes- -> \[man\].- -> \[woman\].--> \ [ john\] .--> \[mary\].--> \ [ loves \ ] .--> \[likes\].intransverb lives --> \[lives\].We use above the type token for English words; the DCGtranslates a list of such tokens to a term of some corre-sponding type.
In the last few clauses certain constants areused in an overloaded manner.
Thus the constant man cor-responds to two distinct constants, one of type token andanother of type i -> b.
We have also used the symbol io tathat has type ( i  -> b) -> i.
This constant plays the roleof a definite description operator; it picks out an individualgiven a description of a set of individuals.
Thus, parsing thesentence "The woman that loves john likes mary" producesthe term (likes (iota Xk(woman X ~ loves X john))mary), the intended meaning of which is the predication ofthe relationship of liking between an object that is pickedout by the description X\(woman X & loves X john))  andmary.Using this DCG to parse a sentence illustrates the rolethat abstraction and application play in realizing the no-tion of substitution.
It is interesting to compare this DCGwith the one in Prolog that is presented in \[10\].
The firstthing to note is that the two will parse a sentence in nearlyidentical fashions.
In the first-order version, however, thereis a need to explicitly encode the process of substitution,and considerable ingenuity must be exercised in devisinggrammar ules that take care of this process.
In contrastin ),Prolog the process of substitution and the process ofparsing are handled by two distinct mechanisms, and con-sequently the resulting DCG is more perspicuous and soalso easier to extend.The DCG presented above may also be used to solvethe inverse problem, namely that of obtaining a sentencegiven a logical form, and this illustrates the use of higher-order unification.
Consider the task of obtaining a sentencefrom the logical form (a l l  X\(man X => (some Y\(womanY ~ loves X Y))) ).
This involves unifying the above formwith the expression (P1 P2).
One of the unifiers for this isPl --> Pk(all X\(man X => P X))P2 --> X\(some Y\(woman Y ~ loves X Y).Once this unifier is picked, the task then breaks into that ofobtaining a noun phrase from Pk(a l l  Xk(man X => P X))and a verb phrase from X\ (some Y\ (woman Y ~ loves X Y).The use of higher-order unification thus seems to provide atop-down decomposition i the search for a solution.
Thisview turns out to be a little simplistic however, since uni-fication permits more structural decompositions than arewarranted in this context.
Thus, another unifier for thepair considered above isPI --> Zk(all Z)P2 --> X\(man X =>(some Y\(woman Y & loves X Y)))which does not correspond to a meaningful decompositionin the context of the rest of the rules.
It is possible toprevent such decompositions by anticipating the rest ofthe grammar ules.
Alternatively decompositions may beeschewed altogether; a logical form may be constructedbottom-up and compared with the given one.
The firstalternative detracts from the clarity, or the specificationalnature, of the solution.
The latter involves an exhaustivesearch over the space of all sentences.
The DCG consid-ered here, together with higher-order unification, seems toprovide a balance between clarity and efficiency.The final point to be noted is that the terms thatare produced at intermediate stages in the parsing processare logically meaningful terms, and computations on suchterms may be encoded in other clauses in our language.
InSection 7, we show how some of these terms can be directlyinterpreted as frame-like objects.6.
Knowledge  Representat ionWe now consider the question of how a higher-orderlogic might be used for the task of representing knowledge.Traditionally, certain network based formalisms, such asKL-ONE \[4\], have been described for this purpose.
Suchformalisms use nodes and arcs in a network to encode252knowledge, and provide algorithms that operate on thisnetwork in order to perform inferences on the knowledgeso represented.
The nature of the information representedin the network may be clarified with reference to a logic,and the correctness of the algorithms is often proved byshowing that they perform certain kinds of logical infer-ence on the underlying information.
Our approach hereis to encode the relevant notions by using A-terms that di-rectly correspond to their logical nature, and to use definiteclauses to specify logical inferences on these notions.
Wedemonstrate this approach below through a few examples.A key notion in knowledge representation is that of aconcept.
KL-ONE provides the ability to define primitiveroles and concepts and a mechanism to put these togetherto define more complex concepts.
The intended interpre-tation of a role is a two place relation, and of a conceptis a set of objects characterized by some defining property.An appropriate logical view of a concept, therefore, is toidentify it with a one-place predicate.
A particularly aptway of modeling the connection between a concept and apredicate is to use A-terms of a certain kind to denote con-cepts.
The following set of clauses that are used to defineconcepts modelled after examples in \[4\] serves to make thisclear.prim_role recipient.prim_role sender.pr imro le  supervisor.prim_concept person.prim_concept crew.prim_concept commander.prim_concept message.prim_concept important message.role R :- prim_role R.concept C :- prim_concept C.concept (X\(CI X & C2 X)) :-concept CI, concept C2..concept (X\(all Y\(R X Y => C1 Y))) :-concept CI, role R.The type of prim_role and role in the above example is(i -> i -> b) -> o and of prim_concept and conceptis (i -> b) -> o.
Any term that can be substituted for Rso as to make (role R) provable from these clauses is con-sidered a role.
Similarly, any term that can be substitutedfor C so as to make (concept C) provable is considereda concept.
The first three clauses serve to define primitiveroles in this sense, and the next five clauses define primitiveconcepts.
The remaining clauses describe a mechanism forconstructing further roles and concepts.
As can be readilyseen, all roles are primitive roles.
An  example of a complexconcept is provided by the term(X\(message X a (all Y\(sender X Y => crew Y))))which may he described by the noun phrase "messages allof whose senders are crew members.
"One of the purposes for providing a representation forconcepts is so that inferences that involve them can be de-scribed.
One kind of inference that is of particular inter-est is that of determining subsumption.
A concept C1 issaid to subsume another concept C2 if every element of theset described by C2 is a member of the set described byC,.
Given our representation f concepts, the question ofwhether C1 subsumes 6'2 reduces to the question of whetherVx(C2(x) D Cl(x)) is valid (i.e.
provable).
Such an infer-ence may be based either on certain primitive containmentrelations, or on an analysis of the structure of the termsused to denote concepts.
The following set of clauses makethese ideas precise:subsume person crew.subsume (X\(all Y\(sender X Y => person Y)))message.subsume (X\(all Y\(recipient X Y => crew Y)))message.subsume message important_message.subsume (X\(all Y\(sender X Y => commander Y)))important_message.subsume C C.subsume A B :- subsume A C, subsume C B.subsume (Z\(A Z & B Z)) C :-subsume A C. subsume B C.subsume A (Z\(B Z & C Z)) :- subsume A B.subsume A (Z\(B Z & C Z)) :- subsume A C.subsume (Z\(all (Y\(R Z Y => A Y))))(Z\(all (Y\(R Z Y => B Y)))) :-subsume A B.The first few clauses specify certain primitive containmentrelations; thus the first clause states that the set describedby crew is contained in the set described by person.
Thelater clauses pecify subsumption relations based on theseprimitive ones and on the logical structure of the termsdescribing the concepts.
One of the virtues of our rep-resentation ow becomes clear: It is easy to see that theabove set of clauses correctly specifies the relation of sub-sumption.
If a and B are two terms that represent concepts,then rather elementary proof-theoretic arguments may beemployed to show that (subsumes A B) is provable fromthe above clauses if and only if the first-order term (allX\ (B X => A X)) is logically entailed by the primitive sub-sumption relations.
Furthermore, any sound and completeinterpreter for AProlog (such as one searching breath-first)may be used together with these clauses to provide a soundand complete subsumption algorithm.Another kind of inference that is often of interest isthat of determining whether an object a is in the set ofobjects denoted by a concept C. This question reduces towhether (C a) is a theorem.
This inference may be encodedin definite clauses in the manner illustrated below:fac t  (important_message ml).fact (sender ml kirk).fact (recipient ml scotty).interp A :- fact A.253interp (A & B) :- interp A, interp B.interp (C U) :-subsume (X\(all Y\ (R X Y => C Y))) D.fact (R V U).
interp (D V).interp (C U) :- subsume C D. interp (D U).In the clauses above, fac t  and in terp  are predicates oftype b -> o.
The first few clauses tate which formulasof type b should be considered true; ( fact  X) may beread as an assertion that X is true.
The last few clausesdefine in terp  to be a theorem-prover that uses subsumeand fac t  to deduce additional formulas of type b. Theonly clause that may need to be explained here is the thirdone pertaining to in terp .
This clause may be explained asfollows.
Let (D V) and (subsume (X\(all Y\ (R X Y => CY) )) D) be true.
By virtue of the meaning of subsumption,((Xk(all Y\ (R X Y => C Y))) V),i.e.
(all Y\ (R VY => C Y)), is true.
From this it follows that for any Uif (R V U) is true then so is (C U).
Given the clauses inthis section, some of the inferences that are possible are thefollowing: kirk is a person and a commander, and scottyis a crew and a person.
That is, (interp (person kirk) ),for example, is provable from these definite clauses.7.
Syntax  and  Semant ics  in Pars ingIn Section 5, we showed how sentences and phrasescould be translated into logical forms that correspond totheir meaning.
Such logical forms are well defined objectsin our language and in Section 6 we illustrated the possibil-ity of defining logical inferences on such objects.
There areparsing problems which require semantical nalysis as wellas syntactic analysis and our language provides the abilityto combine such analyses in one computational framework.A common approach in natural language understandingsystems is to use one computational paradigm for syntacticanalysis (e.g.
DCGs, ATNs) and another one for seman-tic analysis (e.g.
frames, semantic nets).
An integration ofthese two paradigms is often difficult to explain in a for-mal sense.
Using the approach that we suggest here alsoresults in the syntactic and semantic processing being doneat two different levels: one is first-order and the other ishigher-order.
Bridging these two levels, however, can bevery natural.
For example, the query (see Section 4)rel R. R john marymixes both aspects.
The process of determining a suitableinstantiation for R is second-order, while the process of de-termining whether or not (R john mary) is provable isfirst-order.The problem of determining referents for pronounsprovides a example where such an intermixing of levels isnecessary, since possible referents for a pronoun must bechecked for membership in the male or female concepts.For example, consider the following sentences: "John likesMary.
She loves him."
The problem here is that of identify-ing "she" with Mary and "him" with John.
This processingcould be done in the following fashion: First, a DCG similarto the one in Section 5 could be written which returns notonly the logical form corresponding to a sentence but alsoa list of possible referents for pronouns that occur later.
Inthis example, the list of proper nouns \[ john.
mary\] wouldbe returned.
When pronouns are encountered, the DCGwould substitute some male or female elements from thislist, depending on the gender of the pronoun.
The processof selecting an appropriate referent may be accomplishedwith the following clauses:prim_concept male.prim_concept female.fact (female mary).fact (male john).select G X \[XIL\] :- interp (G X).select G X \[YIL\] :- select X L G.A call to the goal (select female X \[john, mary\] ) wouldresult in picking mary as a female from the set of propernouns.
This is, of course, a very simple example.
Thisframework, however, supports the following extension.Let sentences contain definite descriptions.
Considerthe following sentences: "The uncle whose children are alldoctors likes Mary.
She loves him."
Here, "him" clearlyrefers to the uncle whose children are all doctors.
In orderto modify our above program we need to make only a fewadditions.
First, we need to be able to take a concept,such as "uncle whose children are all doctors" and encodethe (unique) individual within it.
To do this, we use thedefinite description operator described in Section 5.
Hence,after parsing the first sentence, the list\[(iota (X\(uncle X(all Y\ (child X Y => doctor Y)) ))) .mary\]would be returned as the list of possible pronoun references.Consider the following additional definite clauses.prim_concept man.prim_concept uncle.prim_concept doctor.prim_relation child.subsume male man.subsume man uncle.interp (P (iota Q)) :- subsume P Q.The first six clauses give properties to some of the lexicalitems in this sentence.
Only the last clause is an additionto our actual program.
This clause, however, is very im-portant since it is one of those simple and elegant ways inwhich the different logical levels can be related.
A termof the form ( io ta  Q) represents a first-order individual(i.e.
some object), but it does so by carrying with it a de-scription of that object (the concept Q).
This descriptioncan be invoked by the following inference: the Q is a P ifall qs are Ps.
Hence, checking membership in a concept istransformed into a check for subsumption.To find a referent for "him" in our example sentences,the goal(select male X\[(iota (X\(uncle X &(all Y\(child X Y => doctor Y))))).mary\] )254would be used to pick the male from the list of possiblepronoun references.
(Notice here that X occurs both freeand bound in this query.)
In attempting to satisfy thisgoal, the goal(Interp(male (iota (X\(uncle X k(all Y\(child X Y => doctor Y)))))))and then the goal(subsume male (X\(uncle X a(all Y\(child X Y => doctor Y)))))would be attempted.
This last goal is clearly satisfied pro-viding a suitable referent for the pronoun "him."8.
Compi l ing  into F i r s t -Order  LogicWe have suggested that higher-order logic can be usedto provide a formal specification and justification of certaincomputations involving meanings and parsing.
We havebeen concerned with explaining a logic programming ap-proach to integrating syntactic and semantic processing.Higher-order logic is, of course, not needed to perform suchcomputations.
In fact, once we have specified algorithms inthis higher-order setting, it is occasionally the case that afirst-order e-implementation is possible.
For example, allthe specifications in Section 6 can be transformed or "com-piled" into first-order definite clauses.
One way of perform-ing such a compilation is to define the following constantsto be the corresponding A-terms:and C\D\X\(C X & D X)restr RkC\X\(all Y\(R X Y => C Y))Using these definitions, the clauses for role, concept, andsubsume may be rewritten as the following:role R :- prim_role R.concept C :- prlm_concept C.concept (and CI C2) :- concept C1, concept C2.concept (restr R CI) :- concept Cl, role R.subsume C C.subsume A B :- subsume A C. subsume C B.subsume (and A B) C :- subsume A C. subsume B C.subsume A (and B C) :- subsume A B.subsume A (and B C) :- subsume A C.subsume (restr R A) (restr R B) :- subsume A B.Introducing the notion of an element of a concept is lessstraightforward.
In order to do this, we need to first differ-entiate between a fact that states membership in a conceptand a fact that states a relationship between two elements.We do this by making the following additional definitions:is_a C\X\(fact (C X))related R\X\Y\(fact (R X Y))If we assume that in terp  is only used to decide membershipin concepts, then we may replace ( in terp  (C X)) by ( i s  aC X).
The remaining clauses in Section 6 can be translatedinto the following:is_a important_message ml.related sender ml kirk.related recipient ml scotty.is a (and A B) X :- is_a A X. is_a B X.is_a C U :- subsume (restr R C) D.related R V U. is_a D V.is_a C U :- subsume C D, is_a D U.The resulting first-order program is isomorphic to the orig-inal, higher-order program.
The subsumption algorithm in\[3\] is essentially the one specified by the clauses that definesubsume.
There are two important points to make regard-ing this program, however.
First, to correctly specify itsmeaning, one needs to develop the machinery of the higher-order program which we first presented.
Second, this lat-ter program represents a compilation of the first program.This compilation relys on simplifing the representation fconcepts and roles to a point where their logical structureis no longer apparent.
As a result, it would be harder toextend this program with new forms of concepts, roles andinferences that involves them.
The original program, how-ever, is easy to extend.Another way to see this comparison is to say that thehigher-order program is the formal semantics of the first-order program.
This way of looking at semantics is verysimilar to the denotational pproach to specifying programlanguage semantics.
There, the correct understanding ofvery simple, low level programming features might involveconstructions which are higher-order and functional in na-ture.9.
Conc lus ionsOur goal in this paper was to argue that higher-orderlogic has a meaningful role to play in computational lin-guistics.
Towards this end, we have described a version ofdefinite clauses based on higher-order logic and presentedseveral examples that illustrate their possible use in a nat-ural language understanding system.
We have built an ex-perimental, depth-first interpreter for AProlog on which wehave tested all the programs that appear in this paper (andmany others).
We are currently working on the design andimplemention of an efficient interpreter for this program-ming language.255References\[1\] Peter B. Andrews, "Resolution in Type Theory," Jour-nal of Symbolic Logic 36 (1971), 414 - 432.\[21 Peter B. Andrews, Dale A. Miller, Eve Longini Cohen,Frank Pfenning, "Automating Higher-Order Logic" inAutomated Theorem Proving: After '25 Years, AMSContemporary Mathematics Series 29 (1984).\[3\] Ronald J. Brachman, Hector J. Levesque, "The Trac-tability of Subsumption in Frame-based DescriptionLanguages" in the Proceedings of the National Con-ference on Artificial Intelligence, AAAI 1984, 34 - 37.\[4\] Ronald J. Brachman, James G. Schmolze, "An Over-view of the KL-ONE Knowledge Representation Sys-tem," Cognitive Science 9 (1985), 171 - 216.\[5\] Alonzo Church, "A Formulation of the Simple Theoryof Types," Journal of Symbolic Logic 5 (1940), 56 -68.\[6\] David R. Dowty, Robert E. Wall, Stanley Peters, Intro-duction to Montague Semantics, D. Reidel PublishingCo., 1981.\[7\] Michael J. Gordon, Arthur J. Milner, Christopher P.Wadsworth, Edinburgh LCF, Springer-Verlag LectureNotes in Computer Science No.
78, 1979.\[8\] Gdrard P. Huet, "A Unification Algorithm for TypedA-calculus," Theoretical Computer Science 1 (1975),27 - 57.\[9\] Dale A. Miller, Gopalan Nadathur, "Higher-orderLogic Programming," in the Proceedings of the ThirdInternational Logic Programming Conference, Impe-rial College, London England, July 1986.\[10\] F. C. N. Pereira, D. H. D. Warren, "Definite ClauseGrammars for Language Analysis - A Survey of theFormalism and a Comparison with Augmented Tran-sition Networks" in Artificial Intelligence 13 (1980).\[11\] David Scott Warren, "Using A-Calculus to RepresentMeaning in Logic Grammars" in the Proceedings ofthe 21st Annual Meeting of the Association for Com-putational Linguistics, June 1983, 51 - 56.256
