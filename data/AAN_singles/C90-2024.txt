Contribution of a Category Hierarchy to the Robustness ofSyntactic Parsing.Damien GENTHIAI~, Jacques COURTIN, lr6ne KOWARSKILaboratoire de g6nie informatique ?lmag Campus ?
BP53XF-38041 GRENOBLE CEDEX - FranceT61 : 76 51 48 78E-Mail : courti.
@imag.imag.frcourtin@imag.UUCPAbstradWe describe how the use o1' at hierarchy oflexical categories instead of a simple set ofcategories leads to the definition of a flexibleand precise language for the description ofdependency structures.
After specifying thet'ormalism we use to decorate these structures,we present an application aiming to detect andcorrect en'ors in a written text.
We outline howtile use of the hierarchy irnproves themanii)ulation of unknown words.\]i. it - troductionThe work presented in this paper is part of anat)re general project which aims towards acomplete system for detection and corrcctio~ oferrors i~ a written text.
Our interes~ here is tit(:creation of a syritactic--semantic module whichbuilds depenttency structures decorated withattribute.-pairs li ts integrating a mechanism forthe inheritance of properties.
We show thecontribtltion of hierarchisation of lexicalcategories to the constructi(m of syntacticalstructures.2.
Construction of dependencystructuresDependency structures are trees which give adescription of the structure of a sentence byestablishing direct links be|wcen the words (orlexical items : the terminal symbols according loconstituent grammars).
The idea is that thestructure of a phrase can be thought of as aparticular word (the head or governor) modifiedby' the other words (the modif iers ordependents).
Dependents can themselves bemodified to produce a tree strucure : thegovernor as root and dependents as his sons.Complex intormation (e.g.
syntactic functionsor semantic relationships) can easily be addedon the links of such trees and rules ofagreement are conveniently expressed.
Forexample, in French, the agreement in genderand number betweeen a noun and its determinerand adjectives implies the same gender andnumber for both the dependents (determinerand adjectives) and their governor (noun).
Onthe other hand, it is difficult to express ptn'aseproperties on dependency structures, becausethe properties of a phrase governed by a wordat(: not necessarily limited to the properties ofthe word alone.In order to describe such structures, we writebinmy relations in "governor-dependent" form.The formalism proposed by Tesni~.res \[120\](dependermy grammars) is very precisE, but allpossible arrangements of the dependents of agovernor must be described.
In Courtin's work\[8\], weighted ependency relations are defined,which are well suited to computation, butlimited in power of expression.We have attempted to design a language for thedescription of dependency structures retainingthe precision of grammars,  but moreappropriate for automatic treatment.To build these structures, we must be able todetermine, for any two words, caracterized bytheir lexical category : det, noun, verb .
.
.
.
.which one governs tile other.
More generally,given two dependency trees, we must knowhow to merge them into a unique tree.t!~,xample : 1s, eL det  ad jWe have defined a language based on rewritingrules ; each rule applies to a dependency forestand produces a dependency tree.
A set of such|Examples given are simple English adaptations of tileFrench originals139rules constitutes a dependency grammar, whichcan be applied to a sentence by means of aninterpreter.
This interpreter can be viewed as au'ee-transducer.Example of a simple rule : (the "--" beginscomments)N V \[ -- Name(~:{N}, (0, SF :{P})2 :{V})  -- Fores t=>( ( i, SF ) 2 ) - -Resu l t ing  t ree\]This rule applies to any forest which includes asequence of an N and a V, whose leftdependents are only preverbal particles P. Itbuilds a new tree where the N is added as adependent of the v.The advantage of these rules, compared tosimple binary relations, is that it is possible toexpress the context of each category whichappears.
It is thus possible to restrict agovernor to one or two dependents only, or toforbid more than one occurrence of a givencategory .... One can also define linked pairs ofbinary relat ions,  as for coord inat ionconjunctions:N coon \[(T ' ""~ :{N}, ~:~coco} ,  ~:t_, ~):>{ ( 1 ) 2 3 ) )\]On the other hand, they present he drawbackof the primitive dependency grammars : therenmst be a rule for almost every pair of lexicalcategories (LC).
To avoid this problem, wehave chosen to use a hierarchy of LCs insteadof the usual linear set of LCs.
This hierarchy isa set, partially ordered by the ?s-a  relation(Figure 1).CLSN \/ Aenoun xbe xhave  verb  pastp  adjFigure 1 ?
Example of hierarchyWe can, in this manner, express very generalrules like the two given above (N V andN coco)  or more specific ones like 'a u x_pp a s \[( l :{xbe ; xhave},  2 :{pastp  )=>( ( 1 ) 2 )\]Thanks to i .s-a ( { cnoun,  pnoun }, N) andi s -a  ( {xbe, xhave ,  verb ,  pas tp  } , V)relations, the N_V rule for instance rnay beapplied to all the following pairs of categories :(cnoun, xbe) (pnoun, xbe)(cnoun, xhave)  (pnoun, xhave)(cnoun, verb) (pnoun, verb)(cnoun, pastp)  (pnoun, pas tp)We can thus define a set of basic categorieswhich describe words in a very specific way,and use these categories for lexical indexing.The categories can then be grouped in "meta-categories" according to the structures we wantto build.
Finally, we can write the rules whicheffectively build these structures.By using this method, we can avoid the usualcompromise between a very fine set of LCs(which multiplies morphological ambiguitiesand syntactic rules ) and a very general set(which multiplies syntactic ambiguities).
Wealso obtain a fairly robust syntactic parsing : allunknown words are given the most generalcategory (CLS), to which any rule carl apply(see ?4).Similar type hierarchies have already been usedin work on language semantics to represent thetaxonomy of semantic types.
We shall thereforeuse the same formalism for the representationof syntactic and semm\]tic knowledge.3.
Type hierarchies and'e-termsWe have chosen to represent knowledge aboutwords and trees with a unique formalism ' q'-terms \[2\].q'-terms are case frame structures which permitthe description of types (in the sense ofclassical programming languages such asPascal), i.e.
sets of values.
~-terrns aredirected graphs (Figure 2) in which nodes aresymbols associated to fundamental types(simple types) and arcs are labelled withattribute symbols.
Each node of the graphincludes a reference tag which can be used todesignate it, thus allowing information to beshared.Simple types are defined in the signature whichis a set partially ordered by the i s -a  relation.This order is extended to q'-terms by the uniqueoperation used to manipulate them : unification\[1, 2\].
The unification of two simple types is1402defined as the set of lower bounds of these twotypes; (in the 2 s - a relation).Ser\[i #sere pat.
ientLinear R.?m :"tJL (J.
@X --> "e&tS" ;cdt7 > ve  zl~' ;sub j  ~:> Uh(sem ':> S :ANIMATE)  ;ob j  , :>  UL  (so ;a  : > O:Y .A '2AB ' .
I;;) ;sere :=> ?NGggT(agent :  :>  g;pat : Jent  > O) )Figure 2 ?
Example of %l:crmUHification al lows implicit irwheritancc ofproperties, and can be ?iTiciently implementedI31.Exmnple of unification ?The two tlJoterms "Uf,(i_ex :>  "dr)g";CaL  : > cr~our%;nbr  -.> s in ;gnu: > re<is;sere  -,:> CA~iqi N:<)UL(cat  : > ,L;sere  : :>  ANIMATP: )unify as"UL( ieN : > "d<)g";C~\]L  -:> Cr lOt ID ;9~r  > mas  ;nbr  > s in ;sere :>  CANINE)under the condition that the associated signatureuni f ies C A N I N E  and A N I M A T E  asCAN I NE .We can del'ine a sel-senmntics on simple types\[1, 191\] ; this semantics can be extended to 't'-terms giving the fol lowing interpretation ofunif ication : if Pl and P2 are two T - te rmsdescribing respectively two sets el and e2 ofvalues, then unification o f  two q'-terms L\](pl,P2) describes the set e lne2 .To t ransduct ion  rules we have addedexpressions which enable us to test and modify'v - te rms at tached to the trees we aremanipulat ing.
We can thus s imultaneouslybuild a syntactic structure (dependency tree)and a semantic structure ( f - te rm,  which alsoconta ins  morpho log ica l  and syntact ica linformation).Example of rules ~md application 'We have two words ?UL ( ?~e>:  ::'~- "co  g~" ;C&t  ::7 (;~l{;,~J~5i ;sere  => CANINE)rTT =:> I t{  .
~ c.  11 ?
,.:?
( \] ~ :< ..~ct, .~- ;".:at.
: > v~.~b;UL(sem ::> ~,c':AN2MATI:) ;ob I =>UL  {s.em ::=> O:\]~ATAJ~L}L) ;seiI'L =:> 1 ~':f'\]'?~''~,o.
',,.0 L (=~ge?/C.
=:> S;\]{:)~.t ient  : :>  O)  )and lhe rule "s 'cb j ( - c t : .
\[ (\].
: {N},  2 :  4V})/',;:~:i.
~: I ,  2 sub) )  ~' ~ ~ .
.
.
.
?
. "
,.. O\[i(._,_ L .1 (9,~ ::2>( ( i 2 ) ;..... ' "  c;bi .
. "
.
.
.
.
.
z~o.
:~; (2  sub  \ ] ,  i , Ac t  : i onsJThe root of the resulting tree is decorated by ?U\[, ( I(',",1 :> "C'~\[L~";<:t&L  :> L '  @ E \ ] : )  ;su i : ;  \] : :>  UL( Iox  .... > , ,Hr~, , .t~ l l<;  <x**  jsere  --:> ,~ ~' :CANINE; )  ;ob ::> UL(sem => O:EATABLE)  ;sere => \ ] :NGEST (agorzt => f_;;oaLJeri!
; ::> O) )4.
Applticafio as : a robusparser of French andsyamcticait vcril\[ica  oWe have implemented on a microcomputer aprototype of the dependency-tree transducer.This prototype is integrated in a system fordetection and correction of errors in a writtentext as a syntactic filter (Figure 3) oThe prototype uses an algor i thm for theappl icat ion of rules adapted to syntactic.-semantic parsing ?
the text is pmsed from left toright ; each time a word is recognized by themorphological parser, it is transmitted to thesyntactic module which includes it in the1413current state of the analysis.
This state isrepresented by a list of dependency forests towhich the transducer tries to attach the newword, according to the rules.Sentence  (Text)Morpho l .Pars ing  IUnknown wordsE 1Hypothes isGenerator  Cor rec t  wordsHypotheses~yn~act icF i it e rI~JSyntact  i co -semant ic  s t ruc turesFigure 3 : ArchitectureIf part of the entry string is not recognized, it ispassed on to the hypothesis-generator whichattempts to correct it by means of threetechniques (skeleton key \[1611, phonetics \[9\],and morphological generation \[7\]).
Thehypotheses are then passed on to the syntacticmodule which handles them exactly in the sameway as morphological mbiguities.
It must benoted that the three modules can functionalmost simultaneously (pipe-line) and that thehypothes is -generator  always transmitssomething to the syntactic module.If a word is so ill-formed as to render itscorrection impossible, tile hierarchical structureof categories can be used to transmit he mostgeneral possible word, i.e.
?
UL (cat :> CLS).Any rule can apply to CLS (which is tile mostgeneral category), so the choice of the rule to beapplied i,; determined only by the context of theunknown word, and this rule will in turndetermine which category the word should havehad.Example"With a forest such as ?
( l :{cnoun},  2 :{coco} ,  3: CLS} )we shall obtain ?
( ( l :{cnoun})  2 :{coco}  (3 {N}) )after applying the rule N_coco .The syntactic filter works like a parser but doesnot take into account agreement in number andgender between words.
A specialized module incharge of verification of these agreements inow being designed.
A prototype of such amodule has been implemented in Prolog ; itdetects agreement mistakes and can proposecorrections by means of a morphologicalgenerator.
We are now working on rewriting itin tile transducer language.The main use of the syntactic filter is thereforeto validate the lexical category of thehypotheses generated by the lexical corrector bybuilding dependency trees which take intoaccount the semantic information attached to thewords.Example"With the phrase "sun and  moun"  we obtainthe following hypotheses for moun :UL( Iex  => "morn";cat => cnoun;sem => TIME)UL( lex  => "moon";cat :> cnoun;sem :> CELEST IAL -OBJECT)UL( iex  => "mount" ;cat => verb;subj  => UL(sem => S:ANIM, hTED) ;obj  => UL(sem => O:PLACE} ;sem :> MOVE (agent => S ;where  => O))Each of these hypotheses is considered aninterpretation f the unknown word moun.The rule of coordination isN coco  \[ (I:{N}, 2 :{coco} ,  3:{N})/Un i f ( l .
sem,  3 .sem) /=>( (  i )2  ( 3 ) ) ;ASS iGN(2 .sem,  Un i f ( l .
sem,  3.sere));ASS IGN(2  .nbr, plu)\]with for sun  :UL( lex  => "sun";cat => cnoun;sem => CELEST IAL -OBJECT)  .The rule cannot be applied to mount  because averb is not a N. It can only be applied to thenoun moon by unification of the senianticfeatures of moon and sun .With a phrase such as "sun  and  mizrn" ,the hypothesis generator gives for mi zrn  :UL(cat  => CLS)The application of the rule N_coco  will givethe tree of the figure 4.5.
ConclusionThe use of a category hierarchy simplifies thewriting of the rules and introduces a way ofmanipulating unknown words which is not partof the mechanisms of the system but which is142 4integrated in the objects it manipulates.
We canthen write rules without thinking about ill-formedness (i.e.
it is not necessary to make therules tolerant because the tolerance is implicit inthe system).UL(Ie:< => "and" ;C~C =:> COCO;nbr  > p lu ;sem =>CELEST IAL -OBJECT)/ kUL( lex  -> "and" ;  UL(cat  : > N)cat  => coco ;sem :>CELEST IAL -OBJECT)Figure 4 : Decorated treeThe throe modules have each been implementedon a microcomputer, we are now working onintegrating the three modules and adding themodule for agreement verification.
We are alsoimproving the performance of the transducer :- by integrating a factorization technique for theintermediate forests in the form of a graph-structured stack \[21 \],- by adding a finer control (graph of ruleapplication) precomputed atcompilation time.Refi.
rencesI1\] : H. A'it KaciAn Algebrai'c Approach to the eJ'\['ectiveresolution of type equations.Theoretical Computer Science 45, 1986, pp293--351\[2\] : H. Ait Kaci, P. LincolnLIFE ."
A natural language for naturallanguage.MCC Technical Report, Number ACA-ST-074-88, February 88\[3\] : H. A'it Kaci et alEjficient implementation o./' LatticeOperations,ACM Transactions on ProgrammingLanguages and Systems l l : l ,  1989, pp116-146\[4\] :C.  BoitetRepresentation a d computation of units oftranslation for Machine Interpretation ofspoken texts.GETA & ATR Technical Report TR-I-0035,August 88\[5\] : J.G.
Carbonell  & P.J.
HayesRecovery Strategies forExtragrammatical Language.AJCL 9:3-4, 1983Parsing\[6\] : E. ChaJ'niakOn the use of framedlanguage comprehension.AI 11, 1978.knowledge for\[7\] : B. CohardLogiciel de d~tection et de correction deserreurs lexicales.Mdmoire CNAM, Mars 1988\[8\] :J. CourtinAlgorithmes pour le traitement interactif deslangues tmturelles.Th6se d'dtat, USMG, Octobre 1977\[9\] : J. Courtin, D. Dujardin, I. Kowarski, D.Genthial, V. L. Strube de LimaCorreqdo de erros de ortografia atrav~s dafondtica em textos escritos em franc~s.XIV Conferencia Latinoamericana deInform~.tica, 17avas Jornadas Argentinas deInformfitica e Investigacidn Operativa,Buenos Aires, Sep. 1988. pp 873-891.\[10\] : J. Courtin, D. Dujardin, I. Kowarski, D.Genthial, V. L. Strube de LimaInteractive Multi-Level Systems forCorrection of Ill-Formed French Texts.Proceedings of the 2 nd ScandinavianConference on Artificial Intelligence,Tampere, Finland, June 1989\[11\] : L. Emirkanianl L. BouchardKnowledge integration in a robust andefficient morpho-syntactic analyser forFrench.12 th CoLing, Budapest, August 1988, pp166-171.\[12\] : J. P. Fournier, J. V6ronisTraitement des erreurs dans lacommunication homme-machine en langagenaturel.Acres des premi6res journ6es nationales duGRECO-PRC Communication Homme-Machine, Paris, Novembre 885 143\[13\] : R.H. GrangerThe NOMAD System : Expectation-BasedDetection and Correction of Errors duringUnderstanding of Syntactically andSermmtically Ill-Formed Text.AJCL 9:3-4, 1983, pp 188-196,\[14\] : Peter Hel lwigDependency Unification Grammar11 th CoLing, Bonn, August 1986, 195-198.\[15\] : G. Lapalme, D. RichardUn systOme de correction automatique desaccords desparticipes passes.Techniques et Sciences Informatiques, 41986\[16\] : J. J. Pollock & A. ZamoraAutomatic' spelling correction in scientti\[i'cand scholarly text.CACM 27:4, 1984\[17\] : D. ScottData Types as Lattices.SIAM Journal on Computing 5:3, 1976, pp522-587\[18\] : S. M. ShieberAn Introduction to Unification-BasedApproach to Grammar.CSLI Lecture Notes 4, 1986\[19\] : G. Smolka and H. A'/t-Kaciinheritance IIierarchies : Semantics andUnification.Journal of Symbolic Computation 7, 1989,pp 343-370\[20\] : Tesni6resEldments de syntaxe structurale.Klincksiek, Paris, 1959\[21\] :M. TomitaGraph-structured Stack and NaturalLanguage Parsing.Proceedings of the 26 th Annual Meeting ofthe ACL, Buffalo, USA, June 88\[22\] : R. Zajac, M. EmeleMultiple Inheritance in RETIF.Report of the ATR Interpreting TelephonyResearch Laboratories.1446
