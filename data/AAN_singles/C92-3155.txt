JD Ih Pars ing I ta l ian  w i th  a Robust  Constra int  GrammarANDREA BOLIOLI LtJC'A DINI ( ; IOVANNI MALNATIDims LogicC.so Turat i  1 l /c ,  10128 Tor ino  Italyfax + +39-11-501618Abst rac tItalian is a language presenting a lot of syntacticalproblems, sucb as a rather unrestricted word order,unbounded agreement controls, long distancestructure checkings and so on.
Things get worse andworse if we pass from "sentences of linguists" to realtexts.
In this paper we will present a system able toretrieve and signal syntactic errors in real italian texts.I Introduct ionWe are going to present a system by whichsyntactical errors of Italian can be recognized andsignalled.
This system is called JDII (James Dean thesecond) and has been developed in Turin by DIMALOGIC.JDII can accept wrong Italian sentences, evenlong and complex ones, and it returns a commenton the type of the detected mistake(s), if any.
Acorpus of 400 grammatical sentences (from aminimum of 4 words to a maximum of 40 words) andpossible ungrammatical variants has been used totest the system.
The sentences contain thegrammatical phenomena treated by the grammar(see below).
The system is implemented in PROLOGand C. It runs on UNIX and DOS environments?The modularity of the system is guaranteed by thedivision of linguistic and software knowledge intotwo indipendent modules.
The linguistic module isroughly made of a morphological component and asyntactic one, while the computational framework(DIMACheck, cf.
chapter 3) is mainly based on aparser and on a theorem prover.
Software resourcesare shared with another syntax checker, aiming atan analogous system for the English.2 Process ing  er rors2.1 Error interpretatitmAn error is a violation of some constraint posed bylinguistic rules on the language The violation ofthese constraints causes, according to standardclassification, spelling, morphological, syntacticand semantic errors.
This classification, which is stilluseful in defining the nature of linguistic violationsfrom an informal point of view, poses some problemsin an authomatic treatment of errors.
The fact is thatan error can be properly classified only on the basisof writer's intentions.
For example, in a sentence like1 ) * Ho scritto una lettera a un ponte t1 wro \ [c  a IcUcr to a bridgeWe could assume:a semantic error, since people generally do notwrite letters to bridges;- a syntactic error, since locative complements withwords like ponte are realized by differentprepositions (sotto, su) :- a spelling error, if the writer had not wanted towrite ponte, but conte ("earl").The fact is that people correcting texts usually havea pragmatic context which allows mistakesdisambiguation.
For "context" we mean allthe background information concerning the writer,the external conditions when the text was written and, above all, the kind of facts and things which tile textdeals with.
(Consider,  e.g.
.
the di f ferentinterpretations of a sentence like 1 if it were foundin the answer of a fool to a psychological test, ina novel about ancient chivalry, or in some essaytitled 'Which is the best place for writing a letter?
').Since we are not able to handle contextualknowledge for error disambiguation, we decided, forour purposes, to drop the classification, and to makeuse of the notion of error interpretation: "Given awrong sentence, an error interpretation is anyhypothesis of substitution in order to make thesentence correct".In correction performed by humans, the numberof error interpretations is constrained bypragmatical and contextual data.
In authomaticdetection this number is linked to the capacity ofammitting constraint violations on the rules.
In theworst case (i.e.
when all the constraints, includinglexical constraints, are allowed to be violated)theset of error interpretations is infinite.2,2 l Jerils rtf tilt' systemTo get out from this empasse we chose toconstrain the possible violations allowed by ourgrammar just to syntactic ones.
We could also dealwith spelling corrections by including a small setof incorrect variants for some words.
This wouldreveal meaningful only by tuning the system on thespecific linguistic background of the user (in factdifferent mispellings are made by people speakingdifferent languages and with different degrees ofinstruction).
As for semantic errors we are not able todeal with contexts, so they are simply ignored and'~ English translations will be word by word In the last chapterwe dont  provide any translation, since ill formed phrases andsentences exemplifying the coverage are language specificAcr~ DE COLING-92, NANTES, 23-28 AOUT 1992 l 003 PRec.
OF COLING-92, NANTES, AUG, 23-28, 1992sentences like 1 are considered correct (and in factthey are, see e.g a context like Giovanni e'impazzito: dice di aver scritto una lettera a unponte)..To sum up, in our system the error checking worksas follows :1) If a word is found the root of which is notpresent in the vocabolary or which cannot beproperly inflected, the message "unkown word isreported.2) If a word is found which is included only in theset of the uncorrect variants, the morphology willreturn to the grammar the texical unit properlyinflected, but containing e violated constraint.3)If all the words in a sentence have beenanalized by the morphological module, the syntacticprocessing starts.4) As we will see, the syntactic parsing willproduce either a comment on the grammaticality ofthe sentence or a general refuse of it ( i.e.
a genericerror such as "unknown grammatical structure").Ha visto un crane - > Unknown word (crane)A visto un cane - > Spelling error (a missing h)Ha visto una cane - > Syntactic error (agreement)Ha visto cane uno - > Unknown structure2.~ Principles el' error diagnosisIn the previous paragraph we stated that ourattention will be drawn only to syntactic violations.However, this limitation does not solve the problemof multiple error interpretations at all, since,even from a purely syntactic point of view, a sentencecan be wrong in different ways.
Let us consider asentence like:2) * 11 ragazzo e' slala af.fettt~oso.Ihc(masc) hey(mast) has hccn(fcm) lovely(mac, )We have at least wo hypotheses of correction:2.a) II ragaz2o c'statO ~f,J?~llltoSO.thc(masc) boy(mast) has bccn(masc) lovely(mast)2.b ) LA ragaz'Jt c'stata qffelluosA.the(fern) girl(Ion) has bccrl(fctn) lovely(f tin)If we take into account psychological plausibility,we should signal only the error on the word stata.This and other data support a principle in errorcorrection which states that "given a set of possibleerror interpretations, the right error interpretation isthe one with the smallest number of violatedconstraints ".
This principle has been implemented asa built-in preference mechanism over the set ofpossible final interpretations, while the set itself isrestricted by the power of the grammar.
Therestriction is obtained by implementing peculiarlinguistic statements thati) impose linguistically plausible criteria rather thanstatistical ones;ii) prevent that the explosion of all the possibleerror interpretations makes the system completelyinefficient.An application of the above criteria is provided bythe sentence:3) * It ragazzo chc c'slal(l picchiata dai fa,~cisti sla male.the(mast) boy(mast) who has been(lore) hit(fen1) hyt'ascisls i  sufferingwhere we can hypothesize two agreementviolations either in the subject NP or in the VP of therelative clause.
In this case our system allows us tostate that agreement features of the head will win onthe ones of the modifiers, so that a genderagreement error is signalled in the relative clause.3 D IMACheck  f rameworkDIMACheck is a general-purpose unification-basednatural language parser that, while retainingcomputational effectiveness and linguistic expressionpower, stresses the concepts of monotonicy,declarativity and robustness.
These goals areachieved, on the one hand, introducing severallinguistic devices, like weak constraints, user-definedoperators and functions, and on the other handenforcing strict data-type checking and implementinga t ime-independent evaluation function (theinterpreter of the rules) that guarantees a highexpressive power in a total ly declarat iveenvironment.In order to mantain readability and ease of use ofgrammars, only two kinds of rules have beenintroduced, namely structure building rules andlexical rules.3.1 User I)elined OperatorsWe think that a re-write system based only onequality constraints is inadequate to express linguisticknowledge, and the introduction of inequalityconstraints does not always solve the problem.
Inorder to augment the linguistic expressive powerwithout  incurr ing in redundancy  andcomputation-ineffectiveness we introduced thefollowing tool.
Formally a User Defined Operator(UDO) is function of the formBoolean <- DataTypcl '~ DalaTypc2i.e.
a UDO is a function mapping pairs of valuesbelonging respectively to DataTypel and DataType2onto boolean values.
The composition rule (the rulethat associates the relevant boolean value to eachpair) is given explicitly, by listing all the value pairs thatmap onto true (all the other ones are mappedautomatically onto false).3.2 User I)elieed FunctionsUser Defined Functions (UDFs) have beenintroduced to stress the locality of computation.
Thebasic idea is that each value inside a constraint (be itan equality constraint or not) may, in principle, bereplaced by a function that computes it on the basisof some given parameters.
So, whenever one mustcompute the value of an attribute which is known todepend on and only on a finite set of other features,AcrEs DE COLING-92, NANTES.
23-28 AOl~rr 1992 1 0 0 4 PROC.
OF COLING-92.
NANTES, AUt\].
23-28.
1992instead of writing lots of rules which embed (and hide)this piece of knowledge into a larger description, it ispossible to declare a UDF that manages thecomputation, thus reducing the number of rules frommany to one.Formally, a UDF is a function that maps values fromN data types into values of a given data type.
insymbols:TargetDataType - - OataType l*  *DataTypeNUDFs are declared explicitely, more or less likeUDOs: for each n-tuple of relevant values the resultvalue is stated.
UDFs need not to be deterministic: agiven pair of input parameters may map into morethan one target value.3.~ Constraint  and constraint bundle~As stated above parsing is, in our view, applyingcation a finite set of constraints over an input list ofwords.
We may therefore distinguish betweenstructural constraints (the ones that deal with theorder, the occurrences, etc.
of parse trees) andfeature constraints, that put restrictions on the valueof a given variable (the value of an attribute inside theparse tree), The former kind is described in paragraph34, while the latter, is described here.3.3.1 I)elinition of I,'eatm'e ConstraintA feature constraint, or simply a constraint, is a tripleof the form:< Operator, At|ributeName, ValueExpression -,Opcralor is the name of either a system definedoperator (' -,' and .... - ') or the name of a user-definodone (e.g.
'is a').AttribulcNamc is a legal name for an attribute, thetype of which matches the type foreseen by theoperator for its left- hand side.ValucExprcssion may bean atomic value- a single variable- a disjunction of atomic values- a user-defined functionIn our formalism a constraint is stated in an infixform (e.g.
'tense =, pres' or 'tense agreem tense' T or'tense compute tense(M,T)' ).When a constraint is applied 1o an object it mayevaluate either to true or to false: we can therefore saythat a constraint is a boolean function.
The way inwhich the result of the application of the constraint ishandled by the system leads to the distinctionbetween strong and weak constraints.3.\].2 Strong and weak conMrainlsA strong constraint is a constraint that, if it fails,causes a strong failure, i.e.
the object to which itapplied is rejected, When a strong constraintsucceeds nothing happens, apart from somepossible variable binding.
Strong constraints are usedmainly to prevent useless overgeneration overirrelevant paths.
(Usually, but not necessarily,constraints that involve the major syntactic categoriesare strong).
They are also used to propagate valuesfrom lower nodes to upper ones.A weak constraint is a constraint that behaves likea strong one if it evaluates to true , but whichotherwise produces a soft failure.
A soft failuresimply consists in recording in the object theinformation that a weak constraint has failed, withoutrejecting it.
In order to mantain trace of the failedconstraints, they are annotated by the user with anumber which is used at the end of parsing togenerate a proper error message irrdicating whichconstraint failed and where.
Apart from annotation,the syntax of weak constraints is the same of thestrong ones, and the same restriction applies.A constraint bundle (CB) is a list of conjunctedconstraints (both weak and strong).
Notationally, aCB is delimited by braces, single constraints areseparated by commas; a slash ('/') splits the list in twoparts: the strong one and the weak one.
If the weakpart is empty', the slash is omitted.
Here are someexamples of legal CB's:{ cat- np / (1) nb ~ N, (2) gd G}{ cat v:aux vlype .V/(81} cat v}{ cat = pp t3.3.3 Con,,,lJ'ainls s.lulionDuring parsing, the parse trees which are built arelabelled with a list of pending constraints - i.e.
ofconstraints that have not yet proved to be true orfalse- and a score .. i.e.
an indication of how manyweak constraints associated to the tree have alreadyproved to be false, Intuitively, the lower is the score,the better is the object.
The constraint solver appliesto the list of pending constraints of each final tree,trying to minimize the number of failed weakconstraints.
The constraint solver selects, as finalresult the tree with the smallest associated error It'sworth noting that this is a global strategy, not a localone.
All parse trees, independently of their score arecarried or\] up to the end of parsing, and only then theselection is made.
There are two reasons for thischoice.
The first one is theoretical: it is not possible toassume that a locally well formed subtree will lead toa better global tree than that produced by a locallyill-formed one.
The second reason is pragmatical:since constraints are solved only when the variablesthey involve get instantiated, partial trees tend tocontain few or no failed weak constraints but long listsof constraints still to be evaluated.
Applying theconstraint solver in the middle of parsing would be awaste of time, and making the choice disregarding the;)ending constraints is definitely wrong.3.4 ( ; rammatica l  rulesThe system operates or\] the input data driven byrules.
Rules mix together structure and featureconstraints in order to produce a quasi-well-formed(sub)tree (the 'quasi' is there because the subtree maycontain failed weak constraints: it would not be properAt'firs I)E COL1NG-92, NANTI~.S.
23-28 Ao~,r 1992 l 0 0 5 PRec.
ov COLING-92, N^N'I'I~S, Auo.
23-280 1992to call it a well.formed one).
Rules are handled by aparser in order to produce all possible results.Currently the system uses a bottom-up, left to rightalgorithm.
However the result is totally independentof the parsing strategy,Structure building rules (sb-rules) are augmentedrewrite rules used to describe the structure of quasiwell-formed subtrees.A sb-rule has the following form:<RuleName> = <TopConstrainteundle> =>< SubTreeExpre~sion 1 >.
"< SubTreeExpre~s ionN >.where:< RuleNamc > iS a legal unique identifier,< TopConslraintBundle > is a legal CB,< SubTrccExprcssion I.,N > are one of the following:-aCB,- a SubTree description (of any depth)- a regular expression over CBs like:'*'Exp : 0 or more occurrences of Exp' + 'Exp : 1 or more occurrences of Exp' ^  'Exp : 0 or 1 occurrences of ExpTExp : 0 or 1 occurrences of Exp(if 0 signal weak error)'?
'Exp : 0 or 1 occurrences of Exp(if 1 signal weak error)Expt,Exp2 : Expl followed by Exp2Expl ;Exp2 : Exp!
or Exp2The error associated to the newly built tree is the sumof the errors contained in all its subtrees plus theerrors originated by the appl ication of all theconstraints of the current rule, both in feature and instructure.
Here is an example of sb-rule:cNP in ter r  = {cat  = npp,qtype  = QT,wh = yes .wh nb  - N.wh_gender = G,nb = N,gender = Gquant = no,ntype = inter,}=>{cat = detp, ntype = interr/(2)gender = G(1)nb = N},?
(81) + {cat = detp},{cat = np,wh = no.nb = N,gender = G,qtype = QT/(67)ntype - = proper_not art;proper}Lexical rules are the interface between the externalrepresentations of words (i.e, strings) and the internalones (i.e.
CBs).
A lexical rules has the general form:<RuleName> = <ConstraintBundle>.where < RulcName > is a legal unique identifier and< CenstraintBundle > is a legal CB3.5 Merphulegi~l RulesIn the morphological rules, each root is associatedto a morphological class and to a lexieal rule.
Beforethe syntactical parsing starts every word in a sentencehas to be processed by the morphological module.The resulting CB is the union of the CB associated tothe ending of the word and the CB defined in thelexical rule associated to the root.4 L ingu is t i csJDII does not make strict use of any linguistictheory,  even if the guidel ines of theimplementation are, in a large number of cases, takenfrom theoretically well founded works (such asBurzio (1986) for the verbal system, Gazdar (1981)for comparative structures, Cinque (1988) forrelative clauses and so on).
On this respect we fullyagree with Dietmar Roesner when he says that"Theorist tend to restrict their approaches to thevery techniques available within their theories.
Inpractical NLP systems it may be fruitful to freelycombine elements from distinct "linguistic schools","Structurally a binary recursive X- BAR schema isfollowed.
The reason why a binary grammar is usedis that we lack of a dedicated kind of rule forperforming structural checking.
As a consequencethe computation of constraints depending either onthe occurrence or on the linear precedence ofoptional constituents would reveal very difficult.Indeed, since UDOs and UDFs are not allowed tocontain optional parameters, a non binary grammarcould handle strings likeX\[agreem oper(V1 V2)}- > Y *B ^  A\[sa = V1\] *B ^  A\[s_a = V2\](where 'agreem' depends on the values of 'VI' and'V2' and on the presence of 'A') only by explodingall the possible cases.
This huge and inefficientexplosion is avoided in a system of rules where 'X'is right recurslve and the 'agreem' value isupdated by an UDF when every new projectionis built:X\[agreem =default\].
>YX\[agreem =VAR0\] - > X\[agreem =VAR0\] BX\[ag teem = funct(VAR1 ,VAR2)\]- > X\[agreem =VARt \]A\[agreem =VAR2\]As for ambiguities, we are not interested inproducing all possible interpretations of asentence, Indeed the production of all semanticallyplausible parses would be out of the scope of asyntax checker, which is supposed to handle onlyambiguities relevant for error retrivial.4,1 Tlne coverageThe coverage of JDII includes:- main sentences, both affirmative or negative- argumental clauses playing the role of eithersubject or object- hypothetical clauses- comparative and consecutive clauses- prepositional clauses- relative clauses- participial clauses- gerundive clausesAs for the other constituents, we have a completetreatment for each possible phrasal projection ( AP's,ACr~DECOI.JNG-92, NAm'ES, 2.3-28 AOtTn" 1992 1006 PRec.
OF COLING.92, NANTES, AUG. 23-2.8, 1992NP's, VP's ...)Particular attention has been drawn to the followingphenomena:- quantification (e.g.
* tutte ragazze, * indite diragazze, * nessuno delle ragazze, ...)- determination (e.g.
* la Maria, * i cromi, * dellaragazza verra', ...)- coordination (e.g.
* la ragazza bells e sensuali, *taragazza e la sua arnica e' venuta, ...)- movementswh-movement (e.g.
* la ragazza che Andreaarea Maria, * la ragazza che dicono che e' stateamato, * la ragazza che dicono che dovrebbeessere state amato, ...)clitic climbing (e.g.
* fi ha amato, * li deveaver amato, * deve averh' amato, ...)- dislocationstopicalization in coordinate structure (eg.?
e' venuta Maria ma Moans, * Maria e' venota maMoans vs. non e' venota Maria ma Moans, 17011Maria e ' venuta ma Moana, ...)comparative structure (e.g.
* he date tantibaci ieri a Maria che a Moans vs. he date piu' baciiefl a Maria che a Moana, ...)In particular the last four phenomena worked as atest bench in order to check the power and theefficency of the formalismw.r.t, hard tasks, such asunbounded distance structure checking, longdistance agreement, discontinuous patterns and soon.On the contrary the formalism proved to beinadequate to tackle context sensitive phenomenasuch as ellipsis in coordination and comparison, whenmore than one constituent is bound by the deletedelement.
In these cases a principle does applywh ich  imposes  a context  sens i t ivecorrispondence (X Y Z W... X Y Z W....) between theconstituents in the second conjunct / comparativeclause and the ones in the main clause:4)Da'lfitt' baci Maria a Ugo chc schit(\[\[i Era a/_ ,caNP NP PP ... NP NP PP4.2 The errorsIn the following we give a description of the mainkinds of errors that our system is able to diagnose42.1 Spell ing er rorsIf a word is found whose root is not present in the setof roots or whose inflection is not in the properinflectional class, the message "unknow word' isgiven.
Unfortunately, if a word is mispelt in such away that the morphology will recognize it as a wordof another category (e.g.
ha visto un corro, wherecorro is mispelt for carro, but it is however presentin the morphology as the first singular person ofthe verb correre) the system is likely to produce ageneric "Unknown grammatical structure" message( indeed there are no grammatical rules able to dealwith complete ly  wrong structures, such as"Verb-det-Verb').
Just in a few cases we havespecific morphological rules which guess  a wronginterpretation of the input word (e.g.
e is interpretedalso as e' and a as ha).4.2.2 Inflectional violations.
* agreement on number, gender, person: e.g.subj  < - > verb ,  determiner  < - > nbar,c l i t i c<->past  part ic iple,  past par t i c ip le<->displaced quantifiers* case: it is controlled just when personalpronouns are involved* tense and mood agreement: main verb<->suburd inate  verb in hypothet ica l  clauses,consecutio temporum, adverbials < - > main verbs.4.2.3 Structura l  violations* missing elements: determiners in particularconstructions (*tutti documenti, *molti di letter\[),negation with particular adverbs ('tlo visto nessuno)* exceeding elements: repetition of determiners,wrong number of NP's with certain kinds of verbs(*Veronica collabora Veronica), repetition ofcertain adverbs (*collabora neppure solo) ....* wrong word order: position of the AP w.r.t, thenoun (*il chirurgico intervento), position of thequantifier w.r.t, the verb (*molto collabora),position of the adverb w.r.t, to the verb (*Veronicaneppure lavora)* wrong head-argument selection: selection ofthe complementizer in objective clauses (*Is vogliache amare), selection of the preposition inhead-shifting constructions...r t ' t ' l ?
I 't ' l l~'?~,eCarhonclLJ.,Haycs,P,"Rccevcry Strategies huparsing Kxtragranufi'alical Language' ,  inA,I('t.,1983.eDictn:ar Rocsncr  "Why i lnplcmcntors el pracli-cal NLP systems can not wail for lingub.licthc,.~rics", in Colir~g 88, 1988.eBtlr:, io,L, "Italian Syntax", 1986.oCinquc,(L,  "La frasc rclativa", in ( ; randc Gram-matica Italiana di Consultazionc.
t0~4S.e( ;azdar , ( ; .
, 'A  Phrase Slruclerc Synlax hlr ( 'pre-parative Clau.'.,c'-.
', in Hockstra,  T., van dcrtlulsl,\[I .
.
Moortgat,M.,cd: Lcxical (;raln-nla r, I ~;'S 1.eJcnscn,K,  cl al., "Parse fitling and Prose Fixing:(;cUing a Hold er.
I l l-\[ormcdncss", in A.I('L,,hf lv-Dcccmhcr 1983.eMcnzcI,W,,  "Error diagrmsis and sclcclhw: in atraining system l~.~r second language Icarlfillg", in(.
'tding 88, 1988.oShwiml,  C.,"Scnsitivc parsing:error analysis andexplanation in an intclligcnl language tulering:.,yslcm", in Coling 88, 1988.eThurmalr,('J.,"Parsing for Grammar  and Slylc('hocking", in Coling I;0, liF){I.ACTES DE COLING-92, NAturES, 23-28 ^ Ot~T 1992 1 O 0 7 PRec.
OF COLING-92, NANTES, AUG. 23-28, 1992
