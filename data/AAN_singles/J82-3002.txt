An Efficient Easily Adaptable Systemfor Interpreting Natural Language Queries 1David H. D. WarrenandFernando C. N. PereiraArt i f i c ia l  In te l l igence  CenterSRI  In ternat iona l333 Ravenswood AvenueMen lo  Park,  CA  94025This paper gives an overall account of a prototype natural language question answeringsystem, called Chat-80.
Chat-80 has been designed to be both efficient and easilyadaptable to a variety of applications.
The system is implemented entirely in Prolog, aprogramming language based on logic.
With the aid of a logic-based grammar formalismcalled extraposition grammars, Chat-80 translates English questions into the Prolog subsetof logic.
The resulting logical expression is then transformed by a planning algorithm intoefficient Prolog, cf.
"query optimisation" in a relational database.
Finally, the Prologform is executed to yield the answer.
On a domain of world geography, most questionswithin the English subset are answered in well under one second, including relativelycomplex queries.1.
IntroductionThis paper describes the results of a three-yearresearch project carried out by the two of us.
Theproject was directed towards the goal of providingpractical computer systems that will answer questionsexpressed in precisely defined subsets of natural lan-guage.
The results of our work are incorporated in arunning prototype system, called "Chat -80" .Two issues have particularly influenced the ap-proach we have taken, namely efficiency and portabili-ty.
Given the practical objective, we wanted toachieve rapid, interactive question answering, and wewanted the techniques to be easily adaptable to a vari-ety of applications, with as much of the implementa-tion code as possible being application independent(cf.
Konolige 1979).There has been no intention to try to handle unres-tricted natural language.
Given the current state ofthe art, we accept that users of a practical naturallanguage question answering system will have to learnhow to use a restricted natural language subset rele-1 This work was carried out in the Department of ArtificialIntelligence, University of Edinburgh, Scotland.vant to the particular application.
The important issueis whether they will find this more convenient han amore formal query language.
We believe that, formany purposes, a suitable natural language subset willbe much preferred, on grounds of conciseness and easeof typing alone (see the examples in Appendix III, forinstance).
It is fair to say that our objective is to soconstrain natural language that it becomes a formal,but user-friendly, query language.The starting point for our work was a questionanswering system for a small subset of Spanish imple-mented by Veronica Dahl 1981,1979, following theapproach advocated by Colmerauer 1978.
We wereparticularly attracted to Colmerauer's approach for theclear insight it gives into some of the essential prob-lems involved in constructing a practical natural lan-guage answering system, especially the problem ofcorrectly interpreting determiners.
In addition, itproved very easy to adapt Dahl's program to English(and to a different domain).
This was due in largepart to the fact that the system is implemented in Pro-log (Roussel 1975; Warren, Pereira, and Pereira1977), a programming language based on f irst-orderlogic.
To be more specific, the system is largely madeCopyright 1982 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial dvantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires a fee and/or specific permission.0362-613X/82/030110-13503.00110 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systemup of rules of the metamorphosis grammar (MG) for-malism (Colmerauer 1978), which map directly intothe Prolog subset of logic.
MGs are an extension of asimpler formalism to which we have given the namedefinite clause grammars (DCGs) (Pereira and Warren1980).We called the adapted program "Chat" .
Whenrunning compiled under DEC-10 Prolog (Warren 1979;Pereira, Pereira, and Warren 1978), Chat's speed atanalysing English sentences proved very satisfactory(under a tenth of a second of CPU time per sentence).Therefore this seemed a promising approach from thepoint of view of both efficiency and portability.
How-ever, we found that Chat has a number of shortcom-ings, the most serious of which is that the process ofanswering a question, once it has been analysed, ismuch too inefficient for any significant application.We have therefore written an entirely new pro-gram, Chat-80, which, like the original Chat, is imple-mented entirely in Prolog.
The main ways in whichChat-80 differs from its forerunner are:?
the semantics given to determiners, and the rules fordetermining their scopes,?
the process of planning and executing a query,?
the rather wider coverage of English,?
the use of extraposition grammars (XGs) in place ofMGs to handle certain " t ransformat ional"  aspectsof English,?
the way the natural language analysis is performedin three separate phases rather than one.In order to test the approach on a nontrivial do-main, Chat-80 includes a database of facts aboutworld geography, and a small vocabulary of Englishwords sufficient for querying the database.
This do-main has the advantage, for demonstration purposes,that the facts in the database are generally commonknowledge, so it is easier to appreciate what is entailedin answering different queries.
The database containsbasic facts about the world's countries (over 150 ofthem), oceans, major seas, major rivers, and majorcities.
The largest relation, 'borders' ,  represents allpairs of countries, oceans, or major seas that are adja-cent, and contains therefore over 850 tuples.
It shouldbe emphasised that the database is itself implementedas ordinary Prolog; it therefore resides within the nor-mal DEC-10 virtual memory.Chat-80 processes a question in three main stages:EnglishtranslationlogicplanningPrologexecutionanswercorresponding roughly to: "What  does the questionmean?
",  "How shall I answer it?
", "What is the an-swer?".
The planning and execution stages are dis-cussed in detail in a companion paper (Warren 1981),so here we will concentrate on the translation stage,which is responsible for the natural language analysis.We first describe the way we represent he "meaning"of an English sentence as a logical expression, andthen outline how the translation process is formalised,in logic, as a practical Prolog program.
Finally, webriefly explain how the logical form is transformedinto a Prolog program by the planning phase and howit is then executed.2.
A S impl i f ied Semant ics  for a Basic English SubsetTo answer a question, one first has to understandwhat it means.
If question answering is to be done bycomputer, there needs to be some precise representa-tion for the result of this first process, what one mightcall the "meaning"  of the question, and also someprecise way of relating the question to its meaning.
Itis further necessary that the meaning representat ioncan in some way be given a precise interpretation (or"semantics")  so that, in the case of questions for in-stance, one then knows precisely what is or is not acorrect answer to the questions.
It is surprising that,even for such basic features of English as the commondeterminers, and even within the different languagecamps represented by linguistics, philosophy, and arti-ficial intelligence, there is as yet no established solu-tion to this problem.One way to try to articulate the meaning of a sen-tence is to paraphrase it into some standard, unambi-guous form of English.
Since these standard forms arelikely to be stilted and long-winded, it will probably beconvenient o represent hem in a more concise nota-tion.
This is essentially the logician's approach, andwe will call such meaning representations "logicalforms".Chat-80 represents the meaning of a question by alogical form.
The approach is a development of thatproposed by Colmerauer 1978 and implemented byDahl 1981,1979.Words approximating to the status of "propernouns" are represented by logical constants, for exam-ple:France francethe Soviet Union soviet unionwine wineMost verbs, nouns, and adjectives (together with anyassociated prepositions) are represented by predicates,taking one or more arguments (which for our purposesare called constants).
A predicate with its argumentsis called a predication (or sometimes a goal).
Exam-ples are:American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 111David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemFrance exports wine to Britain.exports (france, wine, britain)France is a country, country(france)Paris is the capital of France.
capital(france,paris)France is European.
european(france)Many kinds of more complex phrases or sentencescan be represented by conjunctions of predications, forexample:Paris is a European city.european(paris) & city(paris).France is a country that borders on Spain.country(france) & borders(france,spain)The second of these conjunctions, for example, can beread more literally as a shorthand for "France is acountry and France borders Spain", which is just aparaphrase of the original sentence.The most important class of words not covered sofar are the determiners - words such as "a" ,  " the","every" .
Determiners play a particularly importantrole in questions, since they enable relatively complexrequests for information to be expressed very concise-ly.In Colmerauer's approach, each determiner is rep-resented by what he called a "three-branchedquantif ier" (3BQ).
For example, the logical form thatwould be ascribed to the sentence "The boy sleeps"would be:the(X,boy(X),sleeps(X))where the determiner " the"  is represented by the 3BQ'the( , , )'.
3BQs are very close to the meaningrepresentat'ion for determiners used by Woods in theLUNAR system (1977).
Colmerauer gave 3BQs aprecise semantics in terms of certain operations oversets.
However, we have found that this way of inter-preting 3BQs fails to give a correct model of naturallanguage in certain cases, and, worse still, it does notappear to lend itself to efficient implementation.
Cer-tainly this is the case with Dahl's program which,while being very efficient at understanding questions, ishopelessly inefficient at answering questions where thedomain is of any significant size.In Chat-80, we have addressed these problems byinstead translating 3BQs directly into standard first-order logic, or rather into something as close to first-order logic as is practical.
To be more exact, wetranslate into the Prolog subset of logic, which wehave augmented with certain "meta-logical" exten-sions.
(A similar approach as been taken by McCord1982, who has independently been developing a sys-tem influenced by the Colmerauer/Dahl  approach.
)The subset of first-order logic we have chosen has thegreat advantage as a meaning representation that italready has a well understood semantics which isamenable to very efficient implementation.
Thus themeaning representation can in principle be directlyexecuted as a Prolog program (whereas 3BQs require aspecial-purpose interpreter).
Furthermore, the first-order logic formulation lends itself to transformationswhich can greatly improve the efficiency of execution.This corresponds to what is known as "queryoptimisation" in relational database circles, and will bediscussed in more detail later.Our translation into logic completely ignores thepresuppositions which can be implicit in a natural lan-guage question, and which Colmerauer's 3BQ seman-tics took pains to reflect.
In most situations that weare concerned with, this simplification seems relativelyharmless or even beneficial.
For  example, Chat-80ignores the presupposition that there is only one an-swer to the question "Which ocean borders the UnitedStates?
", and simply gives all three answers withoutfurther comment.The way we translate determiners into logic isshown in Figure 1.
Each determiner is translated intoa quantification, which introduces some logic variable(X, N, etc.
), and which links two predications involv-ing that variable, called the range and scope, indicatedby R and S.The determiners "a",  " the"  (in a singular context),and "some" (whether in a singular or plural context)are all translated in exactly the same way, by a stand-ard first-order logic existential quantification.
Read'exists(X,P)' as "there is some X such that P".
Thesame translation is also normally used for the "emptyplural" determiner, for example:Zambia exports minerals.exists(X,mineral(X) & exports(zambia,X)).The determiner "no"  is translated with the aid of akind of negation.
Read ' \+P '  as "it cannot be shownthat P".
Note that this is not the standard negation off irst-order logic, which is outside the Prolog subset.Standard negation is problematic to implement andseems inappropriate for many purposes.
Instead Pro-log systems provide (or can easily be extended with) apartial implementation of nonprovability.
The predica-tion ' \+P '  is considered true if P is not deduciblefrom the facts and rules which define a particular ap-plication domain.
Note that nonprovabil ity is alsoused in the translation of the determiners "every"  and"all".The determiner " the"  in a plural context presents anumber of problems, for which we do not yet feel wehave a completely adequate solution.
In general, weconsider a plural definite noun phrase to denote a set.To cater for this, we have proposed and implementeda "meta-logical" extension to Prolog, which has beendescribed in detail elsewhere (Warren, 1982; Byrd,Pereira, and Warren 1980).
The extension allowspredications of the form:setof(X,P,S)112 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systema, some, the\[singular\]noevery, allthe\[plural\]one, two, ... numeral(N)which, whathow manyexists(X,R & S)\+exists(X,R & S)\ +exists(X,R & \ +S)exists(X,setof(X,R,X) & S)numberof(X,R & S,N)answer(X) <= R & Sanswer(N) <= numberof(X,R & S,N)Some birds migrate.exists(X,bird(X) & migrates(X)).The population of Britain exceeds 50 million.exists(X,population(britain,X) & X > 50000000).There are no rivers in Antarctica.\ +exists(X,river(X) & in(X,antarctica)).Man inhabits every continent.\ +exists(X,continent(X) & \ +inhabits(man,X)).Jupiter is the largest of the planets.exists(X,setof(X,planet(X),X) & largest(X,jupiter)).The Rhine flows through three countries.numberof(X,country(X) & flows through(rhine,X),3).Which birds migrate?answer(X) <= bird(X) & migrates(X).How many countries export oil?answer(N) <= numberof(X,country(X) & exports(X,oi l) ,N).Figure 1.
Translations of determiners.to be read as "the set of Xs such that P is provable isS, where S is nonempty".
Note that this constructbehaves like a quantif ication in that it introduces avariable (or, more generally, a collection of variables)X which is purely local to P. Thus it is possible, as inthe translation of the plural definite article given inFigure 1, to use the same variable name for a set andits "typical"  element.Our translation entails that  certain predicates cantake sets as arguments.
At present, we leave it up tothe definition of each individual predicate to draw anynecessary correspondence between predications oversets and predications over individuals, since it is hardto fix a general rule.
To see what the problem is,compare the sentences:The boys like the girls.The boys are married to the girls.In certain contexts, such as:What are the ages of the boys?plural definite noun phrases are translated somewhatdifferently, as indexed sets.
More on this later.For convenience in translating the numerals "one"," two" ,  " three" ,  etc., we allow predications of theform:numberof (X,P,N)meaning "the number of Xs such that P is provable isN".
This predicate can easily be defined in terms of'setof '  by the logical implication:numberof(X,P,N) <= setof(X,P,S) & sizeof(S,N)Read 'P <= Q'  as "P  if Q".
The predicate 'sizeof'just gives the number of elements in a set.Notice that implications are also used in the trans-lation of questions.
Read 'answer(X) <= P' as "X isan answer if P"  or "I want to know X if P (is true)".Variables in the 'answer'  predicate are not explicitlyquantified.
Such free variables are interpreted, follow-ing normal conventions in logic, as though they wereuniversally quantif ied; that is, one may prefix one'sreading of the entire logical form with phrases "Forany X, for any Y," etc.We have now seen how some common types ofEnglish words are translated into bits of logical struc-ture.
It remains to discuss how the bits fit together toproduce the complete logical form for a whole sen-tence.
For example, a sentence within the scope ofour subset is"Which European country exports no arms to coun-tries in Africa?How is it that the bits of structure corresponding toeach individual work in this sentence fit together toproduce the following logical form:American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 113David H,D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systemanswer(C) <= european(C) & country(C) &\ +exists(X, arm(X) &exists(C1, country(C1) & in(Cl,afr ica) &exports(C,X,C1) )(One should realize that this is just a shorthand for"For  any C, C is an answer if C is European and C isa country and it cannot be shown that there is some Xsuch that X is an armament and there is some C1 suchthat C1 is a country and C1 is in Africa and C exportsX to C I " . )
Hopefully, the reader should already havea fair intuitive idea of what the "assembly process"must do.
Basically, there are two main problems.First, how are the appropriate variables or con-stants chosen to fill each predicate argument position?For example, why is the last argument of 'exports' thesame variable C1 that appears as arguments to'country' and 'in'?
This "slot filling" is determinedmainly by the grammatical structure of the sentence,but the correct attachment of prepositional phrasesoften cannot be determined on purely syntacticgrounds.Second, what determines the scope of the differentquantifications?
For example, why is the existentialquantification corresponding to the empty determinergoverning "countries in Afr ica" nested inside thequantification corresponding to "no"?
This "scoping"is only weakly influenced by grammatical structure.Indeed, it is possible to give an alternative but muchless likely reading to our example sentence, whichcorresponds to the same grammatical structure, but toa different logical form where the nesting of the twoinner quantifications is reversed.
The more likelyreading is that no arms are exported to any countriesin Africa; the less likely reading is that no arms areexported to certain countries in Africa.The details of our mapping from English into logicare made precise in the program text corresponding tothe first phase of Chat-80.
This text itself consists ofclauses of the Prolog subset of logic.
It serves both asa clear formal definition of our mapping and, whenexecuted by Prolog, as an efficient implementation ofthat mapping, which performs the translation of Eng-lish questions into their logical forms.
A fuller discus-sion of this implementation will be given in the nextsection, and further details can be found in Pereira1982.3.
Translating English into Logic, in LogicThe translation from English sentence to logicalform can be seen as involving three main functions -the slot filling and scope determination mentioned inthe last section, and in addition the parsing function,which determines the grammatical structure of a sen-tence.
In Chat-80, in contrast o Dahl's s~stem, thesethree functions are separated into distinct programmodules, which operate in sequence:English questionparsingphrase structureinterpretationsemantic structurescopinglogical formThe parsing module consists of a set of grammarrules of the XG formalism, which the Prolog systempreprocesses into Prolog clauses.
The interpretationand scoping modules consist of various translationrules, expressed irectly as Prolog clauses.
Executingthe grammar ules with Prolog leads to a straightfor-ward top-down, backtrack parsing strategy (Pereiraand Warren 1980).
Although the main concern inwriting the grammar was to produce a clear descriptionof the language covered, some concessions have had tobe made to achieve a reasonably efficient behaviourwith the above parsing strategy; in particular, left-recursive rules have been avoided.
It is somewhatcontrary to current opinion that such a grammar, notcarefully designed for parsing, can also be the basis ofan efficient parser.
One of the reasons for the effi-ciency in this case may be that the grammar itselfmakes no attempt o give the "r ight" modifier attach-ments, as discussed below.There has been some debate on whether the differ-ent parts of language analysis, such as the three distin-guished above, should be done serially or concurrently(Burton 1976; Woods 1977).
Some of the argumentsfor concurrent operation are that early semantic inter-pretation limits search by bringing in relevant informa-tion at the earliest possible moment, and that piece-wise generation of the interpretation is psychologicallymore plausible.
Given that we are not proposing amodel of language comprehension i people, the latterargument is not directly relevant.
The other argumentis a two-edged one: by interweaving several opera-tions, one is multiplying together their nondetermina-cies.
There are two main reasons why we have chosenserial operation.
The first is that serial operation ismuch simpler both conceptually and in programmingterms, particularly if one is trying to deal flexibly withglobal properties of the input, for instance the relativescopes of determiners.
The other reason is that thebacktracking traditionally associated with modifierattachment can be avoided by a careful choice of theparse trees produced by the parsing module.In typical systems where syntactic and semanticfunctions operate in sequence (Woods, Kaplan, andNash-Webber 1972), choices are made in the syntacticanalysis that may be found to be inadequate on se-114 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systemmantic grounds, as for example in prepositional phraseattachment.
In the present system, the syntactic om-ponent of the grammar contains additional constraintswhich block all but one of the potential attachments ofeach postmodifier.
Thus, all analyses produces are ina kind of normal form with respect to postmodifierattachment.
From this normal form, subsequent oper-ations can reconstruct other alternative analyses, ifthat is needed on semantic grounds.
The use of nor-mal form analyses has the useful consequence of mak-ing apparent other, significant, ambiguities in the in-put, which otherwise would be swamped by a largenumber of alternative analyses differing only withrespect o modifier attachment.A major limitation of the current system is thatpronouns (other than interrogative and relative pro-nouns) are not covered at all by the translation phase.This makes the natural language subset strictly lesspowerful than the underlying logic.
For example, thefollowing sentence has a logical form which cannot berendered in our natural anguage subset:Which country contains a city bigger than its capital?answer(C) <= country(C) &exists(X, contains(C,X) & city(X) &exists(Y, bigger(X,Y) & capital(C,Y) ) ).To each of the three modules of the translationprocess there corresponds a separate dictionary.
Thegrammar dictionary contains definitions of the usualsyntactic categories, both for general-purpose, or"closed-category", words, such as determiners, and forapplication dependent, or "content" ,  words, such asthe nouns and verbs corresponding to database predi-cates.
The slot filling module has a dictionary oftemplates, which define the translation of words topredicates and the argument patterns required for eachsuch translation.
Each application will require a dif-ferent set of templates.
Finally, the scope determina-tion module has a small dictionary defining the scoperelationships for determiners and other "operator"words, and their translation as discussed in the lastsection.
This dictionary is independent of the applica-tion domain.
The dictionaries are divided in this man-ner for conceptual and programming reasons, but itwould not be difficult to write a program to create thedictionary entries from a more user-oriented dictionaryformat.
The complete dictionary definition for a sin-gle word is shown in Appendix II.3.1.
Phrase StructureA grammar for any substantial language fragmentneeds to define grammatical relationships which wemay call "transformational",  that is, relationshipswhich cannot be described irectly by a small numberof phrase structure (context-free) rules.
Both MGs(used in Dahl's system) and DCGs have general pro-gramming power, and so can describe any"transformational" relationship, but they cannot do soby specific, well motivated grammar ules.
In particu-lar, this applies to "left extraposition", the underlyingconcept in most grammars for such important con-structions as WH-questions, relative clauses, and auxil-iary fronting.
Similar comments apply to ATNs(Woods 1970), even those using the HOLD/VIR facili-ty.To handle "left extraposit ion", and some other"transformational" concepts, we have introduced thegrammar formalism of extraposition grammars, whichare described fully elsewhere (Pereira 1981).
An XG,like a DCG, is no more than "syntactic sugar" forclauses of logic.As the Chat-80 grammar is intended partly as ademonstration of the power of XGs for treating leftextraposition i English, the coverage of questions andrelative clauses is fairly extensive.
Of course, thiswide coverage is essential if complex queries are to beformulated in a single sentence.A major limitation in the present coverage of Eng-lish syntax is that the only phrases that may be con-joined (with "and",  etc.)
are noun postmodifiers andpredications introduced by the verb 'to be'.
To covermore general conjunctions would require a minorchange in the XG formalism, to cope with the interac-tion between left extraposition and conjoined phrases.The analysis of a sentence produced by the Chat-80 grammar is a fairly conventional annotated surfacestructure, where in general the subtrees for all phrasesappear in the same order as in the input.
This is es-sential for the heuristics used in the scoping opera-tions, which rely on the left-to-right order of nounphrases.3.2.
A t tach ing  Arguments  and Modi f ie rsAs we have seen, the translation of content wordsinto predicates is defined by dictionary templates.
Ofcourse, certain words, like "average", "number (of)"and superlative adjectives, cannot be translated asfirst-order predicates, but represent some higher-orderoperation.
Templates pecify, for each argument posi-tion of a predicate which translates a word, the "case"(usually a preposition) and the most general entity typethat can fill the position, or slot.
Type matching helpsthe system to find a semantically sound argumentplacement, and is also used to create additional predi-cations when attributes are referred to implicitly, as incomparatives.
Templates are similar to the dictionaryentries in Dahl's system, but our attachment proce-dure, by being separate from the syntax analysis, canbe much more flexible in deciding how to fill slots.The following are typical application dependenttemplates:American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 115David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systemproperty(area,measure&area,A,region&Type,R,area(R,A)).transit ive(exceed,measure&Type,X,measure&Type,Y,exceeds(X,Y)).The first template states that 'area'  is a "property" ,  asubclass of nouns which require an argument markedby the preposition "of" .
Variable A in this templatecorresponds to the "area"  value, which belongs to thesub-type 'area'  of the type 'measure'.
Variable R cor-responds to the thing having an area, and belongs tosome sub-type of type 'region'.
The predication forthis word is 'area(R,A) ' .
The second template statesthat " ( to)  exceed" is a transitive verb, whose subjectX and object Y are both measures of some commontype Type, and 'exceeds(X,Y) '  is the correspondingpredication.When Prolog accesses such templates, unificationautomatically does most of the work of "slot filling".The result of the slot filling process is a tree withthree kinds of nodes, quantification odes (Quants),predication nodes (Preds) and conjunction nodes(Conjs).
Quants correspond to noun phrases, Preds toverbs, and Conjs to conjoined restrictive modifiers.As we have seen, quantifications play a crucial rolein the translation of sentences into logics.
The fieldsof a Quant are:?
the determiner, which can be an English determineror one of the special determiners described below;?
the head, which is either the predication translatingthe head noun of a noun phrase, or a term denotinga higher-order operation;?
the predication, a tree describing restrictions on thehead whose determiners have narrower scope thanthe determiner on this Quant;?
the arguments, a list of the trees for the argumentsof the noun, together with the trees of those re-strictions whose determiners may have wider scopethan the present one;?
the bound variable for this quantification.The distinction between the predication and the argu-ment list of a Quant corresponds to one of the mainscoping heuristics in the system: full relative clausesare the only subordinated phrases whose determinerscannot "move up" to dominate determiners in highertree nodes.
Thus, when a Quant is mapped into alogic quantification, the head, predication, and some ofthe arguments will translate into the range of thequantification, whereas the scope will be made fromthe rest of the arguments and some quantif icationswhich are higher in the tree but whose determinershave a narrower scope than the present one.The determiner of a Quant may not be the originalEnglish determiner of the corresponding noun phrase.In nested plural definite noun phrases, only the highestdeterminer gets translated into a set expression follow-ing the translation table of Figure 1; lower determinersare understood to index that set, and are representedin Quants by an index token.
For example, the nounphrase:the children of the employeestranslates into a set of sets of children, indexed byemployees:setof(E-S, employee(E) & setof(C,chi ld(E,C),S),  S1).3.3.
Meaning and Scope of QuantificationsGiven the tree of Quants, Preds, and Conjs pro-duced by slot filling, the final module specifies therelative scopes of determiners, of negation, and ofquestion markers.
The main information for this mo-dule is a set of rules of thumb about what determinersusually "govern"  other determiners.
The relationshipof "governing" is not a total order, or even a partialorder: it is only meaningful for pairs of operators, onein a subordinating and the other in a subordinatedposition.
Relative scopes not decided by "governing"are decided by the left-to-right order of phrases in theinput sentence.Our scope rules are more accurate than those pro-posed by Colmerauer 1982 and used in Dahl's system.Colmerauer's rules determine relative scope strictly onthe basis of predicate-argument relationships definedin syntactic terms.
Our rules are related to the ideasfor improving LUNAR discussed by Woods 1977 andVanlehn 1978.
Unfortunately,  except for set andhigher-order operations, we have no means of usingthe distinct roles of different argument places to helpdecide the scopes of their fillers.As an example of our scope rules, the determiner'each'  is assumed to have a "distr ibut ive" role, andgoverns most other determiners, and also questionmarkers, so the reply to a question containing 'each'will be an indexed list of values, one for each entitysatisfying the conditions in the noun phrase with thatdeterminer.
A negated verb, however, will prevent an'each'  in any of its arguments from assuming its dis-tributive role.
In fact, no determiner governs a nega-tion except 'any',  which is seen as a universal quantifi-cation of wide scope relative to negation.Apart from deciding on relative scopes, this modulealso specifies how set expressions are built from pluraldeterminers and index determiners, and what are thefirst-order predications which make the arguments ofhigher-order functions like 'average'  and 'number of'.4.
Query Planning and ExecutionWe have now seen how an English question is map-ped into its logical form.
Since the logical form has aprecise semantics, it is in principle possible to deter-mine the answer to the question.
However,  there is a116 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable Systembig difference between principle and practice.
Can theprocess of finding the answer really be made fastenough for this to be useful for practical question an-swering purposes?
The evidence of Chat-80 is that itcan.The key question here is how to avoid combinatori-al explosion.
Naive question-answering strategiestypically take a time that is exponential in the size ofthe query.
Even for relatively small databases, uch asthat in Chat-80, exponential behaviour will be disas-trous for non-trivial queries (and non-trivial queriesare what a natural anguage interface ncourages).
Aquery over a small database that can be answeredalmost instantaneously with the right question-answering strategy may easily take hours with a pooralgorithm.
We had actual experience of this phenome-non when we experimented with mounting the Chatdatabase on the relational database system Ingres(Stonebraker, Wong, Kreps, and Held 1976).
Simplequeries Ingres handled easily, but on queries involvingmore than two relations, which were no problem forChat, Ingres usually bogged down completely.
Wetherefore think that the question-answering part ofnatural anguage question-answering is at least as wor-thy of attention as the natural anguage part, and thetwo should be studied hand in hand.A complete description of the way Chat-80 proc-esses logic queries, together with a fuller discussion ofthe efficiency issues, is given in a separate paper(Warren 1981), which we urge the interested reader toconsult.
Here we just give a brief summary, illustratedby one example.
Basically, Chat-80 augments thelogical form of a query with extra control information,to make it into an efficient piece of Prolog program,which can then be directly executed to produce theanswer.
The control information is computed by ageneral planning algorithm, applicable to any query inthe logic subset, not just to those derivable from thepresent natural anguage subset.
The planning processmakes use of certain statistics about the size, etc., ofthe domain relations, and is analogous to "queryoptimisation" in a relational database system.The control information that is generated takes twoforms:?
the ordering of predications within a query, whichwill determine the order in which Prolog will at-tempt to satisfy them;?
the marking of "independent subproblems" by en-closing them in braces, to limit (or "cut") theamount of backtracking performed by Prolog.For example, here is an English question with thelogical form produced by the natural anguage analysisphase of Chat-80:"Which countries bordering the Mediterranean borderAsian countries?
"answer(C) <= country(C) &borders (C,mediterranean) &exists(Cl,country(C1) & asian(C1) &borders(C,C 1))After planning, the logical form is transformed into:answer(C) <= borders(C,mediterranean) &{country(C)} & {borders(C,C1) &{asian(C1) & {country(C1)}}}When executed by Prolog, this produces a behaviourequivalent to the following procedural interpretation:To generate an answer C:generate a C bordering the mediterranean, and thencheck that C is a country, and thencheck that it is possible to:generate a C1 bordered by C, and thencheck that C1 is asian, and thencheck that C1 is a country.Thus Prolog is led to answer the query in an obviouslysensible way; it iterates through the countries border-ing the Mediterranean, and for each one, it iteratesthrough the things bordering that country until it findssomething that is an Asian country.
In fact theDEC-10 Prolog compiler can in principle compile thetransformed query into code which is comparable inefficiency with iterative loops in a conventional lan-guage (Warren 1977).
However, in Chat-80 thetransformed query is actually just interpreted.5.
Per fo rmance  and Portabi l i tyChat-80 at its current stage of implementation,covers a limited but useful subset of English.
A fairidea of the range of the present subset is given by theexamples in Appendix I.
It will be seen that the sub-set includes nouns, verbs, adjectives, prepositions, anddeterminers, with a fairly full coverage of interrogativeand relative constructions.
We have concentrated onfeatures of English that seemed essential for simplequestion answering; there are many directions in whichthe subset could usefully be extended and which donot appear to pose any particular difficulties.At present, the system accepts a small vocabularyof about 100 domain dependent works (not countingproper nouns, but including alternative word formssuch as plurals).
This vocabulary can very easily beextended (as indicated below).
In addition there aresome 50 domain independent words.
On the whole,any question that can be expressed using this vocabu-lary is correctly understood and answered by the sys-tem.The sizes of the different components of the systemare indicated below in terms of the approximate num-ber of Prolog clauses comprised, and the approximatenumber of DEC-10 (36-bit) words occupied:American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 117David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemDEC-10clauses wordsNL analysis 580 24000Query planning and execution, etc.
290 8500Geographical vocabulary 180 4000Geographical database 1590 22500The speed of Chat-80 on some sample queries rela-ting to the geographical database is shown in Appen-dix I.
Generally speaking, any query in this domainthat can comfortably be expressed in a single sentenceof the English subset is answered in well under onesecond of CPU time.
Note that the domain dependentvocabulary could be much extended without havingany significant impact on these times (because of theway the dictionary is indexed).It is also worth noting that, for all but the simplestqueries, natural language analysis represents only asmall proportion of the total time.
This suggests that,as far as the efficiency of natural language questionanswering systems is concerned, it is the answeringprocess rather than the natural language analysis towhich most effort needs to be directed.
Certainly thishas been our approach, although it appears to besomewhat contrary to the prevailing view in artificialintelligence.
In particular, parsing does not seem topose any major efficiency problem, provided one doesnot expect he grammar to do too much.As regards portability, we think Chat-80 should berelatively easy to adapt to different applications - forthe same reasons that we found it easy to adapt Dahl'sprogram to English and to a different domain.Partly this is due to the fact that (in both systems)the domain dependent parts are clearly separated fromthe rest of the system, and are broken down into smallunits which can be added incrementally as "data"  (seeAppendix II).
Thus our natural language analysis mo-dules deal exclusively with general features of English,in contrast to the "semantic grammar" approach(Burton 1976).Now there are other practical systems which havenot taken the "semantic grammar" approach but are,we feel, less easy to modify than Chat-80; LUNAR(Woods, Kaplan, and Nash-Webber 1972) is a goodexample.
The reason lies in the way "meanings" areattached to words.
In LUNAR, a meaning is simply aprocedure.
For nouns it is a procedure to generateobjects in a certain class; for most other words it is aprocedure to test whether some property is true ofgiven objects.
This entails that "meanings" can beexecuted in only one way, and precludes the kind ofquery planning done in Chat-80.
But such a simple-minded approach to query execution is not viable inmost practical situations, as Woods 1977 recogniseswith his "smart quantif iers".
The only alternative,given the procedural approach to meaning, is to repre-sent the meaning of a word by a set of alternativeprocedures to be used in different circumstances.
Butthis makes life very difficult for someone wanting tointroduce a new word or concept into the system.In Chat-80, the meaning of a new word is in princi-ple just a set of facts and general rules that define thepredicate corresponding to that word.
The proceduralaspect is on the whole taken care of by the planningalgorithm, and by Prolog's flexible handling of predi-cations in which only certain arguments are instantiat-ed.
However, with the present system, the definer ofa new word must be responsible for ensuring that thepredicate definition he supplies is not only correct, butis also reasonably efficient when executed by Prolog.6.
Conclus ionWe have shown how questions within a limitedsubset of English can be translated into a certain sub-set of logic which, when suitably transformed, is exec-utable as efficient Prolog code.
Although this map-ping between English and logic may seem "obvious"(since logic is, after all, usually motivated in terms ofits correspondence with natural anguage), it is surpris-ing that a mapping like ours does not appear to havebeen implemented, or even precisely defined, before.Parts of the mapping overlap with Montague's 1974formalisation of aspects of English, but many of thebasics were not covered in his work (for instance, thetreatment of questions, plurals, and determiner prece-dence), and of course he was not concerned to prod-uce a practical implementation.
Among practical im-plementations, the closest work is that of Woods 1977and that of Colmerauer 1982 as implemented by Dahl1981.
Both these efforts are similar in that they mapEnglish into a nonstandard (and more elaborate) logic,where the quantifiers are more directly modelled onthe determiners of natural language.
These nonstan-dard quantifiers are called "FOR expressions" byWoods and "three-branched quantifiers" by Colmer-auer.
We have kept much closer to standard predicatelogic, for the very down-to-earth reason that the tradi-tional formalism seems to make "query optimisation"much easier (see the companion paper, Warren 1981).Our mapping from English to logic, as well as theprocesses of query planning and answering, have allbeen implemented entirely in Prolog.
The result is aprototype natural language question answering system,Chat-80, which we think probably has the best combi-nation of efficiency and portability of any comparablesystem at the present time, due principally to the useof Prolog as the implementation language.AcknowledgementsThis work was supported by a British Science Re-search Council grant, and owes much to the work ofAlain Colmerauer and Veronica Dahl.118 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemReferencesBurton, R.R.
1976 Semantic grammar: an engineering techniquefor constructing natural language understanding systems.
Re-port 3453.
Bolt Beranek and Newman Inc. (December).Byrd, L., Pereira, F., and Warren, D.H.D.
1980 A guide to ver-sion 3 of DEC-10 Prolog.
Occasional Paper 19.
Dept.
ofArtificial Intelligence, University of Edinburgh (July).Colmerauer, A.
1978 Metamorphosis grammars.
In Bolc., L., Ed.,Natural Language Communication with Computers.
Springer-Verlag.
First appeared as an internal report, Les Grammairesde Metamorphose, in November 1975.Colmerauer, A.
1982 An interesting subset of natural language.In Clark, K.L.
and Tarnlund, S.-A., Ed., Logic Programming.Academic Press.Dahl, V. 1979 Quantification in a three-valued logic for naturallanguage question-answering systems.
IJCA1-79, Tokyo(August) 182-187.Dahl, V. 1981 Translating Spanish into logic through logic.
AJCL7, 3, 149-164.Konolige, K. 1979 A framework for a portable natural anguageinterface to large data bases.
Technical Note 197.
AI Center,SRI International (October).McCord, M.C.
1982 Using slots and modifiers in logic grammarsfor natural anguage.
Artificial Intelligence 18, 3,327-367.Montague, R. 1974 The proper treatment of quantification inordinary English.
In Thomason, R.M., Ed., Formal Philosophy.Yale University Press.Pereira, F.C.N.
1981 Extraposition grammars.
AJCL 7, 4, 243-256.Pereira, F.C.N.
1982 Logic for natural anguage analysis.
Ph.D.thesis.
University of Edinburgh.Pereira, F.C.N.
and Warren, D.H.D.
1980 Definite clause gram-mars for language analysis - a survey of the formalism and acomparison with augmented transition networks.
ArtificialIntelligence 13, 231-278.Pereira, L.M., Pereira, F., and Warren, D.H.D.
1978 User's guideto DECsystem-10 Prolog.
Dept.
of Artificial Intelligence,University of Edinburgh.Roussel, P. 1975 Prolog: manuel de reference t d'utilisationGroup d'Intelligence Artificielle, UER de Luminy, Universit6d'Aix-Marseille II.Stonebraker, M., Wong, E., Kreps, P. and Held, G. 1976 Thedesign and implementation f INGRES.
ACM Trans.
on Data-base Systems 1, 3 (Sept.) 189-222.Vanlehn, K.A.
1978 Determining the Scope of English Quantifi-ers.
Master's thesis.
Published as Report AI-TR-483.
M.I.T.
(June).Warren, D.H.D.
1977 Implementing Prolog - compiling predicatelogic programs.
Technical Research Reports 39 and 40.
Dept.of Artificial Intelligence, University of Edinburgh (May).Warren, D.H.D.
1979 Prolog on the DECsystem-10.
In Michie,D., Ed., Expert Systems in the Micro-Electronic Age.
EdinburghUniversity Press.Warren, D.H.D.
1981 Efficient processing of interactive relationaldatabase queries expressed in logic.
Seventh InternationalConference on Very Large Data Bases.Warren, D.H.D.
1982 Higher-order extensions to Prolog - arethey needed?
In Hayes, Michie, and Pao, Ed., Machine Intelli-gence 10.
Ellis Horwood.Warren, D.H.D., Pereira, L.M., and Pereira, F,C.N.
1977 Prolog -the language and its implementation compared with Lisp.
ACMSymposium on A1 and Programming Languages (August).Woods, W.A.
1970 Transition network grammars for naturallanguage analysis.
Comm.
ACM 13 (Oct.) 591-606.Woods, W.A.
1977 Semantics and quantification i natural lan-guage question answering.
Report 3687.
Bolt Beranek andNewman Inc. (November).Woods, W.A., Kaplan, R.M., and Nash-Webber, B.
1972 TheLunar science natural anguage information system: final report.Report 3438.
Bolt Beranek and Newman Inc. (June).American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 119David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemAppendix I.
Sample QueriesThe Chat-80 examples below show the originalEnglish query, its logical form, the executable formafter planning, and the actual answer.
(The logicalexpressions have been "tidied", and superfluous quan-tifiers dropped, to make them easier to read.)
AlsoDoes Afghanistan border China?38 ms. ans(yes) <= borders(afghanistan,china).12 ms. ans(yes) <= {borders(afghanistan,china)}.0 ms. yes.Which country's capital is Ouagadougou?shown, preceding the corresponding output, are theseparate times (in CPU milliseconds on a DEC KL-10)for natural language analysis, for planning, and forexecution.
Time spent in producing output o the useris excluded.41 ms. ans(C) <= country(C) & capital(C,ouagadougou).15 ms. ans(C) <= capital(C,ouagadougou) & {country(C)}.22 ms. upper volta.Which is the ocean that borders African countries and that borders Asisan countries?91 ms. ans(X) <= ocean(X) & country(C) & african(C) & borders(X,C) &country(C 1) & asian(C 1) & borders(X,C 1).51 ms. ans(X) <= ocean(X) &{borders(X,C) & {african(C)} & {country(C)}} &{borders(X,C1) & {asian(C1)} & {country(C1)}}.102 ms. indian ocean.What is the capital of each country bordering the Baltic?81 ms. ans(C-X) <= country(C) & borders(C,baltic) & capital(C,X).12 ms. ans(C-X) <= borders(C,baltic) & {country(C)} & capital(C,X).29 ms. denmark-copenhagen, eas tgermany-eastber l in ,  finland-helsinki, poland-warsaw,sovietunion-moscow, s eden-stockholm, westgermany-bonn.What are the lattitudes of the countries north of the United Kingdom?102 ms. ans(C-LL) <= country(C) & northof(C,united kingdom) &setof (L,latitude (C,L),LL).26 ms. ans(C-LL) <= northof(C,united kingdom) &{country(C)} &setof(L,latitude(C,L),LL).141 ms. canada-60 degrees, denmark-55 degrees, finland-65 degrees, iceland-65 degrees,norway-64 degrees, soviet union-57 degrees, sweden-63 degrees.Which country is bordered by two seas?42.
ms. ans(C) <= country(C) & numberof(X,sea(X) & borders(C,X),2).11 ms. ans(C) <= numberof(X,sea(X) & borders(C,X),2) & {country(C)}.206 ms. egypt, iran, israel, saudi arabia, turkey.How many countries does the Danube flow through?48 ms. ans(N) <= numberof(C,country(C) & flows(danube,C),N).3 ms. ans(N) <= numberof(C,flows(danube,C) & {country(C)},N).21 ms. 6.From what country does a river flow into the Persian Gulf?69 ms. ans(C) <= river(R) & country(C) & flows(R,C,persian gulf).12 ms. ans(C) <= flows(R,C,persian gulf) & {river(R)} & {country(C)}.23 ms. iraq.What is the total area of countries outh of the Equator not in Australasia?115 ms. ans(T) <= setof(A-C,area(C,A) & country(C) &southof(C,equator) & \+in(C,australasia),S) &aggregate (total,S,T).23 ms. ans(T) <= setof(A-C,southof(C,equator) & area(C,A) &{countryof(C)} & \+in(C,australasia),S) &aggregate(total,S,T).182 ms. 10228 ksqmiles.120 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemWhat is the average area of the countries in each continent?101 ms. ans(X-Av) <= continent(X) &setof(A-C,area(C,A) & country(C) & in(C,X),S) &aggregate(average,S,Av).33 ms. ans(X-Av) <= continent(X) &setof(A-C,in(C,X) & area(C,A) & {country(C)},S) &aggregate (average,S,Av).759 ms. africa-233 ksqmiles, america-496 ksqmiles, asia-485 ksqmiles,australasia-543 ksqmiles, europe-58 ksqmiles.How many countries are there in each continent?50 ms. ans(X-N) <= continent(X) & numberof(C,country(C) & in(C,X),N).19 ms. ans(X-N) <= continent(X) & numberof (C,in(C,X) & {country(C)},N).352 ms. africa-48, america-31, asia-39, australasia-6, europe-32.Is there some ocean that does not border any country?68 ms. ans(yes) <= ocean(X) & \+exists(C,borders(X,C) & country(C)).9 ms. ans(yes) <= {ocean(X) & \+exists(C,borders(X,C) & {country(C)})}.14 ms. yes.What does border the ocean that does not border any country?59 ms. ans(Y) <= ocean(X) & \+exists(C,country(C) & borders(X,C)) &borders(Y,X).20 ms. ans(Y) <= ocean(X) & \+exists(C,borders(X,C) & {country,(C)}) &borders(Y,X).24 ms. antarctica, atlantic, indianmocean, pacific.Which are the continents no country in which contains more than two cities whose population exceeds I million?160 ms. ans(X) <= continent(X) &\ +exists(C,exists(N,country(C) & in(C,X) &numberof(Ci,exists(P,city(Ci) & population(Ci,P) &exceeds(P,1000000) & in(Ci,C)),N) &N > 2)).58 ms. ans(X) <= continent(X) &\ +exists(C,exists(N,in(C,X) & {country(C)} &{ numberof(Ci,exists(P,in(Ci,C) & {city(Ci)} &{population(Ci,P) & {exceeds(P,1000000)}}),N) &iN > 2}})).754 ms. africa, antarctica, australasia.Which country bordering the Mediterranean borders a country that is bordered by a country whose populationexceeds the population of India?144 ms. arts(C) <= country(C) & borders(C,mediterranean) & country(C1) &57 ms.204 ms.country(C2) & population(C2,X) & population(indea,Y) &exceeds(X,Y) & borders(C2,C 1) & borders(C,C 1).ans(C) <= population(india,Y) &borders(C,mediterranean) & {country(C)} &{borders(C,C1) & {country(C1)} &{borders(C2,C1) & {country(C2)} &{population(C2,X) & {exceeds(X,Y)}}}}.turkey.American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 121David H.D.
Warren and Fernando C.N.
Pereira An Efficient Easily Adaptable SystemAppendix II.
Sample Word Definit ionTo illustrate how a new word, and the conceptassociated with it, are added to the system, we show aslightly simplified version of the actual Prolog clausesdefining the verb "to drain into."
These clauses repre-sent elementary facts, giving the different forms of theverb, its meaning in terms of the predicate'drains(R,X) '  (including the types of the arguments Rand X), data about the size of the 'drains' relation andof its argument domains, and finally the definition ofthe predicate 'drains' itself.verbroot (dra in )regular present(drain).regu larnpast  (drained,drain).verb form(drains,drain,present + finite,3 +singular).verbmform(draining,drain,present + par iciple).intransitive(drain, drains(R,X), river,R, \[slot(preposition(into),region,X)\]).predicate statistics (drains,41,41,12).drains(amazon,atlantic).drains(amu darya,aral sea).etc.Appendix III.
Comparison wi th  a Formal Query LanguageIt is interesting to compare, from a user's point of Quel, the query language of the relational databaseview, the Chat-80 subset of English with current rela- system Ingres (Stonebraker,  Wong, Kreps, and Heldtional database query languages.
The examples below 1976).
Quel is arguably one of the most concise andshow some Chat-80 queries with their equivalents in user-friendly of current database query languages.Which countries bordering the Atlantic border countries bordering the Pacific?range of C I ,  C2 is countriesrange of B, BI ,  B2 is bordersretrieve (C l .name)where C 1. name = B 1.side 1and B 1.side2 = "At lant ic"and C l .name = B.sideland B.side2 = C2.nameand C2.name = B2.sideland B2.side2 = "Pacif ic"Hew many countries are there in each continent?range of C is countriesrange of Cont is continentsrange of I is inclusionsretrieve (Cont.name, count(C.name where C.name = I.inside and I.outside = Cont.name))Which are the continents no country in which contains more than two cities whose population exceeds 1 million?range of C is countriesrange of Cont is continentsrange of City is citiesrange of I1, 12 is inclusionsretrieve (Cont.name)where 0 = count(C.namewhere C.name = II .
insideand I I .outside = Cont.nameand 2 < count(City.namewhere City.name = I2.insideand I2.outside = C.nameand City.population > 1000000))122 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982
