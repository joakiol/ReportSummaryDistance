The Semantics of Dialogue ActsHarry BuntTiCC, Tilburg Center for Cognition and CommunicationTilburg University, The Netherlandsharry.bunt@uvt.nlAbstractThis paper presents an update semantic for dialogue acts, defined in terms of combinations ofvery simple ?elementary update functions?.
This approach allows fine-grained distinctions to bemade between related types of dialogue acts, and relations like entailment and exclusion betweendialogue acts to be established.
The approach is applied to dialogue act representations as defined inthe Dialogue Act Markup Language (DiAML), part of the recently proposed ISO standard 24617-2for dialogue act annotation.1 IntroductionThe notion of a dialogue act plays a key role in studies of dialogue, in particular in the interpretationof the behaviour of dialogue participants and in the design of spoken dialogue systems.
But in spite oftheir popularity, their status is nearly always reduced to that of informal, intuitive concepts which lackproper definitions (see Poesio and Traum, 1998 for one of the few attempts at formalization).
A widerange of alternative dialogue act taxonomies and inventories have been proposed, causing considerableterminological and conceptual confusion, and problems for reusing annotated corpora.
This has moti-vated the International Organisation for Standards ISO to develop a standard for interoperable dialogueact annotation, ISO 24617-2 (see ISO 2010).
This proposed standard is partly based on the comprehen-sive DIT++ taxonomy, which has added to the earlier DIT taxonomy (Bunt, 1994) a number of conceptsfrom other proposals and studies.
Semantically, the DIT++ taxonomy is based on the dynamic approachto utterance meaning taken in Dynamic Interpretation Theory (DIT), which views dialogue acts as cor-responding to update operations on the information states of participants in the dialogue; an approachcommonly known as the ?information-state update approach?
to meaning in dialogue ?
see e.g.
Bunt(2000); Traum & Larsson (2003).
A dialogue act, on this approach, has two main components: a seman-tic content, which describes the objects, properties, relations, or actions that the dialogue act is about,and a communicative function, which specifies how an addressee should update his information statewith the semantic content.Utterances in dialogue are often multifunctional, i.e., they have more than one communicative func-tion.
Dialogue analysis and annotation frameworks are therefore often ?multidimensional?
in the sense ofallowing the assignment of multiple functions to functional segments.
The DAMSL annotation schemefor example (DAMSL = Dialogue Act Markup using Several Layers) distinguishes nine ?dimensions?
asmutually exclusive groups of function tags.Bunt (2006) introduces a notion of dimension based on the observation that participation in a dia-logue involves, beyond activities strictly related to performing the underlying task, sharing informationabout the processing of utterances, managing the use of time, taking turns, and various other types ofcommunicative activity, and defines dimensions as corresponding to such aspects of communication.Each dimension in this sense constitutes a category of communicative activity, and the dialogue actsinvolved in these activities are concerned with different types of information: feedback acts with thesuccess of processing previous utterances; turn management acts with the allocation of the speaker role,task-related acts with the dialogue task; and so on.
Dimensions thus classify semantic content.1Petukhova & Bunt (2009a; 2009b) formulate criteria for distinguishing dimensions, and apply thesein the analysis of the dimensions that occur in 18 existing annotation schemes, showing that the 10dimensions of DIT++ form a well-founded set of dimensions.
These are the following:(1) 1.
Task/Activity: dialogue acts for performing the task or activity underlying the dialogue2.
Auto-Feedback: providing information about the speaker?s processing of previous utterances.3.
Allo-Feedback: the speaker expresses opinions or elicits information about the addressee?s processingof previous utterances;4.
Contact Management: dialogue acts for establishing and maintaining contact;5.
Turn Management: concerned with grabbing, keeping, giving, or accepting the speaker role;6.
Time Management: the speaker indicates to need some extra time to formulate his contribution;7.
Discourse Structuring: dialogue acts for explicitly structuring the conversation;8.
Own Communication Management: dialogue acts for editing the speaker?s current utterance;9.
Partner Communication Management: dialogue acts to assists or correct the current speaker;10.
Social Obligations Management: dialogue acts that take care of social conventions such as greetings,apologies, and expressions of gratitude.Some communicative functions are specific for a particular dimension; for instance Turn Acceptand Turn Release are specific for turn management; Stalling and Pausing for time management.
Otherfunctions can be applied in any dimension; for instance a Check Question can be used with task-relatedsemantic content, but also for checking correct understanding (feedback).
Similarly for commissiveand directive functions.
These functions are therefore called general-purpose functions, as opposedto dimension-specific functions.
The DIT++ taxonomy therefore consists of two parts: a taxonomyof general-purpose functions and one of dimension-specific functions - see Appendix A and http://dit.uvt.nl.2 DiAML: Dialogue Act Markup LanguageThe Dialogue Act Markup Language (DiAML) which is part of the ISO standard under development fordialogue act annotation (see Bunt et al, 2010, and http://semantic-annotation.uvt.nl)has been designed in accordance with the ISO Linguistic Annotation Framework (Ide & Romary, 2004),which makes a distinction between annotation and representation; ?annotation?
refers to the linguisticinformation that is added to segments of language data, independent of format; ?representation?
refers tothe format in which an annotation is rendered, independent of content.
This distinction is implemented inthe DiAML definition by a syntax that specifies, besides a class of XML-based representation structures,also a class of more abstract annotation structures.
These two components are called the concrete andabstract syntax, respectively.The abstract syntax defines a class of set-theoretical structures, called ?annotation structures?.
Itconsists of: (a) a specification of the elements from which annotation structures are built up, called a?conceptual inventory?, and (b) a specification of the possible ways of combining these elements.
Theconceptual inventory consists of finite sets of elements called ?functional segments?, ?dimensions?, ?com-municative functions?, ?qualifiers?, and ?rhetorical relations?.An annotation structure consists of a set of entity structures and a set of link structures.
Entitystructures contain semantic information about a functional segment; link structures describe semanticrelations between segments.
The most important kind of entity structure is a so-called ?dialogue actstructure?, which is a quadruple ?S,A, d, f?
where S and A are the sender and addressee of a dialogueact; d is a dimension; and f is a communicative function or a pair ?f, q?, where q is a list of qualifiers.The concrete syntax defines a rendering of annotation structures in XML.
It is defined in accordancewith the methodology for defining semantic annotation languages described in Bunt (2010), which intro-duces the notion of an ideal representation format, defined as one where every representation representsa uniquely determined annotation structureThe semantics of the language is then defined for the struc-tures defined by the abstract syntax.
This has the effect that any two ?ideal?
representation formats2are semantically equivalent; every representation in one such format can be converted by a meaning-preserving mapping into any other such format.1 The concrete syntax of DiAML is illustrated in (3)and (2).
P2?s utterance is segmented into two overlapping functional segments: one (fs2.1) in the Auto-Feedback dimension and one (fs2.2) in the Task dimension, with value ?answer?
qualified as ?uncertain?.
(#-prefixed elements are assumed to be identified in the metadata of the source material or in anotherlayer of annotation.)(2)1.
P1: What time does the next train to Utrecht leave?TA: fs1: What time does the next train to Utrecht leave?2.
P2: The next train to Utrecht leaves I think at 8:32.AuFB fs2.1: The next train to UtrechtTA fs2.2: The next train to Utrecht leaves I think at 8:32.
(3)<diaml xmlns:"http://www.iso.org/diaml/"><dialogueAct xml:id="da1" target="#fs1"sender="#p1" addressee="#p2"communicativeFunction="setQuestion" dimension="task"conditionality="conditional"/><dialogueAct xml:id="da2" target="#fs2"sender="#p2" addressee="#p1"communicativeFunction="autoPositive" dimension="autoFeedback"/><feedbackDependence dact="#da2.1" fbSegment="#fs1"/><dialogueAct xml:id="da3" target="#fs2.2"sender="#p2" addressee="#p1"communicativeFunction="answer" certainty="uncertain"dimension="task" /><functionalDependence dact="#da3" functAntecedent="#da1"/></diaml>3 Context Model Structure and ContentAs the proposed semantics of dialogue acts is in terms of information-state updates, the question arisesas to what exactly is an information state in this context; what information does it contain, and how is itstructured.
An information state will be assumed to have a number of components, an assumption whichis shared between all proposals for information states (e.g.
Poesio & Traum, 1998; Bunt, 2000; Ahn,2001; Cooper, 2004); moreover, certain types of information can be argued to be required in informationstates.
The details of an information-state update semantics also depend on whether only the informationstate of an addressee is considered to be updated by dialogue acts, or also that of the sender, and onwhether these updates involve mutual beliefs, as e.g.
argued in Bunt (2000).
We consider here only theupdates of a single addressee?s information state, disregarding mutual beliefs; this is anyway the basisfor more complex approaches involving multiple information states and mutual beliefs.
In DIT, it iscustomary to speak of ?contexts?
or context models?, rather than ?information states?, and we will usethis terminology in the rest of this paper.A fundamental requirement for an adequate context model is that, for a given range of dialogue acttypes, the model contains the kinds of information that are updated by a dialogue act.
Bunt (forthc.
)argues that an agent?s context model does not necessarily have a separate component for each DIT di-mension, but that it is convenient to distinguish the following five components:(4) 1.
Linguistic Context, which contains a record of the dialogue history, information about discourse plans(if any), and wishes concerning the occupation of the speaker role;2.
Semantic Context, which contains the agent?s information and goals relating to the dialogue task, aswell as his assumptions about the dialogue partner?s task-related goals and beliefs;3.
Cognitive Context, which contains information about the agent?s cognitive processes concerned withthe processing and production of dialogue utterances, including time estimates for these processes;1See Bunt (2010) for formal definitions and proofs relating to alternative representation formats sharing the same abstractsyntax, and Ide & Bunt (2010) for applying this to the GrAF framework for linguistic annotation.34.
Physical/Perceptual Context, which contains information about physical and perceptual properties ofthe interactive situation;5.
Social Context, which contains information relevant for interpreting and generating ?social?
acts likegreetings, apologies, expressions of gratitude.Versions of such a 5-component context model have been implemented in the PARADIME dialoguemanager (Keizer and Bunt, 2006; 2007) and for experimentation by Petukhova et al (2010).An update semantics has to take into account that update operations should not undermine the con-sistency of the context model.
A dialogue participant may change his mind during the dialogue, as aneffect of receiving some unexpected information, which can have the effect that the participant brings innew information which contradicts something that was already grounded, and hence cannot simply beadded without making the context model inconsistent.
Rather then building consistency checks into thesemantics of each dialogue act, we exploit the DIT distinction of five levels of utterance processing: (1)attention, (2) perception, (3) understanding, (4) evaluation, and (5) execution.
The level of understand-ing determines the meaning of a dialogue segment in terms of dialogue acts.
The evaluation level checkswhether the corresponding updates would keep the current context model consistent.
If so, it performsthe updates.
One way to implement this approach is to add to a context model a part called the pendingcontext, which serves as a buffer for items to be inserted in the main context once their consistency withthe current content of the main context has been established.2 Updating the pending context is a matterof simply adding items to it.
For convenience we will assume the pending context A?
of an agent A?scontext model to be structured in the same way as the main context.
We will use the notation (5a) tospecify the update consisting of adding the information z to component A?i i of A?s pending context.
Iff is the update (5a) and g the update A?j =+u, then (5b) designates the combination of the two updates.3(5) a.
A?i =+zb.
f unionsq gAn analysis of the definitions of the DIT++ communicative functions shows that a formal descriptionof the update effects of dialogue acts with a general-purpose function requires the basic concepts listed inTable 1.
For convenience, we also introduce the following abbreviations: Bel(S, p) abbreviates BelS, p,firm); Wk-Bel(S, p) abbreviates BelS, p, weak); Assumes(S,p) abbreviates Bel(S,p) ?
Wk-Bel(S,p).In all action-related attitude operators we suppress the argument > representing the ?empty?
condition,hence WilDo(S, ?)
abbreviates WilDo(S, ?,>), and so on.description notation meaningbelieves that Bel(S, p, ?)
S believes that p; ?
indicates whether this is a firm beliefor an uncertain belief (?
can have the values ?firm?
and ?weak?
)knows value of Know-val(S, z) S possesses the information zhas goal Wantl(S, p) S has the goal that pis able to do CanDo(S, ?)
S is able to perform the action ?is willing to do WilDo(S, ?,C?)
S is willing to perform the action ?
if the condition C?
isfulfilled; C?
may be the universally true statement >is committed to do CommitDo(S, ?,C?)
S is committed to perform the action ?
if the condition C?
isfulfilled; the condition C?
may be ?empty?
(>)is committed to RefrainDo(S, ?,C?)
S is committed to refrain from performing the action ?refrain from doing if the condition C?
is fulfilled C?
may be ?empty?
(>)is considering ConsidDo (X,?, Y, C?)
X is considering the action ?, to be performed by Y,to be done if the condition C?
is fulfilled C?
may be ?empty?
(>)is in the interest of Interest(Y, ?)
action ?
is of interest to agent Y .Table 1: Basic semantic concepts for general-purpose communicative function interpretation2This approach has been implemented in the multimodal DenK dialogue system; see Kievit et al (2001).3The combined update (f unionsq g) is undefined if the order of performing the two updates would make a difference.4Dimension PrimitivesAuto- and Allo-feedback Attended, Perceived, Understood, Accepted, Executed, Attention-Problem, Perception-Problem, Interpretation-Problem, Evaluation-Problem, Execution-ProblemTurn Management Current-Speaker, Next-SpeakerTime Mangement Time-Need, small, substantialContact Management PresentDiscourse Structuring Ready, Available, Start-Dialogue, Close-DialogueOwn and Partner Communication Man.
Delete, Replace, AppendSocial Obligations Man.
Available, Thankful, Regretful, Knows-id, FinalTable 2: Dimension-specific semantic primitivesDimension-specific communicative functions are always concerned with a specific category of se-mantic content, which requires certain specific semantic primitives for its representation.
Table 2 liststhe basic concepts for describing their update semantics.For expressing the semantics of a feedback act which is underspecified for the level of processing,we introduce in (6) the predicates Succes-Processing, defined as successful at least at the level of under-standing, and Unsuccessful-Processing, defined as unsuccessful at the level of understanding or lower.
(6) a. Succes-Processing = Understood ?
Accepted ?
Executedb.
Unsuccessful-Processing = Interpretation-Problem ?
Perception-Problem ?
Attention-Problem4 Dialogue Act SemanticsIn this section we outline a semantics of dialogue acts in the form of an update semantics for the ?dialogueact structures?
defined by the DiAML abstract syntax.
A dialogue act structure does not correspond toa full-blown dialogue act representation, since it does not include the full semantic content, but onlythe dimension which classifies the semantic content.
The semantics of a dialogue act structure shouldtherefore be something which can be combined with a semantic content in order to form the interpretationof a full-blown dialogue act.
This is precisely the case, for the recursive interpretation of a dialogueact structure ?S,A, d, f?
is defined through the recursive valuation function V as specified in (7).
Ofthe four arguments of V in the left-hand side of (7), S, A, and d are elements of the categories of theDiAML conceptual inventory, so there is no recursion in their interpretation; for such elements, thevaluation function is defined by a value assignment function F , playing the same role as that of a ?modelassignment?
function in model-theoretic semantics; F for example assigns to a sender and an addresseecertain individuals, identified in the metadata of an annotated dialogue (cf.
#p1 and #p2 in (3)).
To thedimension argument d, F assigns that component of an information state that should be updated.
(7) V (<S, A, d, f>) = (V (f))(F (S), F (A), F (d))4.1 The Update Semantics of Communicative FunctionsA communicative function will be interpreted as a function which, applied to a given speaker, addressee,and dimension, results in a function which can be applied to a semantic content in order to obtain acontext-update specification.
Since related communicative functions often share parts of their definingpreconditions, we will construct such interpretations as combinations of elementary update functions,each of which takes care of the update corresponding to a single dialogue act precondition; see Table3 and Table 4 for illustration: Table 3 lists the definitions of the update semantics of the communica-tive functions of the information-providing class, while Table 4 lists the elementary elementary updatefunctions used in these definitions.54.1.1 General-Purpose Communicative FunctionsThe class of general-purpose communicative functions in the DIT++ taxonomy falls apart into theinformation-transfer functions and action-discussion functions, further subdivided into information-providingand information-seeking functions, and commissives and directives, respectively.a.
Information-Providing and Information-Seeking Functions The class of information-providingfunctions has a hierarchical structure, with the communicative function Inform as the mother of allinformation-providing functions; all other functions are specializations of this function.
These func-tions all have in common that (1) the speaker wants the addressee to possess certain information which(2) the speaker assumes to be correct.Using the epistemic operators introduced in Section 5, these preconditions are formalized as follows:(8) 1.
Want(S,U, Bel(A, p, ?))2.
Bel(A, p, ?
)The semantics of the Inform function, specified in Table 3, binds the variable ?, representing the beliefstrength for both the elementary update functions involved.
(See further below, section 4.2.
)The update semantics in terms of combinations of elementary update functions often brings outimmediately that some communicative functions are specializations of others (as visualized in AppendixA), for instance, the update semantics of the Answer function shares with the Inform function the updatesdefined by the elementary update functions U1 and U2, and adds to that the effects of U7 and U9; thesemantic of the Confirm function adds to that the update defined byU8.
Hence Confirm is a specializationof Answer, which is a specialization of Inform, or in other words Confirm entails Answer entails Inform.F (Inform) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di, p, s) unionsq U2(X,Y,Di, p, s)F (Agreement) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di, p, s) unionsq U2(X,Y,Di, p, s) unionsq U5(X,Y,Di, p)F (Disagreement) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di,?p, s) unionsq U2(X,Y,Di,?p, s) unionsq U5(X,Y,Di, p)F (Correction) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di, p1, s) unionsq U2(X,Y,Di,?p1, s) unionsq U6(X,Y,Di, p2)F (Answer) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di, p, s) unionsq U2(X,Y,Di, p, s) unionsq U9(X,Y,Di, p)unionsq U7(X,Y,Di, p)F (Confirm) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di, p, s) unionsq U2(X,Y,Di, p, s) unionsq U8(X,Y,Di, p)unionsq U9(X,Y,Di, p, s) unionsq U7(X,Y,Di, p)F (Disconfirm) = ?s.?X.?Y.?Di.
?p.U1(X,Y,Di,?p, s) unionsq U2(X,Y,Di,?p, s) unionsq U8(X,Y,Di,?p, s)unionsq U9(X,Y,Di, p) unionsq U7(X,Y,Di, p)F (Question) = ?X.?Y.?Di.
?z.U10(X,Y,Di, z) unionsq U11(X,Y,Di, z)F (Prop.Question) = ?X.?Y.?Di.
?p.U10(X,Y,Di, p) unionsq U11(X,Y,Di, p) unionsq U12(X,Y,Di, p)F (CheckQuestion) = ?X.?Y.?Di.
?z.U10(X,Y,Di, p) unionsq U11(X,Y,Di, p) unionsq U4(X,Y,Di, p)F (SetQuestion) = ?X.?Y.?Di.
?z.U10(X,Y,Di, P ) unionsq U11(X,Y,Di, P ) unionsq U13(X,Y,Di, P )F (ChoiceQuestion) = ?X.?Y.?Di.
?p.U15a(X,Y,Di, p) unionsq U15(X,Y,Di, p) unionsq U16(X,Y,Di, p)Table 3: Update semantics for information-providing and information-seeking communicative functionsAs an illustration of the update semantics of information-providing functions, consider the case of theanswer in (9.2).
(9) 1.
D: twenty-five euros, how much is that in pounds?2.
C: twenty-five euros is something like 20 poundsApplying the semantics of the Answer function (see Table 3) to the participants C and D and the semanticcontent of (9.2), we obtain:(10) F (Answer)(C, D, Task, EU25=BP20) = U1(C,D,SemC, EU25=BP20) unionsqunionsq U2(C,D,Task, EU25=BP20) unionsq U9(C, D, Task, EU25=BP20) unionsq U7(C, D, Task, EU25=BP20) =D?SemC =+ Bel(D, Want(C, Bel(D, EU25=BP20))); D?SemC =+ Bel(D, Bel(C, EU25=BP20));D?SemC =+ Bel(D, Bel(C, Want(D, Know-val(D, EU25=BP20)))); D?SemC =+ Bel(D, Bel(C, Assume(D,Know-val(C, EU25=BP20))))6Hence the following beliefs are added to D?s pending Semantic Context: (1) C wants D to know thatEU25=BP20; (2) C believes that EU25=BP20; (3) C believes that D wants to knowwhether EU25=BP20;and (4) C believes that D assumes C to know whether EU25=BP20.U1(X,Y,Di, p, s) Y ?i =+ Bel(Y , Want(X,Bel(Y, p, s)))U2(X,Y,Di, p, s) Y ?i =+ Bel(Y , Bel(X, p, s))U3(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X, p))U4(X,Y,Di, p) Y ?i =+ Bel(Y , Wk-Bel(X, p))U5(X,Y,Di, p) Y ?i =+ Bel(Y , Bel(X, Assume(Y, p)))U6(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X , Assume(Y, p)))U7(X,Y,Di, p) Y ?i =+ Bel(Y , Bel(X, Assume(Y, Know-val(X,P ))))U8(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X, Wk-Bel(Y, p))U9(X,Y,Di, p) Y ?i =+ Bel(Y , Bel(X, Want(Y, Know-val(Y, p))))U10(X,Y,Di, p) Y ?i =+ Bel(Y , Want(X, Know-val(X, )))U11(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X, Know-val(Y, p))U12(X,Y,Di, p) Y ?i =+ Bel(Y , Bel(X , p ?
?p))U15(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X, p1 xor p2))U15a(X,Y,Di, p) Y ?i =+ Bel(Y , Want(X, Bel(X, p1) ?
Bel(X, p2))))U16(X,Y,Di, p) Y ?i =+ Bel(Y , Assume(X,Bel(Y, p1) ?
Bel(Y, p2))))Table 4: Elementary update functions used in the semantics of information-transfer functionsb.
Commissive and Directive Functions For the classes of commissive and directive communicativefunctions, we provide for reasons of space the semantics of only a small selection of functions; see Bunt(2011a) for more.F (Offer) = ?C?.?X.?Y.?Di.?
?.U25a(X,Y,Di, ?)
unionsq U20(X,Y,Di, ?, C?
)F (AddressRequest) =?C?.?X.?Y.?Di.?
?.U17a(X,Y,Di, ?, C?)
unionsq U18(X,Y,Di, ?)
unionsq U26b(X,Y,Di, ?
)F (AcceptRequest) =?C?.?X.?Y.?Di.?
?.U17(X,Y,Di, ?, C?)
unionsq U18(X,Y,Di, ?)
unionsq U26b(X,Y,Di, ?
)F (DeclineRequest) =?C?.?X.?Y.?Di.?
?.U27(X,Y,Di, ?,C?)
unionsq U18(X,Y,Di, ?)
unionsq U26b(X,Y,Di, ?
)F (Request) = ?C?.?X.?Y.?Di.?
?.U23(X,Y,Di, ?, C?)
unionsq U26(X,Y,Di, ?
)F (Instruct) = ?C?.?X.?Y.?Di.?
?.U24(X,Y,Di, ?, C?)
unionsq U26(X,Y,Di, ?)
unionsq U25(X,Y,Di, ?
)F (AddressOffer) = ?C?.?X.?Y.?Di.?
?.U17b(X,Y,Di, ?, C?)
unionsq U25(X,Y,Di, ?)
unionsq U25b(X,Y,Di, ?
)F (AcceptOffer) = ?C?.?X.?Y.?Di.?
?.U24(X,Y,Di, ?)
unionsq U25(X,Y,Di, ?)
unionsq U25b(X,Y,Di, ?
)Table 5: Update semantics for a selection of commissive and directive functionsAs an example of the interpretation of a directive dialogue act, consider the request in (11.2):(11) 1.
A: (...)2.
B: Could you please repeat that?Applied to the participants A and B and the semantic content Repeat(u1), which situates the Requestact in the Auto-Feedback dimension, the definition of the Request semantics in Table 5 leads to:(12) F (Request)(A, B, Auto-Feedback, ?Repeat(u1), unconditional?)
= ?C?.?X.?Y.?Di.??.
)U23(X,Y,Di, ?, C?
unionsq U26(X,Y,Di, ?
)(A, B, Auto-Feedback, Repeat(u1), >) == U23(A,B, CC, Repeat(u1), >) unionsq U26(A,B, C, Repeat(u1)) =B?CC =+ Bel(B, Want(A, [WilDo(A,Repeat(u1) ?
CommitDo(B,Repeat(u1))]));B?CC =+ Bel(B, Bel(A, CanDo(B,Repeat(u1))))where ?CC?
stands for Cognitive Context.4.1.2 Dimension-Specific Communicative Functions4.1.2.1 Feedback Functions The communicative functions for providing and eliciting feedback in DIT++fall apart in those concerned with the speaker?s own processing of previous utterances (Auto-Feedback)7U17(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , CommitDo(X,?,C?
))U17a(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , ConsidDo(X,?,X,C?
))U17b(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , ConsidDo(X,?, Y, C?
))U18(X,Y,Di, ?)
Y ?i =+ Bel(Y , Bel(X,Want(Y,CommitDo(X,?,C?
)))U20(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y, WilDo(X,?,C?
))U21(X,Y,Di, ?)
Y ?i =+ Bel(Y , Bel(X, Interest(?, Y )))U23(X,Y,Di, ?)
Y ?i =+ Bel(Y , Want(X, [WilDo(Y, ?,C?)
?
CommitDo(Y, ?,C?
)]))U24(X,Y,Di, ?)
Y ?i =+ Bel(Y , Want(X,CommitDo(Y, ?
)))U25(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , Bel(X,WilDo(Y, ?,C?
)))U25a(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , Want(X, Bel(Y, WilDo(X,?,C?
))))U25b(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , Bel(X , Want(Y, Bel(X, WilDo(Y, ?,C?
)))))U26(X,Y,Di, ?)
Y ?i =+ Bel(Y , Assume(X, CanDo(Y, ?
)))U26b(X,Y,Di, ?)
Y ?i =+ Bel(Y , Bel(X, Assume(Y,CanDo(X,?
)))U27(X,Y,Di, ?, C?)
Y ?i =+ Bel(Y , CommitRefrain(X,?,C?
))Table 6: Elementary update functions used in the semantics of action-discussion functions.and those concerned with the addressee?s processing, as perceived by the speaker (Allo-Feedback).
Theelementary update functions for both dimensions are nearly identical, only differing in whose processingis concerned.
Tables 7 and 8 show the update semantics of a small, representative subset of the (25)DIT++ communicative functions for providing and eliciting feedback.U31(X,Y,Di, z) Y ?CC =+ Bel(Y , Want(X, Bel(Y, Succes-Processing(X, z)))U35(X,Y,Di, z) Y ?CC =+ Bel(Y , Want(X, Bel(Y, Accepted(X, z)))U79(X,Y,Di, z) Y ?CC =+ Bel(Y , Want(X, Bel(Y, Perception-Problem(Y, z)))U76(X,Y,Di, z) Y ?CC =+ Bel(Y , Want(X, Bel(Y, Execution-Problem(Y, z)))U61(X,Y,Di, z) Y ?CC =+ Bel(Y , Bel(X, Success-Processing(X, z)))U64(X,Y,Di, z) Y ?CC =+ Bel(Y , Bel(X, Accepted(X, z)))U67(X,Y,Di, z) Y ?CC =+ Bel(Y , Bel(X, Perception-Problem(X, z)))U85(X,Y,Di, z) Y ?CC =+ Bel(Y , Bel(X, Execution-Problem(Y, z)))Table 7: Elementary update schemes for the semantics of auto- and allo-feedback functions (selection).F (AutoPositive) = ?X.?Y.?Di.
?p.U31(X,Y,Di, p) unionsq U61(X,Y,Di)F (AlloPerceptionNegative) = ?X.?Y.?Di.
?p.U33(X,Y,Di, p) unionsq U62(X,Y,Di)F (AutoEvaluationPositive) = ?X.?Y.?Di.
?p.U35(X,Y,Di, p) unionsq U64(X,Y,Di)F (AlloExecutionNegative) = ?X.?Y.?Di.
?p.U76(X,Y,Di, p) unionsq U85(X,Y,Di)Table 8: Semantics of feedback functions (selection)4.1.2.2 Turn Management FunctionsThe communicative functions for turn management serve to decide who has or will have the speaker role.Hence the various functions for taking, accepting, grabbing, keeping, releasing, or assigning the turn areall defined in terms in who currently occupies the speaker and who wants or should have it next.For example, assigning the turn to somebody (Turn Assign) means that the participant A, who cur-rently occupies the speaker role, wants the indicated other participant, B, to occupy the speaker role next.This is expressed in the form of a combination of elementary update functions as shown in (13):(13) F (TurnAssign)(A,B) = [?X.
?Y.U101(X,Y, TurnM) unionsq U102(X,Y, TurnM ](A,B) == U101(A,B, TurnM) unionsq U102(X,Y, TurnM) == B?LiC =+ Bel(A, Current-Speaker(A)); B?LiC =+ Want(A, Next-Speaker(B))In other words, the Linguistic Context component of B?s pending context is updated to contain the beliefsthat A is the current speaker and wants B to be the next speaker.8U101(X,Y,TurnM ) Y ?LiC =+ Bel(X, Current-Speaker(X))U102(X,Y,TurnM ) Y ?LiC =+ Want(X, Next-Speaker(Y ))U103(X,Y,TurnM ) Y ?LiC =+ Bel(X, Current-Speaker(Y ))U104(X,Y,TurnM ) Y ?LiC =+ Wants(X, Current-Speaker(X))U105(X,Y,TurnM ) Y ?LiC =+ Wants(X, Next-Speaker(X))U105(X,Y,TurnM ) Y ?LiC =+ Want(X,?
Next-Speaker(X))U107(X,Y,TurnM ) Y ?LiC =+ Bel(X,?
Next-Speaker(X) ?
?
Next-Speaker(Y ))U108(X,Y,TurnM ) Y ?LiC =+ Bel(X, Want(Y , Next-Speaker(X)))Table 9: Elementary update schemes for the semantics of turn management functions.F (TurnAccept) = ?X.?Y.
?Di.U103(X,Y,Di) unionsq U105(X,Y,Di) unionsq U107(X,Y,Di)F (TurnAssign) = ?X.?Y.
?Di.U101(X,Y,Di) unionsq U102(X,Y,Di)F (TurnGrab) = ?X.?Y.
?Di.U103(X,Y,Di) unionsq U104(X,Y,Di)F (TurnKeep) = ?X.?Y.
?Di.U101(X,Y,Di) unionsq U105(X,Y,Di)F (TurnRelease) = ?X.?Y.
?Di.U101(X,Y,Di) unionsq U106(X,Y,Di)F (TurnTake) = ?X.?Y.
?Di.U105(X,Y,Di) unionsq U107(X,Y,Di)Table 10: Update semantics of turn management functions4.1.2.3 Time Management Functions Time management acts are used by a speaker to indicate thathe needs some time to compose his utterance, as signalled for instance by protracting (decreasing hisspeech tempo) or filled pauses; or that he needs so much time that he suspends the dialogue as in Just amoment.
The semantics of such acts requires a context model to contain beliefs about the amount of timeneeded by cetain cognitive processes; the DIT context model therefore assumes the representation ofestimates of amount of time to be represented in the Cognitive Context component, which also containsother information about the speaker?s cognitive processing.Consider for example consider the update semantics of a Stalling act:(14)V (<Sys,Usr, TimeM, Stalling>) = F (Stalling)(Sys, Usr, CogC)= U111(Sys,Usr ,CogC ,Time-Need(Sys, small))= Usr?CC =+ TimeNeed(Sys, small)This update operation adds to the pending cognitive context of Usr the information that Sys needs a smallamount of time.U111(X,Y,CC ) Y ?CC =+ TimeNeed(X, small)U112(X,Y,CC ) Y ?CC =+ TimeNeed(X, substantial)U111(X,Y,CC ) Y ?CC =+ TimeNeed(X, small)U112(X,Y,CC ) Y ?CC =+ TimeNeed(X, substantial)Table 11: Elementary update schemes for the semantics of time management functions.4.1.2.4 Other Communicative FunctionsThe semantics of the dimension-specific communicative functions for Contact Management, DiscourseStructuring, Own Communication Management, Partner Communication Management, and Social Obli-gations Management is quite similar to that of the dimension-specific communicative functions thatconsidered above.
the main difference being the use of other, dimension-specific predicates.4.2 The Interpretation of Communicative Function QualifiersCommunicative function qualifiers come in two varieties, ?q-specifiers?
and ?q-additives?.
Q-specifiersmake preconditions of the communicative function that they qualify more specific, for instance spec-ifying for an answer that there is some uncertainty about the correctness of its content.
Q-additivesenrich a communicative function, for instance adding that an offer is accepted happily.
Currently DITdistinguishes two classes of q-specifiers, the ?certainty?
and ?conditionality?
qualifiers, and one type of9q-additive, for ?sentiment?
representation.Qualifiers can apply only to general-purpose communicativefunctions; certainty qualifiers to information-providing functions, and conditionality qualifiers to action-discussion functions.
Sentiment qualifiers can be attached in principle to every communicative function.For the semantics of qualified communicative functions we thus have three possible cases to consider,where fi is an unqualified communicative function: (a) ?fi, qsj?
where qsj is a q-specifier; (b) ?fi, qak?where qak is a q-additive; and (c) ?fi, qsj , ask?
where qsj is a q-specifier and qak is a q-additive.
Thefollowing clauses in the definition of the recursive valuation function V for DiAML specify the semanticinterpretation in each of these cases:(15) a. V (?fi, qsj?)
= (F (fi))(F (qsj))b. V (?fi, qak?)
= ?S.?z.
[(F (fi))(S, z) unionsq (F (qak))(S, z)]c. V (?fi, qsj , qak?)
= ?S.?z.
[((F (fi))(F (qsj)))(S, z) unionsq (F (qak))(S, z)]The semantics of each of the individual qualifiers is defined as follows:(16)F (certain) = ?firm?F (uncertain) = ?weak?F (conditional) = ?cond?F (unconditional) = > (the ?empty?
condition)F (sentimentk) = ?X.?u.
SENTIMENT-PREDICATEk(X,u)We consider two examples.
The first illustrates the semantics of an answer, qualified as uncertain, asin (17) (?p5?
abbreviates the proposition that the train to Tilburg leaves from platform 5):(17) 1.
A: Does the train to Tilburg leave from platform 5?2.
B: I think so, probably yes.
(18)V (?B,A,Task, p5, ?Answer, uncertain?)
= V (?Answer, uncertain?
)(A,B,Task, p5)= B?i =+ Bel(B, U1(A,B,Task, p5,weak) unionsq U2(A,B,Task, p5,weak) unionsq U9(A,B, Task, p)unionsq U7(A,B, Tak, p)= A?SemC =+ Bel(A, Want(B,Bel(A, p, weak))); A?SemC =+ Bel(A, Bel(B, p, weak));A?SemC =+ Bel(A, Bel(B, Want(A, Know-val(A, p))));A?SemC =+ Bel(A, Bel(B, Assume(A, Know-val(B, p))))This means that A?s pending semantic context is extended with the following pieces of information:(19) 1.
Bel(B, p5,weak), or equivalently: Wk-Bel(B, p5); i.e., B holds the uncertain belief that p5;2.
Want(B, Wk-Bel(A, p5)), i.e.
B has the goal that A also holds this uncertain belief;3.
Bel(B, Want(A, Know-val(A, p))), i.e.
B believes that A wants to know whether p5.4.
Bel(B,Assume(A, Know-val(B, p))): B believes that A assumes that B knows whether p5.Second, example (20) illustrates the semantics of an unconditional Accept Offer with a happy sentiment(as in A: How about a cup of coffee?
B: Oh yes, that would be wonderful!
), using (15c).
(20)V (?AcceptOffer, unconditional, happy?)
== ?S.?z.
[[F (AcceptOffer)(F (unconditional))](S, z) unionsq [F (happy)](S, z)]= ?S.?z.[[[?X.?Y.?Di.??.?C?.
U24(X,Y,Di, ?)
unionsq U25(X,Y,Di, ?, C?)
unionsqU25b(X,Y,Di, ?, C?
)](>)](S, z) unionsq HAPPY(S, z))]= [[?S.?Y.?Di.?z.?Cz.
U24(S, Y,Di, z) unionsq U25(S, Y,Di, z,>) unionsqU25b(S, Y,Di, z,>)] unionsq HAPPY(S, z))]Applied to the participants A and B and the action ?coffee?, we obtain:(21)= A?Task=+ Bel(A, Want(B,CommitDo(A, coffee)));A?Task =+ Bel(A, Bel(B, WilDo(A, coffee)));A?Task =+ Bel(A, Bel(B, Want(A, Bel(B, WilDo(A, coffee)))));A?CC =+ HAPPY(B, coffee))]10In other words, the Task component of A?s pending context is extended with the beliefs that B wantsA to commit himself to arrange coffee; that A is willing to do s o; and that A wants B to believe that.Moreover, the understanding thatB is happy to get some coffee is represented in the cognitive componentof A?s pending context.Concerning the certainty regarding the correctness of provided information, as represented throughcertainty qualifiers, the unmarked case in natural language is certain.
A speaker who is quite certain aboutsomething may indicate this by expressions like definitely, most certainly, but this tends to occur onlywhen doubt or disbelief has expressed about something that was claimed.
When there is no expressionof uncertainty, the speaker?s utterance is therefore interpreted as expressing certainty.
For conditionality,the unmarked case is unconditional; an unconditional commitment or willingness to perform a certainaction can be expressed explicitly, but this tends to occur only if some doubt has been expressed aboutsomeone?s commitment or willingness.
When no conditions for performing an action are expressed, wetherefore interpret the utterance as unconditional.5 Conclusion and Future WorkThis paper has outlined an update semantics of dialogue acts, associated with annotation structures de-fined by the abstract syntax of the DIAML language for semantic annotation, which forms part of ISOstandard (24617-2) under development for dialogue act annotation.Future work that?s crying to be done includes further implementation, testing and evaluation beyondwhat has already been done (see Petukhova, Bunt and Malchanau, 2010; Keizer, Bunt and Petukhova,2010), and supplementing the approach with an interpretation of the relations between dialogue acts andother units in dialogue (see Petukhova, Pre?vot and Bunt, 2011).AcknowledgementsI thank the members of the Tilburg Dialogue Club, who over the years have contributed to shapingDynamic Interpretation Theory, as well as PhD students and colleagues in related projects.
This includesVolha Petukhova, Jeroen Geertzen, Simon Keizer, Roser Morante, Amanda Schiffrin, Ielka van der Sluis,Hans van Dam, Yann Girard, Rintse van der Werff, Elyon Dekoven, Paul Piwek, Robbert-Jan Beun, Rene?Ahn, and Leen Kievit.
Important contributions have also come from collaborative work in ISO project24617-2 ?Semantic Annotation Framework, Part 2: Dialogue Acts?, in particular with David Traum.ReferencesAhn, R. (2001).
Agents, Object and Events: A computational approach to knowledge, observation andcommunication.
PhD Thesis, Eindhoven University of Technology.Bunt, H. (2000).
Dialogue pragmatics and context specification.
In H. Bunt and W. Black (Eds.
), Abduc-tion, Belief and Context in Dialogue.
Studies in Computational Pragmatics, pp.
81?150.
Amsterdam:John Benjamins.Bunt, H. (2006).
Dimensions in dialogue annotation.
In Proceedings of the 5th International Conferenceon Language Resources and Evaluation (LREC 2006), Genova, Italy, Paris, pp.
919?924.
ELRA.Bunt, H. (2009).
Multifunctionality and muldimensional dialogue semantics.
In Proceedings of Dia-Holmia, 13th Workshop on the Semantics and Pragmatics of Dialogue, Stockholm, pp.
3?14.Bunt, H. (2010).
A methodology for designing semantic annotation languages.
In Proceedings of the 2ndInternational Conference on Global Interoperability for Language Resources, Hong Kong, pp.
29?46.Bunt, H. (2011a).
Formal specification of an update semantics for dialogue acts.
TiCC Technical ReportTR 2011-001, Tilburg Center for Cognition and Communication.11Bunt, H. (2011b).
Multifunctionality in dialogue and its interpretation.
Computer, Speech and Lan-guage (25), 225 ?
245.Bunt, H.
(forthc.).
Interpretation and generation of dialogue with multidimensional context models.
InA.
Esposito (Ed.
), Toward Autonomous, adaptive, and context-aware multimedia interfaces, pp.
81?131.
Berlin: Springer.Bunt, H., J. Alexandersson, J. Carletta, J.-W. Choe, A. Fang, K. Hasida, K. Lee, V. Petukhova,A.
Popescu-Belis, L. Romary, C. Soria, and Traum (2010).
Towards an ISO standard for dialogueact formal annotation.
In Proceedings 7th International Conference on Language Resources andEvaluation (LREC 2010), Malta.
Paris: ELRA.Cooper, R. (2000).
Information states, attitudes and dependent record types.
In L. Cavedon, P. Blackburn,N.
Braisby, and A. Shimojima (Eds.
), Logic, Language and Computation, Vol 3, pp.
85?106.
Stanford:CSLI Publications.Core, M. and J. Allen (1997).
Coding dialogs with the DAMSL annotation schema.
In AAAI FallSymposium on Communicative Action in Humans and Machines, Boston, MA.Ide, N. and H. Bunt (2010).
Anatomy of semantic annotation schemes: Mappings to GrAF.
In Proceed-ings of the4th Linguistic Annotation Workshop (LAW-IV), Uppsala.Ide, N. and L. Romary (2004).
International standard for a linguistic annotation framework.
NaturalLanguage engineering 10, 211?225.ISO (2010).
DIS 24617-2: Semantic annotation framework Part 2: Dialogue acts.
ISO, Geneva: DraftInternational Standard, July 2010.Kievit, L., P.Piwek, R.-J.
Beun, and H. Bunt (2001).
Multimodal cooperative resolution of referentialexpressions in the DenK system.
In H. Bunt and R.-J.
Beun (Eds.
), Cooperative Multimodal Commu-nication, pp.
197?214.
Berlin: Springer.Morante, R. (2007).
Computing meaning in interaction.
Ph.D. Dissertation, Tilburg University.Petukhova, V. and H. Bunt (2009a).
Dimensions in communication.
TiCC Technical Report TR 2009-003, Tilburg University.Petukhova, V. and H. Bunt (2009b).
The independence of dimensions in multidimensional dialogue actannotation.
In Proceedings NAACL HLT Conference, Boulder, Colorado.Petukhova, V., H. Bunt, and A. Malchanau (2010).
Empirical and theoretical constraints on dialogue actcombinations.
In Proceedings 14th Workshop on the Semantics and Pragmatics of Dialogue, Poznan.Poesio, M. and D. Traum (1998).
Towards an axiomatisation of dialogue acts.
In Proceedings of thetwente Workshop on the Semantics and Pragmatics of Dialogue, Enschede, pp.
207 ?
222.Traum, D. and S. Larsson (2003).
The information state approach to dialogue management.
In Currentand New Directions in Discourse and Dialogue, Kluwer, Dordrecht, pp.
325 ?
345.12Appendix: The DIT++ taxonomy of communicative functionsGeneral-purpose functionsHHHHHHHHHjInformation-transfer functionsInformation-seeking functions?Question    @@@@R?
?ChoiceQuestionPropositional QCheck Q?Set Q?Posi-Check Nega-Check@@@@RAction-discussion functions@@@@R@@@@R    Information-providingfunctionsInform    Answer    @@@@RDisconfirm Confirm?Agreement Disagreement?Correction@@@@RCommissives?
@@@@ROffer?AddressSuggestion?AcceptSuggestion@@@@RDeclineSuggestionPromise?AddressRequest@@@@R    AcceptRequestDeclineRequestDirectives@@@@R    RequestSuggestion?Instruct?AddressOffer    DeclineOffer?AcceptOfferFigure 1: General-purpose functionsDimension-specific functions9)    	 ?@@@@RHHHHHHHHjPPPPPPPPPPPPqXXXXXXXXXXXXXXXXzAuto-Feedback?PositiveNegativePos.
AttentionPos.
Perception(...)Pos.
ExecutionNeg.
Attention(...)Neg.
ExecutionAllo-Feedback?PositiveNegativeElicitation(...)Time?StallingPausingContact?C-IndicationC-CheckPCM?CompletionCorrect-misspeakingTurn?    @@@@RTurn-initial?Turn AcceptTurn TakeTurn GrabTurn-final?Turn AssignTurn ReleaseTurn KeepOCM?Error sign.RetractSelf-correctionDS?OpeningPre-closing(...)SOM?I-GreetingR-GreetingSelf-IntroR-Self-IntroApologyAccept-Ap.ThankingAcc.-ThankingI-GoodbyeR-GoodbyeFigure 2: Dimension-specific communicative functions13
