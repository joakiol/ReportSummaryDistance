Denotational Semantics for "'Natural'"Language Question-Answering Programs 1Michae l  G. Ma in  2Dav id  B. BensonDepar tment  of  Computer  Sc ienceWash ington  Sta te  Un ivers i tyPu l lman,  WA 99164-1210Scott-Strachey style denotational semantics is proposed as a suitable means of commu-nicating the specification of "natural" language question answerers to computer program-mers and software engineers.
The method is exemplified by a simple question answerercommunicating with a small data base.
This example is partly based on treatment offragments of English by Montague.
Emphasis is placed on the semantic interpretation ofquestions.
The "meaning" of a question is taken as a function from the set of universes toa set of possible answers.1.
IntroductionWe advocate the use of Scott-Strachey denotationalsemantics for "natural" language question-answeringprograms.
The majority of this paper demonstratesthe use of denotational semantics for a small questionanswerer.
The types of questions possible are similarto those in Harris (1979), Winograd (1972), andWoods (1972).
The analysis is not as deep as in Kart-tunen (1977) or similar studies, as it is oriented to thespecification of useful, but linguistically modest, capa-bilities.Before the demonstration, we discuss the benefitsof formal semantics and why denotational semantics isan appropriate formalization.
The semantics of aquestion answerer is given by defining the action ofthe program for each possible input.
An informalsemantic description, perhaps in narrative form, isnecessary for a potential user who wants to know whatquestions he may ask and what sort of answers theprogram will provide.
Informal meanings are alsovaluable to the designer and implementer of a questionanswerer.
However, the designer and implementermust understand all aspects of a proposed questionanswerer in a precise unambiguous way that informal1 This research was supported in part by NSF grantsMCS7708486 and MCS8003433.2 Current Address: Department of Computer Science, Uni-versity of Colorado, Boulder, CO 80309.methods do not provide.
In short, a formal method ofspecifying the semantics is needed at the design andimplementation stage (see Ashcroft and Wadge 1982).Once a formal semantics has been given, it can beput to other uses as well.
It can provide the basis fora rigorous proof of correctness of an implementation.Furthermore, formal specifications might allow partialautomation of the implementation process in the sameway that automatic ompiler-writers produce parts of acompiler from a formal specification of a programminglanguage (see Johnson 1975).
With the advent of atleast one commercially available "natural" languagequestion-answering program (Harris 1979), these ad-vantages become even more concrete.If there is a familiarity to these arguments, it isbecause the same reasoning is used to justify formalsemantics for programming languages.
The problemsof design and analysis of question answerers are muchthe same for programming languages - Benson (1975)argues this point at length.
An obvious approach is toapply a programming language technique - denotation-al semantics - to the problem of formally specifying aquestion answerer.
As a bonus, the method is under-stood by many programmers and software engineersthrough introductory textbooks such as Stoy (1977),Gordon (1979), McGettrick (1980), Pagan (1981),and Tennent (1981).
Additionally, linguistic treat-ments of natural language, such as Montague (1973),are basically denotational and we can modify suchCopyright 1983 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial dvantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires afee and/or specific permission.03 62-613X/83/010011-11 $03.00American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 11Michael G. Main and David B. Benson Denotational Semantics for 'Natural' Language Q-A Programstreatments to meet our needs.In denotational semantics for programming lan-guages, evaluation functions map program segmentsinto objects in various semantic domains.
These ob-jects are taken as the meanings of the program seg-ments, and determine the output of a program.
Simi-larly, in the semantics of a question answerer, evalua-tion functions map input (questions) into objects thatdetermine the output (answers).Deciding what objects are in the semantic domainshas a fundamental  effect on the capabilities of theoverlying question answerer, as well as an effect onthe usefulness and clarity of the semantic descriptions.Lewis (1972) discusses these considerations for natu-ral language sentences and the domains described insection 2 are based on his, although the treatment ofquestions is closer to Ajdukiewicz (1926).
Also intro-duced in section 2 are the lambda expressions thatdenote individual semantic objects.
Such expressionshave been used in denotational semantics of program-ming languages (see Scott 1970, Milne and Strachey1976, Stoy 1977) and in treatments of fragments ofEnglish by Montague (1973).In section 3, evaluation functions mapping inputsfor a small question answerer to objects in the seman-tic domain are given.
The allowable questions aredefined by a category grammar as has been done byAjdukiewicz (1935), Carnap (1937), Lewis (1972),Montague (1973), and others.
An account of theanswer relationship is given in section 4.In the final section, we briefly describe an imple-mentation of the question answerer and suggest somebroad principles for designing question answerers.2.
Semantic Domains for Natural Language2.1 The DomainsA semantic domain is a set of objects.
The objects aremeanings of syntactic constructs; in our case the syn-tactic constructs are natural language phrases.
In de-notational semantics for programming languages, thesemantic domains often have some order imposed onthe objects to treat recursively defined functions.
Thespecification of a question answerer may also involveexplicit recursively defined questions, although in thisdemonstration only quantification is used and not re-cursion.
This does not prevent an implementat ionfrom using recursion - almost surely it will, to handlethe quantification.
But lack of recursion does allow usto use unordered semantic domains, as described be-low.One domain is the set of objects about which ques-tions will be asked, e.g., moon rocks, toy blocks, orwhatever.
We are not concerned with the internalstructure of these objects; hence they are called atomsand the domain is designated A.
Two other domainsare the set of natural numbers, designated N, and theset of truth values {true, false}, designated T.A fourth domain is the set of possible universes,designated U.
Intuitively, a universe is a descriptionof properties of atoms, the relationships between at-oms, the relationships between relationships, etc .... Auniverse is usually a partial description including onlythe properties and relationships of interest.
For exam-ple, in the toy blocks world (Winograd 1972) a uni-verse is the specification of the size, shape, color, andposition of all the blocks in the scene.
A toy blocksuniverse does not include a description of the density,mass, or material composition of the various blocks.In application, the set of possible universes may becalled a "data base",  and each actual universe is aspecific state or configuration of the data base.
Theinternal structure of such a data base is left unspeci-fied in this paper.Other semantic domains are built from the fourbasic domains.
For example, the set of functions fromuniverses to truth values, designated \[U--T}, is a newdomain.
In general, if X and Y designate sets, then\[X--Y} designates the set of functions from X to Y.Other semantic domains could be conceived (e.g.,product or sum domains), but function domains will beadequate for our examples.2.2 Assigning domains to syntactic categoriesNatural language phrases have been divided into manydifferent categories (see Kahn 1978).
Exactly whichcategories are used depends upon syntax.
In the cate-gory grammar of section 3, the categories include sen-tence, intransitive verb, common noun, noun group,noun modifier, numeral, and so on.
There are alsoseparate interrogative categories for phrases that ask aquestion, such as how many stones.To each syntactic category, a semantic domain isassigned.
The meaning of a phrase is an object in theassigned domain.
Ultimately, from the meaning of aquestion, we will derive its answer.
But first we assigndomains to non-interrogative categories, beginningwith the category of sentences.A declarative sentence is a proposition - that is,something to which a truth value can be assigned.
Themeaning of a sentence somehow determines what thattruth value is in any possible universe.
So, an appro-priate semantic object for a sentence is a functionfrom possible universes to truth values.
The domainassigned to the category of sentences is therefore\[U--T}, which we will designate S. If a declarativesentence has a meaning a E S, and/3 is a universe, thena/3 is true just if the sentence is true in the universe/3.33 Lower case Greek letters are semantic objects.
Juxtaposi-tion indicates functional application and associates left-to-right.Thus, a/3 means the function a applied to the argument /3, and a/37means (a(/3))(),).12 Amer ican  Journa l  of Computational Linguistics, Volume 9, Number 1, January-March 1983Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A ProgramsIf there is a single fixed universe, then sentences couldbe assigned meanings in T alone.
However, questionanswerers are generally based on a changeable uni-verse or data base.
Hence, the \ [U- -T\ ]  approach isneeded to give a fixed meaning to a sentence whosetruth value may vary from universe to universe.Both common nouns and intransitive verbs definesubsets of A.
The subset of stone (a common noun) isthe set of atoms that are stones.
The subset for theintransitive verb phrase belong to Preston is the set ofatoms that belong to Preston.
The meaning of such aphrase determines what that subset is for any possibleuniverse.
This can be done by an object in\[U-~\[A-~T\]\] (i.e., functions from U to \[A--T\]) .
Thisdomain is assigned to both common noun and intransi-tive verb categories, and is designated by C. If a com-mon noun has a meaning a e C, and/3 is a universe and3' an atom, then a/33' is true just if ~, is in the subsetdefined by the common noun in the universe /3 - andsimilarly for intransitive verbs.For most other syntactic categories, the semanticdomain is determined by how phrases in that categorycombine with sentences, common nouns, intransitiveverbs, and other phrases to form new phrases.
Forexample, a noun group combines with an intransitiveverb to form a sentence.
Therefore, a semantic objectfor a noun group should take a semantic object from C(the domain for intransitive verbs) and yield a seman-tic object from S (the domain for sentences).
Thus,the semantic domain for noun groups is \[C-~S\].
4Similarly, a noun modifier, such as black, combineswith a common noun, such as stone, to form a newcommon noun - black stone.
So, the semantic domainfor noun modifiers is \[C--C\].
By examining the syn-tactic rules, this method can be applied to most cate-gories.
5 Occasional exceptions can be made - forexample, numerals are assigned the domain, N, ofnatural numbers.2.3 Interrogative categoriesSo far, the categories include only non-interrogativephrases.
Syntactically, the interrogative phrases paral-lel the non-interrogatives, but semantically an interro-gative lacks something.
For example, Ajdukiewicz(1926) would represent he meaning of the interroga-4 A name, such as John, is one type of noun group that de-notes a particular atom which does not change from universe touniverse Therefore, it might be better to have names in a separatesyntactic category with assigned semantic domain A.
But, doingthis would not do away with the category noun group, since somenoun phrases are not names (e.g., every stone).
But, having twocategories unduly complicates the syntax, so we lump names togeth-er with other noun groups, and treat them as Montague (1973) has.5 This method of assigning semantic domains is an applicationof Frege's rule of compositionality, which says that the meaning ofa compound phrase is composed from the meaning of its parts?
(Frege 1892, van Emde Boas and Janssen 1979)tive sentence what is black and white and read all overas: ?x(x is black and white and read all over).
Here, xis a variable and "?"
a quantifier indicating the lack.In this case, the range of the variable is the set ofnoun group phrases that could answer the question.There are also interrogative phrases in other cate-gories, such as the intransitive verb phrase owns what.And it is not always a noun group that is missing; for?
example, the noun group how many stones lacks a nu-meral.
In general, any non-interrogative category ismade into an interrogative category by indicating whatis lacking.
Hence, if X and Y are non-interrogativecategories, then X?Y designates the category of inter-rogative phrases that are syntactically like X-phrasesbut semantically lack a Y-phrase.
6 If Y has semanticdomain Y and X has semantic domain X, then X?Y willhave semantic domain \[Y--X\].
Furthermore,  if aninterrogative phrase in X?Y has a meaning aE\[Y-~X\],then a/3 is that object of X that results when /3eY an-swers the interrogative.For example, the interrogative sentence who killedcock robin will have a meaning aE\ [ \ [C-~S\] - -S \ ] ,  since itis a sentence (domain S) lacking a noun group(domain \ [C- -S\ ] ) .
If the sparrow has a meaning/3t IC- -S \ ] ,  and the sparrow killed cock robin has ameaning 7ES, then a/3=~,.A similar idea can be applied to one other catego-ry: yes-no questions.
Such an interrogative lacks atruth value, so the semantic domain assigned to yes-noquestions is \ [T - -S \ ] .
If a t \ [T - -S \ ]  is the meaning of ayes-no question, then a(true)?
S is the meaning of thesentence when it is answered by yes, and similarly foran a(false).2.4 Lambda expressionsUp to this point, semantic objects have been describedin English.
In order to be more precise, a formal no-tation is needed.
We use a typed lambda expressionfor denoting functions, similar to the lambda calculi ofChurch (1951).Every lambda expression has a type that indicatesthe semantic domain of the object denoted by theexpression.
These types are in one-to-one correspon-dence with the semantic domains (A, U, T, N, \[U-~T\],etc .... ), so we will use the same letters in ordinarytypescript for the expression types (A, U, T, N,\[U-~T\], etc .... ).The expressions of each type include a set of con-stants and a denumerable set of variables.
A functionthat maps the constants into semantic objects is aninterpretation, and generally remains fixed.
A func-tion that maps variables into semantic objects is avariable assignment and, as its name suggests, will6 This could be extended to include phrases, like who doeswhat, which question more than one thing at a time.American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 13Michael G. Main and David B. Benson Denotational Semantics for "Natural' Language Q-A Programschange.
If q, is a variable assignment, x is a variableof any type, and a is an object from the semantic do-main of x, then ~p\[a/x\] is a changed variable assign-ment that is like ~ except that q~\[a/x\] assigns a to thevariable x.
In this way, new variable assignments areformed from old.
Finally, each lambda expressiondenotes one semantic object, but which object this isvaries as the variable assignment changes.
So, for anexpression b the notation \[\[bll ~ is to denote the se-mantic object for the expression b, with variable as-signment ~p.7Table 1 gives recursive rules defining lambda ex-pressions and the semantic objects they denote.
Wetake as given a set of constants and a denumerable setof variables for each type, and a fixed interpretation,q0.
X and Y are arbitrary types, with correspondingsemantic domains X and Y.Some lambda expressions can be derived more thanone way.
Any such ambiguities are resolved as fol-lows:a.
The expression following a lambda abstraction (i.e.,),x) or a quantifier (i.e., 3x, ?x, 3nx,) will be aslong as possible - that is, to the first unmatchedright parenthesis or to the end of the entire expres-sion.b.
The unary operator -, has higher priority than anyof the binary operators (A, V, =, =>, .-, >, andfunctional application, which is indicated by juxta-position).
Functional application has the highestpriority of the binary operators and associates left-to-right, e.g., bcd=(bc)d.  The other binary opera-tors have equal precedence and also associate left-to-right, e.g., bcAdcVc = ((bc)A(dc))Vc.3.
Syntax  and Semant ics  of a Smal l  Quest ionAnswerer3.1 Syntact ic  categor iesTo illustrate the mechanics of the previous section, wegive the syntax and semantics of a small question an-swerer.
The question answerer accepts questionsabout configurations of pieces in the game of Go.Briefly, a configuration consists of a 19 by 19 grid ofpoints, labeled A-1 through S-19.
Each point maycontain a black or a white stone.
Like-colored stones,connected horizontally or vertically, form blocks.Empty points adjacent to a block are that block's lib-erties.
Each configuration is a universe in the seman-tic domain U.The syntax for a question answerer must answerthe question: what phrases are grammatically correctinput to the question answerer?
Our approach usesvarious syntactic categories, in the style of Montague(1973).
A syntactic category is a set of phrases, in-cluding basic phrases and derived phrases.
The de-rived phrases are specified by recursive syntactic rulesthat describe how phrases from various categoriescombine to form new phrases.The syntax presented here has two kinds of cate-gories.
First, non- interrogative categories, whosephrases do not ask questions.
These categories arelisted in Table 2, along with an abbreviation for each,the lists of basic expressions, and the associated se-mantic domains from section 2.
In the table, A - I ,A-2, and so on are names of points on the Go board.The basic phrases heo, he 1, they o, they 1, and so on areused as variables in a manner made precise by syntac-tic rules given later.The second kind of category is the interrogativecategory.
Syntactically, an interrogative category be-haves like some non-interrogative category, but it alsoasks a question whose answer is from some other non-interrogative category.
If a phrase is syntactically likea phrase from category X, and asks a question whoseanswer is in category Y, then that phrase is in a cate-gory X?Y.
This separation of interrogatives i neededbecause the semantic domain for interrogatives differsfrom that for non-interrogatives (see section 2.3).One additional interrogative category does not followthe X?Y pattern - the yes-no questions.
We designatethis category YN and list it in Table 3 with the otherinterrogative categories.3.2 Syntact ic  and semant ic  rulesWe now give syntactic rules that define the phrases ofeach category.
With each syntactic rule is a semanticrule.
For each phrase that a syntactic rule creates, thecorresponding semantic rule tells precisely how totranslate that phrase into a lambda expression denot-ing the meaning of the phrase.
In these rules, italicletters (u, v, w, ...) are arbitrary phrases from anycategory and F1, F2, ..., are functions that combinephrases to yield new phrases.
Variables in lambdaexpressions are of the following types.?
m,m' , .
.
.o f  type N.?
t,t',.., of type T.?
u,u',.., of type U.?
x,x~,.., of type C.?
y ,y '  .... of type \[C-~S\].?
qi is the (2i+3)th variable of type A.?
Pi is the (2 i+4)th variable of type A.?
z is the first variable of type A.?
z '  is the second variable of type A.7 The semantic object associated with a lambda expressionalso depends on the interpretation function, but we assume this isfixed.14 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A ProgramsLAMBDA EXPRESSION SEMANTIC OBJECT1.
If b is a constant of type X, then b is an expressionof type X.2.
If x is a variable of type X, then x is an expressionof type X.3.
If b is an expression of type X, then (b) is also anexpression of type X.4.
If b is an expression of type Y and x is a variableof type X, then ~x.b is an expression of type \[X--Y\] .5.
If b is an expression of type \ [X- ,Y \ ]  and c is anexpression of type X, then bc is an expression of typeY.6.
If b and c are expressions of type X, then b = c isan expression of type T.7.
If b and c are expressions of type T, then -, b, bAc,bVc, b~,c, and b<==>c are expressions of type T.8.
If n is an expression of type N, then n+l  is anexpression of type N.9.
If b is an expression of type T and x is a variableof type X, then 3x.b and Vx.b are expressions of typeT.10.
If b is an expression of type T, x is a variable oftype X and n is an expression of type N, then 3nx.b isan expression of type T.\[lbll ~ is q0b (i.e., the interpretation ~ applied to theconstant b).II x II q~ is ~x (i.e., the variable assignment ~b applied tothe variable x).II (b) II q~ is 11 b II ~.II ?,x.b II ~ is that function a:X- ,Y ,  such that for every~x,  ~/~ --- Ilbllq~\[/3/x\].II bc II ff is the function II b \[1 ~k applied to the argumentII c II q~.II b = c II ~ is true iff \[\[ b II ~ is the same semantic ob-ject as II c II ~.II-,b II q~ is true iff II b II q~ is false, and similarly for /X(and), V (or), ~ (implication), and <==> (coincidence).II n+ 1 II q~ is the natural number successor of II n II q~.113x.bll~ is true iff there exists an aEX, such thatIlbllq~\[~/x\] is true.
IlVx.bllq~ is 11-,3x.-,bll~.Let n = II n II ~k.
Then II 3nx.b II ~ is true iff there exist,/ distinct objects in X, so that for any of these ,/ ob-jects, say a, II b II q~\[~/x\] is true.Table 1.
Lambda expressions and their semantic objects.American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 15Michael G. Main and David B. Benson Denotational Semantics for 'Natural Language Q-A ProgramsSYNTACTIC CATEGORY SEMANTIC DOMAIN & BASIC PHRASESSE (sentence)CN (common oun)IV  (intransitive verb)NG (noun group)TV (transitive verb)NM (noun modifier)MG (modifying roup)PP (preposition or participial)NU (numerals)S = \[U-*T\].No basic phrases.C = \[U~\[A---T\]\].player, block, stone, liberty, pointC.exist\[c--s\].Black, White, he o, he 1 ..... they o, they 1 ..... A- l ,  A-2 .
.
.
.\[\[C--S\]--C\].own, belong to\[C-~C\].black, white\[C-~C\].No basic phrases.\[\[C-- S\]-- \[C-- C\]\].at, with, owning, belonging toN0 ,1 ,2  .
.
.
.Table 2.
Syntactic categories (non-interrogative).SYNTACTIC CATEGORY SEMANTIC DOMAIN & BASIC PHRASESYN (yes-no question)NG?NG (noun group questioning a noun group)For any two non-interrogative categories, X and Y,X?Y is an interrogative category.\[T-~S\].No basic phrases.\[\[C--S\]-- \[C-~S\]\].who, what\[Y-~X\], where X is X's domain and Y is Y's domain.None of these categories, except NG?NG, have basicphrases.Table 3.
Syntactic categories (interrogative).16 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs3.2.1 The basic ruleSyntactic Rule:RI .
For each category, its basic phrases are phrases.Semantics:We give a translation of each basic phrase, accordingto which category it is in:CN, IV: player translates to a constant of type C,denoted player; and similarly for any other basicphrase of category CN or IV.NG: Black translates to ~xAu.xu(Black), whereBlack is a constant of type A.
Having Black be aconstant of type A emphasizes the point thatBlack is a name, associated with some particularobject in A.
The translation of other basic phras-es of NG will be similar, except for he i and they i (i= 0,  1 .... ).
In particular, he i translates to~x.~u.xuqi and they i translates to ~x.~u.xuPi.TV: own translates to XyAuAz.y(~ut.
(own)uWz)u,where own is a constant of type \[U -* \[A -* \[A-- T\]\]\]; and similarly for any other basic phraseof category TV.
This emphasizes that a transitiveverb is a relation between two objects in A. Inparticular, if own interprets to a ?
\[U -- \[A -* \[A-~ T\]\]\], fleU, and 7, 8 ?A,  then afl3,d if true is theobject 3' owns the object d in the universe ft.8NM: black translates to ~x.AuAz.xuz A (black)uz,where black is a constant of type C; and similarlyfor other basic phrases of category NM.PP: at translates to ~y.~x.Xu.Xz.xuz Ay(XuV.
(at)utz)u, where at is a constant of type\[U -* \[A -- \[A -* T\]\]\]; and so on.NU: 0 translates to 0, a constant of type N, whichinterprets to the natural number 0 in N; and simi-larly for other numerals.NG?NG: what translates to ~,y.y and who translatesto ~yAx.~u.y(player)u/x yxu.3.2.2 The combinative rulesThese rules use a set of syntactic functions, F 1through F4, which combine phrases in various waysinvolving person, plurality, and so on.
We give thesefunctions first.Ft(u,v) is uv', where v' is v (if the first noun in u isplural) or the result of replacing the first verb in vby its third person singular form (if the first noun8 However, this scheme will not work with all transitive verbs,for example, alleged to be.
Such verbs, called intensional verbs,require more complex translations, but the end result will still be oftype \[\[C --,- S\] ~ CI.
The same complexities arise for NM and PP.Our example contains none of these intensional words.in u is singular).F2(u,v) is uv t, where v' is the result of replacing thefirst noun in v by its objective form.F3(u,v) = uv.F4(u,v) = vu.Syntactic Rules:R2.
If u is a phrase from NG and v is a phrase fromIV, then Fl(U,V) is a phrase from SE.R3.
If u is a phrase from TV and v is a phrase fromNG, then F2(u,v) is a phrase from IF.R4.
If u is a phrase from PP and v is a phrase fromNG, then F2(u, v) is a phrase from MG.R5.
If u is a phrase from NM and v is a phrase fromCN, then F3(u,v) is a phrase from CN.R6.
If u is a phrase from MG and v is a phrase fromCN, then F4(u,v) is a phrase from CN.Interrogative Variants of Syntactic Rules:In any of the rules R2 through R6, exactly one of thearguments, u or v, may be a phrase from category X?Y,where X is the original category specified for the argu-ment and Y is any non-interrogative category.
If theoriginal result was to be from category Z, then thenew result is in category Z?Y.
For example, from R2,if u is a phrase from NG?NG and v is a phrase fromIV, then Fl(U,v) is a phrase from SE?NG.Semantics:Let w = Fi(u,v), fo r i  = 1, 2, 3, or 4.
Let u translateto b and v translate to c. Then there are three casesfor the translation of w"Case (i): If neither u nor v is from an interrogativecategory, then w translates to bc.Case (ii): If u is from an interrogative category X?Y,then w translates to ~s.bsc, where s is a variableof type assigned to the category Y.Case (iii): If v is from an interrogative category X?Y,then w translates to ~s.b(cs), where s is a varia-ble of type assigned to the category Y.3.2.3 Extracategorical rulesThese rules combine phrases with words from outsidethe categories to form new phrases.
The rules use twosyntactic functions given here:Fs(u,v) is vu v, where u t is u (if v = 1), or the result ofreplacing the first noun in u by its plural form (ifv~ 1).F6(u ) is the result of replacing the first noun in u withits plural form.Syntactic Rules and Semantics:R7.
Let u be a phrase from CN, translating to b.American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 17Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A ProgramsThen:(i)(ii)(iii)(iv)every u is a phrase from NG, translating toXx.Xu.Vz.buz => xuz.some u is a phrase from NG, translating toXx,Xu.3z.buz A xuz.the u is a phrase from NG, translating toXx.Xu.3z.xuz A ?z ' .
(buz'  < ;.
( z=z ' ) ) .no u is a phrase from NG, translating tokx.Xu.-~3z.buz A xuz.R8.
Let u be a phrase from CN, translating to b.Also let v be a phrase from NU, which translatesto n. Then:(i) exactly Fs(u,v) is a phrase from NG, trans-lating to Xx.Xu.
(3nz.buz A xuz) A- , (3 (n+l )z .buz  A xuz).
(ii) at least Fs(u,v) is a phrase from NG,translating to Xx.Xu.3nz.buz A xuz.
(iii) less than F5(u,v) is a phrase from NG,translating to Xx.Xu.-, (3nz.buz A xuz).R9.
Let u be a phrase from SE, translating to b.Then is it the case that u is a phrase from YN,translating to M.Xu.bu<==>t.R10.
Let u be a phrase from CN, translating to b.Then:(i) what F6(u) is a phrase from NG?NG,translating to ?~y.Xx.Xu.ybu A yxu.
(ii) how many F6(u ) is a phrase from NG?NU,translating to Xm.Xx.Xu.
(3mz.buz A xuz)A -, ( \ ] (m+ 1)z.buz A xuz.3.2.4 The abstraction ruleThis rule is to replace the variables he i and they i byother noun phrases.
The necessity for abstraction isdiscussed in Lewis (1972).
The syntactic functions F 7and Fs, defined below, are used.
In these definitions,let u' be the result of replacing the first noun in u withits objective form, let up be the result of replacing thefirst noun in u with its plural form, and let u'p be theresult of replacing the first noun in u with its pluralobjective form.FT(U,v,i) is the result of replacing, in v, all occurrencesof he i by u and all occurrences of him i by u' .F8(u,v,i) is the result of replacing in v, all occurrencesof they i by Up and all occurrences of them i by U'p.Syntactic Rule:R l l .
Let u be a phrase from NG, v be a phrase fromSE, IV, or CN, and i be a variable index (e.g.,0, 1, 2 .
.
.
.
).
Then FT(U,v,i) and Fs(u,v,i) arephrases from the same category as v.Interrogative Variant of Syntactic Rule:Either u may be from NG?Y or v may be from SE?Y,IV?Y, or CN?Y (but not both), where Y is any non-interrogative category.
In all cases, the result is fromX?Y, where X is the first portion of the category of v.Semantics:Let b be the translation of u and c be the translationof v. The translation of FT(U,v,i) is given in the fol-lowing table, where s is a variable of type Y:Case 1: v from SE and u from NG: b(Xu.Xqi.cu)Case 2: v from SE and u from NG?Y:Xs.bx(Xu.Xqi.cu)Case 3: v from IV  or CN and u from NG:?~u.Xz.b(Xu' .Xqi.culz)uCase 4: v from IV  or CN and u from NG?Y:Xs.Xu.Xz.bs(Xu' .Xqi.cu'z)uCase 5: v from SE?Y  and u from NG:Xs.b(Xu.Xqi.csu)Case 6: v from IV?Y or CN?Y and u from NG:?~s.Xu.Xz.b(?~u' .hqi.csu'z)uThe translation is identical for F8, except that qi isreplaced by Pi-Some of the notions in the syntactic rules must stillbe formalized.
We must define the plural, objective,and plural objective forms of each basic phrase in CN,NG, and NG?NG.
A noun is then any such basicphrase or one of these forms.
A verb is any basicphrase in IV  or TV.
For each verb we must define itsthird person singular form.A brief discussion of the abstraction rules can clari-fy their usage and purpose.
A sentence such as everyplayer owns some stone has two possible meanings.
Itcan mean: there is some particular stone owned byevery player; or alternately, every player owns at leastone stone, but not necessarily the same stone for eachplayer.
These two meanings will be achieved by intro-ducing the NG some stone at different times.
The ab-straction rules allow this by delaying the introductionof a noun phrase.
Initially, a variable (perhaps he o) isput in the sentence as a place holder.
The abstractionrules allow an NG to later replace the variable.4.
Quest ions and Answers4.1 Quest ionsA question is any phrase from category YN, SE?NG, orSE?NU, along with its syntactic derivation.
The syn-tactic derivation is needed because some phrases canbe derived in more than one way (e.g., is it the casethat every player owns some stone).Derivations are represented by trees.
Each leaf ina derivation tree is labeled with a basic phrase.
Eachinternal node is labeled with a derived phrase, plus thenumber of the syntactic rule that is used to derive itfrom its daughter leaves.From the semantic rules, every question translatesto exactly one lambda expression.18 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs4.2 AnswersLet  Q be a quest ion that t ranslates to a lambda ex-pression,  b, of type \[X ~ S\].
A lso let:?
q, be a var iable ass ignment,?
g be a constant  of type U and II g II 4~ = ~',?
d be a constant  of type X and II d II q~ = ,~.Then 6 is an answer to Q, in the universe 3' with var ia-ble ass ignment ~b iff II bdg II ~k is true.If b is an express ion of type \[X --  S\], then theanswers  to its cor respond ing  quest ion are semant icobjects  in X.
In general ,  these objects  depend on thechoice of the universe and also on the var iable assign-ment.
However ,  if the quest ion does not conta in  anyvar iables (he i or theYi), then the set of answers is thesame for any var iable assignment.
Such a quest ion iscal led invariable, and we may speak of an answer  with-out respect  to a var iable assignment.4.3 ExamplesAll  of these examples are invar iable quest ions,  so wemay choose a var iable ass ignment,  ~p, at random.
Thetypes of var iables are as in sect ion 3.2, and we alsouse a lambda constant  g, of type U.
As always,  thereis a f ixed interpretat ion  assigning the lambda constantsto semant ic  objects.In translat ing the examples  to lambda expressions,we use the semant ic  rules of sect ion 3.2.
However ,after  t ranslat ing a phrase,  we will somet imes alter  thelambda express ion in ways that cannot  change thesemant ic  object .
9Example 1.
One der ivat ion of the phrase is it the casethat every player owns some stone is:(R9) is it the case that every player owns some stoneI(R2) every player owns some stoneo (R7) every player wn some stoneI .
/ \player own (R7) some stonestoneWe have these translat ions:own some stone:Xu.Xz.=lz' .
(stone)uz' A (own)uzz '9 In particular, we use logical conversion (such as b A bconverts to b) and the a- and /3-conversions of lambda calculus.a-conversion i volves changing the name of a bound variable (e.g.,?,x.x A y converts to ),z.z A y).
/3-conversion corresponds to func-tional application (e.g., (~,x.x A y)z converts to z A y).
Details canbe found in Stoy (1977).every player:?,x.?,u.Vz.
(player)uz ~ xuzevery p layer  owns some stone:~u.Vz.
(p layer)uz => (3z~.
(stoue)uz t A (own)uzz t)is it the case that every p layer  owns some stone:Xt.?~u.(Vz.
(player)uz => (3zV.
(stone)uz ' A(own)uzz ' ) )  < ;.
tLet  true be a constant  of  type T that  in terprets  to' t rue '~T.
F rom the def in i t ion of an answer,  ' t rue '  isan answer  to this quest ion in the universe II g II ~ iff:II (MAu.
(Vz .
(p layer )uz  A (3z t .
(s tone)uz t A(own)uzz ' ) )  4=0, t ) ( t rue)g  IIHere,  ~p can be p icked at random.
The above expres-sion converts  toII ?z.
(p layer)gz  => (3zt .
(s tone)gz  w A (own)gzz t) II 4~This is a reasonable  condi t ion for ' t rue '  to answer  thequest ion.Example 2.
An  a l ternat ive der ivat ion for the previousphrase is:(R9) is it the case that every p layer  owns some stoneI(R11)  every player owns some stone\ ,some (R)  every p ayer owns h im o(R7) every player (R3)  own h im 0 stoneI / \player own he oIn this case, the t rans lat ions are:own himo:~u.Xz.
(own)uzq 0every player owns himo:Xu.Vz.
(player)uz =~ (own)uzq 0every player owns some stone:~u.3z ' .
( s tone)uz '  A (Vz.
(player)uz ~ (own)uzz v)is it the case that every player owns some stone:kt .ku.
(3z~.
(stone)uz t /k (Vz.
(player)uz(own)uzz ' ) )  < > tIn the universe II g II ~, ' t rue '  is an answer  to this ques-t ion iff:II 3z ' .
( s tone)gz '  A (Vz.
(player)gz => (own)gzz')l imbThis contrasts  with example 1.American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 19Michael G. Main and David B. Benson Denotational Semantics for 'Natural" Language Q-A ProgramsExample 3.
Here is a derivation of a phrase fromSE?NU: \[(R2) howman~tone~long  to Black(RI0)  how many stones (R3) belong to Black / / \stone belong to BlackThe semantic rules give these translations:belong to Black:Xu.Xz.
(belong to)uz(Black)how many stones:km.kxAu.(3mz.
(stone)uz A xuz) A-~ (3(m+l)z.
(stone)uz A xuz)how many stones belong to Black:km.ku.(3mz.
(stone)uz A (belong to)uz(Black)) A-, (3(m+ 1)z.
(stone)uz A (belong to)uz(Black))Let 7/ = II n II ff be a natural number.
Then 7/ answersthis question in the universe II g \[1 if, iff:II (3nz.
(stone)gz A (belong to)gz(Black)) A-, ( \ ] (n+ 1)z.
(stone)gz A (belong to)gz(Black)) IIThat is, there exists ~/ stones (but not ,/+1) that be-long to Black in the universe II g II ft.Example 4.
This question is from SE?NG.
(R2) what owns no black stonewhat (R2) own no black stoneown (R7) no black stoneI(R5) black stone / \black stoneHere are the translations to lambda expressions:black stone:Xu.Xz.
(stone)uz A (black)uzno black stone:Xx.hu.-,3z.
(stone)uz A (black)uz A xuzown no black stone:~u.~z'.-, 3z.
(stone)uz A (black)uz A (own)uz' zwhat owns no black stone:ky.y(ku.kz'.-~ 3z.
(stone)uz A (black)uz A(own)uz'z)The semantic object corresponding to White (namely,II ~x.hu.xu(White)II ~) answers this question in a uni-verse, H g II ~, iff:II-,\]z.
(stone)gz A (black)gz A (own)g(White)z II q~Any realistic interpretation interprets the constantsblack, own, and White so that H (black)gzllff andIt (own)g(White)z II q~ are mutually exclusive for any g,z, and ~k, so that the semantic object for White doesanswer this question.The difficulty with examples such as these is thateven when the translations of individual constructionsare fairly simple the translation of a complex construc-tion inevitably appears cryptic and the translationprocess is tedious.
However, the formal translationsare amenable to mechanical manipulations and thetranslating process is also easily mechanized.
Hence,we leave it as an exerciue in the manipulations to showthat the translation of what blocks own at least 3 stoneswith less than 2 liberties is as follows:Xy.ku.y(bloek)u A y(Xu.Xz"33zL(stone)uz'  A-,(32z.
(liberty)uz A (with)uz'z) A (own)uz"z ' )uThe first part of the translation guarantees that apossible answer, y, is indeed a block.
The second partchecks that y owns at least 3 stones with less than 2liberties.
Note that, although there may be other pars-ings of this sentence in a complete English grammar,our simple syntactic rules have forced this particulartranslation upon us.Answers to SE?NG questions are objects from \[C-~ S\].
However, it might be more convenient to havethese answers be objects from A.
A modification tothe definition of an answer could allow this.
In partic-ular, let b be a lambda constant of type A, which in-terprets to flEA.
Then /3 could answer a question inthe universe II g II ~, with variable assignment ~b, iffII XxAu.xuh II ~ E \[C -~ S\], does.5.
Discuss ionWe have used denotational techniques to define thesemantics of a "natural" language question answerer.The questions are defined by syntactic rules - a cate-gory grammar.
Associated with each syntactic rule isa semantic rule, giving a semantic object for eachphrase the syntactic rule produces.
The semantic ob-jects for questions are functions, from possible an-swers to propositions, where a proposition is an objectthat takes on a truth value.
Thus, if a question, Q, hasa semantic object that maps an answer, A, to a trueproposition, then A answers Q.
In this way, the rela-tion between questions and answers is formalized.While it is not our intent to give implementationdetails for the question answerer, an outline of theprogram's organization will lead to some concludingremarks.
The program was written as a class projectby the first author and four other students.
The logi-cal divisions of the program were as follows:20 American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983Michael G. Main and David B. Benson Denotational Semantics for "Natural" Language Q-A Programs?
Lexical  analysis.
The input is broken into basiccomponent  words, or "tokens", using finite auto-mata techniques as in Johnson et al (1968).?
Syntactic parser.
An augmented transition network(Woods 1970) parses the input according to thecategory grammar with heuristic rules and interac-tive query to solve ambiguities.
The output is asingle derivation tree.?
Semantic interpretation.
The "meaning" of the sen-tence is computed according to the semantic rules.The output of this phase can be thought of as"machine code" for finding answers.
At this stage,the "code" is independent of the actual structure ofthe implementation of the underlying data base.?
Deductive components.
The "code" from the previ-ous stage is improved based on conversion rules oflogic, such as x or x = x.
It is also modified ac-cording to the specific structure of the data base.The latter modif icat ions are implementat ion de-pendent.?
Answerer.
This corresponds to a database query-retrieval program.
The "code" from the previousstep is executed to produce an answer.In the actual implementation, the above stages arenot strictly separate; still, the model is useful.
Thereis a direct correspondence between the first fourstages of the implementation and the initial four stagesof a typical compiler (Aho and Ullman 1977).
Hobbsand Rosenschein (1977) indicate how these last threestages could be developed using an augmented LISP as"code".In this paper, we have recommended using denota-tional semantics as a specif ication technique forquest ion-answering programs.
The implementat ionsuggests that principles of compiler design can be usedas principles of question answerer design by the soft-ware engineer.ReferencesAho, A.V.
and Ullman, J.D.
1977 Principles of Compiler Design.Addison-Wesley, Reading, Massachusetts.Ajdukiewicz, K. 1926 The Semantic Analysis of InterrogativeSentences, Ruth Filozoficzny X.Ajdukiewicz, K. 1935 Syntactic Connexion.
In McCall, S., Ed.,Polish Logic, 1920-1939.
Clarendon, Oxford (1967).Ashcroft, E.A.
and Wadge, W.W. 1982 R~ for Semantics.
ACMTrans.
Prog.
Lang.
and Sys.
4: 283-294.Benson, D.B.
1975 Formal Languages vis-a-vis 'Natural' Lan-guages.
In Sedelow, W. and Sedelow, S., Ed., Computers inLanguage Research: Trends in Linguistics.
Mouton, the Hague(1979).Carnap, R. 1937 The Logical Syntax of Language.
Smeaton, A.,Trans.
Kegan Paul, Trench, Trubner and Son, Ltd., London.Church, A.
1951 The Calculi of Lambda-Conversion.
PrincetonUniversity Press, Princeton, New Jersey.Frege, G. 1892 On Sense and Reference.
In Geach, P. and Black,M., Ed., Translations from the Philosophical Writings of GottlobFrege.
Basil Blackwell, Oxford (1952).Gordon, M.J.C.
1979 The Denotational Description of ProgrammingLanguages.
Springer-Verlag, New York.Harris, L.R.
1979 Experience with ROBOT in 12 CommercialNatural Language Data Base Query Applications, Proc.
6thInternational Joint Conference on Artificial Intelligence.
Tokyo:365-368.Hobbs, J.R. and Rosenschein, S.J.
1977 Making ComputationSense of Montagae's Intensional Logic, Artificial Intelligence 9:287-306.Johnson, S.C. 1975 YACC - Yet Another Compiler Compiler.CSTR 32.
Bell Laboratories, Murray Hill, New Jersey.Johnson, W.L.
; Porter, J.H.
; Ackley, S.I.
; and Ross, D.T.
1968Automatic Generation of Efficient Lexical Analyzers UsingFinite State Techniques, Communications of the ACM 11(12):805-813.Kahn, C. 1978 Questions and Categories.
In Hiz, H., Ed.,Questions.
D. Reidel Publishing Co., Dordrecht, Holland.Karttunen, L. 1977 Syntax and Semantics of Questions, Linguisticsand Philosophy 1 : 3-44.Lewis, D. 1972 General semantics.
In Davidson, D. and Harman,G., Ed., Semantics of Natural Language.
D. Reidel PublishingCo., Dordreeht, Holland.McGettrick, A.D. 1980.
The Definition of Programming Languages.
(Cambridge Computer Science Texts t 1.)
Cambridge UniversityPress, Cambridge.Milne, R. and Strachey, C. 1976 A Theory of Programming Lan-guage Semantics.
Chapman and Hall, London.Montague, R. 1973 The Proper Treatment of Quantification inOrdinary English.
In Thomasen, R., Ed., Formal Philosophy.Selected Papers of Richard Montague.
Yale University Press, NewHaven, Connecticut (1974).Pagen, F.G. 1981 Formal Specification of Programming Languages:A Panoramic Primer.
Prentice-Hall, Inc., Englewood Cliffs, NewJersey.Scott, D. 1976 Data Types as Lattices, SIAM Journal of Computing5: 522-587.Stoy, J.
1977 Denotational Semantics: The Scott-Strachey Approachto Programming Language Theory.
M1T Press, Cambridge, Mas-sachusetts.Tennent, R.D.
1981 Principles of Programming Languages.
Prentice-Hall, Inc., Englewood Cliffs, New Jersey.van Emde Boas, P. and Janssen, T. 1979 The Impact of Frege'sPrineiple of Compositionality for the Semantics of Programmingand Natural Languages.
Report 79-07, University of Amster-dam.Winograd, T. 1972 Understanding Natural Language.
AcademicPress, New York, New York.Woods, W.A.
1970 Transition Network Grammars for NaturalLanguage Analysis, Communications of the ACM 13(10): 591-602.Woods, W.A.
1972 The Lunar Sciences Natural Language Informa-tion System.
Report 2378, Bolt Beranek and Newman.American Journal of Computational Linguistics, Volume 9, Number 1, January-March 1983 21
