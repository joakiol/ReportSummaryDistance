An Algorithm For Generating Referential DescriptionsWith Flexible InterfacesHelmut HoracekUniversit/it des SaarlandesFB 14 Informat ikD-66041 Saarbrticken, Deutschlandhoracek@cs.un i -sb .deAbstractMost algorithms dedicated to the generation ofreferential descriptions widely suffer from afundamental problem: they make too strongassumptions about adjacent processingcomponents, resulting in a limited coordinationwith their perceptive and linguistics data, thatis, the provider for object descriptors and thelexical expression by which the chosendescriptors i ultimately realized.
Motivated bythis deficit, we present anew algorithm that (1)allows for a widely unconstrained, incremental,and goal-driven selection of descriptors, (2)integrates linguistic constraints to ensure theexpressibility of the chosen descriptors, and (3)provides means to control the appearance of thecreated referring expression.
Hence, the mainachievement of our approach lies in providing acore algorithm that makes few assumptionsabout other processing components andimproves the flow of control between modules.1 IntroductionGenerating referential descriptions I requires electing asetof descriptors according to criteria which reflect humanspreferences and verbalizing these descriptors whilemeeting natural anguage constraints.
Over the last decade,(Dale, 1989, Dale, Haddock, 1991, Reiter, 1990b, Dale,Reiter, 1995), and others 2 have contributed to this issueThe term 'referential description' is due to Donellan(Donellan, 1966).
This notion signifies a referringexpression that serves the purpose of letting the heareridentify a particular object out of a set of objectsassumed to be in the current focus of attention.The approach undertaken by Appelt and Kronfeld(Appelt, 1985a, Appelt, 1985b, Kronfeld, 1986,Appelt, Kronfeld, 1987) is very elaborate but it suffersfrom very limited coverage, missing assessments ofthe relative benefit of alternatives, and notorious inef-ficiency.
(see the systems NAOS (Novak, 1988), EPICURE (Dale,1988), FN (Reiter, 1990a), and IDAS (Reiter, Dale,1992)).
Nevertheless, these approaches still suffer fromsome crucial deficits, including limited coverage (see(Horacek, 1995, Horacek, 1996) for an improved algo-rithm), and too strong assumptions about adjacentprocessing components, namely:?
the instant availability of all descriptors for an objectto be described,?
the adequate expressibility of a chosen set ofdescriptors in terms of lexical items.Motivated by the resulting deficits, we develop a newalgorithm that does not rely on these assumptions.
It (1)allows for a widely unconstrained, incremental, and goal-driven selection of descriptors, (2) integrates linguisticconstraints to ensure the expressibility of the chosendescriptors, and (3) provides means to control the appear-ance of the created referring expression.This paper is organized as follows.
After havingintroduced some basic terminology, we elaborate interfacedeficits of existing algorithms, form which we derive desi-derata for an improved algorithm.
Then we describeconcepts to meet hese desiderata, nd we illustrate theiroperationalization in a schematic and in a detailed version.Finally, we demonstrate he increased functionality of thenew algorithm, and we evaluate the achievements.2 Terminology UsedIn the scope of this paper, we adopt the terminologyoriginally formulated in (Dale, 1988) and also used byseveral successor approaches.
The referring expression togenerate is required to be a distinguishing description, thatis a description of the entity being referred to, but not toany other object in the current context set.
A context setis defined as the set of entities the addressee is currentlyassumed to be attending to - this is similar to the set ofentities in the focus spaces of the discourse focus stack inGrosz and Sidner's theory of discourse structure (Grosz,Sidner, 1986).
Moreover, the contrast set (or, the set ofpotential distractors (McDonald, 1981)), is defined toentail all elements of the context set except he intended206referent.
In the scope of some context set, an attribute or arelation applicable to the intended referent can be assignedits discriminatory power, 3that is a measure similar to thenumber of potential distractors that can be removed fromthe contrast set with confidence, because this attribute orrelation does not apply to them.3 Previous Algorithms and DeficitsThe existing algorithms attempt o identify the intendedreferent by determining a set of descriptors attributed tothat referent or to another entity related to it, therebykeeping the set of descriptors as small as possible.
Thisminimization issue can be interpreted in different degreesof specificity, which also has consequences on the asso-ciated computational complexity.
Full brevity, thestrongest interpretation, is underlying Dale's algorithm(Dale, 1989), which produces a description entailing theminimal number of attributes possible, at the price ofsuffering NP-hard complexity.
Two other interpretations,the Greedy heuristic interpretation (Dale, 1989) and thelocal brevity interpretation (Reiter, 1990a) lead to algo-rithms that have polynomial complexity in the same orderof magnitude.
The weakest interpretation, the incrementalalgorithm interpretation (Reiter, Dale, 1992), has stillpolynomial complexity but, unlike the last two interpre-tations, it is independent of the number of attributes avail-able for building a description.
Applying this interpre-tation may lead to the inclusion of globally redundantattributes in the final description, but this is justified byvarious results of psychological experiments (see thesummary in (Levelt 1989)).
Because of these reasons, theincremental algorithm interpretation is generally consi-dered best now, and we adopt it for our algorithm, too.In the realization described in (Reiter, Dale, 1992),attributes are incrementally selected according to an apriori computed omain-dependent preference list, providedeach attribute contributes to the exclusion of at least onepotential distractor.
However, there still remains theproblem of meaningfully applying this criterion in thecontext of nested descriptions, when the intended referentis to be described not only by attributes uch as color andshape, but also in terms of other referents related to it.Neither the psychological experiments nor the realizationin (Reiter, Dale, 1992) can deal with this sort of recur-sion.
In the generalization i troduced in (Horacek, 1996),descriptors of the referents are incrementally selectedaccording to domain-dependent preference lists in a limiteddepth-first fashion, which leads to some sort of inflexibi-lity through restricting the set of locally applicable3 A precise definition based on numerical values assignedto attribute-value pairs is given in (Dale, 1988).descriptors.
Besides, the preference list needs to be fullyinstantiated for each referent to be described, which consti-tutes a significant overhead.An even more crucial problem lies in the fact thatpractically all algorithms proposed so far contend them-selves with producing a set of descriptors rather thannatural anguage xpressions.
They more or less impli-citly assume that the set of descriptors represented as one-and two-place predicates can be expressed adequately innatural anguage terms.
A few drastic examples hould besufficient o illustrate some of the problems that mightoccur due to ignoring these issues:(a) the bottle which is on a table on which there is acup which is besides the bottle .
.
.
.
(a problem of organization)(b) the large, red, speedy, comfortable .... .
car(a problem of complexity)(c) the cup which is besides a bottle which is on a tablewhich is left to another table and which is empty(a scoping problem, in addition)Altogether, two strong assumptions influence existingalgorithms, namely the instant availability of all descrip-tors of a referent and the satisfactory expressibility of thechosen set of descriptors.
They are responsible for threeserious deficits negatively influencing the quality of theexpression (the first one primarily causing inefficiency):1.
Applicable processing strategies are restricted becauseall descriptors of some referent need to be evaluatedbefore descriptors of other eferents can be considered.2.
The linguistic aspects are largely simplified and evenneglected in parts.
Because of the 'generation gap'(Meteer, 1992), there is no guarantee that the set ofdescriptors chosen can be expressed at all in the targetlanguage, not to say adequately.3.
There is no control to assess the adequacy of a certaindescription, for instance, in terms of structural com-plexity, and no feedback from linguistic formproduction to property selection is provided.The first deficit restricts feasible architectures of a gener-ation system in which such an algorithm can reasonablybe embedded because flexibility and incrementality of thedescriptor selection task are limited.
Moreover, the under-lying assumption is unrealistic in cognitive as well as intechnical terms.
From the perspective of human behavior,it would simply be unnecessary to determine all descrip-tors of a referent o be described beforehand without evenattempting to generate a description; usually, just a fewdescriptors are sufficient for this purpose.
The same consi-derations apply to the machine-oriented perspective:neither for a vision system nor for a knowledge-basedsystem is it without costs to determine all descriptors of acertain object - especially for the vision system, thecomputational effort may be considerable.207The second deficit results from ignoring that the ulti-mate goal envisioned consists in producing a naturallanguage xpression that satisfies the discourse goal andnot merely in choosing a set of descriptors by which thisgoal can in principle be achieved.
In general, there is noguarantee that the set of descriptors chosen can be ade-quately expressed in the target language, given somerepertoire of lexical operators: conceptual predicatescannot always be mapped straightforwardly onto lexemesand grammatical features o that the anticipation of theircomposability is limited.
Even more importantly, mattersof grammaticality are not taken into account at all byprevious algorithms.
Simple cases are not problematic,for instance, when two descriptors achieve unique identifi-cation and can be expressed by a simple noun phraseconsisting of a head noun and an adjective.
In morecomplex cases, however, considerations of grammaticalitysuch as overloading and even interference due to scopingambiguity may become aserious concern.The third deficit concerns the lack of control that thesealgorithms uffer from when assessing the structuralcomplexity of a certain description is required, whichcertainly influences its communicative adequacy, too.
Thelack of control over the appearance of the expression to begenerated is further augmented by the fact that any kind offeed-back is missing that puts the property selectionfacility in a position to take the needs of ultimatelybuilding a referring expression into account.
Particulardifficulties can be expected when a referential descriptionneeds to be produced in an incremental style, that is,portions of a surface xpression are built and uttered oncea further descriptor is selected, that is, prior to completionof the entire descriptor selection task.4 Concept ion  o f  a New A lgor i thmBesides the primary goal of producing a distinguishingand cognitively adequate description of the intended refer-ent, there are also the inherent secondary goals of verballyexpressing the chosen descriptors in a natural way, and ofapplying a suitable processing strategy.
In order to pursuethese goals, we state the following desiderata:1.
The requirements on the descriptor providingcomponent should widely be unconstrained, allowingfor incremental nd goal-driven processing.2.
A component that takes care of the expressibility ofconceptual descriptors in terms of natural anguageexpressions should be interfaced.3.
Adequate control should be provided over the comple-xity and components of the referring expression.Several concepts are intended to meet hese desiderata:I.
In the predecessor algorithms, attributes are takenfrom an a priori computed omain-dependent prefer-ence list in the indicated order, provided each attributecontributes to the exclusion of at least one potentialdistractor.
Instead, we simply allow the responsiblecomponent toproduce descriptors incrementally, evenfrom varying referents, provided the selected escriptoris directly related to some referent already included inthe expression built so far.
While the precise form ofthis restriction is technically motivated - it guaran-tees that a description built this way is alwaysconnected - we believe that it is also cognitivelyplausible.
In order to pursue the identification goal,the perception facilities preferably look for salientplaces in the vicinity of the object to be identified,rather than to distant places.
The pre-selection obtain-ed this way can be based on salience, eventuallycombined with some measure of computational effort.By applying this strategy, a best-first behavior isachieved instead of pure breadth-first (Reiter, Dale,1992), depth-first (Dale, Haddock, 1991), and iterativedeepening (Horacek, 1995, Horacek, 1996) strategies.2.
The algorithm interfaces a subprocess that incremen-tally attempts to build natural anguage xpressionsout of the descriptors selected.
Through taking gram-matical and lexical constraints into account, this pro-cess is capable of exposing expressibility problemsearly: expressing a proposed escriptor may requirerefilling an already filled slot, or integrating the map-ping result of a newly inserted escriptor may lead toa global conflict such as unintended scope relations.A goal-driven aspect is added by encouraging theselection of descriptors whose images are candidatesof filling empty slots in the expression built so far.3.
The algorithm enables one to control the processingaspect of building the referential description and itscomplexity.
A parameter is provided to specify theappearance of that expression in terms of slots thatare allowed to be filled.
In an incremental style, whereparts of the referential description are uttered prior toits completion, the slots that can be filled by the des-criptor selected are substantially influenced by prece-dence relations (in the ordinary compositional style,this is simply identical to the set of yet empty slots).5 Operat iona l i za t ion  in the  A lgor i thmThe new algorithm designed to incorporate these conceptsis built on the basis of some predecessor algorithms(Dale, Haddock, 1991, Reiter, Dale 1992, Horacek, 1995,Horacek, 1996), from which we also adopt the notation.The algorithm is shown in two different degrees of preci-sion.
An informal, schematic view in Figure 1 thatabstracts from technical details is complemented by adetailed pseudo-code version in Figure 2.
In both versions,the lines are marked, by IS#\] in the schematic view andby \[C#\] in the pseudo-code v rsion to ease references from208Check Successif <the intended referent is identified uniquely>then <exit with an identifying description>if <the complexity limit of the expression is reached>then <exit with a non-identifying description>Choose propertyif <no further descriptors are available>then <exit with a non-identifying description>else <call the descriptor selection component to propose the next property>if <the descriptor does not reduce the set of potential distactors> or<the referent further described is already identified uniquely> or<the descriptor is inferable from the description generated so far> or<the descriptor cannot be lexicalized with the given linguistic resources> or<lexicalizing the descriptor would cause a scoping problem>then <reject he proposed property> and goto 2Extend description<update the linguistic resources used><determine properties which, when being lexicalized, are likely to fill yet empty slots><update the constraints holding between referents and partial descriptions>goto 1\[SI\]\[$2\]\[s3\]\[s4\]\[ss\]\[$61\[$7\]\[s81\[s9\]is10\]\[Sl~l\[sl2\]\[S13\]IS ~4\]\[sis\]\[S16\]\[S17\]\[S18\]\[S19\]\[$20\]Figure 1 : Schematic presentation of the algorithm, asthe text.
In addition, the identifiers used in the pseudo-code version are explained in Table 1 (the variables) and inTable 2 (the functions).We first illustrate the basic structure of the procedurefrom some sort of a bird's eyes view.
The algorithmconsists of three major parts: Check success IS 1 \], Chooseproperty \[$6\], and Extend description \[S16\]; this organi-zation stems from (Dale, Haddock, 1991) and is extendedhere.
Basically, these parts are evaluated in sequence,which is repeated iteratively \[$20\].
The first part merelycomprises two of the algorithm's termination criteria:\[$2\], which constitutes the successful accomplishment ofthe whole task, and \[$4\], which reports the failure to dothis within the given limits of the linguistic resources,and corresponding return statements \[$3\] and \[$5\].
\[$4\]and \[$5\] constitute an extension to previous approaches.The second part entails a call to an external descriptorselection component \[$9\].
In the unlikely case that nofurther descriptors are available \[$7\] the algorithm termi-nates without complete success \[$8\].
Various tests checkthe suitability of the descriptor proposed in the globalcontext: the descriptor does not contribute further to theidentification task (it must be an attribute) \[S 10\], the needof further elaborating the description of that referent owhich the proposed escriptor adds information \[SI 1 \], thedescriptor's effective contribution to the identificationtask, which may be nullified due to contextual effects\[S12\], unavailability of lexical material to express thean abstraction from the detailed pseudo-code in Figure 2proposed escriptor as an extension to the referring expres-sion composed s.o far \[S13\], and scoping problems in theattempt in extending the referring expression composed sofar \[S 14\].
The last two criteria are additions introduced inthe new algorithm.
In the third part, some sort of bookkeeping is carried out: evidence about the used lexicalresources i updated IS 17\], descriptors that are likely to beexpressible by yet empty slots are determined IS 18\], andrelations between the context sets of all referents consid-ered and partial descriptions are maintained \[S19\].After this overview, we explain the algorithm in detail.We describe the data structure that helps controlling towhether or not a referent is identified and which the poten-tial distractors are.
Next, we illustrate the interfaces to thetwo major external modules.
We conclude this presen-tation by explaining the pseudo code, thereby pointing tothe corresponding parts in the schematic overview.
Incompanion with the variables and functions explained inseparated tables, this description should enable the readerto understand the functionality of the algorithm.Throughout processing, the algorithm maintains aconstraint network N which is a pair relating (a) a set ofconstraints, which correspond to predications over vari-ables (properties abstracted from the individuals theyapply to) to (b) sets of variables each of which fulfillthese constraints in view of a given knowledge base (thecontext sets).
The notation N ~ p is used to signify theresult of adding the constraint p to the network N. In209Variable Descriptionr, gr,v, gvRCNCLFDDDList<p,r>refsP-propsexcludedlocal (r) and global referents (gr) and variables (v and gv) associated with thema specification of slots which the target referring expression may entail(contextually-motivated) expected category of the intended referentconstraint network, a pair relating a set of constraints o sets of variables fulfilled by themcontext set, indexed by variables associated with referents (e.g., C v, Cg v)list of attribute-value pairs which corresponds to the constraint part of Nfunctional description that is an appropriate l xical description expressing Ldistinguishing description, appearing as a pair <L,FD>communicative goals to pursue, expressed by Describe(r,v)property p ascribed to referent rreferents already processedproperties whose images on the lexical evel are likely to fill empty slots in FDproperty-referent combinations that cannot be verbalized in the given contextTable 1: Variables used in the algorithmaddition, the notation \[r~v\]p is used to signify the result ofreplacing every occurrence of the constant r in p byvariable v (for an algorithm to maintain consistency seeAC-3 (Mackworth, 1977), as used in (Haddock, 1991)).According to our desiderata, the new algorithm inter-faces two major external modules whose precise function-ality is outside the scope of this paper: Next-Property andInsert-Unify.
Next-Property \[C19\], \[$9\] selects a cogni-tively-motivated candidate property to be included next.Generally applicable psychological preferences, uch asbasic level categories, as well as special criteria, such asdegrees of applicability of local relations \[Gapp 1995\],may guide this selection.
It is additionally influenced bytwo parameters: refs, which specifies those referent whichmust be directly related to the chosen descriptor, and P-props, which entails a list of properties whose lexicalimages are likely to fill yet empty slots.Insert-Unify updates the data structure FD by incre-mentally inserting mappings of selected escriptors \[C43\],\[S13\], unless Check-Scope detects a global problem\[C44\], \[S 14\].
This language-dependent procedure analyzesthe functional description created so far for potential mis-interpretations and scope ambiguities, which may occur inconnection with nested postnominal modifiers or relativeclauses that depend on an NP with a postnominal modi-fier.
Examining these structures is much less expensivethan a global anticipation-feedback loop, but it requiresspecialized grammatical knowledge.
Whether the intendedreading is also the preferred one depends on selectional re-strictions, preference criteria, and morphological features.Function DescriptionNext-Property(refs, p )A(p)find-best-value(A(p),V)basic-level-value(r,A(p))rules-out(<A(p),V>)Assoc-var(r)Prototypical(p, r)Descriptors(r)Map-to(Empty-Slots(FD))lnsert-Unify( FD,<v,p> )Check-Scope(FD)Slots-of(mappings(p))Rel(A(p)Salient(A(p))selects a property, influenced by the connection to referents refs and by properties psfunctor to provide access to the predicate of predication pprocedure to determine the value of property p that describes r according to (Dale, Reiter, 1992)yields the basic level value of property p for referent ryields the set of referents that are ruled out as distractors due to the value V of property A(p)function to get access to the variable associated with referent ryields true if property p is prototypical for referent r and false otherwiseyields the set of predicates entailed in N and holding for referent ryields properties which map onto the set of uninstantiated slots in FDinserts a lexical description of property p of the referent associated with variable v into FDyields true if no scope problems are expected to occur and false otherwiseyields the slots of the set of lexical items by which predicate p can be expressedyields true if descriptor p is a relation and false otherwiseyields true if salience is assigned to property p and false otherwiseTable 2: Functions used in the algorithm210D_.e..~.
(lh~ ( r,v, N, R, c )DD ~ nil, FD ~ nil \[CI\]unique ~ false \[C2\]gr ~-- r, gv 6-- v \[C3\]excluded ~-- nil, P-props ~-- nil \[C4\]rel:~ ~ {r} \[C5lCv~ Cvn {x I c(x)} \[C6\]List +-- \[Describe(r,v)\] \[C7\]1 Check Success \[C8\]if ICxvl = 1 then \[C9\]?
unique +--- true \[CI0\]return <L,FD> (as a distinguishing description) \[CI I\]endif \[C 12\]if IRI = 0 then \[C13\]return <L,FD> \[C 14\](as a non-distinguishing description) \[C 15\]endif \[C 16\]2 Choose Property \[C17\]repeat \[C18\]<r,p> ~-- Next-Property(rely,P-props) \[C19\]if p = nil then \[C20\]return <L,FD> \[C21\](as a non-distinguishing description) lC22\]endif \[C23\]v ~ Assoc-var(r) \[C24\]if Prototypical(p,r) or \[C25\]((Slots-of(Mappings(p)) n R) = O) \[C26\]then excluded ~ excluded u { <r,p> I \[C27\]elseif (p in Taxonomic-Inferences \[C28\](Descriptors(v))) or (ICvl -- 1) then \[C29\]excluded ~- excluded u { <r,p> } \[C30\]endif \[C31 \]endif \[C32\]if <r,p> e excluded then lC33\]goto 2 \[C34\]endif \[C35\]V = find-best-value(A(p), \[C36\]basic-level-value(r,A(p))) \[C37\]if not (((rules-out(<A(p), V>) ~ nil) and (V ~ nil)) \[C38\]or Rel(A(p))) or  Salient(A(p)) then \[C39\]excluded ~ excluded u {<r,p> } \[C40\]goto 2 \[C41 \]endif \[C42\]FDH ~ Insert-Unify(FD, <v,p>) \[C43\]if not Check-Scope(FDH) then \[C44\]excluded ~ excluded u {<r,p>} \[C45\]goto 2 \[C46\]endif \[C47\]3 Extend Description \[C48\]FD ~ FDH \[C49\]R ~-- R \ slots(FD) \[C50\]P-props ~-- Map-to(Empty-slots(FD)) \[C51\]p ~ \[r\vlp \[C52\]if Rel(A(p)) then \[C53\]for every other constant r' in p do \[C54\]if Assoc-var(r') =nil then \[C55\]associate r' with a new, unique variable v' \[C56\]p ~-- \[r'~vqp \[C57\]ref~ ~-- rel;~ u {r7 \[C58\]List ~ Append(List,  Describe(r'v')) \[C59\]endif \[C60\]next \[C61 \]else set the value of attribute p to V \[C62\]endif \[C63\]N ~- N @ p \[C64\]goto 1 \[C65\]Figure 2: Detailed pseudo-code of the new algorithmThe first part of  the algorithm, 'Check Success',comprises the algorithm's termination criteria:1.
A distinguishing description is completed \[C9-C11\],\[$2-$4\], the exit in case of full success.2.
No more descriptors are globally available \[C19-C22\], \[$7-$8\].
In the predecessor algorithms, thischeck is done for each referent separately.3.
All available slots are filled \[C13-C14\], \[$4-$5\] -this is a new criterion.The second part, 'Choose Property', is dedicated to test thecontextual suitability of  the candidate property proposedby Next-Property, which may be inappropriate for one ofthe following reasons (criteria 3. and 5. are new ones):1.
The property can be inferred from the descriptiongenerated so far, or it is prototypical for the object tobe identified and may thus yield a false implicature\[C25, C28\], \[S12\].2.
The object is already identified uniquely \[C29\], \[SI 1\].3.
The descriptor chosen cannot be mapped onto a slotof the description generated so far \[C26\], \[S 13\].4.
The descriptor is an attribute, and it does not furtherreduce the set of potential distractors \[C38\], \[S 10\].5.
Incorporating the descriptor into the functionaldescription created so far leads to a global conflict\[C43-C44\], \[S14\].The third part, 'Extend Description', takes care of updatingsome control variables.
The descriptor p is fed into N\[C64\] goals to describe new referents reached via therelation p are put into List \[C54-C60\], \[S19\], all slotsfilled in FD are eliminated in R \[C50\], \[S17\], and the yetempty slots are fed into reversed lexicalization rules toyield properties collected in P-props \[C51 \], \[S 18\].6 E f fec ts  the  A lgor i thm Can Hand leSpace restrictions do not permit a detailed presentation ofthe new algorithm at work.
Therefore, we have confinedourselves to a sketchy description of the algorithm'sbehavior in a moderately complex situation.
Let usassume an environment consisting of four tables (t  I tot4), roughly placed in a row, as depicted in Figure 2.
Thecommunicative goal is to distinguish one of the tablesuniquely from the other three, by a referring expressionentailing an adjective (a prenominal modifier), a category,an attribute (a postnominal modifier), and a relativeclause, at most.
The situation permits building a largevariety of expressions for accomplishing this purpose.Some interesting cases are:1) achieving global rather than local goal satisfaction:If t 3 is the intended referent, and on(bl, o) is the descriptorselected next, adding the category of the entities on top oft3 (here, books) is sufficient to identify t3 uniquely.
Somepredecessor algorithms, for instance (Dale, Haddock1991), would still attempt to distinguish b I from b2.211~ bt~ b2 13 ~/~"g'1 I I11212 12 t 2Figure 3: A scenery with tables, cups, glasses, and books2) producing flat expressions instead of embedded onesIf t 2 is the intended referent, and on(gt,t2) is the descriptorselected next, another descriptor must be selected to distin-guish t2 from t4.
The descriptor selection component isfree to choose on(c3,t2),  to yield the natural, flatexpression 'the table on which there are a glass and a cup'.In (Horacek 1996), the same result can be obtainedthrough an adequate selection of search parameters.
Thealgorithm in (Dale, Haddock 1991) would produce the lessnatural, embedded expression 'the table on which there is aglass besides which there is a cup' instead.3) rejection of a descriptor because it can be inferredIf tl is the intended referent, and size(tl,low) is the des-criptor selected this time, another descriptor must beadded, since t 3 is also subsumed by this description.
Ifpart-of(t1,//) is chosen for that purpose (l I being the legsof tl), the descriptor size(lvshort) to describe 11 further isrejected because it can be inferred from {size(tl, Ow),part-of(tl , l l)}.4) Rejection of a descriptor because of a clashLet t 2 be the intended referent, and the descriptors left-of(t3,t2) and type(t3,table ) xpressed by 'the one which isto the left of a table'.
If on(g l , t2 )  is selected next, theonly way to link it to the partial expression generated sofar is via a relative clause, but this slot is already filled.5) Rejection of a descriptor because of a scope problemHowever, if the local relation in the previous example isexpressed by 'the one to the left of a table', adding arelative clause expressing the objects on t3 would stillwork badly because the addressee would interpret heseobjects to be placed on t2 - Check-Scope should recognizethis reference problem.7 Evaluating the AlgorithmThe examples discussed in the previous section demon-strate that our procedure avoids many of the deficits pre-vious algorithms uffer from.
Therefore, it provides excel-lent prerequisites for producing natural referring expres-sions in terms of both, descriptors elected and structuralappearance.
Whether this is actually the case depends pri-marily on the quality of the external components, the des-criptor selection and the lexicalization component and, tosome minor extent, on the parameterization f the struc-tural appearance of the referring expression to be produced.As far as its complexity is concerned, the algorithm isin some sense even more efficient than its predecessors,because it does not require complete lists of descriptors tobe produced for each referent.
However, this saving ispartially nullified by the additional operations incorpor-ated, especially by the application of lexicalizationoperators and scoping verifications.
Nevertheless, anoverall analysis of the algorithm's complexity is hardlypossible in a general sense because?
the operations in this algorithm are rather hetero-geneous, and their relative costs are far from clear,?
the costs of individual operations, such as descriptorcomputation i the descriptor selection component andconstraint network maintenance, may vary signifi-cantly in dependency of the underlying representation,especially if the primary representation is a pictorialrather than a propositional one.8 ConclusionIn this paper, we have presented a new algorithm forgenerating referential descriptions which exhibits someextraordinary capabilities:?
Descriptors can be selected in a goal-driven and incre-mental fashion, with contributions from varyingreferents interleaving with one another.?
A component is interfaced which attempts to expressthe descriptors chosen on the lexical representationlevel to encounter expressibility problems.?
The structural appearance of the resulting referentialdescription can be controlled.212Major problems for the future are an even tighter inte-gration of the algorithm in the generation process as awhole and finding adequate concepts for dealing withnegation and sets.ReferencesDoug Appelt.
1985a.
Planning English ReferringExpressions.
Artificial Intelligence, 26:1-33.Doug Appelt.
1985b.
Some Pragmatic Issues in thePlanning of Definite and Indefinite ReferringExpressions.
In 23rd Annual Meeting of the Associationfor Computational Linguistics, pages 198-203.
Asso-ciation for Computational Linguistics, Morristown,New Jersey.Doug Appelt, and Amichai Kronfeld.
1987.
AComputational Model of Referring.
In Proceedings ofthe lOth International Joint Conference on ArtificialIntelligence, pages 640-647, Milano, Italy.Robert Dale.
1988.
Generating Referring Expressions in aDomain of Objects and Processes.
PhD Thesis, Centrefor Cognitive Science, University of Edinburgh.Robert Dale.
1989.
Cooking Up Referring Expressions.In 27th Annual Meeting of the Association for Compu-tational Linguistics, pages 68-75, Vancouver, Canada.Association for Computational Linguistics, Morris-town, New Jersey.Robert Dale, and Nick Haddock.
1991.
Generating Refer-ring Expressions Involving Relations.
In Proceedings ofthe European Chapter of the Association for Compu-tational Linguistics, pages 161-166, Berlin, Germany.Robert Dale, and Ehud Reiter.
1995.
ComputationalInterpretations of the Gricean Maxims in the Generationof Referring Expressions.
Cognitive Science, 19:233-263.K.
Donellan.
1966.
Reference and Definite Description.Philosophical Review, 75:281-304.Klaus-Peter Gapp.
1995.
Efficient Processing of SpatialRelations in General Object Localization Tasks.
InProceedings of the Eighth Australian Joint Conferenceon Artificial Intelligence, Canberra, Australia.Barbara Grosz, and Candace Sidner.
1986.
Attention,Intention, and the Structure of Discourse.
Compu-tational Linguistics, 12:175-206.Nicolas Haddock.
1991.
Linear-Time Reference Evalu-ation.
Technical Report, Hewlett Packard Laboratories,Bristol.Helmut Horacek.
1995.
More on Generating ReferringExpressions.
In Proceedings of the 5th European Work-shop on Natural Language Generation, pages 43-58,Leiden, The Netherlands.Helmut Horacek.
1996.
A New Algorithm for GeneratingReferring Expressions.
In Proceedings of the 8thEuropean Conference on Artificial Intelligence, pages577-581, Budapest, Hungary.Amichai Kronfeld.
1986.
Donellan's Distinction and aComputational Model of Reference.
In 24th AnnualMeeting of the Association for ComputationalLinguistics, pages 186-191.
Association for Computa-tional Linguistics, Morristown, New Jersey.William Levelt.
1989.
Speaking: From Intention toArticulation.
MIT Press.Alan Mackworth.
1977.
Consistency in Networks ofRelations.
Artificial Intelligence, 8:99-118.David McDonald.
1981.
Natural Language Generation as aProcess of Decision Making Under Constraints.
PhDThesis, MIT, Cambridge, Massachusetts.Marie Meteer.
1992.
Expressibility and the Problem ofEfficient Text Planning.
Pinter Publishers, London.Hans-Joachim Novak.
1988.
Generating Referring Phrasesin a Dynamic Environment.
In M. Zock, G. Sabah,editors, Advances inNatural Language Generation, Vol.2, pages 76-85, Pinter publishers, London.Ehud Reiter.
1990a.
The Computational Complexity ofAvoiding Conversational lmplicatures.
In 28th AnnualMeeting of the Association for ComputationalLinguistics, pages 97-104, Pittsburgh, Pennsylvania.Association for Computational Linguistics, Morris-town, New Jersey.Ehud Reiter.
1990b.
Generating Descriptions that Exploita User's Domain Knowledge.
In R. Dale, C. Mellish,M.
Zock, editors, Current Issues in Natural LanguageGeneration, pages 257-285, Academic Press, New York.Ehud Reiter, and Robert Dale.
1992.
Generating DefiniteNP Referring Expressions.
In Proceedings of theInternational Conference on Computational Linguistics,Nantes, France.213
