American Journal of Computational LinguisticsCOMPUTER UNDERSTAND I NG OFP H Y S I C S  P R O B L E M SSTATED IN I~ATURAL LANGUAGEComputer Science DepartmentUniversity of TexasAustin 78712Microfiche 5 3C o p y r i g h t  @ 1976'Associa t ion for C o m p u t a t i o n a l  L i n g u i s t i c sThis  palltar dcsrril)es n conrpu t or program, r i ~  lled ISAA(:.
\\*hi~-h ($;In rc!
:~(i,underst and ,  so lw,  nnt l  draw pic~.t-iil.cs 01' pl~ysicss p s ~ h l c n ~ s  stnt ocl i t a  1S1lglish.
l 'heprogram has solsrd t ~vi'nty problems.
most of tvhic.11 wcrll' t alicb11 unedit rtl fsonl highschool and collihge physics t tlxts.
Those prohlc~ns  i~lvol\.e taigicl hod icis in st at ic.equilibrium, and  i n c l ~ i d t ~  411cbh objec'ts .as Icv~1,s.
pivots, ivrights, ~*ol,cs, anti s1)rings invarious configurations.
An exanlpltl of the r.l;tss of' p1.c)t)lems sol\?ecl is the follo\ving(from Scilcru nl ',s Out l i r~  of C O I I C ~ C J  /,'/l?si~*s ):The foot of n ladtlcr rrsts i t  n vcrtic*nl i and o n  :I t ~ o ~ , i x o ~ ~ t a tfloor.
Thc top of' the l;\clcltlr is s t l p p t n .
~ ~ d  f'ronl tl l t l  \vall t)y n hot%izotlt;\lrope 3 0  ft long.
l'hc 1;idtlcl is 50 St 10111, \veighs 100 11) \ ( i t \ )  its c,entriS ofgravity 20 ft fl*om thv foot.
ancl a 150 111 marl is 10 1'1 fro111 the to\).Deternlinu the tension in the i s o l ~ t ~ .In order.
to understancl allti sol\.t.
such a pi.oblu~n, it is necessar_v to build a n  i t l t rrnalmodel of the problelli ill ivtlic11 the various objt'cts and the11 i~lter~*elationsllips areadequately represented.
Milny of the ~ .
t s l i l  t ionships ;I nd  feat ulwrs o f  the ohjerts a re  notspecified explicitly in the problein st ; l tc~nrnt hut must  be infe~*re(l by usi~lg conlnlollserlse kno\vlccige of what is usual.
I n  the al)o\v esamplc, we ;*sume that .the m a r  isstanding or1 tlie ladtlcr, i~lth(,ugh this is not esl)licitly stittetl.
Tt lus ,  the untle~*st;ln(ling ofa physics psobletn is a n  acti\tPpl-ocess in \Chic11 the Cet~tences of' the prol~lenl statementa re  used to guide the construction of a model which roprt.sants the relationships ant!features of objects with ~ n u c h  , greater .
detail a n d  spcciticity t'halt they a re  specif'iec!
in t l ~ coriginal probletn sta t e m e ~ t .I n  this l)npf?
)., ive in\.estigate ways in which tllr m e a n i t ~ g ~  of pl1rasc.s antisentences may be unclerst~oorl and  related to  a developing n1otle.l of the problem.
usltlgcommon sense knowledge (represet~tod 1,. com!rutes progrilrns) t o  aid the un~lel-stand in^process.
\Va_vs of representing ot~jects and  rileir relationships tire developecl.
Theserepresentations, which a r e  originally sreated in rehponse to the sentences in the problemstatement,  a re  further elal)ol*atcd by proc:esses which c0nstruct.n ~eonletricl 11lc,dei ot' theproblem, associate ca~lonicnl  objerts (such a5.a point mass) 1~ir11 physical objects r s ~ l c .
!
~a s  a person), ~vr i t e  aild solve equations which tiescribe the inte1.actio11s of the objectsand  construct a diagram of the problenl,This paper is a slightly etlitcd vel-sio1l i,f tlie ar1tllnr.s Ph.'I).
disse!.t a1 ion.
Ia r -  grateful to  11iy co~nmi t t e t  !~~ernt)el s, Prof'6ssors John I,othlin, \\2oodro\v Hler!..
;oe,and  Nornian Martin, a n d  esl>t'ci:~l\y t o  my super~i.
;in;; ~)l.ofus:~oi., Hnbevt F. Simmoils.TABLE OF CON'I'ENrl'SPageLIST OF FIGURES1.
INTROI)T_JCTION AND O V E I i V I E W1.1 Introduction1.2 Ovcr\?iew of the Program2.
REVIEW OF PREVIOUS WORK2.1 Natural Language Problem Solvers2.1.1 Bobrow's STUDENT2.1.2 Chart~iak 's  CARPS2.1.3 Gelb's HAPPINESS2.1.4 Heidorn's Sirnulation Programmi tlg System2.2 Natural Language Processing2.2.1 Woods' Augmented Transition Networks2.2.2 Winograd's SHRDLU2.2.3 Wilks' Prefere~ltial Semantics2.2,4 Simmons' Senlantic Networks2.2.5 Schank's Conceptual Dependmcy2.3 Minsky's Fratlle System Theory3.
PARSING3.1 Introduction3.2 Control Structure of *he Parser3.3 Data Structures Produced During Parsing3.4 Noun Phrase Parsing3.4.1 Basic Noun Phrase3.4.2 Noun Phrase Co~npou%ds and Modifiers3.4.3 Noun Phrase Variants3.5 Verb Phrase Parsing3.5.1 Basic Verb Group3.5.2 Verb Phrase3.6 Prepositional Plwase Parsing3.7 Clause Parsing3.8 Cor~clusion4.
SEMANTICS4.1 Introduction4.2 Preliminary Modifier Procwssing4.3 Preposition Semantics4.3:l Semantic's of the Preposition "OF"4.3.2 Semantics of Other I'reposi tio~us4 .
3 .
3  Ilefinition and Translatiotl of Pr~posit ions4.4 Referent Identification4.4.1 Identifying 13hysic;~l Entity Referents4.4.2 Identifying Location Ii~furtlnts4.4.3 Attachnuent Identification4.5 Modifier Senla t ~ t  ics4.6 Verb Semantics4.6.1 Semantics o f  the Verb "BE"4.6.2 Selnantics of the Verb "SUPPORT"4.6.3 Semantics of 0 t l ~ e r  Verbs4.7 Question Semantics5.
CONSTRUCTION OF OBJECT FRAkIES AXI> THE GEOMETRIC MODEI,5 .
?1 Introductioh 565.3 Making Canonical Object Frames 575.3 Geometric hlodel Co~lstruction 595.4 Frame Completion (3 25.5 Conclusioi~ 6 36.
PROBLEM SOLVING6.1 Generation of Equations6.2 Equation Solviilg6.3 Answer Generation7.
PICTURE CONSTRUCTION7.1 Constructing the PiEture PvIodel7.2 Drawing the Diagram8.
CONCLUSION8.1 Methodology8.2 Directions for Future Research1.
Introduct,iol~ i~ i ld  Overview'1 ,I Introduct ionThis paper describes a computer pl'ogram, called ISAAC, which is able toread and understand physics problems stated in English, write equations for theproblems and solve them, and draw diagrams showing the objects i r l  the problr~;ls ~ i n dtheir spatial relntiot~ships.
The pro~~ilt11 has*solverl twenty problems.
\\*hirh wertr takenessentially ulledited born physics textbooks: some iample problems are shown, with thedrawings and answers generated by the program, in Appcntiis A.While the diagram and answer to a problem are the most eas~ly  observableoutputs of the program, another significant output is its robust intel-11al inodel of theobjects in the problem and their relationships.
It is this model which makes possible thegeneration of the diagram and the answer to the problem.
The  internal nlodel is robustin the sense that  it represents, in a n  explicit and readily accessible form, nos t  of theinrorn~ation which a competent hu~niin reader might be expected to derive from theEnglish problem statement.
I n  addition to the ways in which it is currently used, themodel could be used for answering questions about the objects and their relationships,or.
fbr generating a description of the problem in English or in another language.
or forgenerating other types of diagrams (such as a force diagram).
Since it makes all of thefeatures and relationships of the objects explicit, the internal model is ma 11y t inleslarger than the original problem statement.
which specifies only the major features andleaves many details to be filled in by the' reader.1.2 Overview of the ProgramThe overall organization of the progratn and Its data elements is shown inFigure 1.1; programs are represented by boxes with double lines, and data structures byplain boxes.
In this section, we present an  overview of the functions performed by eachgroup of programs and a n  overview of the types of information represented in the datastructures.The process of unders ta~~ding  and solving a physics problem occurs inseveral distinct steps.
First, the problem statement is translated fro111 E tlglish into astructured par3ing of the sentences, which is iilterpretetl semantically to construct aninitial intel.1131 model.
This nlodel is interpreted to form a model in terms of cclnonif:alphysical obje :ts (such as  a point mass).
A geometric model which reprr.wnts the spatla1position and orientation of each object is corlstructed.
Equations which descr~be theF i g u r e  1.1:  O v e r a l l  Program O r g a n i z a t i o n1bfE n g l i s hProbleinS t a t e m e n tA .,!L .- II c A4LF.rY) ' Y -Semant icProgramsP a r s i n gProgramsP a r s e dS e n t e n c e s> IT' I n i t J a lI n t e r n a lModelY - -C a n o n i c a lO b j e c t1 .EUCLf D Frame- C r e a t i o n  1ModelA4Programs.. -Geometr icModel ?t ProblemS o l v e rP i c t u r eModelProgramsI+ E q u a t i o n sAdrS o l u t i o n sP i c t u r e  dModel .< - iAnswerG e n e r a t o r.. vPictureG e n e r a t o m_1 ,I *Diagram Answer4 A-,8interactions of the objects a.ccolbding to physical laws are written and  solved, andanswers are generated from the solutions.
Finally, a pictu1.e model is coustruc~tc~d ant1used to guide the draw.ing of a diagram of the problem.
'T'hese processes arc dt.scribedbelow in somewhat grcatel8 dctail.The parsing prograals transform each sentence from a linear starill:: of' wordsinto a more structured form in whicli the relationships of words and phrases to  enohother are clearly defined.
Each type of phrnse is parsed by a specialist i)rogram whichimplements the grammar of the phrase a s  a11 augmented transition network.
Thegrammar programs call the semantic programs both t o  interpret the sel~lalltic networkstructure produced Bs a result of the parsing and to guide the parsing process itself,Whether a particular modifier can be used t o  rnotiify a noun phrase, For example, maydepend on the actual relatio~lships l~etwern objects in the model of the problen~.
Af tereach clause has been parsed, the semant io lqout ine associated with the mni 11 \terb iscalled to cotnplete the setnantic processi~lg of the clause.
This 3et11antic processingtransfers the illformation provided by the sentence to' a growing model of  the objects inthe proble~rl and their relationshiljs.
Once the se~narltic processing is colnpleted.
thesemantic netxark str~lctures produced by the parser are  no longer used.
All of thesentences ill the problem statement are parsed and processed semantically before theremaining parts of the program are executed.T h e  routines grouped under the heading of "Semantic Programs" perform avariety of tasks.
Semantic routines are associated with verbs and  prepositions, and 111some cases with other words.
Preposition senl~antic routines must deternline theappropriate sense-nleaning of the preposition (using n decision net work based or1 roughsemantic classifications of the nlodif'ied phrase and the object of the prepositic,~) anrithen make the, appropriate changes 111 the semantic network token of the modifiedphrase.
Verb semantic: ruUMnes typically act to tr:~nsft.r inforrn;~tion from the semant irnetwork ta the internal mtrdul.
or dtll'itle relationshil~s anlong objects i11 the model;determinatioll of the proper dense-meaning o f  the verb is often uileded as well.
Anothermajor semautic task is the identification of the referent of a noun phrase.
Given a nou~ lphrase which denotes a n  object or a location, i t  is necessary to de.c~de whether thephrase refers to an  object or location wlilch already exists in the nlodel (and if' there areseveral possibilities, which one it refers t.01, or whether a new object or location must hecreated as the referent of.the phrase ancl axlded to the model.After all  the sen'tences of the problem statement have been read, the framecreation programs are called to assign to each object a ca~lonical object type (s~icll  a:: apoint mass or an  "ideal" spring) which represents thr behavior of the ohject as  ~tPppears in the problem.
The same t>-pe of actual ntlject nnay hr represented 1 ) ~  clifk~.etltcanonical objects.
depenciing on  its contest  in the pr,obietn.
Thus, a ;~ei.son .n::i berepresented as a pivot wheir carryllg a plank,  o r  as  n point moss ~ v h e n  standing on ,x:e.Once a canonical object frame !1t1i heen selected.
the model of rile object is es,inlinri, tor C -22-4Pa--=L.
.4--++-r34Sn 4L''s3ZC- +I:02..A33 2'r,2 C-fi-373-L'- 4-2'I;.
.-.r.-d* -+-d5.C?sn 42C253'I?PCP ---ud'304ad 4.c,rdScd2.
Review of Previous WorkThis review of previous work, is grouped illto three sections: progriims whichsolve proble~ns tated ill natural lnngunge, natural langui~a processing, allti thcoreticolwork.2.1 Natural Language Problem Solvers2.1.1 Bobrow's SfI'UI)I.:NTThe first natural  language problem-sol~ing progmm \r7ns the STUDENTsystem of Bobrow [Robrow 681 for solving algebra story problems.
The naturallanguage processing of this program is based on pattern matchillg around key wordsand phrases.
The  phrases around the key words become the "variables" in theequations which are  constructed from the sentences.
Thus.
in one of Bobrow'sexamples,If the number of customers Tom gets is twice the squirre of 20  percent ofthe number of advertisements he runs, and the number of advertisementshe runs is 45, what is the number of custom el*^ Tom gets?the two phrases "the number of customers Tom gets" and "the number ofadvertisements he runs" are treated as  variables.
This problem is thus treated as if itwere statedIf x is twice the square of 20 percent of y, and y is 45, what is x?The pattern-matching rules break the input sentences into a possibly embedded set of"kernel sentences", in an order determined by priority values assigned to the keywords.I n  the above example, since "percent" has the highest priority, it would be processedfirst.
There is a fairly direct transformation from English sentences into equations: Infact, the transformatio~ls are made upon the input sentences themselves until thesentences become the equations used in solving the problem.
Large segments of theoriginal sentences remain a s  "variables" in the equations.When the equations constructed from the input are insufficient to find asolution, other equations can be retrieved (based on words in common with "variable"phrases) expressing general relationships, such as(EQUAL (DISTANCE) (TIMES (SPEED) (TIME))).Bobrow's program was impressive for its time (about 1965).
Howev9r.
thistype of approach has  definite limitations.
The technique of transforming sentencesdirectly into equations works only when the sentences express algebraic relationshipsamong quantities.
T h e  "variable" phrases must be similar in each occurrence so theycan be matched properly, and the key words must, not be used in multiple ways whichmight confuse the pattern matcher.
These limitations make it difficult to extend thetechniques Bobrow used to more.cotnplex problem areas.2.1.2 Charniak's CARPSCharhiak's CARPS program [Charniak 681 is a program for solving calculusrate problems.
In many ways, it is an extension of Bobrow's STUDENT program.
Theanalysis of the English input sentences is done by pattern matching which is slightlymore sophisticated than that of STUDENT.
The type of' rate problem (distance orvolume) is determined by the occurrence o f  certain key words in the problem statement.Two sets of patterns are used to analyze the sentences appearing in the two types ofproblems.
Many of the patterns used are very ad hoc.The CARPS program builds a structure (generally a single tree) containingthe information derived from the problem statement.
This structure is used to generatethe equations required to solve the problem.
Additional equations may be derived from"world knowledge", but this is again very ad hoc.
Thus.
while the problems solved byCARPS appear very impressive, the program is tailored so closely to this specific set ofproblems that it would be difficult to extend it to additional problems or problem areas.2.1.3 Gelb's HAPPINESSHAPPINESS [Gelb 711 is a program which solves basic probability problemsstated in English.
This program seems much like Charniak's: it build's a single treestructure representing a single problem.
and selects a solution method based on theoccurrence of keywords in the problem statement.
The input sentences are broken intosimple clauses and phrases by pattern matching.
These simple clauses are thenanalyzed by a context-free grammar to extract the  canonical verb and its voice.
subject.and predicate.
If certain key words (e.g., those referring to dice and coins) are found, aspecial search for possible modifiers of these words is made.This program, like Charniak's.
is tailored very closely to a small set ofspecific problem types.
It wobld be difficult to extend a program using these techniquesto handle a new problem area.2.1.4 Heidorn's Simulation Programming SystemThe NLPQ system of Heidorn [Heidorn 7'21 aqcepts an English statement of aqueueing simulation problem, and produces from it a program in the GPSS simulationlanguage which will simulate the problem.
The system is interactive: it requestsadditional information from the user when the problem statement is incomplete.
allowsthe user to ask questions about the simulation model, and can generate a completeproblem description in English from its internal model.English sentences are parsed and gei~erated frotn two interpreted phrasestructure grammars augmentetl by some semantic programs.
These grammars go downto the character level, and  handle English morphology as well us phrase structtire.
'l'hegrammar is based in part on the theory of  stratificatio~lal inguistics.
The basic unit ofstorage in the internal tnodel is the "record", which is komputationally equivalent to aLISP atom with its property list.This program represents an  advance over those considered previously in thissection.
It uses a legitilnate grammar to parse the inpup sentences, and can constrtict ampdel which expresses relationships among a number of ot)jjects.
The grammar isspecialized for simulation problems, and  would have to be modified to extend theprogram to other areas.
However, the performance of this system is quite impressive.2.2 Natural Language Processing2.2.1 Woods' Augmented Transition NetworksThc Augmented Transition Network (ATN) of Woods [Woods 501 is apowerful formalisnl for representing grammars.
The grammar of ISAAC, while writtenin "pure" LISP, is equivalent to an  ATN grammar.
A transition network consists of aset of nodes (representing states) and a set of directed arcs between the nodes whichspecify transitions between states based upon the input string being scanned.
An ATN isaugmented in several respects.
The test associated with a state transition may bearbitrarily complex, depending on the previously parsed structure as  well a s  the input.T h e  test may be the name of another transition network, in which case control is givento tha t  network a t  a lower level, effecting a "subroutine call" to the subordinatenetwork.
These calls may be recursive.
Transition arcs may also be augmented byarbitrarily complex strhcture-building actions: The  structures so built are  passedamong network levels in designated registers.
If a n  attempted parsing of a subnet fails,the ATN interpreter automatically handles backup from the failure point and triesanother possible transition.
The automatic backup and clearly defined interface (vianamed registers) between network levels make the ATN a very "clean" formalism forwriting grammars.2.2.2 Winograd's SHRDLUWinograd's widely known SHRDLU program [Winograd 721 allows a personto converse with a simulated robot about a "micro-world" consisting of various coloredblocks on a table.
The  robot may be asked to perform actions such as  moving blocks orbuilding structures and  to answer questions about the state of the micro-world or aboutits motivatiolls for performing particular actions.
The system employs a large grammar,based on Halliday's theory of Systemic Grammar.
Much of  the knowledge in t hc systemis represented in the form of MICRO-PLANNER theorems.
This miikes it easy forprograms to be generated to find the answers to questions about the world model, andallows a number of logical forms such as conjunction.
disjunction, and qu:\ntification tobe handled naturally.
The  theorem prover base is a source of consider~~ble  power forcertain types of semantic operations.
The  semantics is made much easier hv the small.finite world of very simple objects (colored blocks).
Still, the SHRDLU svstpm remainsone of the largest and most powerful natural language systems produced to date, anti itsfame is well deserved.2.2.3 Wilks' Preferential SemanticsT h e  work of Wilks [Wilks 751 is unique among "artificial intelligbnce"approaches to  natural language processing in that  Wilks is interested primarily inmachine translation, rather than in deep understanding of natural I anquage bycomputer.
However, there is a n  interesting parallel between the semantic templatesused by Wilks and some of the semantic processing done in ISAAC.
which is of courseconcerned with deep understanding.In Wilks' system, a sense meaning of a n  English word is represented by aformula, which is a list of element names.
The  elements are approximately 70 semant~cclasses which roughly classify the entities, qualities.
actions, etc.
which occur in Englishsentences.
Examples of such elements are MAN (human being), STUFF (substances),KIND (qualities), and CAUSE (cause to happen).
These elements may be combined intoa formula to represent a word meaning, as  in (FLOW STUFF) for the word "liquid".
4sentence is analyzed by trying to  fit a template (whicliis a list of element types) to someof the possible sense meanings of the words occurring in the se~ tence .
The  templates a reintended to represent the basic types of "messages" that people wish to convev inlanguage.
For example, the template MAN BE KIND would represent the class &messages in which the sentence "My sister is pretty" is included.After (possibly several) templates have been fitted 3 a piece of text,"preferences" of parts of each template are examined to s e e  if they are satisfied.
A verb.for example, may prefer a n  animate subject.
The template for which the greatestnumber of preferences are fulfilled will be chosen as  the intended meaning; however,possible fillers for the template slots will be accepted even though they do not meet thepreferences, provided that  the template a s  a whole is the best match.There is considerably more detail to Wilks' system which will not be coveredhere.
We mention Wilks because there seem to he parallels between some o f  histechniques and  techniques used in ISAAC.
One such parallel is the use of roughseinantic classes to distinguish between sense mea~lings of worcls, which we follt~tl-to heparticularly useful for determining pr.cl~osition meanings.
Othurs hove rev-tninljt uxrtlrough seninntic classes tn distinguish srllse melulings in sporial applichtions: \Yilkslwork is valuable for investigating this techllicluu over a large subset of3Rnglish.A second parallel lies in the ncreptnnce of 11 tvord (or lr~rger uni t )  which t'ailsto meet the preferences of the template which rovers it.
111 the ISAAC system, thisacceptance is an active process in which a11 acceptable it~terpretntion n u s t  hrconstructed fro111 the given unit.
These proccssrb ilre ciiscussed in more drtclil 111ter.2.2.4 Sinlmons' Senlt~ntio NettvorksThe Semantic Network formnlism of Sio~mons [Simmons 7:l: S i m m c ~ ~ s  andBruce i l l  provides n po\verful and convenient method for representing the elements of asentence and the semantic relations (deri\-ed from a variety of syl~tactir forms) \ ~ h i r hhold between them.
111 effect, it prodL~ces at1 ordei Tng of the argulhents ofLa ~ t ; .
l ~ l a t ~ t l ~ 'grouping (guch as a verb and its case arguments, modality, and optional modlfierajwhich is invariant cnrer the various syntactic orderings which express the samerelationships.
Thus.John gave Mary the book.John gave the book to hIary.The  book was given to  hlary by John.would al l  generate the same semnntir netv-ork structure.
The semantic netwo1.kformalism has beell used for language gene]-ation [Simmons and Slot~~1111 721 AS \v(3ll 3sparsing.
[Simmons and Bennett-Novak 751 shows how these structures may he usetl toproduce a small natural language understanding system with a minimum of effort.The  structures used by ISAAC in understanding sentenc'rs are ,a na tu ra lextension of Semantic Networks as used by Simmons, In  order to handle unultiples ~ n t e n c e  discourse, links are made from tokens in individuai senterlces to the refel-mtsof the tokens in the problem model which is being co~lstructed.
Semantic interpretationsare placed on some tokens as their meani~lgs are determined: Particular semanticinterpretitions may be specified based on information from many different sources.Making an interpretation of a token may cause links to be made from that token toobjects not mentioned in the sentence and may generate additional inferences about therelationships of the objects involved.
These processes are discussed in derail in laterchapters.2.2.5 Schank's Conceptual Dependency" w The Conceptual Dependency system of Roger Schank [Schank 73.  , a ]  is atheory (embodied in a series of computer programs) which postulates that the conceptstransmitted in natural language can be reyri?setlted as col-11plex structures bnsecl on asmall number of primitive actions.
The primitive actions are linketl by named links t otheir case arguments (some of which are other primitive action groups) and to othergroups to which they are related, e.g.
; causally.
Some case arguments we mal~datory,  sothat ih "John hit Mary" we must infer a n  instrument in this case John's  Ililnd) used i nperforming the action.While the structures and actions used by S c h ~ n k  are not very useful forphysics problems, some of the concepts he uses (such as inferring a requiredsemantic object when it is u nspecifird) are basic to  almost any language u nclerst antler.&hank's work is also importfa nt  because l ~ e  has defined a set of' primitive concepts andactions which can be used to express a fairly wide rmge  (though certainiy 11ot all)  ofnatural language sentences.2.3 Minsky's Frame System TheoryMinsky's frame system theory [Minsky 741 pi-oposes that knowledge i s9organized (in humans and, potentially.
in computers) in terms of interconnectedelements called Frames.A frame is a data-structure for representing a stereotyped situation, likebeing in a certain kind of living room, or going to a child's birthday party.Attached to each frame are several kinds of information.
Some of  thisinformation is about how to use the frame.
Some is abgut what one canexpect to happen next.
Some is about what to do if these expectations arenot confirmed.A frame may have "slots" which can be filled by the particular "arguments" invc~lvedin an instantiation of the frame.
There may be procedures associated with n frame todetermine the suitability of proposed arguments and to infer values for those which areunspecified.Minsky also makes some general comments about how frames may be usedin computational linguistics.. .
.
in understanding a discourse, the synthesis of a verb-structure with itscase-assignments may be a necessary but transient phase.
As sentencesare understood, the resulting substructures must be transferred to agrowing "scene-frame" to build up the larger picture.Minsky's frame system theory has been immensely popular-so popular thatmany people are claiming thatframes are exactly what they bave been doing all along.There are many similarities between the processes and data structures used by ISA.4Cand the frame systems described by Minsky, and the term "frame" will be used indescribing some of them.
The interpretations given will of course be those of the author.The idea of frames is a powerful one.
but the mechanics or their implementationremains a problem for research.3.
Parsing3.1 Introductiol~Parsing, as used in this chapter., means the process of assigning a structure tothe linear string &of words rotnprising a sentence so that the syntactic relationshipsamong the words and phrases in' the sentence are tnade explicit.
The  processes ofrelating the structures in the  sentence' to parts of the developing model of the problemand of determining the meaning of the structures will be treated in the chapter 011Semantics.
Obvionsly, there is no clear division hetween what  is syntas and what issemantics; many constructions could be claimed to be either.
In the sentence processingdone by ISAAC, syntactic and se111~1ltic processing are frequently intermixed.
We shalldescribe the two parts separately to make them easier to understand, while trying toindicate the points a t  which they interact.
How to best organize th8 interactions ofsyntactic and semantic processes in a language understanding program remains anunsolved problem.Although the parsing programs in ISAAC are written in "pure" LISP, theirstructure is strongly influenced by the Augmented Transition Network (ATN)formalism of Woods [Woods 701.
An ATN grammar allows sub-grammars for phrasesto be called (recursively) as subroutines by other grammars.
A grammar program maybuild structures which are passed back to the program which calls it.
I n  case anattempted subgramrnar fails.
the grammar interpreter automatically backs up  from thefailure p o i ~ t  and tries the next possible alterllative which is specified.
These features ofATN grammars are also present in the parsing programs of ISAAC.
The grammarprograms are organized as  a set of parsing functions, most of which parse a singlefunctional unit, such as a noun phrase.
This orga~lization in terms of functional unitsseems natural because it allows the grammar functions to communicate with each otherby passing pointers to complete, well-defined functional structures.
A noun phrase, forexample, causes the production of a noun phrase token structure which has a standardform, independent of the function of the noun phrase in the sentence.
Grammarfunctions which parse larger syntactic units, such as  a clause, connect the smallerstructures, such as noun phrase and verb phrase tokens, by means of named links whichspecify the relationships of the phrases in the sentence.The structures which are produced by the parsing programs bear a strongresemblance, to the semantic networks of Simmons [Simmons '731.
The grammarfunctions which parse the major phrases.
such as noun phrases and verb phrases,produce,"token" structures which represent the itlforlnation in the phrase in a standardand readily accessible form.
Other grammar functions, such as  those which parseprepositio~lal phrases and other modifiers, may make changes anti add information tothe modified token structures rather than creating new structures themselves.
The  linksbetween token structures may specify semantic relationships (for example, that onenoun phrase namesea location on the object referred to by another noun phrase) as wellas  syntactic relationships.
In  some cases (e.g., w i th  prepositional phrase modifiers), thesemantics may be done at onct, so that  semantic links among the tokens are not needed.A s  semantic processing proceeds, the token network structure is elaborated by addingsemantic intelbpretations to some tokens a ~ l d .
by creating links between some tokens andthe objects to which they refer in the program's model of the kvorld.
These semanticprocesses may render a toke11 unnecessary and leave it unlinketl to thL: rest of thestructure.
After all the semantic processing has been done, the information in thesentence has been transferred to the world nlodel, and the network of toker~s is nolonger needed.3.2 Control Structure of the ParserT h e  parsing programs are  written a s  LISP functions.
without using anadditional interpreter as a Woods system does.
Automat~c backup and control of thescanner which points tq the current position in the sentence being parsed areaccomplished bv - a set of small functions which are called from within the individualparsing programs.
These functions set the system registers (global variables)appropriately for the current state of the parser.A sentence is represented internally as an ordered list of ~vords.
As thesentence is scanned from left to right, the global variable SENT is set to point to thecurrent position in the sentence.
The  current word (or multi-word unit) being scanned isput info the * register.
Thus, a grammar program could test whether the word currentlyunder the scanner is "and" by using the LISP code (EQ * "AND), where the quotationmarks are a n  abbreviarion for the function QUOTE.
The  parsing of a sentence isinitiated by setting SENT to the sentence and calling the function S E T V o  set the :':register.
When a grammar program wishes to move the scanner one position to the right.i t  does so by calling the function ( => ).
The  next word to the right and the second wordt o  the right may be gotten by using the functions (NEXT) and (NEXTS), respectively,without affecting the position of the scanner.
The function CAT (category) is frequentlyused to test whether the word currently under the scanner is in a particular category, asdefined in the lexicon.
Thus, (CAT "ADJ) may be used to test whether the current wordis a n  adjective.Since the parser operates from left to  right, it sometimes happens that  agrammar program fails tojfind the type of phrase it expects, after it has moved thescanner from its initial position.
For example, in parsing the sentence "To err ishuman", the parser might first a t , t e ~ i ~ p t  to pilrse a prepositional phrase.
The prepositionwould be found, and the noun phrase parsel would be cnlled after nroving the scanner.The noun pllrnse parser woulcl finti the verb "err", and so, it a n d  the prepositionalphrase parser wnuld fail.
In  order to handle such cases, it is necessary to l ~ e  able to savethe current y~si t ion in the sentence so that the  purser can bark up and try somethingelse when an  attempted parsing fails.
This is nccornplishetl by calling three smitllfunctions, SAVE, SIJCCESS.
ant1 FAIL, within each parsing function.
Nornmally, nparsit~g Rulctiun i l l  esecute (SAVE) ils its firsl.action and esecutc either \ FhII.)
or(SUCCEBS), as appropriate, immedintely before it esits.
SAVE s:nPes the poil~tcrs t o  thecurrent point in the sentence on a push-down stark.
In  atitfition, it saves the currentpoint in the list of generated atqms,  so that ntly atoms gene~ated  by a ftlnction a hichlater fails can be deleted.
SUCCESS removes one set of pointers from the stack: sincethe attempted parsing was successful, these pointers are no longer needed.
FAILrestores the pointers to the sentence to their original position, and calls SET to restol-rthe * register.
In addition.
it releases any atoms which may have bee11 generated by thefunction which failed.In order to illustrate how the parsing functions are actually written, a simplefunction to parse a noun phrase (using the same conventions as the parsing programs ofISAAC) is shown below.
This program parses a simple noun pht-afe consisting of anoptional determiner, zero or more adjectives, and a noun.
The program s~lcceeds andreturns True if it finds such a ph~+ase:  otherwise, it restores the pointers uslng FAIL andreturns NIL.
No structures are built by this program, but it is easy to see how structure-building code Could be added.
(NP (LAMBDA ( ) (PROG ( 7(SAVE)(COND ((CAT WET) (=> )) )A (COND ((CAT "ADJ) ( => ) (GO A ) )((CAT "NOUN) (=> ) (RETURN(SUCCESS)))(T (RETURN (FAIL))) )1))This pmqram accepts a noun phrase equivalent to that accepted by thefollowing grammar:Using the Woods ATN formalism, such a program could be written as  followkr(NP/ (CAT DET T (TO NP1))(TST T T (JUMP NP-1 ) ) I(NP1 (CATADJ T (TO NPI ) )(CAT NOUN T (TO NP2)))(NP2 (POP T T))Our method of writing pnrsing-functions requires t h ~  writing of slightly morecode than is required for a Woods interpreter system, but s i t  avoids the overhead ofinterpretive execution.The functibn SET*, which sets the value of the 'X register, checks formaltiple-word units, and replaces them with single words in the * register.
"As much6 6 as", "center of gravity", cross section".
"point of application", and "so that" arerecognized as multiple-word units.
These gl-oupiqgs could have been lrandled by othermethods, but replacing themby a single "constructed" word is a convenient way to doit.
A large parsing system wpuld need to be able to back up ?n case the multiple-wordinterpretation was incorrect; in our limited field of physics problems no suchambiguities accurred.
Becker [Becker 751 has argued that such groupings play a majorrole in language.Values are passed between levels of the grammar using the normal LISPconventions of function arguments and returned values.
A returned value of NILalways indicates failure of a grammar program.
A grammar program which succeedsmay return a generated token atom (as in the case of a Noun Phrase), or it may attachits results to existing atoms and simply return True (as  in the case of a PrepositionalPhrase).
Some grammar functions have no arguments.
but others (such as the VerbPhrase) have quite a few.3.3 Data Structures Produced During ParsingAs a sentence is parsed, the grammar programs create a set of intertinkednodes representing the major phrases (primarily Noun Phrases and Verb Phrases) of asentence.
These networks initially bear a strong resemblance to the Semantic Networksof Simmons [Simmons 731.
As semantic pmc:essing of the sentence progresses, modifiersof the nodes are removed or changed in form, semantic interpretations are added, andlinks are made from the nodes to objects and relations in the developing model of theproblem.
Finally, after execution of the verb semantics, the network is discarded.Each node in the parse network is a GENSYM atom whose name is TOKfollowed by a number.
Features of the node (also called a "token atom" or "token") arestored on its property list.
The "main" word of the phrase (usually, but not always, aword from the sentence) is stored under the indicator TOK.
The type of phrase is stored2 0under the indicatcjr LFRAME (Linguistic Frame); the poltsible types o f  LFRAMEs a r*rNP ( N o ~ i n  E)hrase), VP (Verb Phrase), QNP (Q\iestio~z No~in  I'l~rase), and IIEIINP(Relative Noun E'hrase).
The noun phrase "each end'' in P;3", for ~ x a r ~ i p l e ,  w o ~ i l dgenerate the fo l lowi~~g token:TOK89 TOK ENDLFHAME NI1NBR (Ns)MODS ((,QNTFIZ EACH))SFRAME LOCPARrrSEMOBJ (SCAFI+'OIJD85)RFNT (LOG91 L0C:lo)The first four items 011 the property list o f  the token,are cre:~trd by theparsing program.
NRR.is the Nuntbur ( N o u n  Singulm),.nntl h1OI)S is n list of modifiei*?
;,in this case the quantifier EACH. '
I 'he~emnining property list items are ~tl(lrti tluringsemantic processing: S FRAME (Semantic Frame) is LOCat ion PART; .$E:hlO BJ(Semantic Object) is a link to the object in the  problenl ~llotlel which the location refvrsto, in this case the scaffold SC'AFF0LYH;'r.
RFN'I' (Referent) is a list o f  painters t o  theitems in the problemmodel to which the phrase refers: the  locarions LOC91 and LOC!
)O.When the semantic function for the verb is exec~ited.
it will dehl tllrcctly with theReferents of the phrase, independent of the syntactic construction in the originalsentence which caused those referents to be selected.
:3.4 Noun Phrase PmsingIn this section w e  will esalnine in some detail the parsing of the noun phraseanci its modifiers.3.4.1 Basic Noun PhraseA flowchart of the  NP parsing program is shown in Figure 3.1.
A flo6chart isused to describe the program because a transition nkt of this size would be unlvieldy.and because a flowchart can mare closely folloiv the actual program structure.
ti fewnonstandard conventions a re  used in the parser flowcharts in *this chapter.
A testconsisting of a word in capital letters indicates a test of whether the word currentlyunder the scanner (the word in the '$ register) is in that  category.
(NEXT) indicates thenext word to  the right, and (NEXT" indicates the second word to the 1-ight.
The symbol=> appearing next to a line indicates that  tohe scanner is moved to the right along thatcontrol path.
The symbol +- indicates that  the right part is appended to the lett:* References to  the example problems are  denoted by the letter P f o l l o ~ ~ e dby the problem number.Proper Noun" A t  (B) che ocher endY P  TOK - (NPAPP NIVIEYP IHODS 4 ("NAME NMLE) 1Figure 3.1 (page 2 )Put NAME on TOK 0generally, A +t- B is implemented ss(SETQ A (NCQNC A (LIST B))).Phrases in quotes next to corltrol paths are examples of phrases which would follow theindicated paths.The initial tests in the flow diagram tgst for proper nouns, geometric names,and pronouns, which are handled separately.
[Geometric names, as in  "AT END (A)",are represented in LISP as lists containing the names; in the original sources fromwhich the problems were taken, such names were written as italic capitnls.]
Thedeterminer, if present, is saved.
A series of tests separates the use of a measurement(e.g., "10 ft") as  a noun phrase by itself or as a modifier ("a 10 f~ pole"), whileprohibiting it if it precedes a relative preposition (as in " 10 f t  from .
.
.")
since this formis more easily handled as  part of the prepositional phrase.
Adjectives which are markedNULLADJ are ignored.
Thus, "a tapering wooden telegraph pole" (PI 1) is treated thesame as  "a pole".
This is one of the few cases in the parser where information from theproblem stqtement is ignored.
Possessive pronouns are rewritten a t  once; the referent ofthe corresponding root pronouh is found, and a modifier of the form (POSSBY referent)is constructed.
This modifier retains the ambiguity of the type of possession.
Notsurprisingly, there is considerable similarity between the semantics of POSSBY andsome of the sense meanings of OF.
Thus, for example, "its end" and "the end of thelever" will be reduced to a n  identical form when processed semantically.When the noun is found, a token atom is created for the noun ph ra~e ,  usuallyusing the singular form of the noun as  the token name.
In some cases, however, anexpanded definition is used, resulting in the use of a different token name and thegeneration of additional modifiers.
Thus, PAUL becomes PERSON, (SEX MALE),(NAME PAUL) and BOY becomes PERSON, (SEX MALE), (AGE YOUNG).
Thisexpansion eases the identification of the same object when it is referred to by differentwords; the identification of these two tokens will result in the inference that Paul isyoung.
The modeling of words as carriers of modifiers to be applied to their rootconcepts is an interesting area of research; [Simmons and Amsler 751 are investigatingthis type of modeling for verbs of 'motion and communication.After the noun token is made, an  attempt is made to execute the semantics ofeach of the modifiers which have been found.
Some modifiers will make changes directlyto the NP token; others will create new modifiers which are saved for later processing.9 1"Both",-for example, will create modifiers equivalent to "Each of the two .
.
.
.The pronoun matching algorithm which is used is very simple.
A pronounwhich was previously used is matched to the same referent as  before.
Otherwise, thelast-mentioned candidate which matches the pronoun in number and is appropriatelyhuman or inanimate is chosen.
This technique is fairly crude, but it worked for this classof problems.
In  general, finding pronoun referents can be very difficult.
[Charniak 721considers this problem in some detail.3.4.2 Noun Phrase Compounds and ModifiersConjunctions and modifying phrases int ~oduce  many potential ambiguitiesinto the parsing of a sentence.
In  a noun phrase containing two prepositional phrases,for example, the second prepositional phrase (Pp) might modify either the top-levelnoun phrase or the noun phrase in the first PI?.
A conjunction het*ween two nounphrqses might join them into a compound noun phrase, or it might connect two top?levelclauses containing the noun phrases.
Although syntactic constraints' may select thecorrect interpretation in some cases, in many other cases the choice cambe made only onsemantic grounds.
For example, inLowering the level of the lake allows city officials to kill weeds andresidents to repair their docks.we must use semantic interpretations to reject the possibility that "weeds andresidents" is a compound noun phrase.
People seem to make these choices easily andcorrectly the first time they read or hear a sentence; only rarely do they have to back upand re-parse a sentence in order to interpret it correctly.
The parsing programs ofISAAC rely heavily on,semantic tests to reject incorrect combinations of phrases.A noun phrase may be' modified by a prepositional phrase,, an adjectivephrase, or a dependent clause.
In each case, the parser for the modifying phrase is calledwith the NF token as  an argument.
The modifying phrase parser may reject thecombination on semantic grounds even though the appropriate syntactic constituent isfound.
This is especially important in the case of prepositional phrases.
Compoundmodifiers, as in "a uniform scaffold 12 ft long and weighing 100 lb" (P5), are permitted.Conjoined noun phrases are required to all  be members of the same semanticclass, which may be one of the set PERSON, PHYSOB (physical object), LOCNAME(location name), ATTRNAME (attribute name), or MEASU (measurement unit).Pronouns are prohibited as members of dompound noun phrases.
These tests handledalmost all cases which OCCUII-ed in the set of test problems.
One pathological sentencerequired additional treatment:If it is placed on the edge of a block 1.5 m from the light end and a weightof 750 nt added to the light end, it will be balanced.
.
0'14)Since the auxiliary "is" is omitted in the second clause, "added .
.
."
could beconsidered a dependent clause modifying "weight", and "blork" and "weight" could becombined as a compound noun phrase under the above rules.
This problem was solvedby a semantic test associated with the preposition "of' which prohibits a compoundobject noun phrase for such cases.
This is not a very pleasing solution.
People probablyaccept "edge of a block" as  a well-formed unit  before reaching the secuand clause, andthus do not consider combining "block" and "weight".
The depth-first operation of thisparser allows it to go fairly far afield in such cases; additional semantic tests to allowsome constituents to be combined earlier would be a desirable, but difficult,improvement.3.4.3 Noun Phrase VariantsThere are three *small parsing programs which accept variants of noun, 9 phrases.
THERENP accepts "there" as a tloun phrase in cases such as  "there is .
.
.
.9 Y QNP accepts a noun phrase beginning with a question word, as in "what force .
.
.
,RELNP parses a "relative noun phrase" containing "as much as", as in "the mansupports twice as much as  the boy" (P7).
The multiplicatioll factor is saved, and a linkis made to the noun phrase involved in the comparison.3.5 Verb Phrase Parsing3.5.1 Basic Verb GroupThe verb group, which is parsed by the program VG, consists of a set ofauxiliary verbs, a main verb, and optional adverbs.
The flowchart of VG is shown inFigure 3.2.
Since tense and modality are not needed for our type of physics problems, theauxiliary verbs are ignored except for determining whether the verb group is active orpassive.
Other authors (for example, [Winograd 721 ) have given procedures fordetermining verb tense f r o q  the auxiliary verbs.The program VG has six arguments.
NPHD is a noun phrase token which isthe syntactic subject of the verb.
VPHD (if specified) is a verb phrase token which iseither the first part of a compound verb phrase or the initial auxiliary verb which isseparated from the rest of the verb group in a question.
CMPND is a flap which is true ifthe verb group is part of a compound verb phrase.
DCLF is true if the verb group is partof a dependent clause; DCLP is true if the dependent clause construction is passive.QFLG is true if the verb group is a top-level verb group in a question.The flowchart of VG is fairly straightforward.
If a previous verb phrase isavailable from a separated verb group in a question, it is deleted and incorporated intothe main verb group.
The syntactic subject is attached to the verb phrase as  subject orobject depending on whether the verb is active or passive.
This transformation frees theverb semantic programs from-having to concern the~se lves  with the voice of the verb.In  a compound verb phrase without a subject (object if passive), the correspondingphrase from the first verb phrase is used.
Thus, in "John was tarred and feathered","~ohn" would be used a s  the object of "feathered".3.5.2 Verb PhraseA flowchart of tlre verb phrnse parsing program, Q1', is shown in Figure :I.:).VP first parses n verb group by calling VG, then i*ollcrts tllt.'
rennt~inillp prt1dic;ltc.phrases and modifiers and attaches them to the verb phmsu loken.
These phrnsesinclude tho syntactic object noun phrase oradjeciive phrase, an i~lfiniti\+e verb phl*nseobject (as in "they wlui~t to go .
.
.
"), and prepositiollnl p11r~ses o r  adverbs modifyingthe verb,After parsing a verb group, VP calls VPMODS t o  collect \*erb modifiers(adverbs and prepo~it~ional phrases).
An  infinitive verb phrnse objort is r0llt3rted ifpresent and attached to the \perb phrase token under the indicator INFOBJ.
If aquestion is being parsed, the  subjecb and the remainder of the separated group arecollected.
A prepositional phrase on HOLD (that is, one which occurred at the st art ofthe sentence and could not be attached to anything, e.g.
"At (B), the other end of thepole, there is , , ."
(P15) is attached to the verb phrase if possible.
The predicate nounphrase or adjective phrase is collected, along with any remaining modifiers.
If the verbphrase is part of a dependetlt clause, it is required to  contain more than just a verb.
Adependent clause (DCLAUSE) is attached to the t o k k  of the phrase it modifies.3.6 Prepositional Phrase ParsingThe  structure of the prepositional phrase is fairly simple.
I n  addition t o  theusual PP consisting of a preposition and noun phrase, the PP parser accepts a phraseinvolving a measurement and a preposition and noun phrase (as i n  "10 ft from oneend") a s  a single prepositional phrase.
Hoth t -yes  may involve question phrases, as  in"at what ppint" (P7) and  "how far from the center" (P20).T h e  PP parser behaves differently from the other parsing programs in that  itsaves a well-formed result which cannot be attached to the head token which wasspecified, due to semantic constraints.
If the  PP parser is called again to reparse thesame phrase (as  it surely will be), it applies the semantic tests to its previous result andthe new head token.
This not only saves the work of reparslng a n  identical phrase twice,but more importantly, it  prevents side effects which occur during the parsing from beingrepeated.
These side effects (such as  the creation of a new object in the model of theproblem) violate the restriction on a pure Woods net parser tha t  all results be passedbetween programs in designated registers; hence, the effects are not undone whenbackup is made from a failing parse attempt.
We could make all such actions reversible,as in CONNIVER [McDermott and Sussman 721, but such arl approach exacts a highpenalty in computational overhead.
Our approach is probably safe for prepositionalphrases, which cannot in general be parsed a s  anything else.
The pure Woods netapproach makes it difficult to mix syntactic and  semantic processing.
More research isneeded on ways to intermix the two and still be able to bnck up when necessary, withoutincurring too much overhead.Preposition semantics are executed, when possible, as soon as  theprepositional phrase has been parsed.
In some rases, the se~nontic routine will electlodelay the s e m ~ n t i c  processing.
In these cases, the PP is saved on the head token underthe indicator' PPS for la&r processing.3.7 Clause ParsingThe clause parsing programs, CLAUSE and QCLAUSE.
are relati\?elysimple programs which accept the several for~ns of declarative, ia~perative, u i ~ dquestion clauses.
An iuitial prepositio~~nl phrase, if present, i s  placed on n HOI,D list forlater processing.
A noun phrase or question phrase is parsed and then used as allargument for calling the verb phrase parser.
The result of parsing a clause is the verbphrase token, which contains pointers to its various arguments.
This verb phrase tokenis passed as an argument to the verb serna~ltics driver, EXVBSEM, which completessemantic processing of the sentence.Figure 3.4 shows the structure formed after parsing and seniantic processingof a complete sentence.
Much of the information iri the structure is produced by thesemantic programs after parsing, but we will describe it briefly as an introduction to thesemantic processes.
The root of the parse tree (the value returned by the SEWTENCEparsing function) is TOK185, the verb phrase token for the main verb of the sentence.The object of the verb is TOKltll ,  which was the syntactic subject (since the verb phraseis passive); the subject (agent) of the verb is TOK186, which was intl~oduced by thepreposition "by".
The semantic routine for "by" sinlply attached its object phrasetoken, TOK186; to the verb phrase token as the subject of the verb; hence, there is noneed for "by" to appear anywhere in the structure) T O K l 8 l  is the noun phrase tokenproduced from the initial noun phrase of the sentence; it is a TOKen of the wordSCAFFOLD, is a Linguistic FRAME of t-ype NP (Noun Phrase) has an  INDEFiniteDETerminer, and has a NBR (number) of NS (Noun Singular).
The modifier "12 f tlong" has been converted to the form (LENGTH 12 FT); the same modifier form wouldbe produced for the phrase "a 12 f t  scaffold".
TOK181 is the syntactic subject of aDCLAUSE (Dependent CLAUSE) whose verb token is TOK182.
The SFRAjWE(Semantic FRAME) interpretation of TOK181 is PHYSENT (PHYSical ENTity), andits RFNT (Referent) is SCAFFOLD184, which is a n  object in the model of the problem.The remaining tokens shown in the figure have a similar structure.
The modifier"vertical" of TOK186 has been converted to the form (ROTN 90); this token has tworeferent objects.
The modifier*"its" of TOK188 was converted to a modifier of the form(POSSBY SCAFFOLD184), which was semantically processed to make TOK188 aLOCPART (LOCationlPAIiT) SFRAME whwe SEMOBJ (SEMantic ODJect) isSCAFFOLD1 84; idelltif'ication of the location referents of TOK 188 yieldad the twolocations LOC190 and LOC189, which are locations on SCAFFOLD184 in the model ofthe problem.
Since TOKIBN was the object of a preposition, semantic processilig of theprepositional phrase transferred its referents to a modifier of the verb phrase TOK187;this left TOK188 unconnected to the rest of the structure.3.8 ConclusionThe computer time required for parsing and semantic processing averagesabout one second per sentence, running on a CDC 6600 and using interpreted LISP.
Theparsing programs constitute only about 15% of the total; the semantic programs aretwice as  large.
Syntactic processing is thus a -relatively small part o f  the completeprocess of language understanding.
On the other hand, this program has convinced theauthor thax even in so constrained and well-defined an area as  physics problems,syntactic processing cannot reasonably be isolated and done without recourse tosemantic tests, some of which ultimately involve reasoning based on the particular factswhich are known about the objects being discussed.
"A uniform scaffold 13 ft long and weighing 100 lb is supported horizontally by twovertical ropes hung from its ends.
"TOK181 TOK182TOK SCAFFOLD TOK WEIGHLFRAME NP LFRAME VPDET INDEF MAINVB WEIGHINGNBR (NS) DCLAUSE ?
'T*MODS (UNIFORM (LENGTH 12 FT)) INTRANS *T*DCLAUSE (TOK182) ACT *T*SFRAME PHYSENT SUBJ TOIC181RFNT (SCAFFOLDl84) COMP TOK183TOK183TOK LBLFRAME N PQTY 100TOK185TOK SUPPORTLFRAME V PMAINVB SUPPORTEDAUX (1s)TRANS *T*PASV q*OBJ TOK181SUBJ rOK186TOK187TOK HANGLFRAWE V PMAINVB HUNGDCLAUSE *T*INTRANS *T*PASV *T*OBJ TOK186MODS (LOC FROM (LOCI90 LOC189))TOK186TOK ROPELFRAME NPQTY 2NBR (NPL)MODS ((ROTN 90))DCLAUSE (TOK187)SFRAME PHYSENTRFNT (ROPE192 ROPE191)TOK188TOK ENDLFRAME NPNBR (NIX,)SFRAME LOCPARTSEMOBJ (SCAFFOLD184)RFNT (LOCI90 LOC189)Figure 3.4: Structures Produced for a Complete SentenceIt may be helpf'ul a t  this stage to realize that the primary form ofmathematical communication is not description, but injunction, i n  thisreppect it is comparable with practical art forms like cookery, in  whichthe taste of a cake, although literally indescribable, can be conveyect to areader in the form of a set of i~~junctions called a recipe.-G. Spencer Brown4.
Semantics4.1 IntroductionSemantics, for our purposes, is the procr.ss of constructing the meaning of asentence: the process of relating the objects in the sent.cnce to objects in the world modelof the reader, and of updating the world model to reflect the meaning of the sentence.The sentence itself is not a description of the meaning, but rather a set of injunctions, arecipe which can be followed to construct the meaning from what the reader alreadyknows.As the above definition implies, the way in which a sentence is interpreteddepends strongly on the knowledge, intelligence, and inclinations of the reader.
As iswell known, different readers will interpret the same text (even in physics problems) indifferent ways.
A semantic interpretation of a sentence may, be viewed as  satisfactory orunsatisfactory for a particular purpose, but it would be difficult to judge it as "right" or1 4  wrong.
"Updating the world model to reflect the meaning of a sentence can be a veryinvolved process, since the meaning of a single sentence call have many consequences.In  our physics problems, these deductions do not propagate very far beyond theimmediate understanding of a sentence during the time when the sentences are beingread.
In this chapter, then, we will primarily discuss "linguistic semantics," which wemay define as  the semantic processing up to the point a t  which the parsing of a sentencemay be discarded.
This distinction is well defiried within the computer program.
Underthis heading there are a number of distinct semantic processes: determining themeaning of ambiguous words and phrases; finding anaphoric referents (such aspronoun referents) and elliptical referents (such as  the physical object referred to whena location is named alone as  in ('one end"); determining the meaning of groups ofwords whose meaning in combination is more than a combination of tkeir individualmeanings; determining the meanings of modifiers of nouns and verbs and saving themeanings so that they can be effective a t  the proper place in the processing; determiningwhether an  object or location mentioned in a sentence is a new one, or whether it refersto one mentioned previously; adding objects and relations to the world model, andupdating existing ones to reflect new information; expanding the model of a11 object sothat its subparts may be referenced; testsing n modifier to determine whether it canreasonably 111odify a given phrase (which may require reasoning based on theparticulars of the world nlodel); interpreting all object of a given type as a11 obdect of adesired type (for exa~nple, interpreting an object as a locnt.ion or vice versa), All of theseprocesses will be discussed in this chapter,4.2 Preliminary Modifier ProcessingAdjective and adverb modifiers of  noun and verb phrases frequentlv havetheir effects a t  a relatively late stage of semantic processing: the idulltification of thereferent of a noun phrase, or the execution of verb semantics.
These modifiers musttherefore be saved for later reference.
In  some cases, a semantic routine will beassociated with the modifier itself; ill other cases.
it is more convenient for a largerroutine to look for the existence of certain modifiers to guide its processing.
Preliminarymodifier processing puts modifiers of certain classes into a standard form so that theywill be easy to identifv or so that a single semantic routine can be used for the wholeclass.
I n  some cases, different meanings for a modifier may be selected depending on themodified phrase.Adjectives such as "one", "other", "first", and "second" are put directly onthe noun phrase token under the indicator DET2.
These modifiers are referenced indetermining the referent of the noun phrase.
Adjectives such as  "heavy", "left", and"upper" are converted to modifiers of the form (SELECT adj); they are used inselecting a particular referent from several possible ones.
Quaritifiers such as "each"become modifiers of the form (QNTFR adj).
Adjectives such as "horizontal","vertical", and "upward" are converted to rotation modifiers of the form (ROTN ang),where "ang" is the appropriate angle.Adjective phrases indicating measurement (as in "a 10 ft pole" or "a pole 10f t  long") are converted to modifiers where the measured quantity is made explicit, e.g.,(LENGTH 10 FT).
When the referent of the noun phrase is found, the modifier istransferred to the property list of the referent.
In the case of unspecified forcemeasurements, tests are made on the modlfied noun phrase to determine the rrleasuredquantity.
Thus, a 150 lb man is a man whose weight is 150 lb, while a 150 lb force is aforce vector whose magnitude is 150 lb.4.3 Preposition SemanticsPreposition semantics is an interesting area.
A single preposition can have anumber of sense-meanings (as many as seven in our set of physics problems) dependingon the types of objects it connects.
The actions required of the semantic routine are ingeneral quite different for each sense-meaning; for our purposes, sense-meanings aredifferentiated by the different actions required to process them adequately.Discrimination net tests based on rough semantic classifications of the phrasesconnected by the preposition were found to be adequate to distinguish the prepositionsense-meanings in our sample problems.
We shall discuss in detail the semanticprocesbing for some prepositions, auld then compare our sense-meaning classificatiol~swith dictionary classifications and postulate that techniques similar to ours may beuseful fqr machine translation of prepositional phrases.4.3.1 Semantics of the Preposition "OF"The sense-meaning classifications for the prepositions were determined bylisting the occurrences of each preposition together with the modified (or "head")phrase and the object phrase of each.
Occurretlces which seemed to be af the samesemantic class were grouped together, and a set of discrimination net tests wasdeveloped which would distinguish between preposition uses in each of the diffe~entclasses.
Using this procedure, seven distinct sense-meanings of the preposition "OF"were found in our small sample of twenty physics problems-a surprisingly largenumber considering that the problems are all of a similar.
type.
The seven sense-meaning classes are listed below with examples.
Although the classes were determinedfrom our physics problems, it is easy to think of examples of each class which are incommon usage and are not limited to the narrow area of physics problems.1.
< quantifier> OF < objects> each of the ropes2.
< measurement> OF < value> a length of 10 ft3.
< object> OF < value> < attribute> a pole of uniform cross section4.
< location> OF < object> the left end of the lever5.
< attribute> OF < object> the weight of the lever6.
< group> OF < objects> pair of legs7.
< part> OF < object> hinges of a doorThe semantic classes for the head and object phrases are given for eachsense-meaning in the left-hand column; the discrimination net at the beginning of apreposition semantic routine uses tests for these semantic classes to determine theproper sense-meaning for a given use of the preposition.
Once the proper sense-meaninghas been determined, the processing required is fairly simple.
For sense-meaning 1 of"OF", <quantifier> OF < objects>, the quantifier token is replaced by the objecttoken, and the quaritifier is made a modifier of the token; thus, "each of the ropes" isput into the same form as "each rope".
For sense-meaning 4, <location> OF< object> , the SFRAME (Semantic Frame) of the head is set to LOCPART, and thereferent of the object phrase is put on the head token ynder the indicator SEMOBJ(Semantic Object).
[The process of referent identification is discussed in a later section.
]In cases such as  this one, the determination of the prepositsion sense-meaning also servesto determine the proper sehlantic frame for the head phrase.
The prepositional phraseitself serves to supply one of the nrglimehts of the semantic frame.
Just ns parsing makesexplicit the syntactic relations which hold among the words in a sentence, the reductionof phrases to their semantic frame form makes explicit the semantic relations whichhold among the objects referred to '(explicitly or implicitly) by the phrases.
The semanticframes constitute a set of standard forms into which phrases representing similarmeanings are translated; thus, nulnerous different ways of expressing the samemeaning can all be translated into an  identical semantic frame form.In the case of senge-n~eaning 7, < part> OF < object> , a special semanticroutine may be calledinto play to define the parts and their relation to the object theyare part of.
In  our example, "the hinges of a door" (P9), the correct formulation of theproblem requiresbthe use of world knowledge that'a door has two hinges (if the numberis unspecified) which are arranged vertically and attached to the door on one side.
Thispragmatic knowledge is contained in a semantic routine for defining parts of doors.
Byrepresenting the knowledge in this way, it is possible to refer to the parts of a complexobject if necessary without expanding the i n t e~na l  model of the object into its parts ifthey are not referenced.In ,our sample problems, there was'only one case where a prepositionalphrase modified a conjoined noun phrase: "magnitude, direction, and point ofapplication of the equilibrant" (PI3 and P15).
In this instance, the prepositional phrase"of the equilibrant" should be assumed to modify each of the three conjoined phrases;this is handled within the semantic routine for "OF".
I t  would be desirable to handlesuch cases at a higher level and thus in a more general fashion.
More research is neededto  find rules to govern the interpretation of prepositional phrases which modifycompound phrases.4.3.2 Semantics of Other PrepositionsIn this section, we will briefly describe the sense meaning classifications andsemantic processing for the remaining prepositions.
In each case, of course, there aresome sense-meanings of the preposition which are not handled by the program; wediscuss only those which are.BY is used only to specify the agent of the verb in a passive verb phrase.
Theobject of the preposition is put on the verb token under the indicator SUBJ.AGAINST is used to specify a case argument for a verb, as in "rests against avertical wall" (P8).
The referent of the object phrase is identified, and the prepositionatld referent are put on the verb token as  a modifier under the indicator CASEARG.CASEARG modifiers are processed by the verb semantic routines, which may havespecific interpretations for case arguments illdicated by certain prepositions.TO with a location object is used to specify a location for a verb phrase.
Thelocation referent is identified, and the preposition and refhent are used as a-modilierunder the indicator LOC.
Since lnodifiers are kept as "a list under the property listindicator MODS, there can be multiple LOC modifiers.
The preposition is kept in casethe verb semantic routine can derive additional information from it; usually, however,only the location referent will be used.Proposed LOC modifiers are tested against the head phrase to determinewhether the modification is acceptable; this is done by a function called LOCTSI'.
If thehead is a verb phrase, the verb is tested to see whether it can properly take a locationmodifier.
For example, in the sentence "There is a man weighing 150 ib a t  one end", theLOC modifier "at one end" would be rejected as a modifier of "weighing", while in thesentence "There is a man standing a t  one end" the LOC modifier would be accepted asa modifier of "standing".
If the modified phrase is a noun phrase, the object referred to(explicitly or implicitly) by the location modifier is tested against the head object; if theyare the same, the modification is rejected.
Thus, in the sentence "one-painter .
.
.
stands on the scaffold 4.0 ft from one end" (P3), the location modifier "4.0f t  from one end" is rejected as a modifier of "scaffold", since its implicit object referentis the scaffold.
This rejection on semantic grdunds (making reference to therelationships among objects in the model of the problem which has been constructed,sofar) will cause the parsing in which the prepositional phrase modifies "scaffold" ta berejected, so that the prepositiopal phrase will eventually be interpreted as a LOCmodifier d the verb "stands".
In the case "a boy 3 ft from one end" (PT), the locationmodifier is accepted since different objects are referenced by the head and objectphrases.FROM (without a measurement phrase preceding it) modifies a verb as aCASEARG, as  in "supported from the wall" (P8), or a LOC, as in "From end ( A )  aweight of 2500 nt is hung" (P15).
FROM2 (preceded by a measurement phrase) alwaysspecifies a LOC; the measureme~lt phrase may be a question phrase, a8 in "how far fromthe center" (P20).
If the object of FROM2 specifies a physob rather than a location on aRELPOBJ (an object on which relative positions are defined), a a  appropriate object forthe location to be on must be found.
This is done by finding an attachment pointbetween the specified object and a RELPOBJ; thus, "0.5 m from Paul" (P ly)  specifies alocation on the pole Paul is carrying which is 0.5 m from the point of attachmentbetween Paul and the pole.
The semantic routine for FROM2 must interpret the givenobject (a physob) as  a n  object of the desired type (a location on a different physob of aparticular type),PETWEEN occurs only once in our problems: "on a pole between them"(P17).
When it connects a single physob and two physobs, as  in this case, BETWEEN isinterpreted to mean that the first object is attached to  (.he other two a t  the "usual"places for the object (in this case, the ends of the pole).A T  always specifies a lo~at ion,  which may be a question phrase, as in "atwhat point" (P7).IN specifies either a location, as  in "stand in the center", or an attribute ofan object, as in "the tension in each rope" (P5).
In the latter case, the SFRAME of thehead noun phrase is set to ATTROF and its SEMOBJ is set to the referent of the objectnoun phrase.
The same semantics are used for sense-meaning 5 of OF, < attribute> OF< object> , and for one sense-meaning of ON.WITH may be used to connect a n  object with an attribute and value, as in ' 'aspring with a constant of 40 Iblft" (PI), or to connect a second participant in arelationship with the relationship, as  in "an angle of 60 deg with the horizontal" (P4).The latter sense-meaning is frequently used in English to define the participants in arelationship, usually using the verbs "have" and "make".There are five sense-meanings of ON which are recognized by the program:1.
< physob> on < loc> the rope on the left end (P4)2.
< attribute> on < physob> the tension on each of the ropes (P3)3.
< action> on < physob> the forces on the supports (P6)4.
< verb> on < physob> stands on the scaffold (P3)5.
< verb> on < loc> placed on the edge of a block (P14)Sense-meanings 1 and 5 are processed as LOC modifiers; meaning 2 isconverted to an ATTROF SFRAME; nleaning 4 is converted to a CASEARG modifier.Meaning 3 is converted to the SFRAME ACTON, with the referent of the object nounphrase as  its SEMOBJ.4.3.3 Definition and Translation of PrepositionsOut of curiosity, the sense-meaning classificatior~s for the preposition OF(which had the most sense-meanings of any in the program) were checked against thedefinitions given for OF in several dictionaries.
The agreement with the dictionarydefinitions was very poor.
Often, several of our classes would fit in a single dictionaryclass, or one of our classes would fit in several dictionary classes.
Prepositions are ofcourse hard to define, and native speakers of a language rarely need to look them up ina dictionary.
However, in translating from one natural language to another (whetherdone by a human or by a machine), the correct translation of prepositional phrases is adifficult problem.
For example, the preposition OF can be translated into about a dozendifferent prepositions in German; some uses of OF are translated into the genitive caseor other constructions which do not use prepositions.
It seems plausible thatdiscrimination nets similar to those used in our preposition semantic routines might beused to discriminate preposition sense-meanings for machine translation.
Hopefully,sense-meaning classes could be found such that all usages of a preposition which fallwithin each class could be acceptably translated into the same form in the targetlanguage.4.4 Referent IdentificationReferent Identification is the process of associating the phrases in a sentencewith the objects and relationships they refer to (explicitly or implicitly) ih the reader'smodel of the world.
Such a process involves a number of possible steps.
Candidatereferents must be found.
In  some cases the candidates will be identified by the sameword used in the sentence, or will be members of the same class which can be matchedtogether (e.g., "Paul ' and "boy", both of which are members of the class PERSON withthe restriction (SEX MALE)).
In other cases, the phrase in the sentence identifies thecandidates implicitly by identifying their relationships or attributes.
(For example, in(P17) the word "load" refers to a sack which is being carried on a pole.)
In such a case,the candidate can be considwed a n  instance of the phrase in the sentence in itsparticular instantiation, but not in general.
If there are no candidates (or if there arenot enough), a referent must be created and added to the model.
If there are severalcandidates, it may be necessary to select a particular one, either arblitrariiy or based onmodifiers of the phrase in the sentence.
If modifiers are used, problem solving may berequired to determine which of the candidates satisfies the modifiers.
Once thereferent(s) of the phrase have been identified, modifiers of the phrase must be processedto  add information t o  the referent as appropriate.ISAAC contains programs to identify three types of referents: Physicalentities (objects and non-material physical entities such a s  forces), locations, andattschments.
These referent identification programs are described below.4.4.1 Identifying Physical Entity ReferentsPhysical entity referents are identified by the function IDRFNT.
Sf therefe~ent  was previously identified, it is retrieved from the noun phrase token's propertylist.
Okherwise, the referent is identified using the function PHYSNP and put on thgtok~n's  property list under the indicator RFNT.
(The "referent" is a list of pointers toeach of the objects or relations denoted by the noun phqase.)
If the noun phrase&compound, the referent of each component noun phrase is determined, and theconcatenation of all the referents is used as  the referent of the compound.A flowchart of PHYSNP is shown in Figure 4.1.
The first step in identifyingthe referent is to find the existing objects in the world model to which the  noun phrasemight refer.
(If the dcternliner is indefiilito, it is assumed that a new object is bringreferred to, and this step is bypassed.)
The list of esisting object& is sea~ched first forobjects with the satne token word ns the noun phrtlse.
ant1 then for ot~j,jr~lts \vhosr tokenwords are synonyms of the token word of  the noun phrase.
I f  no cnndid~tvs are foutld byeither of these searches, n semantic routine associated with the nourl phrase token wordis executed (if available) to see if there is a suitablereferent for that \yard in  the tncldr.1.Such a semantic routine allows the noun phrltse "the load" in (PIS) to be mntched tothe object whose toke11 word is "snck" The referent semantic r o u t i ~ ~ e  for "load" selectsan object which is a physical entity, is not R person, is supported by something, and c to~snot support anything itself.
The  semantic routine for "support" selects the appropriatenumber of  objects which all support the same objwt.
If candidate objects are found byany of these searches, they are subjected to further testing beg i~~r~ ing  at the floivchartlabel (B) (page 2 of Figure 4.1).If no candidate objects are found, or if all candidates are rejected onsemaatic grounds, new referent objects must be created.
The number of objects to becreated is set equal to the QTY (quantity) attribute of the noun phrase if specified (as in"two boys" (P20)), to two if the noun phrase is plural and not compound, to the numberof locations if there is a locatiorl modifier (as  in "a pier at each end" (P13)), or to oneotherwise.
The proper number of objects is then created using the function MAKENT.In most cases, MAKENT simply creates a GENSYM atom, sets its tokenword appropriately, and adds it to the libt of created objects.
Provisio~~ is made,however, for special semantic routines to  create referents for particular words.
Aseesaw, for example, is not a single object, btit E\ rigid plank pivoted at  its center.
Thesemantic routine to make a referent for "seesaw" creates both objects and specifies theirattachment.
Similarly, an equilibrant is a force which is applied to a rigid body toproduce equilibrium.
The semantic routine to create a referent for "equilibrant" createsa force, finds a n  appropriate rigid body, and specifies the attachment of the force to therigid body at an unknown position;When the refererits of the ,noun phrase have finally been determined orcreated, the function DOMOUS is called to execute the nlodifier semantics for each ofthe modifiers which remain on the noun phrase token.
Modifier semantics is discussedin a later section.The second page of Figure 4.1 shows the tests which are performed oncandidate referents for a noun phrase in order to reject those candidates which areclearly inappropriate on semantic grounds and to select the proper candidate(s) fromthose which remain.
First, each candidate is subjected to RSTRTEST (restriction test)and NAMETEST.
RSTRTEST requires that if the candidate and the noun phrase haveRESTRKT modifiers with the same indicator, the restriction values must be equal.Thus, " ~ a u i "  and "boy", both of which have thefmodifier (RESTRICT (SEX MALE)),would match, while "Paul" and "girl" would not.
NAMETEST requires that if boththe candidate and the noun phrase token have names, the names must match.After any candidates which fail RSTRTEST or NAMETEST have beenremoved, thearemailling candidates ace examined to see if they constitute the propernumber of referents.
If there is  onry one candidate, if the quantifier "each" is present, ifthe number of candidates matches the QTY (quantity) of the noun phrase, or if the nounphrase is plural and there are two candidates, then the existing set of candidates isaccepted without further tests.
If a determiner adjective is present, the corresponaingcandidate is picked: the first for "one" or "first", or the second for "other" or "sepond".Otherwise, the candidates are tested against modifiers of the noun phrase.
If acandidate is found which has a matching modifier (e.g., both have the modifier(WEIGHT 125 LB)), that candidate is selected.
If a candidate has a rqismatchingmodifier (e.g., (WEIGHT 150 LB)), that candidate is removed from the list ofpossibilities.
Some modifiers, such as location modifiers, may have special semanticroutines fbr selecting candidates.
A candidate is selected by the location semanticroutine Bif the location referent of the location modifier is a member of one of theattachment relations of the candidate.
Thus, "the rope on the left end" (P4) will selectthe rope which is attached to the left Bnd of the bar.
If multiple candidates remain afterall the modifiers have been tested, the first one is selected arbitrarily.Inl some cases, the number of referents created for a noun phrase is notenough when the context of the noun phrase is considered; in such cases, the functionMORERFN?
may be called to create additional referents.
For example, "the pier a teach end of the bridge" (P18) will cmse two "pier" objects to be created because of thetwo locations in the location modifier generated by the prepositional phrases.
However,in "a plank .
.
.
.
supported at  each end by a stepladder" (P19), the locatian modifier isattached to the verb phrase, so that initially only a single "stepladder" referent iscreated.
The verb semantics for SUPPORT, however, requlres a separate supportingobject for each specified location, so that MORERFNT will be called to make a second"stepladder" referent.4.4.2 Identifying Location ReferentsThere are two primary functions involved in the identification of locationreferents, IDLOC and LOCNP.
IDLOC identifies a location given the object to which thelocation is relative, the location name, a n  optional SELECT modifier, and an optionallist of location frames to be excluded from the selection process.
For example, thephrase "the left end of the lever" would result in a call to IDLOC with the referentobject for "the lever", the location name "END'', the SELECT modifier "LEFT", anda null exclusio~l list as~arguments.
IDLOC is used both by iilternnl pimcesses R I I ~  byLOCNP*LOCNP identifies the locqtion(s) referred to by a noun phrase.
$' 1 1 1 ~  alocatioll may be specified by a wide variety of syntactic forms, LOCNP lnust identify theform of the t ~ a u n  phrase and the features of the lor~t io l l  which arq specifietl.
Thesefeatures a re  collected, and missing features a re  filled ill by inaking inferences; finally,IDLOC is called to identify the location referents.
'I'hus.
LOCNP serves as an  interfacefunction to collect the nrguments for IDLOC tltld put tlletll into a standard form.IDLOC and LOCNP are described in detail \)elow.A flowchart of IDLOC is shown in Figure 4.2.
IDLOC first examines all theexisting locations on the specified object to see if one of them is suitable.
An existinglocation is rejected if it is a member of the excluded locations list, if it has the wronglocation name, or if it has a relative positio~l (displacement) from the named position.
Ifthe location passes these tests, it is examined for the specified SELECT value.
In mostcases, the SELECT semantics consists of a test for a n  identical SELECT modifier (e.g.,RIGHT or LEFT).
In some cases, however, a special semantic routine must be used totest the world model and determine whether a location meets the selection criterion.
T ofind "the heavy end" (P12), for example, it is necessary to esamine the object frame forthe object involved; the "heavy" end is the one which is closest to the center of gravity ofthe object.
Which end is the "heavy" one could be changed by changing the numericvalue of either the length of the bar or the distance from one end of the center of gravity,while leaving all the English words the same.
Thus, numerical problem solving by aspecialist program, based on the particular values specified for certain parameters, isrequired to  determine the proper location referent.If no SELECT parameter is specified to IDLOC, or if the object being-examined has  no SELECT modifier, the object is saved as  a second choice in case abetter candidate is not found.
Thus, if a SELECT value of LEFT is specifitxi, a l l  thelocations on the object with the proper location name (e.g., END) will be examined for aSELECT LEFT modifier.
If none is found, a location with no SELECT modifier will bechosen; when the modifiers of the noun phrase are processed, the select value will beadded to that  location frame.In addition to its use by LOCNP, IDLOC is used internally by semanticroutines to identify particular locations on objects.
For example, when a referent objectfor "seesaw" is created, IDLOC is called to create a location frame for the center of thenewly created seesaw plank; this location is then used in specifying the at tachme~lt  ofthe plank to the pivot which is created.LOCNP identifies the referent(s) of a location noun phrase; such a locationmay be denoted in many different ways.
If the location has  a name, the name alone maybe used (as in "80 cm from (A)" (PG)); the ol~ject o which the location is relative lnhy ormay not be named ("the left end of the lever" or simply "the left end"); a physicnlobject name may be used to specify n location, since every physical object occupies aposition in space.Most of the function LOCNP co~lsists of code to make the 'inferet~cesand collect the argutnents.needed t o  identify a location when the location is dci~oted byany of the noun phrase forms mentioned above.A flowchart of 1,OCNP is shown in Figure 4.3.
If the referent of the nounphrase is known, it is returned a t  once.
Otherwise, a series of tests is made to determinethe type of location noun phrase.
If n location is specified by name, the existing locationframes are  searched for a location with tha t  ~-rame.
When the correct location is found, itis saved on the noun phrase token under the indicator KFNT, and the functionDOMODS is called to process any modifiers of the noun phrase.
If the noun phrase isalready marked as being a LOCPART SFRAME, the object to which the location isrelative is already known; this will be the case if a modifier of the location noun phrasespecifies the object, as  in "the end of the lever" or "its left end".
In such cases, LOCNPtransfers directly to the label "B" (page 2 of Figure 4.3).
If a location is named withouta n  object (as  in "one end"), it is necessary to find a n  appropriate object.
This is done byexamining the GEOMODEL (geometric model) of each object in the model of theproblem until an object for which the location name is appropriate has been found.Once the appropriate object for the location has been inferred, the noun phrase token isconverted to a LOCPART SFRAME, and control is transferred to label "B".
If tfienoun phrase names a physical object or person, IDRFNT is called to identify thephysical object referent.
If the object to which the location is relative is specified in thecall to  LOCNP and is different from the object named by the noun phrase, a search ismade for a location at  which the named object is attached to the desired object; thus, in"0.5 m from Paul" (P17), which specifies a location on a pole which Paul is carrying,"Paul" is interpreted as a location on the pole by finding the point on the pole wherePaul  is attached to it.
If the  desired object is unspecified, a location is made for thedefault lacation of the  named object.At label "B" of the flowchart, where LOCPART SFRAMEs are processed, atest is made ?0 see if the noun phrase is plural or modified by the quantifier EACH, a s  in"its ends" or "each end".
If sa.
the number of such locations is gotten from theGEOMODEL of the object, and that number of locations is identified by calls toIDLOC.
Thus, "wch end" (P3), referring to a scaffold, will cause two "end" locationframes to  be generated.
If the noun phrase is singular, IDLOC is called to identify asingle location referent.
If a location name is specified, the location found is required topass NAMETEST, having either the correct name or no name.
Once the proper referentP HD Is a LOCPART SFWIEHD plural  Get  t h e  number of c h i 3tvpe of l o c a t ~ o n  forchis objectIDLOCI d e n t i f y  locat ionreferentIdent~fv propernumber o f  locationsFigure 4.3 (page 2)has been found, control is passed to the label "H" to save the referent and processmodifers of the noun phrase.4.4.3 Attachment IdentificationAn attachment relationship among two or more objects is identified by thefunction IDATT.
Attachment relations are not the direct referents of phrases in asentence, but are defined by verb semantic routines or modifier semantic routines.
Theargument of IDATT is a paired list of objects and locations on the objects; one memberof each pair may be nil.
IDATT identifies an attachment frame which specifies theattachment of all the objects in the list; if no such attachment frame exists, one iscreated, along with links between it and the objects involved.
(The structure ofattachments and other frames is described in Appendix B.)
If an existing attachmentwhich matches the 1is t .
i~ found and the list contains locations which were previouslyunspecified, the locations are put into the existing attachment frame.
Thus, in casessuch asA painter .
.
stands on a plank .
.
.If he stands 1.0 m from one end of ?he plank .
.
.
(P19),the second attachment will be identified with the earlier one and will cause the locationon  the plank to be added to the attachment frame.
The order i~ which theobjectllocation pairs are specified in the call to IDATT is unimportant.A second parameter in the  call to IDATT is the type of attachment:CONTACT (as in the above example) or PINJOINT.
The type of attachment is not usedby IDATT, but is saved with the attachment frame for later use.
The interaction ofobjects a t  an attachment point may depend on the type of attachment.
A CONTACTattachment with a "smooth" surface, for example, implies that the force exerted by thesurface is nonnegative and perpendicular to the surface.
A PINJOINT att,achment maytransmit a force in any direction, but may not transmit a torque.
Although other types ofattachments could be used, CONTACT and PINJOINT are the only ones used by theprogram in its present form.4.5 Modifier SemanticsModifiers of noun phrases are savedi after some preliminary processing(Section 4.2), on the property list of the noun phrase token under the indicator MODS.After the referent of the noun phrase has been determined, the semantic routines.
ofthese saved modifiers are executed so that  the appropriate changes may be made to thereferent of the noun phrase.
(Some modifiers, which are used in selecting the proper.referent, are deleted before this stage is reached.
)Modifier semantic processing is controlled by the driver function DOMODS,which calls PUTMODR for each modifier.. PUTMODR (which is also used for modifierprocessing by some verb semantic routines) transfers the modifier to the property list ofeach referent, or executes a special semantic routihe if there is one associated with themodifier.
Thus, in simple cases such as "a 150 lb man", the modifier (WEIGHT 150LB) generated from the adjective phrase is transferred to the referent's property list asthe value (150 LB) under the indicator WEIGHT.
In other cases, semantic routines maymake inferences from modifiers, e.g., that a n  object which is at a location on anotherobject is attached to the other object at that location.RESTRICT modifiers are cotlcatenntcd and y laced on the referent objectunder the indicator RESTRICT; this allows an object to have multiple RESTRICTmodifiers, which are used in determining 110~11 phrase referents.Measurement modifiers are transferred directly to the property list of thereferent.
In  the process, the measurement units for each type 6f measurement are savedfor use in answer generation.
I t  would be easy to modify the measurement modifiersemantic routine to allow differing units (e.g., feet and meters) to be used in the sameprotilem.NAME modifiers are processed in different ways depending on the type ofname and the type of object which is named.
Simple names are transferred directly tothe property list of the named object.
Geometric names which modify locations aredistributed to the named locations.
I-f geometric names are assigned to a physical object,as in "a uniform bar (A  B)" (P6), location referents are created for the appropriatelocations on the object (in this case the ends of the bar) as determined by the object'sGEOMODEL, and the geometric names are assigned t o  the location referents.An APART modifier gives the distance between twb' locations, as in "thehinges of a door .
.
.
are 12 ft apart" (P9).
This modifier not only gives the distancebetween the two locations, but also implicitly determines the size of the object if the twolocations are on the same object.
In the above case, for example, we can infer that thedoor is at least 12 f t  tall.
The semantic routine for APART modifiers consults theGEOMODEL of the object, calculates the overall size dimension which would give thespecified distance between the two points, and assigns that size to the object.In our set of physics problems, a location modifier of a noun phrase alwaysimplies that  the referent object is attached to something a t  that location, as in "anautomobile .
.
.
which, is 30.0 ft from one end of the bridge" (P18).
The modifiersemantics routine for location modifiers calls IDATT to define the attachment.
In  alarger system which handled a wider range 6f problems, some additional semantic testswould be needed to determine whether an attachment was actually implied by thelocation madifier.4.6 Verb SemanticsThe semantic functions performed by verbs are very diverse.
Some verbs (forexample, certain sense-meanings oE the verbs "is'', "have", and "make") serve only asfunction words which c o n ~ ~ e c t  o her phrases; the semantics of such verbs residesprimarily in the phrases they connect.
Other verbs (e.g., "need" or "wish") intrdduceverb phrases to which they pass some of their case arguments.
Some verbs carry casearguments and other inferences to be used with their "underlying*' verbs; for e x m p k ,"stand on .
.
."
specifies an attachment by contact between the feet of the subject addthe object of "on", with the subject in a standing position.
A single verb may havemultiple sense-meanings; as  in the case of prepositions, we found that discrilnit~atio~lnet tests based on rough semantic classifications 61 the case arguments of the verb weresufficient to differentiate the sense-meanings.In this section, we will describe the semantic functions for a number of verbsas  they are implemented in the program.
In the cases where a verb appearedinfrequently in the s a m ~ l e  problems, the verb semantic routines handle only the limitedsense-meanings necessary for those cases; often, there are not many error checks to keepthe program from going astray if it were presented with different cases.
Some of the verbsemantic routines handle a number of variations in the types of their case arguments; itseems likely that general rules for handling different types of arguments which wouldbe applicable to classes of similar verbs might be found.
This would be an interestingarea for further research.The execution of a verb semantic routine is initiated by EXVBSEM, which iscalled when a clause or dependent clause has been parsed.
'EXVBSEM executes thesemantic routines for any prepositional phrases or adverbs which modify the verbi Itthen binds some of the case arguments of the verb (and their referents) to globalvariables so that they will be easily accessible, and calls the semantic functionassociated with the main verb of the verb phrase.4.6.1 Semantics of the Verb "BE"There are seven sense-meanings of the verb "BE" which are recognized bythe program; the sense-meaning classes are listed with examples below.1.
THERE BE < physob> < l o o  At @)...there is a weight (P15)2.
< physob> BE < loc> a man is 10 ft from the top (P8)3.
< physob> BE < adj  phrase> the door is 3 ft wide (P9)4. c attrof> BE < measurement> the weight of the lever is 8 lb (PI)5.
< attrof> BE WHAT what is the weight of the bar (P4)6.
< locpart> BE < lot> its center of gravity is 6.0 ft from one end (PI 1 )7.
< subj> BE TO < verb phrase> the bar is to be supported ...( P6)These sense-meanings are easily separated by a set of discrimination nettests, most of the sernantic classes being tested a t  this point are SFRAME types, so thatany of the syntactic forms which result in the creation of a particular SFRAME will beaccepted.
Once the sense-meanings have been separated into these classifications, wefind happily that most of the semantics has already been done: it is only necessary topass the arguments of the ver,b to routines which were written to do the same semanticsfor different syntactic forms.
Sense-meaning 1 is changed to the same form ns 2; IDATTis called for both cases to define an attachment of the object a t  the location specified.For sense-meanings 3 and 4, PUTMODR is calleil to esecute'the semantics of themodifier for the referent of the object involved.
For sense-meaning 6, the argume~lt isconverted to arguments for the question routine WHATIS; WHATIS is expiained in qlater section.
For sense-meaning 6, the location is saved on the property list of the objectreferent using the location name as the indicator.
For sense-meaning 7, the functionSUBSTINF is called to substitute the subject of the verb as the syntactic subject of theinfinitive verb phrase and execute its verb semantics.
Thus, in "the bar is to besupported" (P6), the subject "the bar" is substituted as  the syntactic subject of thepassive verb phrase, so that the referent of "the bar" becomes the semantic object of theverb "support".4.6.2 Semantics of the Verb "SUPPORT"Six sense-meaning classes of the verb "SUPPORT" are recognized by theprogram; these are listed with examples below.1.
< physob> SUPPORT < physob> the lever is supported by a spring (PI)2.
< physob> SUPPORT < N the boy ... supports '6 as much as the man (P2:times > AS MUCH AS < physobs3.
< physob> SUPPORT WHAT what load does each pier support (P13)c force>4.
< nil> SUPPORT < physob> a beam ... is supported dt both ends (PIG)5. c physob> SUPPORT < locpart> the top of the ladder is supported from the wall bya horizontal rope (P8)6.
< physob> SUPPORT < a t t r o b  the weight of the door is supported by the upperhinge (P9)It might be argued that these are not distinct sense meanings, but rabher sixdifferent ways of specifyiflg the arguments for a single sense-meaning.
Essentially, theverb SUPPORT (for our purposes) specifies an  attachment of two objects at  a particulanlocation on each object; a force is exerted on one object by the other object in order tosupport it.
For sense-meaning classes 1,4, and 5, the arguments of the verb are arrangedto serve a s  arguments for IDATT so that the attachment relation may be specified.
(Inthe case of sense-meaning 4, a pivot object is created to serve as  the unnamed supportingobject.)
In  the remaining sense-meaning classes (2.
3, and 6), the force exerted in theattachment relation is referenced.
Such a force is identified by the function IDFORCE,which creates variables for the force vector and adds them to the attachmefit relation ifnecess-ary.
for sense-meaning 2, < physob> SUPPORrr < N times> AS MUCH A S< physob> , equations are written which relate the two force vectors so that one is Ntimes as much as  the other.
For sense-meaning 6, < physob> SUPPORT < attrof> , anequation is written equating the force and the specified force attribute.
For sense-meaning 3, < physob> SUPPORT WHAT < force> , the force vector variables aremarked as  desired unknowns, and an entry is made to use the force vector values as  areply.
(The latter opera t io~~s  are discussed in more detail in the section on questionsemantics.
)4.6.3 Semantics of Other VerbsVerbs such a s  WEIGH and STRETCH express attributes in verbal form.T h e  semantic routines for these verbs call the function ATTRVBSEM with theappropriate case argument of the verb (subject for WEIGH, object for STRETCH)specified as  the object which is modified.
ATTRVBSEM uses the attribute associatedwith the verb to make a modifier, whose semantics are executed by PUTMODR.
( In  thecase of a question, the case argument and attribute are used as parameters for thefunction WHATIS.)
Thus, a semantic transformation is used to transform the verbalform into a modifier form for which the semantics already exists.
The forms "a manweighs 150 lb", "a 150 lb man", and "the weight of a man is 150 lb" are all reduced toan identical "semantic deep structure", which cotlsists of the referent object for "aman" and the modifier (WEIGHT 150 LB), by the time the semantics of the modifierare to be executed.
A single modifier semantic routine performs the final semanticoperations for all three cases.In addition to the verb SUPPORT, the verbs REST, PIN, BALANCE, SIT,HANG, CARRY, ATTACH, STAND, LIFT, and EXERT can all be used to specifyattachment relations.
S IT  and STAND imply that particular locations on the personwho is sitting or standing are involved in the attachment, and that the attachment is oftype CONTACT.
(These verbs could also determine the person's posture for the picture-making programs, but that  is not done in the present system.)
A number of the verbsimply that one of the objects iil the attachment relation supports the other.
Thesesupport relations are marked by SUPPORT and SUPPORTBY links among the objects;they are used in later inferences, such as  inferring whether a person shoul'd be modeledas a pivot or a s  a weight by the problem solver.
The verb PIN implies (as  used in theseproblems) a pivot object which must be created as the other object for the attachmentrelation.
CARRY, if used with an instrument, implies that  the subject, is attached to theinstrument and that  the object i5 attached to and.
support etl hy the instrument, as in"Paul and Henry carry a sack .
, on pole between them" (P17).The verbs WISH NEI':D. w~ul REQCIIIIE nre used in the sample prohlemswith infinitive verb phrase objects, as ill "two boys .
.
.
wish to btalance on n seesaw"(P20).
For our purposes, the "modal" il~formatioil provided by these verbs can  beignored.
The  verb seloanti6 routines far these verbs call the function SUHSTINF tosubstitute the appropllinte argument as the syntactic subject of the infinitive verb phraseand execute its verb se~nnntics.
The  above example is processed as if it were simply "twoboys balance on a seesaw".HAVE appears with only one sense-mennit~g, < physob> HAVE< locpart> < loc> as in "a bar .
.
.
has its center of gravity 1.5 m from the heavyend" (P4).
The  location is put on the property list of the subject referent using theLOCPART name as  the indicator This sense-meaning is similar to sense-meaning (i ofthe verb BE, < locpart> BE < loc> , escept that  the arguments are in a different order.MAKE is used with a relation name a s  an object, as  in "the rope .
.
.
makesa n  angle of 45 deg with the horizontal" (P4).
In such cases, the semantics is determinedprimarily by the relation involved (in this case, "angle").
The verb semantic routine forMAKE calls the semantic routine for the relation, passing to it the arguments of theverb.
The semantic routine for "angle" creates a relative rotation modifier and attachesit to  the former subject referent.
The ambiguity of the direction of rotation is maintainedby the relative rotation modifier; later,, absolute rotations are chosen (based onsymmetry considerations) to provide a plausible interpretation of the problem.FIND, CALCULATE, COMPUTE, and DETERMINE are &ll handled bya common semantic routine.
If the object of the verb is an ATTROF SFRAME.
as in"find the tension in each rope" (P5), the object and attribute are used as argumrlts  forthe question routine WHATIS.
If the object of the verb is an ACTON SFRAME, as in"compute the forces on the supports" (P6),  thp desired force is identified usingIDFOHCE.
The force variables are marked as  desired unknowns, and an entry is madeto print the value of the force as  a reply.4.7 Question SemanticsA question of the type found in our physics problems specifies two t-ypes ofinformation: a set of variables whose values rnust be found in order to answer thequestion, and the manner in which the information provided b y t h e  variablesois to bepresented in the answer.
For example, the sentence "T>etermine the magnitaide,direction, and point of application of the equilibrant" (P15) identifies the two variablesin the equilibrant's force vector and the distance variable in the equilibrant'sattachment relation as "desired unknowns", or variables whose values are required togenerate the answer.
In a(lditio11, the sentence specifies that the inagnitude anci-*r m3C;3hJ;%Icj'I:cF-a,azQ,st,c.-CI5r, +C,Q,--%L,;3raC*k",wsGC +mia- 4 2s- r.h V$2Ac.1.u3II)a5-+4 230&E=0I CI*E0)E:aM5.
Construction of Object Frames and the Geometric Model5.1 Introductiox~In reading the English problem statement of a physics problem, ISAACbuilds an internalmodel of the problem in which most of the objects nnd re la t i~ t l sh ip~in the problenl are ~qepresented.
A n ~ i n b e r  of steps are tlecessnry to ronrtert this t ~ l o t i ~ linto a model for which equations describing the i ~ ~ t c r a c t i o ~ ~ s  of the objects mn bewritten.
I t  is necessary to determine for each object thr.
canotlical object frame whichrepresents tht?
object in its particular instantintion in the problan for the purpose ofsolving a physics problem.
(The fr'amr representing 3. similar40bject in n differentsituation or for a different purpose might be a completely difftrent type of ct\i~onicalobject.)
A person, for example, might be modeled as n weight when sitting on a pole, oras a pivot when carrying it.
Qnce the ca11onic~L object frame has beerr selected, it isnecessary to make appropriate assumptions to fill in information qecessary for thecanonical frame which may not be present in the original problem statement.
A"weight" object must have a weight, although it heed not have a geometric size, ifi theweight is unspecified and is not a variable, a symbolic constant is created for it.
A"lever" object lieed not have a weight, but must have a length.Once the canonical object fraines Kave been selected for all the objects in themodel, a geometric model of the problem in which the locations and orientations of theobjects are made explicit must be constructed.,Since the sizes of some objects may besymbolic constants, the geometric locations for some points mby contain algebraicexpressions.
Problem solving by specialist programs (for example, solving a trianglegiven two sides and an angle) may be necessary in order to create a complete geometricmodel.After the geometric model of the problem has been created, the canonicalframes for each object are completed by filling in any necessary information thatremains unspecified.
The weight of an  object, for example, is modeled as a force exertedon the object a t  its center of gravity.
(The geornetric model is needed to determine thelocation of the center of gravity.)
Attachment relations are completed by creating forcevariables for each object involved in the attachment.
After all of these processes havebeen completed, the problem solver is called to write equations for the interactions ofthe objects and solve the resulting equation set.This chapter describes the processes of making canonical object frames,creating the geometric model of the problem, and completing the frames which werecreated.5.2 Making Canonical Object FramesA Canonical Object is a n  idealizatio~~ of an actual physical object whichrepresents its salient characteristics for a particular physics problem.
A pole, forexample, may be represented as a weightless rigid body; this i s  an  idealization of anactual pole, which has a finite weight and is not perfectly rigid.
The idealized canonicalobjects used in physics problems, such as weightless poles and frictioilless pulleys,rarely exist in the real world, but often give good approximations to the behavior ofreal-world objects.
The same object may be representecl in different problems bydifferent canonical object frames, depending on its relationship to other objects in eachproblem.
For each object in the problem, it is necessary to decide which canonical frameshould be used to represent it, to mark the object with the canonical frame type, and tofill in any information necessary for the frame which is missing.The function MFDRIVER calls the appropriate frame making routine foreach physical entity in the model of the problem.
Associated with each physical entitytoken word is a list of the frame-making routines which might be applicable to that- t-ypeof object; there may be a specialist routine for a particular object (as in the case of aperson) which decides which of several possible canonical object frames to use, or theremay be a list of more general routines Svhich can fail if they are inappropriate for- aparticular object in a particular context.
In  the present system, only a single frame-making routine is needed for each physical entity token.The functions REQUIREVAL and REQUIREVAR examine a n  object framefor a specified quantity; if the quantity is unspecified, they create a symbolic constant ora variable, respectively, to represent the missing quantity, and add the constant orvariable to the property list of the object frame atom.
A constant or variable is aGENGYM atom which is added to the list of objects in the model; it has property listvalues which tell the canonical object frame it is associated with, the quantity itmeasures (e.g., TENSION), the units (e.g., LB), and whether it is a constant or variable.There are seven canonical object types in the present system: LEVER,WEIGHT, SPRING, PIVOT, ROPE, SURFACE, and FORCE.
The simplest, thePIVOT and SURFACE frames, do not require any attributes.
A WEIGHT is requiredto have a weight; if absent, a constant is generated for it.
A SPRING or ROPE musthave a TENSION (variable); a SPRING must also have a STRETCH (variable) andCONSTANT (constant).
[The type of symbol generated for each quantity if it isunspecified is given in parentheses.]
A SPRING or ROPE must have a LENGTH(constant) only if it is attached to more than one object.
CKROTATION is called tocheck and disambiguate the orientation of a SPRING or ROPE, and DISAMLOCS iscalled to disambiguate locations; these functions are described below.
A FORCE frameis required to have a11 orientation; if.
absent, a n  orientat,ion of zero i s  assumed.
ALEVER (actually, rigid body) frame is required to have a IXNGTH (consttint).
If awidth is specified (as in the case of the door in (P9)), it is used in ~nnk i~ lg  the geometricsize vector; otherwise, n width of zero is assumeci.
Unless n LEVER is orientedvertically, it is required to  be attached a t  more than one point; if i t  is not, a PIVOTobject is created and attached to a point similar to the existing attachment point.
Thus,in a problem such as  "What force is needed to lift one end of [a beam]" (PI  0): n pi\rot iscreated to hold up the ather end of the beam while one end is being lifted.
IIISAMLOCSis called for a LEVER frame to disalnbiguate its locations.
The function MFPEIISON,which makes a frame for a PERSON, esnmines* the contest to determine whether tomodel the PERSON ns a WEIGHT or as (1 PIVOT.
If the PERSON is supported bysomething or supports somethi~lg, a WEIGHT or PIVOT model is used, respectively:Otherwise, the objects the person is attached to are examined to see whether theysupport something or are sup~or ted .
A person is assumed to be supported by an objectwhich is supported, and to support an object which supports something.
( A  function toinfer support relationships based on "usual" relationships and a more carefulexamination of the known relations of objects in the problem would not be too difficult,and would give correct answers in more general cases than the above heuristic canhandle,)CKROTATION examines a n  object to see if its orientation is specified by arelative rotation, as  in "the rope on the left end makes an angle of 45 degrees with thehorizontal" (P4).
If so, the relative rotation is oo~~vertecl to  an absolute rotation.
1x1addition, the objects to which the specified object is attached are examined to see if asimilar object is attached to one of them with a relative rotation; if so, the rotation ofthe other object is made absolute in a direction symmetrical to that  of the first object.This insures that if an object is hanging from two ropes, for example, the orientations ofthe ropes will be made symmetrical:Right WrongDISAMLOCS disambiguates locations by assigning specific locations on anobject to location frames which were originally specified by ambiguous location names.The ends of a bar, for example, may be specified by "one end .
.
.
the other end".
"theleft end .
.
: the other end", "ends ( A )  and (B)", and so forth.
These locations must beassigl~etl to specific locations on the object so that geometric positions can he computed.DISAMLOCS First assigns location names to locations which have specific SELECTmodifiers; the appropriate SELECT motlifiess and correspontling absolute locationllames are specified as part of the  GEOMOIIIGL of' the object.
thus,^ location with thename END and the modifier (SEI,ECT I,EFT) is assigned the absolute location nameLEFTEND.
After those locations which have specific SELI3CT values have beenassigned, the remainilig locations are given unique absolute location names; thus, "theother end'' would be given the absolute name RlGHTENL) if it appeared with "the leftend".
Absolote location names are propagated to locatiolls relative to  named locations(e.g., "2 m from the right end" (P4)) by the fut~ction RENAMELOC.5.3 Geometric Model ConstructionAfter a canonical object frame has been made for an object, its geolnetric sizeand (frequently) its absolute rotation are known, and absolute location names areassigned to all of its locations.
his information is sufficient to construct a geometricmodel of the problem in which absolute locations (coordinates which are numeric orcomposed of expressions involving constants or variables) are assigned to each objectand (implicitly) to all of its locations.
The geometric model is two-dimensional.
Theposition of an object is completely specified by three quantities: the coordinates of itsstarting poinF, its rotation relative to its standard orientation, and its geometric size.The GEOMODEL of the object gives the coordinates relative to the starting point f ~ reach named absolute location.
The geometric position of a named point on the objectcan be found by taking the coordinates of the point relative to the starting point, scalingthis vector by the geometric size, rotating it by the object's rotation, and adding theresulting vector to the geometric coordinates of the starting point.
This process isillustrated in Figure 5.1.
The vector V, which is the position of the point P relative to thestarting point S in the GEOMODEL of the object, is scaled m the appropriate geometricsize and rotated through the angle 6 to give the vector V'.
Adding V' to St, the geometricstarting point of the object in the problem, yields Pt, the coordinates of the pointcorresponding to the point P.Once a n  object has been added to the geometric model by specifying valuesfor its GSTART, GSIZE, and ROTN (rotation), the geometric coordinates for anylocation on the object may be obtained by calling the funtion EXECLOCA with thelocation frame as an  argument.
If the location specifies a position relative to a namedlocation, EXECLOCA calls itself to find the position of the named locatiotl.
A relativeposition vector of the appropriate size is created and added to the geometric position ofthe named point to give the position of the relative point.
The direction of the relativeposition vector is taken as  the direction of a vector from the named point toward thecenter of gravity of the object; if the named point is the center of gravity, the direction ofthe rotated x-axis of the object is used.Construction of the geometric model is performed by the function EUCLID.When EUCLID is initiated, every object has a geometric size (in terms of length units,e.g., meters) specified under the property list indicator GSIZE.
The GSIZE of eachobject is recomputed by dividing each component by the corresponding scale factor(stored under the indicator FRMSCL) for the GEOMODEL of the object.
After this hasbeen done, a relative position vector from the GEOMODEL can be multiplied by theobject's GSIZE to yield the corresponding vector in length units.The geometric model is built up by repeatedli adding objects which areattached to objects which are already part of the model.
(The first object is selectedarbitrarily and assigned a starting point of (0 O).)
In order to add the object to themodel, its rotation must be determined.
If the rotation is unspecified.
the futlctionTRITEST is called to test whether the abject is part of a triangle; if so, its rotation iscomputed by the function TRIANGLE.
Otherwise, the "tlormal" rotation for the object,or zero, is assumed.
Given the rotation and geometric size of the object, its starting pointfS S 'GEOMODEL of Object Object as it appears in problemFigure 5.1: Finding Relative Position on an Object<can be calculated from a point of attachment to an object which is already in the model.Tlle coordinates of the pomt are calculated for the object in the model, and for the newobject assuming a starting point of zero; subtracting the latter vector from the formeryields the starting point for the new object.
This is illustrated in Figure 5.2, where thenew object 02 is to be added to the model based on its attachment to the existing object01 a t  point P. The coordinates of the point P in the geometric model are computed, andthe vector V2 is calculated by finding the coordinates of P relative to 0 2  with 52assumed to bB zero.
Subtracting Vp from the geometric model coordinates of P gives thegeometric coordinates of the new starting point, Se.After the starting point of the new object has been determined, thecoordinates of all of its attachment points are computed and saved.
Any objects towhich it is attached which are not part of the model or on the waiting list are added tothe waiting list.
Finally, the next object from the waiting list is selected to be added tothe geometric model.
When the waiting list has been emptied, the model is complete.If three objects are attached to each other so that they form a triangle, it willgenerally be necessary to solve the triangle for one or more sides and angles in order toproperly construct the geometric model.
Since the triangle may be implicitly specified byspecifying the attachments of the three objects, it is necessary to test object,s which havea finite size to see if they are part of a triangle; this test is performed by the functionTRITEST.
Given a n  object A, TRITEST looks for objects B and C such that.A isattached to B and C and B is attached to C; if such a set of objects is found, TRITESTreturns a list of the three objects as its value.
This list may then be used as  the argumentC 1Figure 5.2: Calculating the Starting Point for a New Object4 *for the function TRIANG1,E.Given a list o f  three objects which are attached so that thev form a trinngle,the function TRIANGIX attempts to solve the triangle to find the unknowtl sidcs andangles.
Since a triangle is solvnble given three sidcs, two sides and a n  angle, or a sideand two angles, there are u number of ways in which the known data for a solvabletriangle may be present.
TRIANGLE first enumertltes the kno~\w data for the threeobjects in the order in which they are given.
The  funct,ion GDIST cnlculntes thegeometric distance bet~veen the two nttauhment points for each object.
The functionGANGLE conlputes the angle between two objects whose rotations are known.
(GANGLE as itnplerne~lted does not 11nndle all possible riiscs, but it would be fairlystraightforward to malte it do so.)
Lists are made of  the sides and angles, and a tsanskris made to the appropriate subsection based bn the types of known quantities.
(Only thesection for solvillg triangles for which two sides and a n  angle are  given is coded, butprovision is made for the other sections.)
The triangle is "normalized" by circularlyshifting the order of the sides so that  the single known quantity (e.g., the  known angle) isin the first position; this makes it relatively easy to test for the remaining unknown andsolve the .5 triangle.
After all unknowns have been found, the triangle is un-normalized byshifting back to the initial order of the objects, and the newly found information istransferred to the objects which comprise the triangle.
In the case of computed angles,the function DEFANG defines the rotation of the object based on the angle it makeswith other objects in the triangle.The geometry found in elementary physics problems is usually fairlv simple;the solution of a triangle is the ~ m s t  difficult geometric problem which is typicallyfound.
EUCLID and its subroutines solve such problems in a general way which isbased on legitimate geometric rules, rather than on "canned" forn~ulas which work forparticular problems but are not true in general.
Geometric programs like EUCLID {butmuch more sophisticated) might be of great benefit to scientists and engineers forAsolving problems in geometry, just as  symbolic manipulation packages are now used toaid in solving algebraic problems.Although the present program does not do so, it would be easy to generate ageometric diagram, similar to the "force diagrams" often found in physics texts, fromthe geometric model of the problem.
Such a diagram would be useful if a programsimilar to ISAAC were to be used for computer-assisted instruction in physics.5.4 Frame CompletionAfter the geometric model has been completed, the function CFDRIVER iscalled to complete the cauonical object frame for each object.
Since the canonical objectframe has  already been selected for each object, CFDRIVER simply calls the frame-completion routine associated with the canonical frame for each object.The primary operation performed during frame complctioh is the completioxlof attachment relations by associating appropriate force vectors for each object ~ v i t  11 theattachment frame.
In some cases, the geometric model is* requlred i n  comp~lti~lg theforce vectors.
The function CMPA'I'T, which is used for LEVER and PIVOrI' frames,associates a two-variable f ~ r c e  vector with each attachment for which the force vector isunspecified.
(A separate force vector is added to an attachment frame for each objectwhich is dttached there.)
The forces exerted by the object and t,hc geometljic position ofthe point a t  which each force is exerted are  collected and saved on the 111y)prrty list o fthe object under the indicator FORCES.
For a LEVER frame, the location of a PIVOTattached to it is noted if there is one.
The function MKWTFRC makes a weight f@>rec,exerted on the object a t  its center of gravity, for a lever ob,ject if it has a weight.In the case of a WEIGHT object, the weight of the object (which must existsince the frame creation routine requires it) i s m e d  to make a downward force vector.This vector is inserted directly into the attachment frame.In  the case of a spring (or rope), the force exerted by the spring is equal to thetension in the spring and directed from the end of the spring toward its center.
~ h ; s  lawis so "obvious" that it is almost never s t ~ t e d  in a physics text; nevertheless, it is wphysical law of the SPRING and ROPE canonical objects, and is necessary to solve theproblems.
The frame completion routine for SPRINGS and ROPES calculates the unitvwtor from each attachment point to the center of the object.
Each component of thehnit vector is mul.t.iplied by the tension, and the resulting force vector is put into theattachment frame.A FORCE may be specified as  a two-component force vector, or in magnitudeand direction form.
If the vector form is specified, it is used directly.
If the xnagnitudeand direction are used, they are .converted to vector form for use in the attachmentrelation.A SURFACE is assumed to be a "smooth" surface as  found in physics texts:that  is, it can only exert a force perpendicular to the surface.
The unit vectorperpendicular to the surface is calculated and multiplied by a single force variable togive the force veetor.Once the canonical object frame for each object has been completed, theproblem model is ready to be turned over to the problem solver.5.5 ConclusionThe processes of frame selection, geometric model construction, and framecompletion which were described in this chapter are relatively simple processes: yet.they are crucial for solving physics problems.
We shall argue that  selecting andcompleting canonical object frames is a primary skill which is taught in a physics class,that this skill is taught mostly by example rather than explicitly, and that  failure tolearn the skill from the examples is what causes people to  be "bad" a t  physics.6.
Problem SolvingProblem solving, a s  described in this chapter, is the process of writingequations which describe the interactions of objects according to well-known physicallaws, solving these equations for the deqired unknowns, and printing the answer in thedesired form.
Compared to the processes of' language understanding and frameconstruction which precede it, the problem solvix~g process seems very simple: it consistsmostly of elementary algGbra, which is well understood.6.1 Generation of EquationsSome equations may have been generated directly in Eesponse to statementsin the prablem, e.g.
"the man supports twice as much as the boy" (P7).
Any existingequations such as these are passed to the equation solver, SOLVEQ, a t  the beginning ofthe problem solving process.
The remaining equations are generated and solved by thefunctions ATTDRIVER and PSOLVER.ATTDRIVER writes equations for eqch attachment relation according tothe physical law that the sum of the x forces and the sum of the y forces must each bezero for a b ~ d y  in static equilibrium.
The x and y components of each force involved inthe attachment are added to two accumulators using the function SPLUS (symbolicPLUS);.two equations are then written setting each of the accumulators equal to zero,and the equations are used as arguments in calls to SOLVEQ.
These equations aregenerally quite simple, and result in a numeric value for a variable or a substitutionequation which allows one variable to be rewritten as a function of another.
Thefollowing equations from the set generated for (P4) are typical of the types of equationsgenerated by ATTDRIVER:(EQUALS 0 FORCE179)(EQUALS 0 (PLUS -100 FORCE180))(EQUALS 0 (PLUS (TIMES TENSION173 ,7071 ) FORCE175))The first two equations give numerical values for the variables, and the lastequation allows FORCE175 to be expressed a s  a function of TENSIONl'i3, thusreducing the number of active unknowns by one.The function PSOLVER calls the problem-solving functions which areassociated with some canonical object frames to write equations for objects of that t-yeand solve them.
The objects which have desired unknowns associated with them areselected first, followed by objects which involve other unknowns.
After a problem-solving function has been called for an  object, a test is made by TESTSOL to seewhether values have been found for all of the desired unknowns; if-so, PSOLVERreturns, without requiring that values be found for the other variables.
In  the presentsystem, there are problem-solving functions for SPRING and LEVER cauonical objects.SOLVESPRING generates a single equation for the spring law, which statesthat the tension on a spring is equal to the spring constant times the distance the springis stretched.
The other laws which apply to a spring, namely that the sum of the forcesexerted on it must be zero (in static equilibrium) and that  t h e  force exerted by the springis directed from the end*of the spring toward its center, are made true implicitly by theway the force vectors are generated by the frame completion routine for springs.SOLV$LEVER generates the three equations, which govern a rigid body instatic equilibrium, namely that the sums of forces (in the x and y directions) must bezerb and that the sum of moments on the body must be zero.
If a PIVOT object attachedto the LEVER was found by the frame completion routine for the LEVER, the pivotpoint is chosen as  the point around which moments are summed; otherwise, a pointwhose position is known and which has one or more unknown forces exerted there ischosen.The number of equations generated for a single problem is surprisinglylarge: between seven and thirteen equations per problem, with an average of about tenequations per problem.
For a reasonably skilled human problem solver, all of oursample problems can be solved using two equations except for (P4), which requiresthree.
This large discrepancy suggests that the human problem solver performs anumber of steps (which become largely subconscious with practice) to reduce thenumber of equations which must be written.
Some equations, such as  those involvinghorizontal forces in a problem where all the significant forces are vertical, are simplyignored.
Others, such as  our attachment equations, are eliminated by substitution ofvariables which is done mentally.
Since these processes are largely subconscious in askilled person, it may be difficult to teach them to a person who is unable to acquire theskill by watching the solution of example problems.
A program such as  ISAAC, whichmakes all of the steps explicit, might be useful for teaching physics to such persons.6.2 Equation SolvingThe equations which are generated to describe the interactions of objects inthe model of the problem are solved by a set of routines for simplifying expressions andsolving linear equations.
This small symbolic manipulation package is fairly primitivecompared to the state of the ar t  in symbolic manipulation.
Much more powerfulpackages exist, such as MACSYMA [Moses 741; a more powerful program for soJxringphysics problems could easily be interfaced to such a system (as was Charniak's CARPSprogram), allowing problems involving more complex mathematics to be solved.Equations are solved by the method of substitution, that  is, by expressingone variable as  a function of another variable and substituting this fur~ction for thevariable when it occurs in other equations.
Since this reduces the number of activevariables by one, the process can be repeated until a value is found for sollle variable,This value can then be substituted illto the f ~ ~ x ~ c t i o t ~ s  t  calculate the values of othervariables, and 80 forth until values have been calculated for all of the variables.
Thismethod is the one generally used by humans for solving simple equations.
For equationsas simple as  those generated for our sample problems, the method works well and isreasonably efficient; for more complex equations, other methods (such as Gaussianelimination) would be needed.Equations are written using the five functions SPLUS, SMINUS, SDIFF,STIMES, and SQUOT.
These functions perform some elementary simplifications ontheir arguments when possible; for example, (SPLUS 0 x) = x, where x is anyexpression.
If no simplification is possible, these functions construct a prefixsubexpression using the corresponding LISP function name.The function SIMPLIFY may be used to simplify an  expression (notnecessarily a n  equation) by operations such as  removing double negations, combiningconstant factors of a variable, and so forth.
SIMPLIFY is used in making the geometricmodel as well as in the problem solving process.
The function SIMVECT simplifies avector by callihg SIMPLIFY for each component.The function COPYSUB copies an  expression, substituting the VALUE ofeach variable (gotten from its property list) for the variable if the value is defined.
Sucha value may be either numeric value or a substitution function in terms of anothervariable.SOLVEFOR solves a n  equation for a given variable.
which should occuronly once in the equation.
This is easily done by finding a path from the root of the treerepresenting the equation to the desired variable.
Inverse operations are then generatedalong this path to bring the desired variable to the top.
For example, to solve theequation (EQUALS A (TIMES B C)) for C, we generate the inverse operationQUOTIENT to obtain (EQUALS C (QUOTIENT A B)).
A similar process is easilyapplied to an  arbitrarily large expression.The function LISTVC examines an expression and const'ructs a list of all thevariables and constants used in the expression and the number of times each symbolappears.
This list is used by SOLVEQ to guide the equation solving process.The function SETEQUAL is used to define the value of a variable based onan equation.
The equation is solved for the value of the variable using SOLVEFOR;this value is put on the variable's property list under the indicator VALUE.
The valueis then substituted in the value expression for each variable whose value is expressed asa function of the variable just defined; a list of all such variables is stored on theproperty list of the variable under the indicator USEDIN.
For each such variable,COPYSUB is used to copy its value, substituting the new value of the variable justdefined.
The resulting expression is made into an equation, and SETEQUAL is calledagain (recursively) to define the new value of the variable.
In this way, a new definitionof a variable is propagated to all the variables whose values are dependent on it.
Sincethe new definition of a variable may make some saved equations solvable, eachequation on the list EQUATIONS is copied using COPYSUB; S O L V ~ Q  is then calledto  solve the resulting equation.SOLVEQ attempts to solve an equation; if it succeeds, the results arepropagated to related equations and variables, which may lead to the solution ofadditional equations.
SOLVEQ first uses COPYSUB and SIMPLIFY to substitutevalues for any variables whose values are known or defined in terms of other variablesand simplify the resulting expression.
LISTVC is then called to list the number ofconstants and variables in the expression and the number of times each occurs.
If thereare more than two variables, the equation is considered temporarily unsolvable and isput on the EQUATIONS list.
If there is only one variable in the equation, SETEQUALis called to define the value of the variable based on the equation; SETEQUAL willpropagate the consequences of this definition, possibly causing SOLVEQ to be calledagain.
If the equation involves two variables, an attempt is made to solve for onevariable in terms of the other.
(If both variables occur more than once in the equation, itis saved on the EQUATIONS list).
After defining one variable as a function of the otherand adding it to the USEDIN list of the other, the new value of the variable ispropagated to all members of its USEDIN list, which is then set to NIL.
Thepropagation is done by using COPYSUB and SIMPLIFY on the value of each variableon the USEDIN list to substitute the value of the new variable, then adding the variableto  the USEDIN list of the other variable in the equation.
Thus, for example, if a weredefined in terms of b as  a = f(b) and b was then redefined as b = g(x), we wouldredefine a as  a = f(g($) and put both a and b on the USEDIN list for i . '
~ f  theaewlydefined variable is used in any of the equatibns on the EQUATIONS list, the new valueis substituted using COPYSUB, and SOLVEQ is called recursively to attempt to solvethe resulting equation.The time required to solve a set of equations varies, but typically is about onesecond (using interpreted LISP on a CDC 6600) for our sample problems.6.3 Answer GenerationOnce the values of the desired unknowns have been calculated, answergeneration is fairlyeasy.
The name of a n  answer-generation routine rind the object to beused as  its argument are saved (for each part of the answer) on the list SYSREPLY inresponse to the question asked in the problem statement.
The functiot~ PRTSOLevaluates each of the members of this list in turn, putting commas between thegenerated answers.PRTVAR prints the value of a variable and the w i t s  associated with it, Ifthe answer is an  expression which contains constants, the f~ilnction EXPLCON is calledto explain each constant.
EXPLCON gets the object with which the constant is;associated and the attribute which it measures from the constant's property list, andoutputs these in a standard format, e.g., "where 1 ENGTH'iG is the length of the pole''(P2).
EXPLCON is called by most of the answer generation routines if the answer is anexpression involving constants.PRTFV prints the two compo~lellts of a force vector in parerrtheses,separated by a comma.
PRTMAG and PRTDIR compute and print the magnitude anddirection, respectively, of a force vector.PRTLOC generates a description of a location; typically, a location which isthe object of a question will be represented as a point which is a certain distance from aknown point, with the distance an unknown.
PRTLOC pri~nts the distance from theknown point, then generates a description of it.
If the known point has a name, the nameis printed following the location name, as  in "end (A)"; if it has a meaningful SELECTmodifier, the modifier is printed with the location name, as in "tha heavy end".Otherwise, an attempt is made to find an  object which is attached a t  the known point; ifsuch an object is found, it is used to describe the location, as in "7.4 Et from the boy"(P7)*All of the answer generation functions comprise about two pages of LISPcode, compared to 44 pages of code for input parsing and semantics.
Languagegeneration to describe the answers to physics problems is a relatively easy task, sincethe "objects" to be described are so simple.
[Simmons and Slocum 721 describe amethod for generating fairly complex sentences using semantic networks and an ATNgrammar.7.
Picture ConstructionThe process of constructing a picture from the internal model of the problemis in many ways similar to the process of constructing the geometric model of theproblem; however, there are some significant differences.
While a WEIGHT object isrepresented as a point in the geometric model, it must be drawn a,t a reasonable size.
Asize must be chosen for each object whose size is a symbolic constant, and relativepusitions on the object must be scaled accordingly.
The size of the picture must be scaledto the space available for the drawing, independent of the size of the objects in theproblem.Construction of a picture is done in two stages.
First, a picture model isconstructed, specifying the position and size of each object.
From this model, globaloffsets and a scale factor are computed to properly scale and position the picture withirlthe drawing area.
Finally, picture generation functions are.
called to generate eachobject in the picture.7.1 Constructing the Picture ModelThe picture model for the problem is constructed by the function DIAGRAM.Each object in the picture is assigned a starting point and a size, which are stored underthe property list indicators STVAL and PSIZE, respectively.
The rotation, stored underthe indicator ROTN, is the same as for the geometric model.
A set of objects arranged ina picture is represented by a "picture frame", or PFRAME, consisting of a set ofminimum and maximum x and y values which bound all 6f the objects in the picture,and a list of the objects in the picture frame..The starting point value for each object isrelative to  its picture frame set.
Two picture frame sets niay be combined by specifyingthe coordinates relative to each of a point which is to be made common tcr both.
A newset of bounds is computed, and objects from one picture frame set are incorporated intothe oiher by adjusting their starting points and adding them to the object list of theother picture frame set.DIAGRAM first calls the function PICSCALE to determine the picturescaling factor for each object.
Some objects are scaled according to the value of a certainattribute: poles according to their length, weights according to their weight, springsaccording to their spring constant, and so forth.
If such an attribute is defined for anobject and the attribute has a numerical value, the attribute name and value are savedon the property list of the object under the indicator SIZEDET.
In addition, PICSCALEkeeps a list of the different attributes and the maximum value found for each attribute.This list and the saved SIZEDET value are used later to determine the scale factor tobe used for each object in the picture.
If R scaling attribute is not specified for an objector is not defined as a numeric value, a test is l~ lade  to see if there is n special Rinctidx~ todetermine the scaling factor for the object: such fut~ctiotls exist for FOIiCE i ~ n d  ri8idbody objects.
PSIZEFORCE computes the magnitude of t~ two-rompdnent forre vectorand returns this value as the scaling factor.
I11 additicln, it computes the rotation of theforce vector and storus this 011 the force object's property list under the indicator ROTN.PSIZERB is used to compute the scaling factor for rigid body objects, includillg bothSURFACE and LEVER objects.
The attachment points of the object are esamined.
Ifthe attachment goints have ntimcric geonletric posit ions, then the largest distance in thex or y directions between two att~chrnent points is used 8s a LENGTH srnlc factor.Thus, in the picture for (PX), the uilspecified length of the vertical wall is set equal to thedistance between the rope and ladder which are attached to it.
If numeric values are notavailable for the attach~nent points, but there are some numerical relative positions, theminimum distance from the center of gravity of the object to i t s  boundaries in the sdirection is made equal to the maximum relative position offset: this guarantees that allof the relative positions will be drawn within the area of the object in the picture.
Thus,in the picture for (P2O), the seesaw is made large emugh so that both boys are drawn asbeing on the seesaw, with their relative distances from the center in correct proportion.If neither of the above methods can be used, the rnaxi~num dimension of the dra\ving ofthe object is used as the scaling factor with the artificial attribute name CLENGTH.This will cause objects of unspecified size to be drawn at a size proportional to theunscaled size produced by their drawing programs.Once the picture scaling factors have been conlputed by PISCALE,DIAGRAM constructs the picture model in a manner similar to the way the geometricmodel is constructed by EUCLID.
An initial object.
is chosen arbitrarily to start thepicture.
Objects are added to the picture by combining a new object with the existingpicture a t  a point of attachment between the new object and an object already in thepicture.
Objects which are attached to the new object but are not in the picture areadded to the waiting list of objects to be added to the picture.
The subroutines which areused in performing this process are described below.MAKEPF is a function which makes a picture frame for a single object.
Inorder to do so, it must compute the drawing size to be used for the object and a set ofpicture frame boundaries which will completely enclose the drawing of the object,.
Someobjects, such as  a door or person, have special size computation routines; these are usedto compute the size for an object if they are defined.
If a SIZEDET attribute and valuewere found for the object, its size is scaled in proportion to the rnasimurll value foundfor that attribute in the problem.
(For some objects, such as WEIGHT objects, thepicture could be made more realistic by using a special function to make the picture sizeproportional to, say, the square root of the weight proportion.
This was done in a nearlier version of the program, but is not in the present version.)
If all else fails, thescale factor is set to one.
The size computation routine for a doorbcomputes separatescale factors for the height and width of the door.
The picture making function for adoor draws a square, but with separate scale factors for the x and y coordinates; thisallows a door to be drawn to scale for the specified width and height.
The sizecomputation routine for a person uses the SIZEDET value if it is available.
Otherwise,a test is made to see if the person has a RESTRICT YOUNG modifier; if so, the size isreduced slightly.
Thus, in (P2) the boy is drawn slightly smaller than the man.
If thesize of an object is defined in terms of length, tho scale factor between length and picturesite is computed and stored on the object's property list under the indicator PSCALE.The picture size (which is s vector, although in most cases only one component is used)is stored under the indicator PSIZE.
The initial picture frame is computed by scalingthe basic picture size (stored under the indicator FRMSCL in the GEOMODEL of theobject) by PSIZE; the minimum values and'starting point are defined by convention tobe (0 0).
i f  the object is rotated, its picture frame is recomputed by ROTPF.
This is doneby computing the positions of the corners of the picture frame after rotation, andcomputing a new .frame which encloses all of these points.
Tbis process is illustrated inFigure 7.1.
As the figure shows, the-rotated picture frame may be somewhat larger thanneeded to contain the object.
However, it is easily computed-in this manner, and iscertain to be large enough.
The only effect on the final drawing from a picture framewhich is too large is to make the drawing slightly smaller than it might have been.Figure 7.1: Computing Picture Frame for a Rotated Object> -After a picture frame has been made for an object by MAKEPF, DIAGRAMsearches the attachment rclutions of the object to find a pbint a t  which it is attached toan object which is al~*eildy in the picture.
Whrn such an attachment is found, PICTI,OCis called twice to find the position of the point of nttnchment on the new object relativeto its picture frame and the point of attachment on the other o\)ject relative to thc lurgcrpicture frame.
These two positions are then used in a rill1 to  COMPFHM to combine t hanew object's picture frarl-le into the total picture fra111~ which is being r\onstrwtr.d.Finally, objects which are att>ached to the new object c1nd are not ~ l r e ~ d y  it1 the pictureor on the waiting list are added to the waiting list.
After all the ub,iects on the waitinglist have been processed, DIAGRAM esits with the completed picture frame set as itsvalue.PICTLOC calculates the position of a point on an  object relative t o  theobject s picture frame.
When the geometric size of the object and the name of thelocation are specified, the position is calculated by simple vector operations as describedin section 5.3 and illustrated in Figure 5.1 for geometric positions.
If there is a relativeposition offset from a known location and the geometric size of the object is R symbolicconstant (as in (P2), where the weight is attached 0.75 times the length of the pole fromthe boy), PSIZERB will have made a CLENGTH size factor for the object.
When it doesso, PSIZERB also defines the VALUE of the length constant to be the same factor.Thus, by performing COPYSUB and SIMPLIFY on the relative position expression, thecorrect proportional length on the object in the diagram is obtained.
(If the relativeposition were a function of other constants, this procedure would fail, and the relativeposition would be ignored.
This does not happen in our sample problems.)
If no locationname is specified for the object, a default location must be found for the object's point ofattachment in the picture.
(This is not usually necessary in the geometric model, wheresuch an object is typically treated as a single point.)
The defaultn location for the objectmay be stored on the property list of its token word, or there may be a function tocompute it.
Such a function is provided for PERSON objects; this function selectsHANDS as  the default location if the person is modeled as a PIVOT object, or FEETotherwise.
(Some verbs, such as SIT and STAND, specify the location as  part of the verbsemantics, so that  a default location is not needed.
)COMPFRM combines two picture frame sets, given a point relative to eachpicture frame which is to be made a common point in the combined picture frame.
Aconstanttranslation vector is easily computed from the two givein points; by adding this.vector to the coocdiriates of each point in the second picture frame, the coordihates ofthe eonresponding point in the first picture frame (which will become the combinedframe) are obtained.
Since the position of each object is relative to its .starting point,only the starting point coordinates of the objects in the second picture frame need to berecomputedq.
A simple loop is used to  recompute thP starting p ~ i n t  of each objcct in thesecond picture frame and add it to the ohject set of the first picture frame.
The pictureboundaries are recomputed by clrlculati~lg the offset positions of the boundaries of  thesecond picture frame, then choosing boundaries for the combined set which e~\close bothof the component picture frames.
This process is illustrated in Figure 7.2, where theframe drawn with solid lines is the cot~~bined frame for the two smaller frames drawnwith dotted lines.
(The solid lines are drawn outside of the dotted lilies for clarity wherethey would be in the same place.
)Many of the functions used for constructing the picture model and drawingthe pictures are similar or identical to those used in (Simmons and Bennett-Novak 751.The picture frame concept used in constructing the picture model is so simple andobvious that  it probably is not new; it is described here for completeness.7.2 Drawing the DiagramThe completed picture frame set is passed as a n  argument to the functionDRAWPICS, which control$ the drawing of the picture.
The size of the picture frame inthe x and y directions is computed from the frame boundaries.
These size values areused in conjunction with the size of the available picture area to set the global constantGLOBALSIZE so that  the finished picture will occupy 0.9 of the available space alongits maximum dimension.
The frame boundaries and global size are used to compute anoffset base vector so that  the picture will be centered in the available area in eachdimension.
For each object which is to be drawn, DRAWPICS calculates the properoffsetstarting position, sets the initial position and heading, and calls the program todraw the object with the size a s  an argument.The functions used from LISP to  draw the pictures have a structure similarto the LOGO language of Papert [Papert 721.
The "turtle" concept of plotter commandsused in LOGO is convenient for drawing objects because an object can be drawn in anyorientation if the turtle is initially pointed in the right direction.Figure 7.2: Cohbining Two Picture FramesJ8.
Cox~clusionIn  the preceding chapters, we have described a particular pi*ograrn which iscapable of reading, understanding, solving, anti drnwirlg pictures of  a class of physicsproblems which are stated in English.
I n  this ~1111pt~'r, \YO shall exatnine themethodology of this research, some directions t'or future research \vl~ic'h are suggested bythis work, and- potential al)plic:\tintls of programs similiti* to this one.
Finally, \vupresent some data  on the progrn,m's sixe und execution time, and exanrille whatextensions would be necessary to handle ciddit ional problems.8.1 MetfiodologyThe  area of physics problems invol~ing rigid body statics is certainly a"micro-world", and a fairly sniall one a t  th t~ t ;  howevtlr, in the opinion of this authnr.
itis a fruitful one for research in computational linguistics.
The area is sufficiently --circumscribed to be tractable for progranlnling, but still involves a number ofinteresting problems-many more than a casual glance at the sample problems ivouldsuggest.
In some cases, the correct parsing of a sentence depends on the particularrelations of objects in the model of the problem, thu3 forcing the integration of syntax,semantics, and world knowledge in the parsing program.
The difficult problem ofreferent identification must be solved (though of course in a limited way) for bothphysical objects and locations.
Different sense-meanings of words (particularly verbsand prepositions)  nus st be disambiguated.
C;tnonical object frames must be selected torepresent objects in the model, and inferences nlust be niade to construct a corllylete andconsistent model.
Geometrical models of the probleln must be constructed both forsolving the problem and for drawing the picture.
Thus.
although the problem sol\ying isspecific to the area of physics problems, the process of understanding the Englishstatement of the problem involves a number of interesting sub-p~*ocesses which arelikely to be important in any language-understanding program.
The area of physicsproblems is a good one for investigating these sub-processes because there is a relativelyclear urlderstanding of what the result of understailding a physics problenl must consistof: a model of the  problem in which the attributes and relationships of objects arerepresented with sufficient specificity to allow equations to be written describ~ng theinteractions of the objects and to allow a diagram of the problem to be constructed.The twenty sanlple problems used to test the progrnrn were selected beforethe major version of the program was  written.
(When the program was almost complete,one problem which involved a great deal of worlcl.knowledge required only for thatproblem was deleted and replaced by another problem.)
Thus.
iil a sense.
the programwas written to solve twenty specific problems-not a very large number.
However.
wetrled to solve the pr6blr.m~ it1 a legitimate.
general way, using a lnitlimum of "tricks"We hope (but have not yet shown) that the program could be espanded considerablywithout rewriting very much of the existing code, and that it could be made to solvetwellty more problems of the same type with relatively little difficulty.
(Atlding theproblem which replaced the deleted one required only a semantic routine for (,nu word.
)The use of twenty preselected problems by several different authors actually niatle theprogram much more clifficult than it might have been.
Almost every problem had someidiosyncracy which required additional capabilities of the program or prevented a11 easytrick from being used in a superficially similar situatio~l in another p rd~ lem.
On theother hand, the diversity of  the problems led to the discovery of many interestingregularities which would have been missed if we had (say) selectcd problems that  anexisting program could solve or edited the problel~ls to make it easier otl the program.Thus, in a sense we are treating computational linguistics u s  an  e x p c r i ~ ~ ~ e l ~ t a l  science, inwhich the experimental data are existing examples of linguistic yerformuncr hycompetent native speakers, and in which the goal of the research is the production ofprogra~ns which can adequately understand the examples of language perfo14rnance.
Inthis author's opinion, this is a valuable approach.
Many interesting problems whichwould never have been noticed were made glaringly apparent when the program Sailedto work.
Likewise, many regularities were found bx suddenly rmlizing that  a subroutinealmost identical to the one needed for the current task was written earlier.
Thisapproach does'not replace theory, but rather lays the g r a ~ n d w o r k  for theories whichcan be powerful because they account for a large number ~f exarpples of l i~~guist icperformance.
Because a program such a s  this one deals with the whole process ofunderstanding language, it can serve as the basis of a more complete theory of language,rather than a theory which deals only with a narrow aspect such as syntax.8.2 Directions for Future ResltzarchIn this section, we will comment briefly on some interesting possibilities forfuture research which are suggested by some af the techniques used in this program.The SFRAME (semantic frame) concept.
in which a sernantirl interpretationis assigned to a phrase, inferences are made to fill in missing arguments of the semanticframe, and specialist routirles are associated with the frame to perform tasks associatedwith that  type of semantic object, is au  interesting one.
Only a few types of SFKAMEsare used in ISAAC; it would be ihteresting to see if this technique is useful forunderstanding language in other areas besides physics problems, and to investigate howthe use of SFRAMEs might be integrated into the parsing process.The process of referent identification is an important one for understandingvirtually all types of language.
The procedures used for referent identification byISAAC are fairly rudimentary, are specific to the area of physics problems, and dealonly witb extensionally specified referents.
This area deserves much more research todetermine rules for referent identification in wider contexts and ways to represent anduse intensionally specified referents.
(For example.
when identifying the phrase "the 8million people of New York", we would like to create an  intensional referent, rather76than creating 8 million PERSON referents.)
While a PLANNER theorem can be used asan intensional representation, it would be desirable to have a representation which ismore accessible QS a data object than a PLANNER theorem is.The concept of the cal~oniral object frame (due primarily to Minsky) is opowerful one.
The  canonical frames dealt with in ISAAC are particularly simple ones.It would be interesting to develop canonical frames for more complex objects in physicsand engineering.
Analpis  done by engineers is based very heavily on the use ofcanonical object frames; it would be interesting to study how such frames are selectedand used, and how such frames are used when the modeled object doesn't fit thecanonical frame very well (as, for example, when piecewise lillear analysis is used tosimulate a nonlinear device charactefistk).Since the model of n problem is constructed before equations nre written tosolve the problem, the existing program could be used as s test bed fcr in~es t iga~iqgother strategies for solving this type of problem.
It is clear that the prqsent methodgenerates many more equations than are usually generated by humans; it would beinteresting to investigate how the fey critical equations could be writ ten more directly,and what rules might be used to select and inhibit such shortcut methods.It would be interesting to extend ISAAC to additional tvpes of physitsproblems.
Although the present program handles only static problems.
most dynamicproblems are handled as a sequ-ence of (usually two) "static" situations with a specificrelationship (such as a conservation law) which holds between the two situatiol~s.
[de Kleer 751 investigates the interaction of qualit nt ive and q u ~ n t i t  at i v r  knobv!c)dye insolv i t ~ g  dynan~ic problems.8.3 Potential ApplicationsPrograms similar to ISAAC, but with expanded capabilities, might finduseful application in two arcas: a s  engineering assistants, and in technical education.There are many specialized programs to aid in the analysis of engineeringproblems.
'Often, however, these progrqrns are not used for problems of small tomoderate size, either because considerablb knowledge of a system is required in order touse it (and it isn't worth the effort-to acquire this knowledge for a small problem), orbecause the data  must be laboriously prepared i n a  rigidly specified format.
A programwhich, like ISAAC, could accept a problem statement id English could overcome theseproblems.Another patential application of a program stlch as ISAAC is in computer-assisted instruction (CAI).
Other CAI progra~n's using natmal language, such as theSOPHIE program [Brown and Burton 753 for teaching electronic circuit analysis, havebeen successfully developed and used.
ISAAC is particularly interestit~g for applicationin this area because of the insights it give$ into the problem solving process.
Theprimary skill $hich is taught in a physics class to enable the students to solve problemsis the application of physical laws to actual prob1t.111~.
The physical laws themselves areof less importance-in fact, not all of the laws uecessary to solve a problem are taughtexplicitly (such as, for example.
the "laws" that  the force exerted l ~ y  a rope is d i rec t~dtoward the center of the rope and cannot be negative).
Many of' these laws are "bu~aied"in the procedures for setting up  a problem sol'utioll.
These p~ocedures are usually taughtby example-often with Inany steps left out.
The stutlent who does not understand howthe missing steps are being skipped may become completely lost.
A program such asISAAC could be valuable for teaching physics (and similar subjec.ts) because it couldpresent all of the steps in detail, progressing to Inore abbreviated forms onre the studc~ltgrasped the steps that were to be skipped.8.4 Program StatisticsThe time required by the program to process a complete problem (includingparsing, semantics, problem solving, and picture generation) averages about 10 secondsper problem, using interpreted LISP on a CDC 6600.
This is really quite fast.
By usingcompiled LISP instead of interpreted LISP, an  iiwrease in speed of several times mightbe obtained, so that the processing time per problem in a "production" system might bereduced to a second or two.
I t  took the author about 45 minutes to solve all  theproblems (drawing only minimal diagrams a6 a innemonic aid);  two of the answers werewrong due to "careless" errors.
Thus, even in its present form, the program is more thanten times as fast as a human test subject and (assuming the problem is within its rangeof competence) more accurate.The program fs coded in U T  LISP 1.5, using a virtual memory package forfunction definitions which was written by Mabry Tyson.
Virtual memory is particularlygood for programs such as this one because it allows se~nantic  functions for a largevocabulary to be available without clogging the machine when they are not in use.
Someof the standard transcendental functions needed for the geometry and picturegeneration were coded in LAP to ir~crease their executiotl speed,The complete program comprises about 5000 lines of LISP source code,including comments.
(This is admittedly a n  impl~ecise measure of the program's size.
)Breaking the program down roughly into functional categories, the percentages of thetotal code in each of the categories are approximately as  follows:SyntaxS e m  nticsCanonical Frame ProgramsGeometric ModelProblem SolvingSymbolic Algebra PackageAnswer GenerationPicture ModelPicture Genera tionLexicon and Other DataMiscellaneous78The current version of the program has a vocabulary of about 2000 words.Some of these (for example, different ways of writing tnensurement units) d o  not appearin the sample problems.
Not counting different forms of' the same root word, tile twentysample problems use a total of 138 words.
It  is interesting to graph the number of wortisrequired as  a function of the number OF problems, even though this is somewhatdependent on the arbitrary ordering of the problems.
Such a graph is s h o \ ~ n  in Figure8.1; the graph is extended to include the vocabulary for fi\re udditionnl prnhlems, whichare discussed in the next section.
The graph suggests that twenty pl-oblems (even thoughthey are of the same type) are not enough to read1 a plateau where the esistingvocabulary will handle many new problems.
I n  the next section, we discuss theprogram's ability to handle new problems.-aI I 1O 011 1 I I .,5 10 15 20 25ProblemsFigure 8.1: Required Vocabulary as a Function of Number of Problems68.5 Handling Additional ProblemsThe ultimate test of an artificially intelligent program is its ability to handlenew situations for which it was not specifically programmed.
Unfortunately, manyartificial intelligence programs turn out to be "toy'' programs which cannot solve manynew problems beyond the few test cases used and cannot easily be extended.
I t  is ofinterest, therefore, to examine the ability of ISAAC to solve new problems and, moreimportant, to examine the specific improvements (in the many abilities of the program)which are required to handle new problems.
In  order to do this, we asked our colleague,Michael K. Smith, to select independently five additional test problems.
Therestrictions on this selection were that the.
problems ~ h o u l d  be problems involvillg rigidbody statics, and that they should be stated in English without requiring a diagram aspart of the problem statement.
The five additional problems are reproduced below.P21.
A uniform steel meter bar rests WI two scales at its ends.
The bar weighs 4.0 lb.Find the readings on the scales.P22.
A 60 ft ladder weighing 100 lb rests against a wall a t  a point 48 ft above theground.
The center of gravity of the ladder is one-third the way up.
A 160 lbman climbs halfway up the ladder.
Assunling thut the wall is Erictio~~less, findthe forces exerted by the system on the ground and the wall.P23.
A uniform beam is hinged a t  the wall.
A wire conne'cted to  the wall a distance dabove the hinge is attached to the other-end of the beam.
The bean1 makes anangle of 30 deg with the horizontal when a weight w is hung from a stringfastened to the end of the beam.
If the beam has a weight W atid a length I, findthe tension in the wire and the forces exerted by the hinge 011 the beam.P24.
A door 7.0 ft high ant1 3.0 ft wide weighs 60 lb.
A hinge I .O ft from the top andanother 1.0 ft from the bottom each support half the door's weight.
Assumethat the center of gravity is at the geometrical center of the door and dete1;lninethe horizontal and vertical force components exerted by each hinge on the door,P25.
An automobile weighing 3000 lb has a wheel base of 120 in.
Its center of gravityis located 70 in behind the front asle.
Determine the force exerted on each ofthefront wheels (assumed the same) and the force exerted on each of the backwheels (assumed the same) by the level ground.These problems are taken from Physics [Halliday and Resnick 67]*, pages327-339, This is a somewhat harder book than the texts from which cc: took the origillaltwenty sample problems; nevertheless.
all of the new problems except (P23) are withinthe existing capability of the problem-solving, geometry, and picture-generation parts ofthe program.
However, the program could not complete any of these problems withoutsome modifications.
In order to solve all five of these problems, it would be necessary toextend the capabilities of the program in the areas of vocabulary, grammar.
worldknowledge, and algebraic manipulation.
We do not feel that these modifications wouldbe too difficult, and we believe that they could be made within the existing framework ofthe program.
In the sections below, we consider the specific extensions needed in each ofthese areas to solve the additional problems.
"Copyright 1967 by John Wiley & Sons, Inc. Used by permission.8.5.1 VocabularyEach of the new problems requires additional vocabulary.
The averageincrease of seven words per problem is higher than that of the last few problems of theoriginal set, probably due to the fact that the problems are written by different authorsand are somewhat harder.
The new words required for each problem are listed below.Of the thirty-six words, ten (those-marked with an asterisk) could be added trivially assimple lexicon entries or as synonyms of existing words.
For example, "one-third" couldbe defined as a nun~ber with a value of 0,33333:33:3; "connect" could be madesynonymous with "attach", and "wire" and "string" could be made synonymous with"rope"P21 meter bar'" P23 hinge [verb]* P25 wheel basescale wire* frontreading connect* axledistance wheelsP22 above string* sameground fasten* backone- third* length level*way behindUP P24 anotherclimb* each [proizoun]halfway ha lPassume geometricalfrict~ionless force [adj]system componenthighbottomOf the remaining words, some (such as "wheel base") are useful only forindividual problems; however, there are still a number of more general words (such as"above" and "distance") which are likely to be used in a number of problems out of alarge sample.
This seems to indicate that it would take a much larger vocabulary(perhaps twice as large) to include most of the "general" wordslikely to be encounteredin this type of physics problems.
I t  also indicates that  several times more than twentytest cases would be needed before we could have confidence in the program's ability tosolve a new,, independently selected problem,There are several constructions in the new problems which are not handledby the existing grammar.
We shall discuss these below, w t h  the caveat that it is easy tooverlook subtle features of sentences which might confuse the existing grammar andrequire some debugging.In  (P22), the phrase "one-third the way up" would not be handled by thepresent grammar.
Such a phrase would become a type of LOCPART SFRAME, withinferences required to determine the object involved, the starting point for the relativeposition, and the length of the object.
A slight grammar extension might be required to9 1 handle the initial clause "assuming that .
.
, .In (P24), an  extension would be necessary to accept the "each'' ill the secondsentence.
Extensions would also be aeecied to accept "half the door s weight", both tohandle the "half '  and to 'iiccept the possessive form of 11ouns as an adjective (this wouldnot be hard, since possessive pronouns are already hanciled).
An extension would beneeded for the compound adjectives in "horizontal and vertical farce components".In  (P25), it would be necessary to handle the two parenthetical expressions"(assumed the same)".8.5.3 World Knowledge"World knowledge", as we use the term here, is knowledge of the usualrelationships and.
features of objects which is used in making inferences used tounderstand a problem.
Additional world knowledge is needed for several of the newproblems.In (P22), we need to infer that the bottom of the ladder is resting on theground.
Similar knowledge is needed for (P26), where we need to infer that the groundsupports the automobile in four places (the four wheels).
In  (P24), we need to know that(whatever their vertical position) the hinges are on one side of the door.
This wouldrequire additional semantic routines to control the generation of these locations.Additional research on  ways to represent and control world knowledge suchas that  described in this section would be-very valuable.8.5.4 Comments on Individual Problems(P21) is of course very simple.
If we substituted another word (say"supports") for "scales" and substituted "forces" for "readings", the present programcould solve it.
To handle the problem as stated, we would need to add a SCALEcanonical object (which has a reading equal to the force on it) and add a drawingprogram to draw a scale.In (P22), we could take a static view of "climbs" and make it equivalent to"stands".
Although the program automatically assumes that walls are frictionless, itwould be easy to write a semantic routine to set a zero coefficient of friction if desired.
Asemantic routine would be needed to identify the referent of "system".
(P23) is beyond the algebraic capabilities of the present program, since itinvolves algebraic arguments bf transcendental functions.
It wo\ild not be hard to allowthis, although the resulting expressions might be intractable for-the present expressionsimplifier and equation solver.
The present prograrri would work if d and.
1  ereconstants.
(P24) would present no problems beyond the ones previously mentioned.For (P25), a semantic program (or a more general program which referencedthe object's GEOMODEL) would be needed to correctly define the wheel base of the caras the distance between the two axles.
The car's GEOMODEL would have to beexpanded to include wheels and axles.
I t  would be desirable to he able to handle anobject such as a car either as a single point, as in (el@, or as a lever system in its ownright, as in (P25).
(F1 LEVER 10 FT LONG IS PINNED FIT I T S  LEFT END1 ITHE LEVER I S  SUPPORTED BY fl SPRING WITH RCONSTFINT OF 40 LB/FTI [THE SPRING IS  ATTRCHED6 FT FROM THE LEFT END OF THE LEVERI[f l  NEIGHTOF 20 LB I S  RTTRCHED FIT THE OTHER END OF THELEVER) (THE NEIGHT OF THE LEVER I S  8 LBI(H0WMUCH IS THE SPRING STRETCHED)ANSWER: 1.00000 FTP2 SCHRUM" PAGE 12 NUMBER Ll[WHERE MUST A UEIGHT BE HUNG ON A POLE .
OFNEGLIGIBLE NEIGHT SO THAT THE B O Y  RT O N EEND SUPPORTS 113 RS MUCH RS THE HflN f lT THEOTHER END)RNSWER: [TI I IES LENGTH76 7.50000E-1) FROV THEBOY .
MHERE LENGTH76 IS THE LENGTH OF THEPOLE*Problems marked SCHAUM are from College Physics [Schaum 611.
Copyright 1061 byMcGraw-Hill Book Company.Used by permission.Appendix B: Object Frame RepresentationsThis appendix briefly describes the representat ions of objects and theirrelationships which are constructed by the various parts of the program.
The vnriousitems of information associated with each object are stored in its property list undernamed indicators; in describing each type of information, we give the name of theindicator under which it is stored, followed by a description of the information itself.B.1 Physical Entity RepresentationThe property list indicators for physical entities (which include ezplieitforces as well as physical objects) and the type of information stored under each one aredescribed below.ENTITY: PHYSENTTOK i wordWORD wordNAME: nameRESTRICT: ((attribute value) .
.
.
)SELECT: (selection)PARTOF: objectPARTS: (object.
.
.
)COFG: (location)LOGS: (location .
.
.
)ATTACH: (attachment.
.
,)Identifies the object as a physicalentity.Identifies the tokenbword of which thisobject is an example.
Usually the wordrepresenting the object in the sentence.Identifies the specific word describingthe object in a sentence, if differentfrom the TOK.
For example, "boy"would be represented by TOK:PERSON and WORD: BOY.Name of the object if it has one.Restrictians on the TOK f o ~  thisobject.
For example, "boy'' would have(RESTRICT (SEX MALE) (AGEYOUNG)).Selection used to select a particularobject.
For example, "the upper hinge"would have SELECT: (UPPER).Object which this object is a part of.List of all objects which are part of thisobject.Location object dhich is the location ofthe center of gravity of this object (ifspecified).List of all locations on this object.List of all attachment relations whichinvoIve this object.SUPPORT: (object .
, .
)SUPPORTBY: (object .
.
.
)UNKNOWNS: (variable .
.
.
)CONSTANTS: (constant .
.
.
)ROTN: (angle)FRAME: frameGSIZ E : (sx sy)GSTART: ( X  Y(.
)PIVOT: (x Y)FORCES: ( ( C X  y) (fx fy)) .
.
)SIZEDET: (measurement .
value)PSCALE: scalePSIZE : (sx sy)STVAL: (x Y)IMLACXTEM: *T*LENGTH:" (value units)WEIGHT: (value units)TENSION: (value units)CONSTANT: (value units)B.2 Location RepresentationENTITY: LOCATIONFRAME: LOCATIONOBJECT: objectLOCNAME: wordNAME: nameList of objects which this objectsupports.List of objects which support thisobject.List of all variables associated withthis object.List of all constants associated withthis object.Rotation of the object.
(counterclockwise in degrees) from itsGEOMODEL orientation.Name of the canonical object freurnewhich represents the object in itscurrent instantiation, e.g., LEVER.Geometric size scaling vector.Geometric starting point.Preferred pivot kcation for a rigidbody object.Position and force vector for each forceexerted by the object.Measured quantity and value for thisobject, used to determine picture siztscaling.Scale factor between geometric-lengthand picture size.Picture size scaling vector.Starting point for object in drawing.True if the object has been drawn, Notreally used in current system.Measurements of various attributes, a sappropriate for a particular type ofobject.Identifies the object as a locationentity.Identifies a location frame.Identifies the object with which thelocation is associated.Location name, e.g,, END,Name of the location, if specified.SELECT:REFLOC:REFLOCS:RELPOS:(selection)location(location .
.
.
)(type (quantity units))POSITION: ( s  y)Selection used to select this particularlocation.
For example, "the ltlft end"would have SEIIX;'ICT: (Ll.
(=lJrr),Location to  which this locnt ion isrelative.List of all locations which nru relativeto this 10ca t ion.Specifies posit ion relnt i1.e t o  ther e f e r m e  locntion.
For example, "ti f tfrom on@ en(.\" ~ \ * n u l d  hrt\-e l3E:I,l3C)S:(FROMLOC' ( 6  FT)),Gcornetric posit ion of t hc loc.nt ion.FRAME: ATTACH Identifies this as an attachment frar-r~e.T Y  PEATT: type Type of attachment.
e.g.. PINJOINTor CONTACT.LOCS: ( (object 1ocatio11 (fx.fj7)) .
.
.)
Specifies each object involved in theattachment, along w i t h  the location onthat object and the force vector for theforce exerted by the object a t  thatlocation.B.4 Constant or Variable RepresentationENTITY: CONSTANTor VARIABLESYSTEM: objectMEASURE] attributeUNITS: unitsVALUE: valueGeometric position of the point ofattachment.Identifies this object as a constant orvariable.Physical entity object with ~vhich theconstant or variable iS assocla~ed.Attribute which is measured, e.g.,TENSIONUnits of the measurement.
e.g., FT.Numeric or symbolic espression whichis the calculated value of a variable.Appendix C: Generated Structures for a Sample ProblemThis appendix contains snapshots of some of the major data structuresproduced by ISAAC a t  various stages in the processing of the sample problem (P8).
Thefirst part of the listing shows the st?uctures produced by the parsing and semanticprocessing of each sentence.
After each sentence, the result of the parsing is shown;< S> indicates that a major clause was parsed, and the list of tokens which followsgives the root of the parse tree (the verb) for each of the major clauses which was parsed.This is followed by a listing of each of the tokens produced during parsing.
The dumpfollows all of the semantic processing: the tokens are not used thereafter except infinding pronoun referents.Following the dump of the parse structures is a listing of the internal modelof the problem as it exists just after all of the input sentences have been processed, butbefore frame creation and all the subsequent processing.
Each of the GENSYM atoms isa separate object in the model.
The four atoms UNKNOWNS, DESUNKS, SYSREPLY,and SYSUNITS are global variables whose bindings are the list of all unknowns, thelist of desired unknow~~s ,  the reply to be generated once the problem is solved, and themeasurement units used for various types of measurements, respectively.The next part of the dump- shows each of the equations presented toSOLVEQ for solution, followed by the answer generated by PRTVAR.
The equation(EQUALS 0 0 )  is caused by a deficiency in CFSURFACE (complete frame forSURFACE) which went unnoticed because it didn't cause any problems.
CFSURFACErequires that the force exerted by a surface be perpendicular to the surface; this is finefor an  attachment of type CONTACT, but not for one of type PINJOINT, such as theattachment between the rope and the wall.
Thus, one of the zeros should be a variablerepresenting the vertical force exerted by the wall.
The other zero, representing thevertical force exerted by the rope on the wall, is correct.The final part  of tlle dump shows the model of the problem a t  the end of theproblem solving and picture generation processes.
It can be seen that a great deal ofinformation has been added to the model beyond that which was  available immediatelyafter the problem statement was read.
The meaning of the information associated witheach of the objects in the model is explained in Appendix B.
'3 0Sentence Structures After Parsing and Semantics( T H E  FOOT O f  A LADDER RESTS AGAINST A V E R T I C A L  WALL AN0 ON AHORIZONTAL FLOOR)TQK289 ( ( T O K  e FOOT) (LFRAME NP) I D E T  * DEF) (NOR Y S )(SFRAME .
LOCPART) (SEMOBJ LADDER2913 (RFNT L O C 2 9 7 ) )TOK290 ( (TOK .
L.ADOER) (LFRAME NP) ( D E T  .
INDEF) (NSH NF)(SFRAME PHYSENT) (RFNT LADDER291 1TOK292 ( (TOK .
REST) (LFRAME , VP) ( Y A I N V B  .
R E S T S )( I N T R A N S  * T * )  ( A C T  * T * )  (SUBJ * TOK289) (MODS.
(CASEARG AGAINST (WALL294)) {CASEARG ON IFLOOR296)l))T O K 2 9 3  ( ( T O K  WALL) (LFRAME NP) (DET INDEF)  (NBR N S )(MODS (ROTN 90)) (SFRAME PHYSENF) (RFNT WALLZ94))TOK295 ( (TOK FLOOR) (LFRAME NP) ( D E T  INDEF)  (NBR N S )(MODS (ROTN 0)) (SFRAME .
PHYSENT) (RFNT F L O O R 2 9 6 ) )(THE T O P  OF THE LADDER I S  SUPPORTED F R O M  THE WALL BY AHORIZONT4L ROPE 30 FT LONG)TOK300 ( (TOK TOP) (LFRAMf NP)  ( D E T  DEF) (NBR NS)(SFRAME .
LOCPART) (SEMOBJ LADDER291)  (RFNT LOC309) )T O K 3 0 1  ( ( T O K  LADDER) (LFRAME .
NP)  [ L I L T  .
D E F )  ( N R R  N S )(SFRAME , PHYSENT) ( H f N T  LADDER291 1T O K 3 0 2  ( (TOK SUPPORT) 4 (LFRAME , VP) ( M A I N V B  .
SUPPORTED)( A U X  IS) (TRANS r 'T") (PASV .
O f " )  ( O B J  .
TOK300)[ M O D S  ( ,CASEARG F R O M  (WALL2941  1 ( ~ b ~ d  .
TOK304)  1T O K 3 0 3  ( ( T O K  WALL) (LFRAME .
N o )  (DET DEF).
(NBR V S )(SFR4ME .
PHYSENT) ( R F N t  W A L L 2 9 4 ) )TOK304 ( (TOK .
ROPE) (LFRAME NP)  (DET .
INDEF) (NR2 NS)  (MODS(ROTN 0) (LENGTH 30 F T I )  (SFRAME .
PHYSENT) (RFNJ R O P E 3 0 5 ) )(THE LADDER I S  SO FT LONG r WEIGHS 1 0 0  LP WITH  I T S  CEdTER OFGRAVITY 20 F T  FROM THE FOOT AND A 1 5 0  LB MAN I S  1 0  FTFROM THE T O P )T O K 3 1 1  ( ( T O K  .
LADDER) ( & F R A Y ?
NP) (DET .
DEF) (NBQ NS)(SFRAME PHYSENT) (HFNT L A D Q E R 2 9 1 ) )TOK312 I(TOK BE)  (LFRAME V P )  (MAINVB I S )  ( INTRANS*Ta)  ( A C T  'T") (SUBJ .
T O K 3 1 1 )  ( C O M P  LENGTH 50 F T )(VPCONJ TOK313)TOK313 ( ( T O K  WEIGH) (LFRAME VP)  ( M A I N V 8  , dEIGHY)( INTRANS UTU) ( A C T  f i T { ' )  (SURJ T O K 3 1 1 )  ( C O M P  .
T O K 3 1 4 ) )TOK314 ( ( T O K  .
L B )  (LFRAME .
NP)  ( Q T Y  .
1 0 0 ) )TOK315 ( (TOK C O F G )  (LFHAME NP)  (NBR N S )  ( S F M A M E  0LOCPART) ( SEMOBJ LADDER291 1 (MODS (LOC AT (LOC317)TOK316 ( ( T O K  F O O T )  (LFHAME NP) ( O E T  DEF)  (NBR Y S )(SFRAME .
LOCPART) (SEMOHJ L A D D E H Z o l )  (HFNT LOC297)TOK3lb ( ( T O K  PERSON) (LFRAME NP) (WORD MAN) (MOD5( R E S T R I C T  ( S E X  M A L E ) )  (RESTRICT ( A G E  A D U L T ) )  (NEIGH1150 L B ) )  ( D E T  .
INDEF)  (NBH NS)  (SFHAME PHYSENT)(RFNT PERSON3191)TOK320 ( ( T O K  BE)  (LFHAME VP) (MAINVB 1 5 )  ( INTRANS .$T*)  ( A C T  * T * )  (SUBJ T O K 3 1 8 )  ( M O O S  (LOC A T  4 0 C 3 2 2 3 ) ) )TOK321 ( ( T O K  .
TOP) (LFRAME .
NP)  (DET .
DEF)  (NBR NSI(SFRAME , L O C P A R T )  (SEMOBJ ~ a n n ~ ~ 2 9 1 )  (HFNT ~ 0 ~ 3 0 9 ) )(DETERMINE THE TENSION I N  THE ROPF)TOK324 ( ( T O K  DETERMINE) (LFRAME 9 VP) (MAI*NVB DETEHMINE)( T R A N S  *f*)  ( IMPERATIVE aTU)  ( A C T  .
* T * )  ( O R 3  .
T O K 3 ?
5 ) )TOK325 ( ( T O K  TENSION) ([..FRAME .
NP) (DET .
D E F )  (N8R NS)(SFRAME .
ATTROF) (SEMORJ  R O P E 3 0 5 ) )TOK326  ( ( T O K  .
ROPE) (LFRAME .
N P )  (DET .
DEF) (NHR Y S )(SFRAME .
PHYSENT) (RFNT R O P E 3 0 5 ) )Initial Model After Reading Problem StatementLADDER291 ( ( T O K  .
LADOER) ( E N T I T Y  PHYSENT) ( L O C S  LOC297LOC309 LOC317 LOC322) (ATTACH ATTACH298 ATTACt i299A T T A C H 3 4 0  ATTACH3231 (SUPPORTBY FLOOR296 WALL294ROPE3051 (COFG L O C 3 1 7 )  (LENGTH 50 F T )  (WEIGHT 1 0 0  L B ) )WALd2Y4 ( ( T O K  WALL) ( E N T I T Y  PHYSENT) (ROTIU 9 0 )  ( A T T A C HATTACH299 ATTACH3081 (SUPPORT L A D D E R 2 9 1 ) )FLOOR296 ( ( T O K  FLOOR1 ( E N T I T Y  .
P+iYSENT) ( R O T N  0) (ATTACHATTACH2981 (SUPPORT L A D D E R L 9 1 ) )LOC297 ( (FRAME a LOCATION) ( E N T I T Y  LOCATION) (OBJECTLADDER2911 (LOCNAME .
FOOT) (REFLOCS L O C 3 1 7 ) )A T T A C H 2 9 R  ( ( F R A M E  ATTACH) (TYPEATT a CONTACT) (LOCS(LADDER291 LOC297)  (FLOOR296 N I L ) ) )ATTACH299 ( (FRAME ATTACH)  (TYPEATT m CONTACT) (LOCS( L A D D E R 2 9 1  LOC297)  (WALL294 N I L ) ) )ROPE305 1 ( T O K  , ROPE) (ENTITY PHYSENT) lROTN 0,) (LENGTH30 FT)  ( L O C S  LOC306 LOC307) ( A T T A C H  ATTACH308ATTAcH310)  (SUPPORT LADDER291)  (UNKNOWNS TENSION327)(TENSION TENSION327 L R ) )L O C 3 0 6  ((FRAME * LOCATION) ( E N T I T Y  LOCATION) (OBJECT ,ROPE305) (LOCNAME a E N D ) )LOG307 ( (FRAME LOCATION) ( E N T I T Y  LOCATION) (OBJECTROPE305) (LOCNAME END) 1ATTACH308 ( (FRAME a ATTACH) (TYPEATT .
P I N J O J N T )  (LOCS(WALL294 N I L )  (ROPE305 L O C 3 0 7 ) ) )LOC309 ((FRAME LOCATION) (ENTITY LOCATION) (OBJECT ,LA DOER^^^) (LOCNAME .
TOP) (REFLOCS LOC322))ATTACH310  ( ( F R A M E  .
ATTACH) (TYPEATT .
P I N J O I N T )  (LOCS(ROPE305 LOC306) (LADDER291 L O C 3 0 9 ) ) )LOC317 ((FRAME L O C A T I O N )  (ENT-ITY a LOCATION) (OBJECTLADDERZBI,) (LOCNAME FOOT) (REFLOC .
LOC297)  IRELPOSF R O M L O C  ( 2 0  F T ) ) )PERSON314 ( ( T O K  PERSON) (WORD .
M A N )  ( E N T I T Y  PHYSENT)(RESTRICT (SEX MALE)  (AGE ADULT) )  (WEIGHT 150 LB)(ATTACH A T T A C H 3 2 3 ) )L O C 3 2 2  ((FRAME a LOCATION) ( E N T I T Y  a L O C A T I O N )  (OBJECTLADDER291) (LOCNAME .
TOP) (REFLOC LOC309)  iRELPOSFROMLOC (10 F T ) ) )ATTACH323 ( (FRAME .
ATTACH) (TYPEATT CONTACT) (LOCS(PERSON319 N I L )  (LADDER291 L O C 3 2 2 ) ) )TENSION327 ( ( E N T I T Y  VAQIABLE)  ( S Y S T E M  ROPE305) (YEASURE.
TENSION) ( U N I T S  L R ) )UNKNOWNS (TENS I O N 3 2 7  1OESUNKS ITENSION327)SYSREPLY ( ( P R T V A H  TENSION327 1 1S Y S U N I T S  ( ( F O R C E  .
L B )  (LENGTH F T ) )Equations Generated By Problem SolverSOLVEQ (EQUALS 0 FORCE3281SOLVEQ (EQUALS 0 (PLUS FORCE329 FORCE3381SOLVEQ (EQUALS 0 (PLUS FORCE330 ( T I M E S  FORCE336 - 1 ) ) )SOLVEQ (EQUALS 0 FORCF331)SOLVEQ (EQUALS 0 (PLUS ( T I M E S  FORCE337 -1  TENSION327)SOLVEQ (EQUALS 0 0 )SOLVEQ (EQUALS 0 (PLUS ( T I M E S  TENSION327 -1 ,00000 )  F3HCE332))SOLVEQ (EQUALS 0 FORCE3331SOLVEQ (EQUALS 0 FORCE3341SOLVEQ (EQUALS 0 (PLUS -150 FOHCE335))SOLVEQ (EQUALS 0 (PLUS 250 (MINUS FORCE338) ' ) )SOLVEQ (EQUALS 0 (PLU5 FORCE332 FORCE33611SOLYEQ (EQlUALS 0 (PLUS (PLUS (PLUS (DIFFERENCE ( T I M E SFORCE332 8 o 0 0 0 0 0 )  ( T I M E S  FORCE333 6 , 0 0 0 0 0 ) )  ( (1IFFERENCE( T I M E S  FORCE330-32*80000)  ( T I M E S  FOHCE331 - 2 4 , 0 0 0 0 0 ) ) )(DIFFERENCE ( T I M E S  FORCE328 -32 ,00000 )  ( T I M E S  FORCE329- 2 4 .
0 0 0 0 0 ) ) 1  1 2 0 0 .
0 0 0 0 0 ) )ANSWER: 1 2 0 0 0 0 0 0 0  LRFinal Model of the ProblemLADDER-291 ( ( T O K  .
LADDER) ( E N T I T Y  , PHYSENT)  ( L O C S  L 3 C 2 9 7LOC309 LOC317 LOC322) ( A T T A C H  ATTACti298 ATTACtiL99ATTACH310  ATTACH3231 (SUPPOHTRY FLOOR296 WALL294ROPE305) rCOFG LOC317)  (LENGTH 50 FT )  ( W E I G H T  1 0 0  LY)(GSIZE 1.00000 0) (FRAME LEVER) (SUPPORT PERSON3141( G S T A R T  0 0) (ROTpiJ 5 3 , 1 3 0 1 0 )  (FOYCES ( ( 2 4 .
0 0 0 0 032 .000001 (FORCE334 FORCE335) )  ( ( 3 0 , 0 0 0 0 0  4 0 , 0 0 0 0 0 )(FORCE332 FORCE3331 1 ((0 0 )  (FORCE330 FOHCE331)) ( ( 0  0 )(FORCE328 FORCE32911 ( ( 1 2 .
0 0 0 0 0  1 6 , 0 0 0 0 0 )  ( 0  1 0 0 ) ) )(UNKNOHNS FORCE328 FORCE329 FORCE330 FORCE331 FORCE332FORCE333 FORCE334 FORCE3351 (S IZEDET LENGTH , 5 0 )( P S I Z E  1.00000 1 .
0 0 0 0 0 )  (PSC4LE 1 .
0 0 0 0 0 )  (STVAL 0 0 )( IMLACITEM . '
+ T * ) )WALL294 ( ( T O K  l WALL) ( E N T I T Y  PHYSENT) ( R O T N  - 9 0 )  (ATTACHATTACH299 ATTACH3081  (SUPPORT LADDER2911 (G5IZE 0 0 )(FRAME .
SUHFACE)(GSTART 0 0 )  (UVKNONNS FORCE336FORCE337) (FORCES ( ( 6 , 1 3 9 0 9 E - 1 2  40.00000) ( ( T I M E SFORCE337 - 1 )  6Tl ( ( 0  0) ( ( T I M E S  FORCE336 - 1 )  0 ) ) )(S IZEDET LENGTH l 4 0 , 0 0 0 0 0 )  ( P S I Z E  8 e 0 0 0 0 0 E - 18 ,00000E-1)  (PSCALE 1,250001 (STVAL -8 ,00000E-16 r 0 0 0 0 0 E - 1 )  ( I M L A C I T E M  .
* T U ) )FLOOR296 I ( T Q K  FLOOR) ( E N T I T Y  PHYSENT) (HOTN 0) [ A T T A C HATTACH2981 (SUPPORT LADDEREB1) (GSIZE 0 0 )  [ F R A M ESURFACE) (GSTART 0 0) (UNKNOWNS F O R C E 3 3 8 1  (FORCES ( ( 00) (0 FORCE330) ) )  ( P S I Z E  1 1)  ( S T V A L  -8,000OOE-16 ,00000E-1)  I I M L A C I T E M  " T ' ) )LOC297 ((FRAME , LOCATION) ( E N T I T Y  L O C A T I O N )  ( O B J E C TLADDER2911 (LOCNAME .
F O O T )  (REFLOCS LOC317)  ( P O S I T I O N  0  0))ATTACH298 ((FRAME ATTACH) tTYPEATT CONTACT) CLOCS( L A D D E R 2 9 1  L O C 2 9 7  (FORCE328 ~ 0 ~ 6 ~ 3 2 9 )  1FLOOR29b N I L  ( 0F O R C E ' ~ ~ B - )  1 ) (POSITION 0 0 1ATTACH299 ( (FRAME , ATTACH)  (TYPEATT , C O N T A C T )  (LOCS(LADDER291 L O C 2 9 7  ( ~ 0 ~ ~ ~ 3 3 6  FORCE331)) (WALL294 NIL( (TJMES FORGE336 -1) 0))) (POSITION 0 0 1 1ROPE305 1 ( T O K  r ROPE) ( E N T I T Y  PHYSENT) [RQTN 0 )  (LENGTH3 0  FT)  ( L O G S  LOC306 LOC307)  (ATTACH ATTACH308A T T A C Y 3 1 0 )  (SUPPORT L A O D E R Z 9 1 )  (UNKNOWNS TENSION327)(TENSION .
T E ~ S I O N ~ ~ ~  l.0) (GSIZE 6.00000E-1  0) ( F R A M E  .ROPE) ( G S T A R T  6 ,13909E-32 4 0 , 0 0 0 0 0 )  ( F O R C E S ( !
3 0 .
0 0 0 0 0 ~40.00000) ( ( T I M E S  TENSION327 -1.000QO) 0 ) )( ( 6 .
1 3 9 0 9 f - 1 2  k 0 .
0 0 0 0 0 )  (TENSION327 0 ) ) )  (S IZEDETLENGTH , 3 0 )  (PSIZE 6,0000OE-1 6,00000E-11 (PSCALE1.66667) ( S T V A L  -8 .00000E-1  4 0 , 3 0 0 0 0 )  ( IMLACITEM * T o ) )~ 0 ~ 3 0 6  ((FRAME .
L O C A T I O N )  (ENTITY .
LOCATION) (OBJECTROPE305') (LOCNAME RIGHTEND] ( P O S I T I O N  3Tl.00000 0 ) )LOC307 ( (FRAME r LOCATION) ( E N T I T Y  .
L O C A T I O N )  (OBJECT lROPE305) (LQCNAME LEFTEND) (POSITION 6.13909E-1240.00008)lATTACH308 ((FRAME ATTACH) (TYPEATT .
P I N J O I N T )  ( L O C S(WALL294 N I L  ( ( T I M E S  FORCE337 -1) 0 ) )  (ROPE305 LOC307(TENSION327 0 1 ) )  ( P O S I T I O N  6,13909E-12 4 0 , 0 0 0 0 8 )  1LQC30?
( (FRAME r LOCATION) ( E N 1  I T Y  LOC4TION) (OBJECTLADDERZ91)  (LOCNAVE TOP) (REFLQCS L O C 3 2 2 )  ( P O S I T I O N30oOOOOO 4 0 , 0 0 0 0 0 ) )ATTACH310 ( ( F R A M E  4.
A T T A C H )  (TYPEATT P I N J O I N T )  ( L O C S(ROPE305 LOC306 ( ( T I M E S  ~ ~ ~ ~ 1 0 ~ 3 2 7  -1 .00000)  0 1(LADDER291 Lot309 (FORCE332 F O R C E 3 3 3 ) ) )  (POSITIOY3o.ooooo 40.060oo13LOC317 ((FRAME , LOCATION) ( E N T I T Y  , L O C A T I O ~ J )  ( o ~ ~ f c f  ,LADDER2911 (LOCNAME F O O T )  (REFLOC LOC297) (RELPOSFROMLOC ( 2 0  F T ) )  ( P O S I T I O N  12 ,00000  1 6 , 0 0 0 0 0 ) )PERSON319 ( ( T O K  .
PERSON) (WORD , M A N )  ( E N T I T Y  , PHYSENT)( R E S T R I C T  (SEX MALE) ( A G E  A D U L T ) )  (WEIGHT 150 L R )(ATTACH ATTACH3231 (GSIZE 0 0 ) (SUPPORTBY ~ ~ 0 0 ~ ~ 2 9 1 )(FRAME .
WEIGHT) ( G S T A R T  ~ 4 .
o o o o o  32 .00000 )  ( R O T Y  o j(FORCES ( (24 .00000  32 .00000)  ( 4  -150)  1 )  (S IZEDET FORCE1 5 0 )  ( P S I Z E  6,00000E-1 6 a 0 0 0 0 0 E - 1 )  ( S T V A L  17.8000032.60000) ( ~ M L A C I T E M  .
* T Q )LOC322 ( (FRAME LOCATION) (ENT ITY  LOCATION) (OBJECTLADDERZ91) (LOCNAME T O P )  (REFLoC LOC309)  (RELPOSFROMLOC ( 1 0  F T ) )  (POSITfON' 24m00000 3 2 a 0 0 0 0 0 ) )ATTACH323 ((FRAME .
ATTACH1 ( T Y P E A T T  , C O N T A C T )  t L O C S( P U S O N 3 1 9  NIL ( 0  - 1 5 0 ) )  (LA0DER291 LOC322 (FORCE334FORCE335)) )  ( P O S I T I O N  24m00000  3 2 , 0 0 0 0 0 ) )TENSION327 ( ( E N T I T Y  .
VARIABLE) ( S Y S T E M  ROPE305) (qEASURETENSION) ( U N I T S  a L B )  (VALUE 1 2 0 e 0 0 0 0 0 ) )FQRCC328 ( ( E N T I T Y  .
VARIABLE)  (SYSTEM , LADDER2911 (MEASUREa FORCE) (UN ITS  .
LB) (VALUE 0 ) )FORCE329 ( ( E N T I T Y  a VARIABLE)  (SYSTEM kADDEH2Q1) (MEASURE.
FORCE) ( U N I T S  L B )  (VALUE .
- 2 5 0 ) )FORCE330 ( ( E N T I T Y  VARIABLE) ( S Y S T E M  LADDER2911 (MEASURE.
FORCE) ( U N I T S  .
L B )  (VALUE - 1 2 0 ~ 0 0 0 0 0 ) )FORCE331 ( ( E N T I T Y  a VARIABLE) ( S Y S T E M  LADDEH291) (YEASUWE1 FORCE) ( U N I T S  L B )  (VALUE .
0))FORCE332 ( ( E N T I T Y  VARIABLE) (SYSTEM .
LAODER291) (MEASUREr FORCE) (UN ITS  + LB) (VALUE , 1 2 0 , 0 0 0 0 0 ) )FORCE333 ( ( E N T I T Y  .
VARIABLE) (SYSTEM LADDER2911 (YEASUREFORCE) ( U N I T S  .
LR) (VALUE , 0 ) )FORCE334 ( ( E N T I T Y  .
VARIABLE) (SYSTEM l LADDER291) (VEASUREFORCE) ( U N I T S  L B )  (VALUE 0 ) )FORCE335 (.
(ENT ITY  VARIABLE) (SYSTEM .
LADDER291 CAEASUREFORCE) ( U N I T S  L B )  (VALUE a 1 5 0 ) )FORCE336 ( ( E N T I T Y  a VARIABLE) (SYSTEM , WALL2941 (MEASUREFORCE)  (UN ITS  L B )  (VALUE - 1 2 0 .
0 0 0 0 0 ) )FORCE337 ( ( E N T I T Y .
.
V A R I A B L E )  (SYSTEM , H A L L 2 9 4 )  (MEASUREFORCE) ( U N I T S  .
L B )  (VALUE , 1 2 0 a 0 0 0 0 0 ) )FORCE338 ( (ENT ITY  VARIABLE)  (SYSTEM E'LOOR296) (MEASURE.
FORCE) ( U N I T S  L B )  (VALUE 2 5 0 ) )Becker, Josep!~ D. "The Phrasal IJesicoll", pp.
6O-(il in TIleoretical issues in Nottr~*nlLanguage Pr.oressirg, prt~cecldings of n conference held at  M.I.T.
OR +June10-13, 1975.Bobrow, Daniel G. "Naturul Language Input for a Coinguter Problem-SolvingSystenl" , ill [hl insky 68).Bobrow.
Dnniel and Collins.
A411iul 1Kd.1.
Rel~r*rserztntio~l nrttl Li~ciers/nric~i;!g NP\YYork: Aoudenric P~*ess, 197;i.Browi1, G. Spencer.
Lows o f  F O I W ~ .
Xc\v York: R:inturn Hooks, 1972.Brown.
John Sltely and Burton.
Hicl~:~l~d K."hlultiplr Hrpresrntntions of Knc,wlcdxcfor Tutorial Reasoning " In Hnbrow and Collins.Charniak, Eugene.
"Computer Solutiotl of Calculus K u r d  Problems" Proc.
1st IntlJoint ConJ on Artificial Irltellige~ce, pp.
303-916.
Boston: MitreCorporation, 1969.. "CAKPS, a Program which Solves Calculus Word Problems."
3I.I.T.report MAC-TH-31, available frotn W " S  3 s  AD 673  ($70, .Jul?
19BS.. "Toward a Mndel of Children's Story Comprehensior~",', M.I.T.
*I.I, LabReport A1 TR-3Glj.
Dec.
l!
)'i2.de Kleer, Johan.
"Qualitative and Quantit at i ~ r  Knowlecige in Classical RIechnnics "M.I.T.
A.I.
L R ~  l3eport AI-TR-35'2, Ilccember 19'75.Dull, C.E., hletcolf'e, H.C., n l ~ d  'CVilli~ilns, .J.E.
.lIoder.rl Physics, Ntw York: W o i t ,Rinehart  and \Vinstou, l9ti4.Gelb, Jxck P. "Esperinlents with a Nntul-nl Z,angutige Problenl-Solving Systunl' ' , Yr.oc.Brzd Intl.
Joint Conf.
O I Z  .41.tificinl Intelligence.
pp.
-135-462.
LAondon: TheBritish Cotrlputer Society, 197 1.Halliday, David and Resnick.
Robert .
'Ph~sics \Parts  I and 11).
Nex York: John UTile> $Sons, 1967.
* .
Heidorn, George E. "Natural Language Inputs to a Sirnulation Programming System.NPS-55HD72101X, Naval Postgraduate School.
Monterrey, Califol-nla,1972.McCarthy, John, et al.
LISP 1.5 Programmer's illar~ual.
Cambridge, Mass.
: hI.1.T.Press, 1965.McDermott, D.V.
and Sussnlar~, G.J.
"The CONXIVER Reference M a n ~ ~ a l " ,  h1.I.T A.1.Lab Memo No.
259, 197'3.Minsky, Marvin.
Senlantic Inforrrmtion Processing.
Cambridge, Mass.
: M.I.T.
Press.1968.. "A Framework for Representing Knowledge".
M.I.T.
A.I.
Memo No.
306.1971.
Also appears in Wqinston (d.) 1975.Moses, Joel.
"MACSJyMA-The Fifth Year."
ACM SIGSAV Bttlletin.
Vol.
8, No.
3(Aug. 1974), pp.
105-1 10.Papert, Seymour.
"Teaching Children to be Mathematicians vs.
Teaching About.Mathematics."
h t .
J Math.
Educ.
in Science & Tech., New York: Wiley &Sons, 1972; M.I.T.
A.I.
Meluo No.
249, July 1971.Schank, Roger C. "Identification of Co~lceptualizatiolls Underlying NaturalLanguage", in Schank and Colby (eds), 1973..
Conceptual Informfation Processing.
New York: American Elsovier, 1975.Schank, Roger C. and Colby, K.M.
(eds).
Computer Models of Tllought and Language.San  Francisco: W.H.
Freeman and Co., 1973.Schaum, Daniel; Theory and Problems of  College Physics, 6th ed.
New York: McGraw-Hill, 1961.Simmons, R.F.
"Natural Language Question Anstvering Systems: 1969," Corntn.
ACM,vol, 13, no.
1 (January, 1970), yp.
15-30,.
"Semantic Networks: Their Computatiotl and Use for UnderstandingEnglish Sentences", in Schank and  Colby (eds.
),'1979.Simmons, R.F.
and Amsler, R.A. "Modeling Dictionary Data" Technical ReportNL-25, Computer Science Dept., T h e  University of Texas a t  A.ustin.
1975.Simmons, R.F.
ahd Bennett-Novak, G. "Semantically Analyzing an  English 5ubset forthe Clowns Microworld", American Journal of Computational Linguistics,Microfiche 18, 1975.Simmons, R.F.
a n d  Bruce, B.
"Some Relations between Predicate Calculus andSemantic Net Representations of Discourse."
Proc.
2nd in ternat io1~~2 JointConf.
on Artificial Intelligence, London: British Computer Society, 19'7 1.Simmons, R.F.
and Slocum, J.
"Generating English Discobrse from SrtnanticNetworks," Conzm.
ACM, vol.
lt5, no.
10 (October 1972), pp.
891-9115.Wilks, Yorick.
"An Intelligent Analyzer.
and Understandel of English"Communications of the ACiM, vol.
18. no.
5 (hIay 19751, pp.
26.4-274.Winograd, Terry.
Understanding Natural Languczge.Nekr York: Acatie~nic Press.
1972.Winston, Patrick H. The Psychology of Cornputer Vision.
New York: McGraw-Hill,1975.Woods, William A.
"Transition Network Grammars for Natural Language Allalysis"Communications of the ACM, vol.
1 3 ,  no.
10 (October 1970).
pp.
591-(506.
