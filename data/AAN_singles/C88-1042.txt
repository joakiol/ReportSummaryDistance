All Active Bilingual Lexicon for Macldne Translationlgal GOLAN,  Shalom I.APPIN*, Mori RIMONIBM Israel Scientific Center,The Technion City, l laifa 32000, Israel(*) Main affiliation: The University of tlaifaE-mail address: golan and/or lappin and/or rimon @israearn.bitnetAbstractAn approach to tile Transfer phase of a Machine Translationsystem is presented, where the bilingual lexicon plays an activerole, guiding Transfer by means of executable descriptions ofword senses.
The means for lexical sense specification are,however, general enough and can in principle apply to othersystem arthitectures, e.g.
in tile Generation phase if Transferis intentionally kept minimal.
The active lexicon is the one andonly systea~ component which is exposed to users and canserve to linguistically control Transfer effects.
A unifiedapproach to lexicon creation and maintenance is proposed,which contains means to gradually refine sense specificationand tailor the definitions to specific text domains.
The under-lying linguistic principles, the nature of sense distinctionrequired tot translation, and tilt: formal structure of thelexicon are discussed.I?
h t t roduct ionWhile melbods of monolingual Analysis and Generation arealso treated in other contexts, bilingual Transfer problems arehardly inw~stigated outside the context of Machine Translation.Research in Machine Translation can, in this case, make a spe-cific contribution to Computational l,inguistics.
The generalissue here is tire formal representation f phrase structures andlexical units and the  methodology for specifying transf-ormations between these representations in two (or more) lan-guages.
The role of tile bilingual lexicon in the Transferactivity, attd its power to assist in the resolution of mappingproblems, is a key element.In tills paper we present an approach to the formal represen-tation of bilingual exical knowledge and to the way this know-ledge is incorporated into the translation process.
In section 2we describe the role and place of the bilingual lexicon in thetranslation process, present the concept of executabledescriptions of word senses as lexical definitions, and discusssome aspects of practical usage.
Our approach to the sensedistinction required for translation, which is different frommonolingual sense distinction, is discussed in section 3.
Insection 4 we make a few methodological comments, arguingthat wha!
is often portrayed as the ideal Transfer-based archi-tecture, is not the only, and not necessarily the best way toachieve modularity and save work.
Section 5 contains a formaldefinition of the lexicon specification language with some dis-cussion of its features and the intended restrictions on thepower given to the lexicographer.
Finally, an additionalexample is given in detail in section 6.This work has been carried out as part of the MENTORproject, where several groups in European IBM ScientificCenters are collaborating on M(A)T research.
The approachpresented here has been developed and prototyped by thegroup in Ilaifa, Israel, as part of the proposal for tire designof Transfer-related operations.
The examples below involvetranslations from English into I lebrew.We thank our colleagues Danit Ben-Ari, Esther Bentur andMaria Vilkuna for their contributions and comments.2.
"lhe Role and Content of the Bilingt, al Lexicon\[Cullingford 87\] describes an MT system which is purelylexicon driven.
Ills system follows the Conceptual Processingmodel, and is not Transfer-based, hence the emphasis there ison deep Analysis and Generation.
Many other systems distin-guish between I.exical Transfer and Structural Transfer, butthey take different approaches to the actual separation of thesetwo sub-processes.
In the work reported here, an attempt wasmade to strictly separate lexicon-driven selection of target lan-guage equivalents from the global mapping of syntactic struc-tures in the SIA into those of tile 'I'I~ (cf.
\[Biewer 85\]). '
lhelexicon lookup phase, which takes place before phrase struc-ture transformations, gets as its input the internal data repre-sentation provided by the SL parser (PEG \[Jensen 86\], in outprototype).
The terminal nodes (leaves of a parse tree) aresearched in a pre-defined order for certain parts of speech.For each word in turn a target equivalent is selected from thebilingual exicon and attached to the corresponding node in theparse.
Features may also be added to other affected nodes.f lowever, no structural modifications are made.
Structuraltransformations are carried out as an independent sub-process,upon completion of tire bilingual exical phase, and are not dis-cussed in this paper.Since in many cases, and ill fact for most verbs, several alter-native translations exist, tile selection is done by texical differ-entiation rules.
These rules refer to the syntactic environmentof tile word in the parse tree and to a limited number ofsemantic features.
The rules can access any node and attributeidentified by the parser.
Given that the rules are stated interms of the SL phrase structure, it seems more natural toapply them as close to Analysis as possible.
Nevertheless, thesense distinction cannot be done as part of SL Analysis itself,as in many cases it depends on factors which may vary fromone TL to another.The sub-process of bilingual lexical substitution proceeds uni-directionally.
No iterations take place for any given phrase.
Insome cases this may require extensive searching of' the phraseThe filllowing abbreviation~ are u~ed throughout hi~ pal~er:SL =: Source Language ,  BL = BiLingual,  TL  = Target  Language205structure in a manner determined by the relevant differen-tiation rules.The differentiation rules which comprise an entry in the bilin-gual lexicon are stated in a special language, and are directlyexecutable by a set of functions (LISP, in our implementa-tion).
Although the phrase attributes and features they canrefer to are similar, to some extent, to what is done in certainother systems (see for example \[Nagao 86\]), it seems thataction rules are more-flexible and powerful than static form-oriented structures.
In fact, each statement in the set of ruleswhich comprises a given lexical entry defines a correspondencebetween a syntactic environment (with semantic decoration) inthe source language and a translation into the target language.Consider, for example, one of the four rules which comprisethe entry for the verb "avoid" in the English-ilebrew lexicon.This particular ule identifies the case where the current verbnode (CN) has a postmodifier noun phrase and the head nounof that noun phrase has the semantic attribute Animate (e.g.
"She avoids her old father.").
In that case the Hebrew trans-lation should be "r~ pr3rEn~".
In terms of the lexicon specifica-tion language and the attributes used by the PEG parser, therule looks as follows:If ( CN has Postbrother ((CAT NP)(ANIMATE +)) )Then < Put (HEB "13 p~nnn" ) ;>;The put instruction attaches the tlebrew translation as afeature on the current node (CN is the default node assumedwhen no explicit node name is specified for put).Certain lexical rules can be simply and elegantly formulated interms of functions which identify grammatical relations ofvarious kinds.
Thus, for example, the rule for translating theverb "return" can be specified in terms of the feature Passive,and the presence or absence of a direct object.
The set of ruleswhich follows makes the required istinction between the erga-tive (intransitive) sense and the transitive reading of the verb:Start RETURN VERB1 If (call OBJECT) Then < Put (HEB ""l~tl'l,"l" );end;> ;@ Example: Ron returned the book.
@ Example: The book was returned.2 Put (ItEB "'tin" );@ (this is the default ranslation)@ Example: Ron returned early.FinishIdeally, the feature OBJECT could be defined as part of theinformation provided by the parser.
However, if for somereason the parser does not identify such relations, it can bedefined as a function, written in the lexicon specification lan-guage described in this paper, which will evaluate the parsetree during Transfer.
An example of such a function, which isincluded as a utility function in the active bilingual lexiconsystem, is given in \[Golan 88\], an extended version of thispaper.
This function tests a tree for the presence of a constit-uent which is the direct object of a given verb.
If the verbappears in the passive voice, it assumes existence of a directobject (note that the active voice is selected for the ltebrewequivalent even in the passive case; passivization is done laterin Generation).It may be necessary to define functions which identify morecomplex grammatical relations than the direct object of agiven verb.
It is, for example, necessary to refer to the relation'head noun argument, with property P, of an adjective', whenformulating the rule for an adjective like "available":Start AVAILABLE ADJIf (Call N-of-ADJ (HUMAN))Then < Put ( I tEB"~I~") ;>@ Example: The doctor is not available now.
@ Example: Any available salesperson can help you.Else < Put (HEB "~l~lr3" ); > ;@ Example: This book is available in every store.FinishThe algorithm N-of-AD.I, given in detail in section 6 below,characterizes a parameterized function which identifies thehead noun argument, with property P, of a given adjective.This algorithm is written in the lexicon specification languageand is also included as a utility function in the lexicon system.Rules which employ this function can render the translation ofan adjective dependent upon the modified noun phrase havingspecific attributes.
It should also be noted that the functionN-of-ADJ identifies the noun when the adjective acts as a pro-nominal modifier as well as when it appears in the VP predica-tive form.It is important o recognize that functions of this kind areuseful to the extent hat they can be employed in a significantnumber of lexical rules.
There are, however, many cases inwhich the translation rules must be formulated directly assearch procedures on trees.
There are no obvious generalgrammatical functions which can be used to define the syn-tactic relations that must be tested in order to determine trans-lation in these cases.
Consider, for example, the set of rules forthe adverb "precisely":Start PRECISELY ADVERB1 If (CN has ancestor((CAT NP PP)))Then < Put (IIEB "p~,'l't" );end;> ;@ Example: This is precisely the question.
@ Example: Rina spoke precisely to the point.2 Put (tlEB "p~rll3a" );@ Example: Ron formulated his answer precisely.FinishThe disjunctive relation of being the descendent of either anNP or a PP does not seem to be the sort of grammaticalrelation which one would wish to encode in a general gram-matical function.Similarly, consider the set of rules below, which are part of thedefinition of the verb "allow".
The case where this verbappears in an active voice and forms part of the verb-particleconstruction "allow for" are identified by searching the tree forthe preposition "for" which may be the head of a possibly non-adjacent PP:1 If ( CN has First Postbrother (name-l((CAT PP))has Son name-2C(CAT PREP)(base "for"))))Then < Put (IlEB "l~a'~na np'~" );Put in name-2 (11EB "");end; > ;@ Example: Ron allowed for the results.2 If ( CN has Postbrother (A((CAT AVP))has Descendent (name-l((CAT PREP)(base "FOR"))before B((CAT NP)))))Then < Put (HEB "l~a'~na np~" );Put in named (I IEB "");end; >;@ Example: Ron allowed reluctantly and cautiously@ for the results.In fact, the basic need to look for a nonoadjacent particle israther common.
It may justify inclusion of generalized206relations in the lexicon formalism.
A generalized notion of"postbrother" will enable the statement of the sense distinctionabove as one rule.
However, the detailed design of such gener-alized relations is very complex and is not yet included in ourmodel.The "allow for" example presents yet another problem fortranslation.
The Ilebrew translation "llaton3.
tlptJ " consists oftwo words which have individual verb and noun entries in theTL  lexicon.
If the target translation is a recognized collocationor idiom it can be specified as such in the TL lexicon.
Butthere are cases where an SL entry must be rephrased in the'FL as an ad-hoc combination of words which does not form alexical entity.
In that case the lexical rule must mark wordswith corresponding parts of speech, or provide alternativeinformation which will serve later in Generation to properlydecide on the required morphological manipulation.Generally, our experiments with actual lexical entries lead usto believe that the most efficient strategy for formulatinglexical rutes is to use a combination of general functions andrule-specific search procedures.
A formal description of thespecification language and a detailed example of its expressivepower am given in sections 5 and 6 below.Tire creation of a large scale full-fledged BL lexicon is a veryheavy tar;k, impeding development of product level systems.There is no way to avoid it, but there are ways to facilitate thepractical development of the lexicon by making the processmore modular.
The scheme presented in this paper enables thesystem lexicographers - and each individual user - to proceedin steps.
As a first, rough, approximation, one may sinrplydefine one "default ranslation"; e.g., for the verb "type":Start TYPE VERB Put (\[IEB "'o~9"r~" ); FinishThis will account for the use of "type" in the sense of "type-write".
Later, other senses can be defined (e.g.
"),ll~ro", for"classify"), going from the most frequent in a given context tothe relatively rare ones, thus achieving an increasingly refinedlevel of sense specification.
The optimal level of detail maydepend on user needs and on specific text domains.
In fact, dif-ferent sense distinctions may be required for different domains.The user can modify the lexicon accordingly, or define his/herown private addenda lexicon, overriding identical entries in themain lexicon.The lexicon of the system is accessible to revision by users.l-lowevel, users cannot modify the global transformationswhich map syntactic structures in tile St. into those of the TL,nor can they interfere with morphological aspects of Gener-ation (TL values in the bilingual lexicon are given in a canon-ical form; e.g.
for ttebrew verbs: 3rd person - singular - pasttense - active voice).
Consequently, user influence is con-strained in such a way that it cannot disrupt the functioning ofthe large scale architecture of the system, but can at mostaffect lo?al changes of a lexically based nature.This is one obvious advantage of the strict separation betweenbilingual lexical transfer and general phrase structure transf-ormations.
Another benefit of this approach is the restrictionof the structures that must be considered for transformationsto standard, non-distorted SL phrase structures, as providedby the SL parser.
This eliminates complications and loss ofgenerality of the structural transformations.
Also, from asoftware engineering perspective, it is clearly advantageous tokeep the two sub-processes independent of each other.llowew~r, the extent to which this separation can be main-tained is not evident.
In certain cases, e.g.
when there is nosimple way to preserve tire part of speech in translation, lexi-con-driven modifications of the phrase structure could facili-tate the process.
In such cases, which are fortunately not verycommon, we will consider attachment of "transformationtriggers" to nodes, based on the bilingual lexicon processing.Technically, this can be easily done in our specification for-realism.
The lexical phase itself will not make any changes inphrase structure, and only one pass of structural transf-ormations will still be required.Indeed, as \[Melby 86\] points out, the whole issue of lexicaltransfer and in particular the effect lexical transfer has on theoverall quality of translation deserves further study.3.
Sense  D is t inc t ion  Character i s t i csThe highest level of distinction in the bilingual lexicon is thepart of speech.
Within each part of speech one may distinguishdifferent senses (and specify lexical rules) as required in lightof TL sense distinctions.
According to one initially plausibleview, it is possible to make use of the subcategorization infor-mation present in standard monoliugual dictionaries to obtainthe necessary syntactic information for disambiguating dif-tcrent senses of words in the SL.
In fact, we have found thisview to be untenable.
Thus, for example, among the 13 sensesthat \ [ l .ongman 78\] distinguishes for the verb "hold", many aremapped to the ltebrew verb "p~trl,-l", even when they belongto diffelent syntactic categories as defined in l .ongmanssystem.
On the other hand, consider the different uses of"hold" in the following sample sentences:- She is holding tile baby- We held our breath in fearWe were holding a meetingAlthough l .ongman makes a distinction between the threesenses (cases 1,3, and 13, respectively), all of them are classi--tied as TI verbs according to Longman's coding system, whichis the only feasible instrument for cornputer reference, h-tl lebrew, different w.qbs nmst be used ("p~tlnW, " '1t1~",  "t3~rF)" ,respectively).
Moreover, even under the same sense (10), tw~sample sentences are given, which in ltebrew require differc~ltverbs:What he said still holds ("qprr')- Can the good weather hold'?
("'l~Nr3n ")As a second example of the inadequacy of standard monolin-gual subcategorization, consider l .ongman's class of T3 verbs .-verbs which take infintival complements with "to" and NPobjects.
E.g.
:want Ron to winask Ron to leavetell Ron to comellowever, each of the corresponding \[lebrew verbs has a dis.tinct subeategorization frame:- "lnSll~ l~l~ n~2tl ?
(want that Ron will win)- ":a~tg~ \]Ytt3 ~p:at3" (ask from Ron to leave)- "R~ttt~ lrtt~ lrJlR" (tell to Ron to come)Note that the form-.
"a~ty, I13~9 ~par3" (ask that Ron will leave)is also valid ill Ilebrew, but as a translation of "ask that Ronleaves" rather than "ask Ron to leave".
Therefore, Transfeland not Generation seems to us the natural place to decide onthe appropriate form.207These, examples illustrate the lack of isomorphism betweensubcategorization patterns for specific verbs in English andtheir counterparts in Hebrew.
It is reasonable to expect that,generally, subcategorization is not invariant under translationbetween most SL-TL pairs (cf e.g.
\[Warwick 87\]).
As \ [Nagao86\] points out, "it is not exceptional, but rather usual, that averb of SL has to be translated into different target lexicalitems, even though the native speakers of SL cannot clearlyrealize the meaning difference".
Consequently, we have foundit useful to construct algorithms which map lexical items, con-sidering subcategorization properties and sense distinctions ofboth SL and TL.
This is especially useful for verbs, but thesame specification formalism is used for all other lexical cate-gories, making use of syntactic information in different ways.We anticipate that the construction of a large scale lexicon willbe facilitated by the existence in the SL of subclasses of items,in each lexical category, which have identical or highly similarsubcategorization frames, and which correspond to items inthe TL with similar frames.
The entries for the elements ofsuch subclasses can be handled by algorithms whose state-ments have more or less the same selection conditions.In constructing the BL lexicon of our system we have followeda lexicalist view of syntax.
In particular, our view of the inter-action of the syntactic omponent and the lexicon in Transferis inspired by the projection principle \ [Chomsky 1981\].
Thisprinciple states that the syntactic structure of a phrase (at anylevel of representation) !s a projection of the argument struc-ture imposed by the lexical entry of the head of the phrase.Mapping of a lexical item in the SL onto a counterpart in theTL depends upon a matching of the subcategorization framesof the two items.
This matching requires recognition of an SLitem in a tree as the head of a sub-phrase which satisfies theargument structure specified by the antecedent conditions ofone of the statements in its lexical entry.
Translation of anysub-clause begins with its head, as this determines the argu-ment structure of the clause.It is necessary to qualify this characterization f our approachin an important respect.
Although our algorithms are statedprimarily in terms of the syntactic information provided by theparser, we have found it necessary to supplement this informa-tion with a restricted list Of general semantic features.
Forexample, consider the verb "run".
On its intransitive use, ittranslates into l lebrew as "p~", while its transitive use corre-sponds to the ttebrew causative verb "~,"1".
l lowever,intransitive "run" allows certain NP adverb complements, as in"run a mile".
To identify these NPs as adverbial phrases andso preserve the intransitive sense of "run", we attach attributesTime or Distance to the entries of nouns like "time" and "mile"in the SL lexicon.
The algorithm for "run" can then recognizeit as having its intransitive sense when it takes only one com-plement and the head N of this NP contains one of these attri-butes.
Features such as 1 luman/Non-human,Concrete/Abstract, etc., and a small number of domain specificfeatures (e.g.
hardware device, software component, state, etc.,for the domain of computer manuals) are also included.There is yet another kind of feature marker that we include inthe SL lexicon, and which we call "list marker".
These markersassist disambiguation in cases where a few nouns can begrouped together, usually for computational efficiency,although their common denominator has no obvious name.For example, in the sense distinction for the verb "assume", ifthe complement is an NP with a noun in the set \[office, chair-manship, position,...\], then the ttebrew verb-equivalent is dif-ferent from other sub-cases of "assume".
We give this groupof nouns a name and mark the nouns in the group accord-ingly.
Then one can refer to this name as a feature.
Indeed,nouns in such groups have semantic similarities, and in prin-ciple, they are equivalent to traditional semantic markers.
Thepoint is that list markers can be formed in an ad-hoc fashion,without worrying about the generality of the group, or findingan appropriate label for it.The different mechanisms presented above provide, in fact,various levels of characterization of the relation between agiven verb and a noun (or an NP) to which it refers: subcat-egorization requirement for the very existence of a noun (NP)in a given position (e.g.
as a direct object); a more constrictingrequi~ement for the existence of a noun with specifiedsemantic features (defined as such, or by means of lists, in theSL lexicon); and a particular equirement for the existence of aspecific noun (or group of nouns).The sense distinction for multi-sense nouns (homonyms andpolysemes) and other parts of speech is done according to bas-ically the same strategy which we use for verbs; namely appli-cation of context-sensitive differentiating rules.
Generally,nouns and adjectives are less ambiguous for translation, butthe ambiguity, when it exists, is more difficult to resolve at thesentence level without extensive semantic and pragmatic know-ledge.
Still, many cases can be resolved by rules of the kindshown above.
For example, although nouns, unlike mostverbs, do not require complement structures, disambiguationin the source language can sometimes be facilitated by ruleswhich refer to the presence of optional N complements.
Con-sider, for example, the noun "statement".
When it has a 'that'S' complement ("a statement that Rina has been promoted") ittranslates to l lebrew "~9~ra~ " when it occurs with a PP com-plement headed by "of" with an NP object headed by an inani-mate noun ("statement of the theory"), it translates to "tq~Xg~:l".When sense distinction cannot be expressed in terms of oursystem (e.g.
for the homonymous noun "bank"), we specifyonly the more common sense in the given text domain.
In thefuture, we may mark such cases so that the information aboutthe lexical ambiguity can be made available to an interactivedisambiguation module.For adjectives, the characterization is done in most cases byreference to semantic features of the noun(s) they modify.
Insome cases different ranslations will be required for an adjec-tive when it appears as a prenominal modifier or in the VPpredicative form:- My old friend is not old"lpt '0~R ~9~9 p~ln  "1:lrlWThe syntactic distinction between the two forms of "old", andthe selection of the different \[lebrew equivalents ("IPt","p~rn'), are easy to specify in our formalism (cf.
the definitionof N-of-ADJ in section 6 below).4.
Some Methodo log ica l  AspectsFrom the discussion and examples above, it is apparent hatour lexicon specifies bilingual information in great detail.
Thismay seem to conflict with certain modern approaches toTransfer methodology, where the guiding view is "small (andsimple) is beautiful".
\[lsabelle 86\], \[Arnold 87\], and others,advocate an approach where the BL lexicon states only factslike:208know -> wissen (in German; or "savoir" in French;or "n9~9" in I lebrew,when the verb takes a sentential object)know -> kennen (ill German; or "conaitre" in French;or "'1~3,'19" in t lebrew,when the verb takes a nominal object)The selection of the correct translation is then done in theGeneration t/hase, based on restrictions on tile target language.We claim that this approach is problematic for the followingreasons.First, the "know" example, although widely quoted in the liter-ature, is rather simplistic.
Even in the monolingual subcategor-ization for "know" in \ [Longman 78\], there are 15 differentframes, re:my of which require a different verb, or verb-form,use of a preposition, or even a completely different syntacticstructure in I lebrew.
Ill addition, there are verb-particle andother collocations which would be quite difficult (and unna-tural) to handle if decisions were postponed to the monolin-gual Generation ("know of", "know better", "know X to beY", are some examples which hold not only for 1 lebrew).
It isnot single words but patterns and structures that must behandled sirnuitaneously.Second, one should note that the mechanism presented in thispaper may also, ill principle, be applied to Generation ratherthan TransDr; the conditions will then be stated in terms oftile target language.
By the same token, certain differentiatingrules may be also applied as part of Analysis (or post-Ana-lysis), t lowever, we feel that the right place for this kind ofprocessing is in Transfer.
At least when the target and sourcelanguages are linguistically renlote (as, for example, in the caseof English and l lehrew), severely restricting the scope of BLoperatimls may result in loss of information vital for trans-lation on the way to Generation; e.g.
dependence on tense orvoice, when tile structural expressions of these properties aredifferent irt the SL and TL.
Alternatively, such informationcould be carried forward to Generation, but then Generationloses its primarily monolingual nature.Allowing Transfer to pass forward alternative translations forSI~ lexical entries, may result in a large number of possiblesentence t~anslations which must be handled by Generation.Even if conceptually viable, this strategy is computationallyhighly unattractive.
A similar comment is often made in othercontexts (e.g.
Analysis - cf.
\[Stallard 87\]).Finally, it ~&ould be enlphasized that keeping Transfer small isnot, in itself, the crucial issue.
More important, it seems to us,is the isolation of bilingual considerations.
(Isolation shouldnot be mistaken for serialization of SI,-BL-TL operations,which is not at all required.
Ideally, isolated modules couldeven work in parallel, as suggested by \[Isabelle 86\]).
In fact,trying to minimize bilingual Transfer at any cost may yieldunnecessarily complex Generation and/or Analysis, which areforced to handle problems that are not inherently within theirscope.
If, for example, Generation has to consider patternsthat were .n ly  created by phenomena ill a certain source lan-guage but were not fully resolved in Transfer, then minimizingTransfer represents no real gain in nmdularity or languageindependence.
Nor does it save lexicographic effort, as in anycase, the linguistic classification and judgement processre,nains b:~.sically tile same, even if shifted to other systemcomponents.A remark is in order concerning multi-target generality.
Inprinciple, it is technically possible to add tags at tile put state-ment, along with the ItEB tag, to define multilingual trans-lations (cf.
e.g.
Boitet g6\]).
l lowever, from our discussion ofttre difference between monolingual subcategorization patternsand the sense distinctions needed for translation, it follows thatthe algorithms in the lexicon must be further refined in orderto cove," all sub-senses needed for a set of given target lan-guages.
For any one language in the set, many of the differen-tiating rules will be redundant (see "voir trad n" definitions in\[Boitet 86\]).
In practice, it would be better to construct dis-tinct variants of the lexicon for different arget languages.
Thisneed not significantly increase the lexicographic work required,as it is possible to use an existing lexicon as the basis for con-structing new variants.
The linguistic re-evaluation of senses isrequired anyway.
What is important is that all target languagesuse the same structure and formalism.5.
The  Spec i f i ca t ion  Language\[Slocum 87\] claims (correctly, ill our view) that "lexical entriesfor computer use tend to be \[ormally stated, compact, andthus cryptically encoded".
While the formal style is inevitable,we have tried to avoid compactness and cryptical expressionby allowing the lexicographer to state the lexical facts and theeffects they have on processing in terms that are directlyrelated to the logic of the linguistic process.
Therefore, tile setof available instructions i rather simple and intuitive.
We havetried to allow enough expressive power to support a variety ofrequirenlents for bilingual lexical mapping, while restrictingthe scope of operations as much as possible, to reduce com-plexity and avoid undesired side effects on other entries orsuhsystems.
We have also emphasized ease of maintenance andtesting, and strict isolation of the lexical subsystem from otherparts of the translation system.Each entry in tile bilingual lexicon is in fact a mini-program.Although executable declarations may look complicated at firstglance, they have, in our view, many advantages over a rigiddata structure.
The specification formalism may be less neatand "natural" than ttre metalanguage \[Isabelle 86\] hopes for,but it call be made more "user friendly" through the introduc-tion of higher level abbreviations on top of the basic language,as required by users.
Some functions for abbreviated writingwere mentioned in section :2 above.
Other mechanisms (e.g.macros) can be used to tailor the specification style to indi-vidual tastes.The program which comprises a lexical entry is initiated byreference to a lexical item that appears on tile Sl.
parse tree.The program ternlinates when an end instruction is reached,or when the last instruction in the program is executed.
Afunction is terminated by a return instruction.The instructions allow the lexicographer to check for the exist-ence of a |)articular condition or pattern on the parse tree byan appropriate /_f instruction; control tile seqnencing ofinstructions by using a goto instruction; and decide on a partic-ular translation for a word by using a put instruction (this isnot allowed in the case of a function).The following represents tile current inventory of lexieal oper-ations supported by the specification formalism.
It may benecessary to extend this formalism as more experience isgained with actual lexical entries.The syntax of the specification language is given below.
Boldletters denote non-terminal constructs, normal letters denoteterminals (keywords).
The notation used is as follows:209symbo l  descr ip t ion  symbol description= = a meta-symbol.
\ [ term\]I a meta-symbol denoting choice.
(term) +nil a representation of the null string or list.
(term)*( )  < > ; terminals.program = = start access-key statement + finishstatement = = \[label :\] instructionuric or no appearance of term.one or more appearances of term.zero or more appearances of term.instruction = = end; I goto(label); I put \[in u-name\] (allowed-attribute value); I call function-name(parameter-list); Iif (condit ion)then < instruction + > \[else < instruction + > \];function-name = = user-delined-\[unction-name \[ pr -defined-\[unction-nameuser-defined-function = = define user-delined-\[unetion-name In-statement + finishhi-statement = = \[label :\] \[n-instructionfn-instruction = = goto(label); I return(true); I return(false); I call pre-defined-function-name(parameter-list); Iif (condit ion)then < \[n-instructio n + > \[else < \[n-instruction + > \];condition = = call fimction-name I simple-pattern \[ not (condition) L (condition) and (condition) I (condition) or (condition)simple-pattern = = n-name(attribute-pair +)  I n-name has \[ no \] relation patternpattern-condition = = node has \[ no \] relation patternnode : = \[n-name\](attribute-pair +)  I n-namerelation : = \[f irst\] prebrother I \[f irst\] postbrother I \[f irst\] son i father I ancestor \[\ [ last\]  prebrother \[\[ last\] postbrother \[\[ last\] son I descendent I relativepattern = = simple-pattern-condition { (pattern-condition) I (pattern \ [not \ ]  before pattern) I (pattern \ [not \ ]  after pattern)simple-pattern-condition = = node I (node,) + node \[ (node or node) \] (node and node)u-name = = main I cn \] nameparameter-list = = nil i parameter +attribute-pair = = (attribute-name value +)value = = string \[ key I ( value + )label : = Ilanleaccess-key = = lexical item followed by part of speech.attribute-name = = nameallowed-attribute = = an attribute-name the user is allowed by the system to change.pre-defincd-function-name = = a name of a function defined by the system.user-defined-function-name = = namename = = a string of letters and digits starting with a letter.parameter = = a parameter passed to a function.comment = = each line starting with @ is a comment.210The programs and functions in the dictionary include namesfor various entities.
The scope of these names is limited asmuch as possible in order to facilitate debugging and mainte-nance (e.g.
a name of a label or of a particular pattern (node)is recognized only within the program in which it appears).The user's ability to define variables and names is also inten-tionally restricted.
There are two special names: MAIN, thename of the root of the parse tree; and CN (Current Node),the name of the leaf node representing the word for which theprogram wa:; invoked.Additional information about the semantics Of names, a formaldefinition of the relations between odes (e.g.
prebrother, firstprebrother, descendent, relative, etc.)
and the keywords Beforeand After, etc., are provided in \[Golan 88\], an extendedversion of this paper.6.
An Additional ExampleThe following is the function N-of-ADJ, introduced in section2 above, which identifies the head noun argument, with prop-erty P, of a given adjective.
It is a somewhat simplified versionwhich deals with the major relevant phrase structures.
It isgiven here mainly to illustrate the expressive power of the spe-cification folmalism as a general tool for pattern matching onparse trees.Define N-of.
ADJ@ The funclion N-of-ADJ returns a True/False value@ The parameter P refers to a feature that can get +/- valuesIf (CN has Ancestor ( A ((CAT AJP)) has PostbrotherF((CAT NP NOUN)(P +))))Then < Return(True); > ;@ John is an old and valued friend.
@ John spoke to many old and valued friends.If (CN has Ancestor (A((CAT AJP)) has PrebrotherF((CAT NP NOUN PRON) (Wtl nil)(P +))))Then < Return(True); > ;@ John is very old,@ Mary is very old and tired.If (CN has Ancestor ( A ((CAT QUES)) has First SonF ((CAT NP PRON)(WH l))))Then < If (F ((P +))) Then < Return(True);>Else < Return(False); > ; > ;@ Who is competent?
@ Who does John expect o seem old?
@ What does John expect o seem old?If (CN has Ancestor B((CAT INFCL)))Then < If(((B has PrebrotherF ((CAT NP NOUN PRON)(WH nil)(P +)))or (B has Father ( C ((CAT AJP)) has PrebrotherF ((CAT NP NOUN PRON)(WH nil)(P +)) ) ) )or (B has Father ( C ((CAT INFCL)) has PrebrotherF ((CAT NP NOUN PRON)(WH nil)(P + )) ) ) )Then < Return(True); > ; > ;@ John wants to be rich and famous.
@ Bill is certain to be happy.
@ Mary wants to seem to be competent and punctual.5 If ( CN has Ancestor ( A ((CAT RELCL)) has PrebrotherF((CAT NOUN)(P + )))) Then < Return(True); > ;FinishReferences\[Arnold 87\] Doug Arnold and Louis des Tombe: "BasicTheory and Methodology in Eurotra", in Machine Translation.
"1fieoretical and Methodological Issues, Sergei Nirenburg (ed.
),Cambridge University Press, 1987.\[Biewer 85-1 Axel Biewer, Christian Feneyrol, JohannesRitzke and Ervin Stegentritt: "ASCOF - A Modular MultilevelSystem for French - German Translation", Computational Lin-guistics, vol 11, no.
2-3, April-September 1985.\[B0itet 86 \ ]  Christian Boitet and N. Nedobejkine: "TowardIntegrated Dictionaries for M(a)T", Proe.
of COLING'86,Bonn, August 1986.\[Chomsky 81\] Noam Chomsky: Lectures on Government andBinding, Foris Publications, Dordrecht, Holland, 1981.\[Culling\[ord 87\] Richard E. Cullingford and Boyan A.Onyshkevych: "An Experimentation in Lexical-drivenMachine Translation", in Machine Translation.
712eoretical ndMethodological Issues, Sergei Nirenburg (ed.
), Cambridge Uni~versity Press, 1987.\[Golan 88\] Igal Golan, Shalom Lappin and Mori Rimon:"An Active Bilingual Lexicon for Machine Translation", Tech-nical Report 88.242, IBM Israel Science and Technology, July1988.\[Isabelle 86\] Pierre lsabelle and Elliott MackIovitch:"Transfer and MT Modularity", Proc.
of COLING'86, Bonn,August 1986.\[Jensen 86\] Karen Jensen: PEG 1986: A Broad-coverageComputational Syntax of English, Technical Report, IBM T.J. Watson Research Center, February 1986.\[Longman 78\] Longman Dictionary of Contemporary Engfish,Longman Group lad., Harlow and London, England, 1978(1986 edition).\[Melhy 86\] Alan K. Melby: "Lexieal Transfer: a MissingElement in Linguistic Theories", Proe.
of COIANG'86, Bonn,August 1986.\[Nagao 86\] Makato Nagao and Jun-ichi Tsujii: "TheTransfer Phase of the Mu Machine Translation System", Proc.of COLING'86, Bonn, August 1986.\[Slocum 87\] Jonathan Slocum and Martha Morgan: "TheRole of Dictionaries and Machine-Readable L xicons in Trans-lation", International Lexicon Workshop, Stanford, July-Au-gust 1987.\[Stallard 87\] David Stallard: "The Logical Analysis ofLexical Ambiguity", 25th Annual Meeting of the ACL, Stan-ford, July 1987\[Warwick 87\] Susan Warwick: "Automated LexicalResources in Europe", International Lexicon Workshop, Stan-ford, July-August 1987.211
