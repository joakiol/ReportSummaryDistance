THE DESIGN OF THE KERNEL ARCHITECTURE FOR THE EUROTRA* SOFTWARER.L.
Johnson**, U.M.I.S.T., P.O.
Box 88, Manchester M60 IQD, U.K.S.
Krauwer, Rijksuniversiteit, Trans 14, 3512 JK Utrecht, HollandM.A.
RUsher, ISSCO, University of Geneva, 1211 Geneve 4, SwitzerlandG.B.
Varile, Commission of the European Conm~unities, P.O.
Box 1907, LuxembourgABSTRACTStarting from the assumption that machinetranslation (MT) should be based ontheoretically sound grounds, we argue that,given the state of the ar t ,  the only v iab lesolution for the designer of software tools forMT, is to provide the linguists building the MTsystem with a generator of highly specialized,problem oriented systems.
We propose that suchtheory sensitive systems be generatedautomatically by supplying a set of definitionsto a kernel software, of which we give aninformal description in the paper.
We give aformal functional definition of its architectureand briefly explain how a prototype system wasbuilt.I.
INTRODUCTIONA.
Specialized vs generic software tools for MTDeveloping the software fo r  a spec i f i c  taskor class of tasks requires that one knows thestructure of the tasks involved.
In the case ofMachine Translation (MT) this structure is not apriori known.
Yet it has been envisaged in theplanning of the Eurotra project that thesoftware development takes place before ageneral MT theory is present.
This approach hasboth advantages and disadvantages.
It is anadvantage that the presence of a softwareframework will provide a formal language forexpressing the MT theory, either explicitly orimplicitly.
On the other hand this places aheavy responsibility on the shoulders of thesoftware designers, since they will have toprovide a language without knowing what thislanguage will have to express.We are grateful to the Commission of theEuropean Communities for continuing supportfor the Eurotra Machine Translation projectand for permission to publish this paper;and also to our colleagues in Eurotra formany interesting and stimulatingd iscuss ions .
** order  not  s ign i f i cantThere are several ways open to thesoftware designer.
One would be to create aframework that is sufficiently general tosccomodate any theory.
This is not veryattractive, not only because this couldtrivially be ach ieved  by selecting anyex is t ing  programming language,  but  a l sobecause  th i s  would not  be of  any he lp  fo r  thepeople doing the linguistic work.
Another,equally unattractive alternative would be toproduce a very  spec i f i c  and spec ia l i zedformalism and offer this to the linguisticcommunity.
Unfortunately there i s  no way todec ide  in a sensible way in which d i rec t ionsthis formalism should be specialized, andhence it would be a mere accident if thedevice would turn out to be adequate.
What isworse, the user of the formalism would spend acons iderab le  amount of h is  time t ry ing  toovercome its deficiencies.In other words, the difficulties that facethe des igner  of such a software system is thatit is the user of the system, in our case thelinguist, who knows the structure of theproblem domain, but is very often unable toarticulate it until the language for thetransfer of domain knowledge has beenestablished.
Although the provision of such alanguage gives the user the ability to expresshimself, it normally comes after fundamentaldecisions regarding the meaning of thelanguage have been frozen into the systemarchitecture.
At this point, it is too lateto do anything about it: the architecture willembody a certain theoretical conTaitment whichdelimits both what can be said to the system,and how the system can handle what it istold.
This problem is particularly severewhen there is not one user, but several, eachof whom may have a different approach to theproblem that in their own terms is the bestone.This requires a considerable amount of\[!exibility to be built into the system, notonly within a specific instance of the system,but as well across instances, since it is tobe expected that during the construction phaseof an MT system, a wide variety of theorieswill be tried (and rejected) as possiblecandidates.226In  o rder  to  best  su i t  these  apparent lyconf l i c t ing  requ i rements  we have taken thefo l low ing  des ign  dec is ions  :1.
On the one hand, the so f tware  to  bedes igned w i l l  be or iented  towards a c lass  ofabstract systems (see below) rather than onespecific system.
This class should be sores t r i c ted  that  the dec is ions  to  be taken dur ingthe l ingu is t i c  development of  the end usersystem have d i rec t  re levance  to the l ingu is t i cproblem domain, wh i le  power fu l  enough ~oaccommodate a var ie ty  of  l ingu is t i c  s t ra teg ies .2.
On the o ther  hand, jus t  spec i fy ing  ac lass  of  systems would be insu f f i c ient ,  g ivenour expectat ion  that  the h igh ly  exper imenta lnature  of  the l ingu is t i c  development phase w i l lg ive r i se  to  a vas t  number of  exper lmenta lins tant ia t ions  of  the system,  which should  notlead to  cont inuous ly  c reat ing  complete ly  newvers ions  of  the system.
What is  needed is  acoherent  se t  of  so f tware  too ls  that  enable  thesystem deve lopers  to  adapt  the system to  changeswi th  a minimal amount of  e f fo r t ,  i .
e .
a sys temgenerator .Thus, we re jec t  the view that thearch i tec ture  shou ld  ach ieve th i s  f lex ib i l i ty  bys imply  evading theoret i ca l  commitment.
Ins teadi t  shou ld  be capable  of  d i sp lay ing  a whole rangeof  h igh ly  spec ia l i zed  behav iours ,  and there forebe capab le  of  a h igh degree of  in terna lreconf igurat ion  accord ing  to externa l ly  supp l iedspec i f i ca t ions .
In o ther  words we aim at  asystem which is  theory  sens i t ive .In our ph i losophy  the reconf igurat ion  ofthe system should  be ach ieved by supp ly ing  thenew spec i f i ca t ions  to the system rather  than toa team in charge of  redes ign ing  the sys temwhenever new needs fo r  the user  a r i se .There fore  the par t  of  the sys tem that  is  v i s ib leto the l ingu is t i c  user  w i l l  be a sys temgenerator ,  ra ther  than an ins tance  of  an MTsystem.B.
Computat iona l  Paradigm for  MT Sof twareThe computat iona l  paradigm we have chosenfo r  the systems to be generated  i s  the one ofexper t  systems because the des ign  of  so f twarefo r  an MT system of  the scope of  gurot ra  hasmuch in common wi th  the des ign  of  a very  la rgeexper t  system.
In  both cases  success fu loperation relies as much on the ease with whichthe specialist knowledge of experts in theproblem domain can be communicated to  and usedby the sys tem as on the programming sk i l l  o f  theso f tware  des igners  and implementers .
Typ ica l ly ,the des igners  of  exper t  systems accommodate theneed to incorporate  la rge  amounts of  spec ia l i s tknowledge in a f lex ib le  way by a t tempt ing  tobu i ld  in to  the system des ign  a separat ionbetween knowledge of  a domain and the way inwhich that  knowledge is  app l ied .
Thecharacter i s t i c  a rch i tec ture  of  an exper tsystem is  in the form of  a P roduct ion  System(PS)(c f  Davis & King 1977).A progranuuing scheme is  convent iona l lyp ic tured  as hav ing two aspects  ( "A lgor i thms +Data = Programs")  - -  ( c f  Wirth 1976); ap roduct ion  system has three  : a data  base ,  aset  of  ru les  (somet imes ca l led  'p roduct ions '- -  hence the name), and an in terpreter .
Inputto  the computat ion  is  the in i t ia l  s ta te  of thedata  base .
Rules cons is t ,  exp l i c i t l y  orimp l i c i t l y ,  of  two par ts  : a pat tern  and anact ion .
Computat ion proceeds  by progress ivemod i f i ca t ions  to  the  data  base as thein terpreter  searches  the data  base anda t tempts  to  match pat terns  in ru les  and app lythe cor respond ing  act ions  in the event  of  asuccess fu l  match.
The process  ha l t s  e i therwhen the in terpreter  a t tempts  to app ly  aha l t ing  ac t ion  or  when no more ru les  can beapp l ied .Th is  k ind of  o rgan isat ion  i s  c lear lya t t rac t ive  fo r  knowledge-based computat ions .The data  base  can be set  up to model ob jec tsin the problem domain.
The ru les  representsmal l ,  modular  i tems of  knowledge, whosesyntax  can be ad jus ted  to  re f lec t  fo rmal i smswi th  which exper t  users  are  fami l ia r .
And thein terpreter  embodies a genera l  p r inc ip le  aboutthe appropr ia te  way to  app ly  the exper tknowledge coded in to  the  ru les .
Given anappropr ia te  problem domain, a good exper tsys tem des ign  can make i t  appear  as i f  thes ta tement  of  exper t  knowledge is  ent i re lydec la ra t ive  - -  the idea l  s i tuat ion  from theuser ' s  po in t  o f  v iew.A major  aim in des ign ing  Eurot ra  has beento  adapt  the essent ia l  dec la ra t ive  sp i r i t  ofp roduct ion  systems to the requ i rements  of  asys tem for  la rge  sca le  machine t rans la t ion .The reason  fo r  adapt ing  the arch i tec ture  ofc lass ica l  exper t  sys tems to  our  spec ia l  needswas that  the s imple  product ion  system schemei s  l i ke ly  to  be inadequate  fo r  our purposes .In  fac t ,  the success  of  a c lass ica l  PSmodel in a g iven domain requ i res  that  a numberof  assumpt ions  be sat i s f ied ,  namely:1. that  the knowledge requ i red  can beappropr ia te ly  expressed  in the form ofp roduct ion  ru les ;2. that  there  ex is ts  a s ing le ,  un i fo rmpr inc ip le  fo r  app ly ing  that  knowledge;3. f ina l ly ,  that  the pr inc ip le  of  app l i ca t ioni s  compat ib le  w i th  the  natura l  express ion  ofsuch knowledge by an exper t  user .227In machine translation, the domain ofknowledge with which we are primarilyconcerned is that of language.
With respect toassumption (I), we think automatically ofrewrite rules as being an obvious way ofexpressing linguistic knowledge.
Some cautionis necessary, however.First of all, rewrite rules take on anumber of different forms and interpretationsdepending on the l ingu is t i c  theory  w i th  whichthey are assoc ia ted .
In the s imples t  case ,  theyare mere ly  c r i te r ia  of  the we l l - fo rmedness  ofstrings, and a co l lec t ion  o f  such ru les  iss imply equ iva lent  to a recogn i t ion  dev ice .Usually, however, they are also understood asdescribing pieces of tree structure, although insome cases -- phrase structure rules inparticular -- no tree structure may beexplicitly mentioned in the rule: a set of suchrules then corresponds to some kind oftransducer rather than a simple acceptingautomaton.The point is that rules which look the samemay mean different things according to what isimplicit in the formalism.
When such rules areused to  dr ive  a computat ion ,  everything which isimp l i c i t  becomes the respons ib i l i ty  o f  thein terpreter .
This  has two consequences  :a. if there are different interpretations ofrules according to the task which they aresupposed to perform, then we need differentinterpreters to in terpret  them, which iscontrary to assumption (2); an obvious case isthe same set of phrase structure rules used todrive a builder of phrase structure trees givena string as input, and to drive an integritychecker given a set of possibly well-formedtrees;b. alternatively, in some cases, informationwhich is implicit for one type of interpretermay need to be made explicit for another,causing violation of assumption (3); an obviouscase here is the fact that a phrase structureanalyser can be written in terms oftransductions on trees for a general rewriteinterpreter, but at considerable cost in clarityand security.Secondly, it is not evident that 'rules',in either the pattern-action or the rewritesense, are necessarily the most appropriaterepresentation for all linguistic description.Examples where other styles of expression maywell be more fitting are in the description ofmorphological paradigms for highly inflectedlanguages or the formulation of judgements ofrelative semantic or pragmatic acceptability.The organisational complexity of Eurotraalso poses problems for software design.
Quiteseparate strategies for analysis and synthesiswill be developed independently by languagegroups working in their own countries,a l though the resu l t s  of  th i s  decent ra l i sed  anddistributed development will ultimately haveto be combinable together into one integratedtranslation system.
What is more, newl anguages  or  sub languages  may be added at  anyt ime,  requ i r ing  new s t ra teg ies  and modes ofdescr ip t ion .Finally, the Eurotra software i s  intendednot only as the basis for a single, large MTsystem,  but  as a genera l  purpose  fac i l i ty  fo rresearchers  in MT and computat iona llinguistics in genera l .These extra considerations imposerequirements of complexity, modularity,extensibility and transparency not commonlyexpected of today's expert systems.The conclusion we have drawn from theseand similar observations is that theinflexible, monolithic nature of a simple PSis far too rigid to accommodate the variety ofdiverse tasks involved in machinetranslation.
The problem, however, is one ofsize and complexity, rather than of the basicspirit of production systems.The above considerations have led us toadopt the principle of a controlled productionsystem, that is a PS enhanced with a controllanguage (Georgeff 1982).
The elements of thevocabulary of a control language are names ofPSs, and the well-formed strings of thelanguage define just those sequences of PSapplications which are allowed.
The usersupplies a control 'grammar', which, in aconcise and perspicuous way, specifies theclass of allowable application sequences.
Ourproposal for Eurotra supports an enhancedcontext free control language, in which namesof user-defined processes act as non-terminalsymbols.
Since the language is context free,process definitions may refer recursively toother processes, as well as to gran~aars, whosenames are the terminal symbols of the controllanguage.A grammar specifies a primitive task to beperformed.
Like a production system, itconsists of a collection of declarativestatements about the data for the task, plusdetails of the interpretation scheme used toapply the declarative information to the database.
Again, as in a production system, it isimportant that the information in thedeclarative part should be homogeneous, andthat there should be a single method ofapplication for the whole grammar.
We departsomewhat from conventional productions systemphilosophy in that our commitment is todeclarative expression rather than toproduction rules.228The dev ice  of  us ing  a cont ro l  language tode f ine  the organ lsat ion  of  a co l lec t ion  ofgrs~muars prov ides  the user  w i th  a power fu l  too lfo r  s imu la t ing  the procedura l  knowledge inherentin const ruct ing  and tes t ing  s t ra teg ies ,  w i thoutdepar t ing  rad ica l ly  from an essent ia l l ydec la ra t ive  framework.An important feature of our designmethodology is the commitment to interactionwith potential users in order to delineate theclass of tasks which users themselves feel to benecessary.
In this way, we aim to avoid theerror which has often been made in the past, ofpresentin 8 users with a fixed set of selectedgenerally on computational grounds, which they,the users, must adjust to their own requirementsas best they can.II OVERVIEW OF THE SYSTEM GENERATORThe task  of  our  users  is  to  des ign  theproblem or iented  machine here  ca l led  "eurot ra" .Our cont r ibut ion  to th i s  task  is  to prov ide  themwi th  a machine 1 in terms of  which they canexpress  the i r  percept ion  of  so lu t ions  to  theproblem (bear ing  in mind a l so  that  we may needto accommodate in the fu ture  not  on lymod i f i ca t ions  to users ' s  percept ion  of  theso lu t ion  but a l so  to the i r  percept ion  of  theproblem i t se l f ) .I t  i s  c lear ly  unreasonab le  to  expect  usersto express  themse lves  d i rec t ly  in terms of  somecomputer ,  espec ia l l y  g iven the character i s t i cso f  the convent iona l  von Neumann computers  whichwe can expect  to be ava i lab le  in the inuuediatefu ture .
The normal s t ra tegy ,  which we adopt i sto  des ign  a prob lem-or iented  language which thenbecomes the users' interface to a specialpurpose virtual machine, mediated by a compilerwhich transforms solutions expressed in theprob lem-or iented  language in to  programs whichcan be run d i rec t ly  on the appropr ia tecomputer .
Funct iona l ly ,  can express  th i s  in thefo l low lng  way :We use the term "computer" to refer to aphys ica l  ob jec t  implemented in hardware ,wh i le  "machine" is  the ob jec t  w i th  which aprogrammer communicates.
The essence  ofthe task  of  des ign ing  so f tware  too ls  i s  tot rans form a computer in to  a machine whichcor responds  as c lose ly  as poss ib le  to  theterms of  the problem domain of  the user  fo rwhom the tools are written.eurot ra  = compi le r  : usd 2where usd s tands  fo r  "user  so lu t ionde f in i t ion" .
We can dep ic t  the arch i tec turegraph ica l ly  as :usdCOMPILER,Lsource text --~ COMPUTER --~ target textF ig .
1In  Symbols :( compi le r  : usd) : text  -9  textThe p ic ture  above is  c lear ly  s t i l l  anovers impl i f i ca t ion .
In  the f i r s t  p lace ,  sucha compi le r  would be enormous ly  d i f f i cu l t  towr i te  and mainta in ,  g iven the  t remendouscomplex i ty  of  the poss ib le  so lu t ion  space ofMachine Trans la t ion  problems which thecompi le r  i s  in tended to represent .
Secondly ,espec ia l l y  in the l ight  of  our  observat ionabove that  the users '  v iew of  the problemspace i t se l f  may change,  i t  would be veryunwise to  invest  enormous e f fo r t  in theconst ruct ion  of  a very  complex compi le r  whichmay turn  out  in the end to be const ructed  toaccept  so lu t ions  to  the wrong c lass  ofp rob lems.Fo l low ing  we l l -es tab l i shed  so f twareeng ineer ing  pract i ce ,  we can compensate fo rth i s  d i f f i cu l ty  by us ing  a compi le r  generatorto  generate  appropr ia te  compi le rs  ra ther  thanbu i ld ing  a complete new compi le r  fromscratch .
Apart  from making the ac tua l  p rocessof  compi le r  const ruct ion  more rap id ,  weobserve  that  use of  a compi le r  generator  hasimpor tant  benef i c ia l  s ide  e f fec ts .
F i r s t ly ,i t  enab les  us to  concent ra te  on the cent ra li ssue  of  language des ign  ra ther  than secondaryquest ions  of  compi le r  imp lementat ion .Secondly ,  i f  we choose a we l l -des ignedcompi le r  generator ,  i t  tu rns  out  that  thedescr ip t ion  of  the user  language which i sinput  to  the generator  may be very  c lose  to  anabst rac t  spec i f i ca t ion  of  the  language,  andhence in an impor tance  sense  a descr ip t ion  ofthe  potent ia l  of  the  user  machine.2 For  the  remainder  of  th i s  sect ion  we sha l luse the  notat ionx :y -~ zwith  the  in fo rmal  meaning of  "app l i ca t ion  o f  xto  y y ie lds  resu l t  z " ,  or  "execut ion  of  x w i thinput  y g ives  output  z" .229Af ter  the in t roduct ion  of  a compi le rgenerator  the p ic ture  of  our  a rch i tec ture  looksl l ke  th i s  (u ld  s tands  fo r  "user  languagedef in t ion" ;  CGstands  fo r  "compi le r  generator" ) :usduld ---~ CG ---9 COMPILERsource text -- ~ COMPUTER -- target textFig.
2In symbols :((CG : uld) : usd) : text -~ textFor many software engineering projects thismight be an entirely adequate architecture tosupport the design of problem oriented systems.In OUr case, however, an architecture of thiskind only offers a partial resolution of the twoimportant issues already raised above :incomplete knowledge of the problem domain, andcomplex i ty  of  the semant ics  of  any poss ib leso lu t ion  space.
The use of  a compi le r  generatorcer ta in ly  he lps  us to separate  the problem ofde f in ing  a good user  language from that  ofimplementing it.
It also gives us the veryimportant insight that the use of generators asdesign tools means that in optimal cases inputto the generator and formal specification of themachine to be generated may be very close oreven identical.
However, we really only areaddressing the question of finding anappropriate syntax in which users can formulatesolutions in some problem domain; the issue ofdef in ing  the semant ics  under ly ing  that  syntax ,o f  s ta t ing  fo rmal ly  what a par t i cu la r  so lu t ionmeans is  still open.We can perhaps make the point moreexplicitly by considering the conventionaldecomposition of a compiler into a parser and acode generator (cf, for example, Richards andWhitby-Strevens 1979).
The function of theparser is to transform a text of a programminglanguage into a formal object such as a parset ree  which is  syntact i ca l ly  un i fo rm and easy todescr ibe ;  th i s  ob jec t  i s  then t rans formed by thecode generator into a semantically equivalenttext  in the language of  the ta rget  machine.With in th i s  approach,  i t  i s  poss ib le  tocontemplate  an organ isat lon  which,  in la rgemeasure, separates the manipulation of thesyntax of a language from computation of itsmeaning.
Since the syntactic manipulation ofprogramming languages is by now well understood,we can take advantage of this separation toar r ive  at  formal  de f in i t ions  of language syntaxwhich can be used d i rec t ly  to generate  thesyntact i c  component of a compi le r .
The processof automatically computing the meaning of aprogram is, unfortunately much more obscure.Our task  is  rendered  doubly d i f f i cu l t  bythe fac t  that  there  is  no obv ious  re la t ionbetween the k ind of  user  program we can expectto have to t reat  and the s t r ing  of  von Neumannins t ruct ions  which even the most advancedsemant ica l ly  o r iented  compi le r  generator  i sl i ke ly  to  be tuned to produce.We can ga in  some ins ight  in to  a way roundth i s  d i f f i cu l ty  by cons ider ing  s t ra teg ies  l i kethe one descr ibed  fo r  BCPL (R ichards  andWhitby-Strevens, clt).
In this two-stagecompi le r ,  the input  program i s  f i r s tt rans la ted  in to  the  language of  apseudo-mach ine ,  known as O-code.
Theimplementer  then has the cho ice  ofimplement ing an O-code machine d i rec t ly  as anin terpreter  or  of wr i t ing  a second stagecompi le r  which t rans la tes  an O-code programin to  an equ iva lent  program which i s  runnab led i rec t ly  on ta rget  machine.
This  techn ique ,which is relatively well established, isnormally used as a means Of constructingeasily portable compilers, since only thesecond-stage intermediate code to target codetranslation need be changed, a job which isrendered much easier by the fac t  that theinput language to the translation is invariantover all compilers in the family.Clear ly  we cannot  adopt th i s  modeld i rec t ly ,  s ince  O-code in o rder  to beoptimally portable is designed as the languageof a generic stack-oriented yon Neumannmachine, and we have made the point repeatedlythat yon Neumann architectures are not theappropriate point of reference for thesemantics of MT definitions.
However, we canalso see the same organisation in a differentlight, namely as a device for allowlng us tobuild a compiler for languages whose semanticsare not necessarily fully determined, or atleast subject to change and redefinition atshort notice.
In other words, we want to beable to construct compilers which can compilecode for a class of machines, so as toconcentrate attention on f ind ing  the mostappropriate member of the class for the taskin hand.we now have a system architecture in whichuser solutions are translated into asyntactically simple but semantically ratherempty intermediate language rather than thenative code of a real computer.
We want to beable easily to change the behaviour of theassociated virtual machine, preferably byadding or changing external definitions of itsfunctions.
We choose to represent thismachine as an interpreter for a functionallanguage; there are many reasons for thischoice, in particular we observe here thatsuch machines are characterised by a verysimple evaluator which can even acceptexterna l  redef in i t ions  of itself and apply230them dynamica l ly ,  i f  necessary ;  they  typ ica l lyhave a very  s imple  syntax  - normal ly  composedon ly  of  atoms and tup les  - which i s  s imple  fo r  acompi le r  to  generate ;  and the funct ionde f in i t ions  have,  in programming terms,  a veryt rac tab le  semant ics  which we can exp lo i t  inident i fy ing  an ins tance  of  an exper imenta limplementat ion  wi th  a fo rmal  system def in i t ion .With the add i t ion  of  the in terpreters lmu la t ing  the abst rac t  machine,  our  in fo rmalp ic ture  now looks l i ke  th i s  :u ld - -~ CG- -~source  text --3usdCOMPILERINTERPRETER --~COMPUTERta rget  textF ig .
3or  in symbols :(INTERPRETER : ((CG:uld) : usd)) : text -~ textWe now turn  to the kind of  de f in i t ionswhich we sha l l  want to in t roduce  in to  th i ssystem.
We decompose the funct ion  of  themachine not iona l ly  in to  cont ro l  funct ions  anddata  man ipu la t ion  funct ions  ( th i s  decompos i t ioni s  impor tant  because of  the great  importance ofpat tern -d i rec ted  computat ions  in ~rr).In fo rmal ly ,  in de ference  to the in terna lo rgan isat ion  of  more convent iona l  mach ines ,  wesometimes re fer  to the funct iona l i ty  of  thesetwo parts with the terms CPU and MMU,respectively.
What we want to do is to make the"empty" kerne l  machine in to  a complete ande f fec t ive  computing dev ice  by the  add i t ion  of  ase t  o f  de f in i t ions  which :a l low the kerne l  in terpreter  to d i s t ingu ishbetween cont ro l  operat ions  and dataoperat ions  in an input  language const ruct ;de f ine  the complete set  of  cont ro loperat ions ;de f ine  the domain of  lega l  dataconf igurat ions  and operat ions  on them.With these  add i t ions ,  the completearch i tec ture  has the form :FP : cont ro lde f  - -~REL : datadef  - -~languagesusdLR(k) : uld -~  CG --~ COMPILERinner  prog.CPU lII~ w!
!KERNEL I$COMPUTERF ig .
4or  symbo l i ca l ly ,  wr i t ing  "adder"  fo r  the nameof  the funct ion  which adds de f in i t ions :(((adder : controldef,datadef ) : KERNEL): ((CG : uld) : usd)) : text -~ textCapitalized symbols denote componentswhich are part of the system generator, whilelower case symbols denote definitions togenerate a system instance.An alternative way of describing Fig 4. isto see the system generator as consisting of aset of generators (languages and programs).The languages of the generator are :a. an LR(k) language for defining the userlanguage syntax (cf Knuth 1965);b. a funct iona l  programming (FP) language fo rde f in ing  the semant ics  of  the user  supp l iedcont ro l  ( fo r  FP cf  Backus 1978);c. a re la t lona l  language (REL) fo r  de f in ingthe semant ics  of  user  de f ined  pat terndescr ip t ions ;d. the de f in i t ion  of  the inner  programsyntax  (see  APPENDIX).The programme of  the system,  which ,supp l ied  w i th  the appropr ia te  de f in i t ions ,w i l l  generate  sys tem ins tances ,  are  :e. a compiler-compiler defined functionallyby a. and d. in such a way that for each tokenof user  language syntax  de f in i t ion  and eachtoken of  user  program expressed  in th i s  syntaxi t  w i l l  generate  a un ique token of  innerprogram.f.
a CPU, which is essentially an FP system,to be complemented with the definitions ofpoint b.
The CPU is responsible forinterpreting the scheduling (control) parts of231the user program.
It can pass control to theMMU at defined points.g.
a MMU to be complemented with thedefinitions of point c. The MMU is responsiblefor manipulating the data upon request of theCPU.Given the above scheme, a token of  aproblem or iented  system for  processing userprograms is obtained by supplying the de f in i t iono f  :- the user language syntax;- the semantics of the control descriptions;- the semantics of the data patterndescriptions;- the expansion of certain nonterminalsymbols of the inner program syntax.Note that a primitive (rule-)executionscheme ( i .e .
a grammar),  i s  obta ined  recurs ive lyin the same way, modulo the mod i f i ca t ionnecessary  g iven the d i f fe rent  meaning of  thecont ro l  def in i t ion .I I I .
FORMAL DEFINITION OF THESYSTEM GENERATOR'S ARCHITECTUREThis section presupposes some knowledge ofFP and FFP (cf.
Backus cit, Williams 1982).Readers unfamiliar with these formalisms mayskip this section.We now give a formal definition of thegenerator's arch i tec ture  by funct iona l lyde f in ing  a mon i to r  M fo r  the machine dep ic ted  inF ig.
4.
We w i l l  do so by de f in ing  M as an FFPfunct iona l  ( i .e .
h igher  o rder  funct ion)  (c f .Backus c i t ,  Williams c i t ) .An FP system has a set of functions whichis fully determined by a set of primitivefunctions, a set of functional forms, and a setof definitions.The main difference between FP systems andFFP systems is that in the latter objects (e.g.sequences) are used to represent functions,which has as a consequence that in FFP one cancreate new functionals.
The monitor M is justthe definition of one such'functional.Sequences in FFP represent functionals inthe following way : there is a representationfunction D (which belongs to the representationsystem of FFP, not to FFP itself) whichassociates objects and the functions theyrepresent.The association between objects andfunctions is given by the following rule(metacompos i t ion)  :(p <x l  .
.
.
.
.
xn>)  : y =(o xl)  :~x l  .
.
.
.
.
xn> ,y>The formal definition of the overallarchitecture of the system is obtained by thefollowing FFP definition of its monitor M :D ~M,  uld, cd, dd~ : usd = ~M):<<pM, uld, cd,dd >, usd> wi th  :M E app ly .
\ [capp ly , l ' \ [app ly l "\ [app ly2" \ [  yapp ly ,2 -1 \ ]  , 23,apply.\[~(3-1), 'CD3 ,app ly ' \ [~(4" l ) , 'DDT\ ] \ ]where :M is the name of the system monitoruld is the user language definition in BNFcd is the control definition (controldef inFig 4.
)dd is the data definition (datadef in Fig 4.
)usd is the user solution definitionThe meaning of the definition is asfollows :M is defined to be the application ofcapply to the internal programe ipapply : <capply, ip.>capply is the semantic definition of themachine's CPU (see below).ip is obtained in the following way :app ly l  : ~app ly2  : ~yapp ly ,u ld>,  usd>Where apply2 : Cyapp ly ,  uld~ yields theCOMPILER which is then applied to the usd.For a definition of applyl, apply2, yapplysee the section on the implementation.apply" \[;(3-1), 'CD\]andapply" \[4(4"1), 'DD \]just add definitions to the control, reap.data definition stores of the CPU and the MMUrespectively.is the 'store' functional of FFP.A.
Semantic Definition of the CPUAs mentioned earlier, the bare CPUconsists essentially of the semanticdefinition of an FP-type applicationmechanism, the set of primitive functions andfunctionals being the ones defined in standardFP.232The app l i ca t ion  mechanism of  the CPU i sca l led  capp ly ,  and i t s  de f in i t ion  i s  as fo l lows  :p(x) = x s A ~ ?
;x = <xl .
.
.
.
.
xn> ~ (~x l  .
.
.
.
.
~xn > ;?
= (y:z)(yeA & (~:DD) = T ~ mapply:~y,z> ;yea & (~:CD) = # ->~((py) (~z));yaA & (~:CD) = w ->~(w:z);y = <y l  .
.
.
.
.
yn)~(y l :<y ,z> );~(~y:z ) ) ;be ing the FFP semant ic  funct ion  de f in ing  themeaning of  ob jec ts  and express ions  (whichbe longs  to the descr ip t ive  system of  FFP, not  toFFP i t se l f ,  ( c f  Backus c i t ) ) .The funct iona l i ty  o f  ~ is: Express ion  -> Ob jectthat  i s ,  ~ assoc ia tes  to each FFP express ion  anob jec t  which i s  i t s  meaning.
It i s  de f ined  inthe fo l low ing  way :x i s  an ob jec t  -> ~x = xe = <e l  .
.
.
.
.
en> is  an express ion  ->~ef~e l  ..... pen>i f  x ,y  are  ob jec ts  -> ~(x :y )  = ~(~:y)where OX is  the funct ion  represented  by theob jec t  x.i s  the FFP funct iona l  ' fe tch 'DD is  the de f in i t ion  s tore  of  the MMUCD is  the de f in i t ion  s tore  of  the CPU# i s  the resu l t  o f  an unsucces fu l  searchmapply is  the apply  mechanism of  the MMUThe execut ion  of  a pr imi t ive  ( i .e .
agranuuar) represents  a recurs ive  ca l l  to  themon i to r  M, modulo the d i f fe rent  funct ion  of  thecont ro l  in terpreter  ( the  CPU).For the res t ,  as fa r  as the user  languagedef in i t ion  is  concerned th ings  remain unchanged(remember that  i f  appropr la te , the  language fo rexpress ing  knowledge ins ide  a gratmuar as we l l  asthe  data  s t ruc ture  can be redef ined  fo rd i f fe rent  p r imi t ives ) .The recurs ive  ca l l  o f  M is  caused by capp lywhose def in i t ion  has to  be augmented byinser t ing  a f te r  l ine  6 Of the de f in i t ion  g ivenabove ~he fo l low ing  eondt%ion|y = app lypr lm 9 <M,uld,cd,dd) :xwhere x i s  the spec i f i ca t ion  of  the pr imi t ive(e .g .
the  ru le  set ) .IV.
EXPERIMENTAL IMPLEMENTATIONAn exper imenta l  imp lementat ion  of  thearch i tec ture  descr ibed  above has to  accomodatetwo d is t inc t  a ims.
F i r s t ,  i t  must re f lec t  theproposed  funct iona l i ty ,  which i s  to say ,rough ly ,  that  the par ts  out  o f  which i t  i smade cor respond in content ,  in funct ion  andin ter re la t ionsh ip  to  those  la id  down in thedes ign .
Second, i t  must ,  when supp l ied  wi th  aset  of  de f in i t ions ,  generate  a system ins tancethat  i s  both cor rect ,  and su f f i c ient ly  robustto be re leased  in to  the user  community toserve  as an exper lmenta l  too l .The ent i re  imp lementat ion  runs  under ,  andi s  par t ly  de f ined  in terms of  the Unix*operat ing  system.
The main reason  fo r  th i scho ice  is  that  from the  s tar t ,  Unix has beenconce ived as a funct iona l  a rch i tec ture .
Whatthe user  sees  i s  externa l ly  de f ined ,  be ing theresu l t  of  app ly ing  the Unix kerne l  to  a she l lprogram.
Fur thermore ,  the s tandard  she l l ,o rcsh , i t se l f  p rov ides  us w i th  a language whichcan both descr ibe  and const ruct  a complexsystem,  essent ia l l y  by having the vocabu laryand the const ructs  to  express  thedecompos i t ion  of  the  whole in to  more pr imi t ivepar ts .
We sha l l  see some examples of  th i sbelow.Another  reason  fo r  the cho ice  of  Unix i sthe  ava i lab i l i ty  o f  su i tab le ,  ready-madeso f tware  that  has turned  out  to  be su f f i c ient ,in la rge  measure ,  to  const ruct  a respectab lefirst approximation to the system.
Finall~,the  decent ra l i sed  nature  of  our  p ro jec tdemands that  exper imenta l  imp lementat ionsshou ld  be maximal ly  d i s t r ibutab le  over  apotent ia l l y  la rge  number of  d i f fe rent  hardwareconf igurat ions .
At p resent ,  Unix i s  the on lypract i ca l  cho ice .A.
System ComponentsThe system consists of 4 main parts, thesebe ing  :a.
A user  language compi le r  generator .b.
A cont ro l  de f in i t ion  generator .c.
a kerne l  CPU.d.
A data  de f in i t ion  generator .These modules ,  together  w i th  a userlanguage descr ip t ion ,  a cont ro l  descr ip t ion ,and a data  descr ip t ion ,  are  su f f i c ient  tospec i fy  an ins tance  of  the system.1.
User  Language Compi ler  GeneratorYACCAfter rev iewing  a number ofcompi le r -compi le rs ,  i t  was dec ided to  use YACC* UNIX i s  a t rademark  of  the Be l l  Laborator ies233(Johnson 1915).
Quite apart from itsavailability under Unix, YACC accepts an LALR(1)grammar, a development of LR(k)grammars (Knuth cit; Aho & Johnson (1974).
LALRparsers (Look Ahead LR) give considerablysmaller parsing tables than canonical LRtables.
The reader is referred to Aho & Ullman(1977) which gives details of how to derive LALRparsing tables from LR ones.LEgLEX (Lesk 1975) generates lexlcal anslysers,end is designed to be used in conjunction withYACC.
LEg accepts a specification of lexicalrules in the form of reBular expressions.Arbitrary actions may be performed when certainstrings are recognised, although in our case,the value of the token recognised is passed, andan entry in the symbol table created.2.
Control GeneratorA user programe presupposes, and an innerprogram contains a number of control constructsfor organlslng the scheduling of processes, endthe performance of complex databasemanipu la t ions .
The meaning that  theseconst ruc ts  sha l l  have i s  determined  by thede f in i t ions  present  in the  cont ro l  s to re  o f  thekernel.The language in which we have chosen todefine such constructs is FP (Backus cit).
Itfollows that the generator must providecompilations of these defintions in the languageof the kernel machine.
The implementation ofthe control generator is an adaptation ofBaden 's  (1982) FP in terpreter .
Th is  i s  astand-alone program that essentially translatesFP definitions into kernel language ones.3.
Kernel CPUWe are currently using the Unix Lispinterpreter (Foderaro & Sklower 1982) to standin for FFP, although an efficient interpreterfor the latter is under development.
Noticethat an FFP (or Lisp) system is necessary toimplement the appllcative schema described insection Ill, since these systems have the powerto describe their own evaluation mechanisms; FPitself does not.4.
Data Definition GeneratorUnfortunately, we know of no language assuitable for the description of data as FP forthe description of control.
The reason is thatat this moment, we are insufficiently confidentof the basic character of data in this domain tomake any definitive claims about the nature ofan ideal data description \]anguage.We have therefore chosen to express datadefinitions in the precise, but over generalte rms  o f  f i r s t  o rder  log ic ,  wh ich  are  thenembedded w i th  very  l i t t le  syntact i ctransformation into the database of a standardProlog implementation (Pereira & Byrd 1982).The augmented interpreter then constitutes theMMU referred to above.
The data definitionfor the current experiment presents the userwith a database consisting of an orderedcollection of trees, over which he may definearb i t ra ry  transductions.The CPU and MMU run in parallel, andcommunicate with each other through a pair ofUnix pipelines usin 8 a defined protocol thatminlmises the quantity of information passed.A small bootstrap program initlelises the MMUand sets up the pipelines.B.
ConstructinK the SystemThe decomposition of a system instanceinto parts can be largely described within theshell language.
Figure 5. below summarisesthe organisation using the convention that amodule preceded by a colon is constructed byexecuting the shell commands on the nextl i ne .
The runnab le  vers ion  o f  f igure  4.
( thatconta ins  ra ther  more odd symbols )  conforms tothe  input  requ i rements  o f  the  Unix 'make 'program.targettext :( (cpu<bootstratp)< eurotra)< sourcetext> targettext / *capp ly* /eurotra :compi le r  < usd  >eurot ra  / *app ly  I * /COMPILER :yacc <u ld  \[ cc~compi le r  / *app ly  2* /cont ro lde f  :fpcomp < cd> cont ro lde fMMU :echo ' save(mmu) '  I pro log  ddCPU :echop '(damplisp cpu)' I l isp<controldefF ig .
5V.
CONCLUSIONWe have arBued for the need oftheory-specific software for computationallinguistics.In cases where, as in MT, such a theory isnot available from the beginning of a project.hut rather, is expected as a result of it, wehave argued for the need of a problem-orientedsystem generator .234We have proposed a so lu t ion  by which,s ta r t ing  from the not ion  of  a compi le r  generatord r iven  by an externa l  de f in i t ion ,  one ar r ives  ata way of  bu i ld ing  runnab le ,  p rob lem-or ientedsystems which are a lmost  ent i re ly  externa l lyde f ined .
In our v iew, th i s  approach has theadvantage,  fo r  a domain where the c lass  ofproblems to  be so lved  is  underdetermined ,  thatthe semantics of the underlying machine can beredefined rapidly in a clean and elegant way.By a care fu l  cho ice of def in i t ion  languages ,  wecan use the de f in i t ions  s imul taneous ly  as inputto a generator  fo r  exper imenta l  p ro to typeimp lementat ions  and as the cent ra l  par t  o f  aformal  spec i f i ca t ion  of  a par t i cu la rapp l i ca t ion -or iented  machine.VI  REFERENCESAho, A.V & Johnson,  S.C. (1974) - LRpars ing .
Computing Surveys 6 : 2Aho, A.V .
& Ul lman,  J .V .
(1977)  -P r inc ip les  of Compiler Design.
Addison-Wesley.Backus, J (1978) - Can programming bel iberated  from the von Neumann s ty le?
Comm.
ACM21 : 8.Baden, S. (1982) - Berke ley FP User ' sManual, rev 4 .1 .
Department of  ComputerSc ience ,  Un ivers i ty  of  Ca l i fo rn ia ,  Berke ley .Davis ,  R. & King, J .
J .
(1977) - An overv iewof  p roduct ion  sys tems,  in : E lcock,  E.W.
&Michie,  D. (eds) -  Machine In te l l igence  B:Machine representat ion  of  knowledge, E l l i sHorwood.Foderaro J.K. & Skowler K. (1982).
TheFranz Lisp Manual.
University of California.Georgeff, M.P.
(1982) - Procedura l  cont ro lin p roduct ion  sys tems.
Ar t i f i c ia l  In te l l igence18 : 2.J ohnson ,  S.C. (1975) - Yacc : Yet anotherCompi le r -Compi le r ,  Computing Sc ience Techn ica lReport  No.
32, Be l l  Laborator ies ,  NJKnuth, D.E.
(1965) - On the translat ion oflanguages from left to right.
Information andControl 8:6.Lesk, M.E.
(1975) -Lex  : a Lex ica lAna lyzer  Generator ,  Computing Sc ience Techn ica lReport  No.
39, Be l l  Laborator ies ,  NJ.Pere i ra  & Byrd (1982) - C -Pro log ,  Ed CAAD,Department of  Arch i tec ture ,  Un ivers i ty  ofEd inburgh.R ichards ,  M & Whi tby -St revens ,  C. (1979) -BCPL: The language and i t s  compi le r ,  CambridgeUn ivers i ty  Press.Wi l l iams,  (1982) - Notes on the  FPfunct iona l  s ty le  of  programming,  i n :Dar l ington ,  J .
,  Henderson,  P. and Turner ,  D.A.
(eds) ,  Funct iona l  programming and i t sapp l i ca t ions ,  CUP.Wirth, N. (1976) - Algorithms + DataStructures = Programs, Prentice Hall,Englewood Cliffs, New Jersey.VI I .
APPENDIXBelow we g ive a BNF def in i t ion  of  theinner  program syntax .
Cap i ta l i zed  symbolsdenote non- termina l  symbols ,  lower easesymbols denote te rmina ls .PROC : :=  <quI~>QUINT ::= ~NAME EXPECTN FOCUS BODYGOALL>NAME ::= IDENTIF IERIDENTIFIER ::= ""EXPECTN ::= PAT I nilFOCUS ::= VARPAIRVARPAIR ::= ~ARG ARG>VAR ::= VARIDVARID ::= **BODY ::= <nonpr im CEXP~pr im PRIMSP>CEXP ::= COMPLEX I SIMPLEXCOMPLEX ::= ~CONTRLTYP CEXP+>SIMPLEX ::= NAMECONTRLTYP ::= serial \[ paral lel  J lteratePRIMSP ::= ~RULE+>RULE ::= <PAT PAT>GOALL : := <PAT zPAT : :ffi ~ SYMBTAB ASSERT >SYMBTAB : : = ARGLARGL ::= <ARG + >ASSERT ::= ~b ASSET ASSRT>I<vASSRT ASSRT ~(~ASSI~>ASSET ::= SIMPLASSRT I ASSERTSIMPLASSRT ::= ~EELNAM TERML>EELNAM : := >1< I =l *lIDENTIFIER\[prec \ [  domJpre f ix  Isu f f i x  I in f ixTERML : : ffi <TERN ~ >TE~ : := ~G !
<FUSC TERm.
>ARG ::= (TYP  VAR>\[ LITERAL nullL ITERAL ::ffi "*FUNC ::ffi IDENTIFIER I lengthTYP : := node I t ree  i cha in  I boundFor each ins tance  of  the system,  there  i san ins tance  of  the inner  program syntax  whichd i f fe rs  from the bare  inner  program syntax  inthat  cer ta in  symbols are  expanded d i f fe rent lydepending on o ther  de f in i t ions  supp l ied  to  thesystem.
** t r iv ia l  expans ions  omi t ted  here .
:=  PAT*235
