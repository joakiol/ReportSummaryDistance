The ACQUILEX LKB: representation issues in semi-automaticacquisition of large lexiconsAnn CopestakeUn ivers i ty  of Cambr idge  Computer  LaboratoryNew Museums Site, Pembroke  St reet ,  Cambr idge ,  CB2 3QG,  UKAnn.Copestake@cl .cam.ac .ukAbst ractWe describe the lexical knowledge base sys-tem (LKB) which has been designed and im-plemented as part of the ACQUILEX project 1to allow the representation f multilinguM syn-tactic and semantic information extracted frommachine readable dictionaries (MRDs), in sucha way that it is usable by natural languageprocessing (NLP) systems.
The LKB's lex-ical representation language (LRL) augmentstyped graph-based unification with default in-heritance, formalised in terms of default unifi-cation of feature structures.
We evaluate howwell the LRL meets the practical requirementsarising from the semi-automatic construction ofa large scale, multilingual lexicon.
The systemas described is fully implemented and is beingused to represent substantial amounts of infor-mation automatically extracted from MRDs.1 In t roduct ionThe ACQUILEX LKB is designed to support repre-sentation of multilingual exical information extractedfrom machine readable dictionaries (MRDs) in such away that it can be utilised by NLP systems.
In con-trast to lexical database systems (LDBs) or thesaurus-like representations (e.g.
Alshawi et al, 1989; Calzolari,1988) which represent extracted ata in such a way asto support browsing and querying, our goal is to builda knowledge base which can be used as a highly struc-tured reusable lexicon, albeit one much richer in lexi-cal semantic information than those commonly used inNLP.
Thus, although we are using information whichhas been derived from MRDs (possibly after consider-able processing involving some human intervention), ouraim is not to represent the dictionary entries themselves.Our methodology is to store the dictionary entries andraw extracted ata in our LDB (Carroll, 1990) and touse this information to build LKB entries which couldbe directly utilised by an NLP system.
Briscoe (1991)discusses the LDB/LKB distinction in more detail anddescribes the ACQUILEX project as a whole.1'The Acquisition of lexical knowledge for Natural Lan-guage Processing systems' (Esprit BRA-3030)Practical NLP systems need large lexicons.
Even incases such as database front ends, where the domain ofthe application is highly restricted, a practical naturallanguage interface must be able to cope with an exten-sive vocabulary, in order to respond helpfully to a userwho lacks domain knowledge, for example.
For applica-tions such as text-to-speech synthesis, interfaces to large-scale knowledge based systems, summarising and so on,large lexicons are clearly needed; for machine transla-tion the requirement is for a large scale, multilingua\]lexical resource.
Acquisition of such information is aserious bottleneck in building NLP systems, and MRDsources currently seem the most promising source forsemi-automatically acquiring the syntactic and semanticinformation eeded.Previous work on extracting and representing syntac-tic information includes the work done on the AlveyTools lexicon project (Carroll and Grover 1989) in whicha large scale lexicon was produced semi-automaticallyfrom LDOCE (Longman Dictionary of ContemporaryEnglish, Procter, 1978) using a feature and unificationbased representation.
There has been considerable dis-cussion and some implementation f LKBs for the repre-sentation of semantic information extracted from MRD~,(e.g.
Boguraev and Levin, 1990; Wilks et ai, 1989).
How-ever the knowledge representation languages assumedare rarely described formally; typically a semantic net-work or a frame representation has been suggested, butthe interpretation and functionality of the links has beenleft vague.
Several networks based on taxonomies havebeen built, and these are useful for tasks such as sense-disambiguation, but are not directly utilisable as NL1 clexicons.
For a reusable lexicon, a declarative, formallbspecified, representation language is essential.In the ACQUILEX project we are concerned with theextraction and representation f both syntactic and lexi-cal semantic information.
A common representation lan-guage is needed, to allow the interaction of lexical se-mantic and syntactic properties to be described.
Ther~is currently a considerable amount of work in lexical se-mantics where unification based formalisms are used tcrepresent his interaction (e.g.
Briscoe et al's (1990'account of logical metonymy (Pustejovsky, 1989, 1991)Sanfilippo's (1990) representation f thematic and aspec.tual information).
However we also wish to structure th~lexicon, in order to link lexical entries.
This is essential88since we are ultimately considering lexicons with maybe100,000 entries for each language.
Although the aim ofthe ACQUILEX project is to determine the feasibility ofusing MRD sources, rather than attempting to build alexicon of such size, we nevertheless need an LKB whichcan cope with tens of thousands of entries.There are currently several approaches to develop-ing representation languages which allow the lexiconto be structured, in particular by inheritance.
Theseinclude object-oriented approaches (Daelemans, 1990),and DATR (Evans and Gazdar, 1990).
We chose touse a graph unification based representation languagefor the LKB, because this offered the flexibility to rep-resent both syntactic and semantic information in a waywhich could be easily integrated with much current workon unification grammar, parsing and generation.
In con-trast to DATR for example, the LKB's representationlanguage (LRL) is not specific to lexical representation.This made it much easier to incorporate a parser in theLKB (for testing lexical entries) and to experiment withnotions such as lexical rules and interlingual links be-tween lexical entries.
Although this means that the LRLis in a sense too general for its main application, the typ-ing system provides a way of constraining the represen-tations, and the implementation can then be made moreefficient by taking advantage of such constraints.Our typed feature structure mechanism is based onCarpenter's work on the HPSG formalism (Carpenter1990) although there are some significant differences.We augment he formalism with the more flexible psortinheritance mechanism, which allows for default inheri-tance.
Much of the motivation behind this comes fromconsideration of the sense-disambiguated taxonomiessemi-automatically derived from MRDs, which we areusing to structure the LKB (see Copestake 1990).
Thenotion of types, and features appropriate for a giventype, gives some of the properties of frame representa-tion languages, and allows us to provide a well-defined,declarative representation, which integrates relativelystraightforwardly with much current work on naturallanguage processing and lexical semantics.Thus the operations that the LKB supports are (de-fault) inheritance, (default) unification, and lexical ruleapplication.
It does not support any more general formsof inference and is thus designed specifically to supportprocesses which concern lexical rather than general rea-soning.
In the rest of this paper we first informally intro-duce the way in which lexical entries are represented inthe LKB.
We then describe the LRL, and discuss how thedesign of the default inheritance system was influencedby the application.
(A fuller and more formal accountof the LRL appears in papers in Briscoe et al, forth-coming.)
We conclude with an overview of the actualimplementation and a discussion of the utility of typedfeature structures and the psort mechanism in practise.2 Lex ica l  ent r ies  in  the  LKBConsider Figure 1, which is a screen dump of theLKB system showing part of a file containing a semi-automatically generated lexical entry for the Dutch nounkippevlees (chicken meat) (top right of figure), the fea-ture structure (FS) representation of that description(bottom right) and the fully typed feature structureinto which it is expanded in the LKB (left of figure).See Vossen (1991) for the details of the generation ofthis entry.
Features are shown uppercased, types arein lowercase bold, reentrancy is indicated by numbersin angle brackets.
The identifier for the lexical entry,kippevlees_V_O_l, indicates that it corresponds to thesense kippevlees 1 in the Van Dale dictionary.
The un-expanded lexical entry is relatively compact, but a largeamount of information is inherited via the type and psortsystems.
The expanded lexical entry is not shown com-pletely; the entry's syntactic type is noun-cat ,  and thebox round this indicates that its internal structure isnot displayed.
The same applies to the sense-id infor-mation (which enables the corresponding LDB entry tobe accessed) and the argument structure.
Figure 2 (left)shows the type lex -uncount -noun,  which determinesthe basic skeleton of the entry.
Feature structures (calledconstraints) are associated with types and inherited byall FSs of a particular type.
Thus the form of this lexi-cal entry is due to the constraint on lex -uncount -nounshown in the figure.Default inheritance from the lexical semantic struc-ture for the lexical entry for vlees_V_0_l augments thetype information for the entry for kippevlees.
We encodea relatively rich lexical semantic structure for nouns (re-ferred to as the 'relativised qualia structure', RQS) basedon the notion of qualia structure, described by Puste-jovsky (1989, 1991).
Noun lexical entries are parsed toyield a genus term, vlees in this case, and differentia.The genus term is normally interpreted in LKB termsas specifying the lexical entry from which information isinherited by default; as explained in Section 4 this alsopartially defines the lexical semantic type (RQS type),which is c_nat_subst in this example (for comestible,natural, substance).
A fragment of the RQs type hierar-chy is also shown in Figure 2 2.
The differentia can bepartially interpreted relative to the RQS type; in this ex-ample < rqs : o r ig in  > = "k ip"  is an indication thatkippevlees comes from kip; eventually this will allow theirlexical entries to be linked automatically by the appro-priate lexical rule (Copestake and Briscoe, 1991; Copes-take et al, 1992).
The feature ORIGIN is introduced attype natura l  (the FS definition of natura l  is shown inFigure 2, top right, before expansion by inheritance fromnomrqs) .
Since natura l  is a parent of c_nat_subst,ORIGIN is an appropriate feature for c_nat._subst.The feature TEL IC  is used to provide a slot for the se-mantics of the verb sense which is associated with thepurpose of an entity (eating in this case).
The way inwhich such a representation may be used in the treat-ment of logical metonymy was described in Briscoe etal (1990).
Other features (such as  PHYSICAL-STATE) areused to encode information which is useful for applica-tions such as sense-disambiguation.
This attempt o rep-resent detailed lexical semantic information illustrates ageneral principle of the ACQUILEX project; such lexical2Unlike Carpenter(1990) we adopt a notation with themost  general type at the top of any diagram, because thisseems more natural to the main users of the system.89I I  File Edit Find Windows  Tools P re ferences  Ldb Lkbk ippev lees  - ex landed',_ip.p~,~ee~ van( l - food .
lexlex-uncount-noun k ippev lees  U-O_1ORTH:kippevlees < sense- ld  : d io t lonaPu  > = "URHD"CAT:~- -~ < sense- id  : Idb -ent r t j -no  > = "16810605"SEM'.
pnm2f-lfemula-entity-eqi l l J  < sense-  i d : homonym-no > - "0"SENSE-ID:lsense-id j < sense- id  : sense-no  > - " !
"RQS:\[c_n~t._subst < r'qs : o r - ig ln  > = ( "k ip" )ORIGIN~REA: st~ing < I ex -uncount -noun rqs  >\]I_=LIC: \[strict-trams--.
;em < ULEES_U_D_I < lex -noun-s  ign r'qs >.IND: <0> = e~ePRED: ~t41ARG I : \ [verb- fennelsIND: ,(0>PRED: eat_ l _O_ lARG1 : <0>\]ARG2: \ [b im~/- i fe rmul lIND: <0>PRED: stud~RQ 1 : p-4qlt~ennul~ IARG2: p-pltt-I'onnul:lQJPHVS ICAL: trueOBJECT-INDEX: <1 > = obiANIMACV: f , , IsePHVS ICAL..STATE: so l id_ i@UAL: phys.-quai IFORM: \[physfonnVOLUME: seeJmrWEIGHT: sea l~SHA PE: nor, - individulted\]CONSTITUENCY: ~:enstituency 1ORIGIN: kip\]\]k ippev lees  - def in i t ion'OR'~: IdllqPe~4eesSENBE-ID: \[topLANGUAGE: 4vtahFB-ID:kippevlees v 0 |D ICTIONARY: ylmdLDB-ENll:IY-NO: 16610606HOkC>NYM-HO: 0SEHSEJ~O: I \ ]RQS: \[e substORIGIN: kip\]\]< lex-unoouet-~ou, rqs > < YLI=I~8Expanded psortFigure 1: A lexical entryentries are usable by a wide range of NLP systems be-cause they are relatively rich and detailed; applicationswhich do not make use of detailed lexicM semantic infor-mation can simply discard the information.
Clearly theconverse is not true, and a more impoverished represen-tation would be less generally useful.
We thus aim forrepresentations which are as rich as possible in informa-tion which we can extract automatically, and representformally, but which are also well motivated linguisticallyand/or useful for practical NLP applications.
This alsoapplies to our use of thematic roles in the semantics; seethe examples of LKB entries for verbs given in Sanfilippoand Poznanski (1992, this volume).3 The type systemIn the definition of a type hierarchy we follow Carpen-ter(1990) very closely.
The type hierarchy defines a par-tial order (notated E_, "is more specific than") on thetypes and specifies which types are consistent.
OnlyFSs with mutually consistent ypes can be unified - -two types which are unordered in the hierarchy are as-sumed to be inconsistent unless the user explicitly spec-ifies a common subtype.
Every consistent set of typesS C_ TYPE must have a unique greatest lower bound ormeet (notation \[7S).
3 This condition allows FSs to betyped deterministically - - if two FSs of types a and bare unified the type of the result will be a \[7 b, whichmust be unique if it exists.
If a ~ b does not exist unifi-cation fails.
In the fragment of a type hierarchy shown inFigure 2 c__natural and natura l .
.
substance  are consis-tent; c_natura l  R naturaLsubstance  --- c_nat_substBecause the type hierarchy is a partial order it has prop-erties of reflexivity, transitivity and anti-symmetry (frorrwhich it follows that the type hierarchy cannot contaircycles).We define a typed feature structure as a tuple F =(Q, q0,/f, 0), where the only difference from the untypeccase is that every node of a typed FS has a type, 6(q)The type of a FS is the type of its initial node, O(qo)The definition of subsumption of typed FSs is very sireliar to that for untyped FSs, with the additional provis(that the ordering must be consistent with the ordering oItheir types.
We thus overload the symbol E ("is-more.3In order to check the type hierarchy for uniqueness ogreatest lower bounds we carry out a p~irwise comparison eltypes with multiple parents to see if they have a unique lowest greater bound.
Since the number of types with multipbparents is typically much less than the totaJ number of typesthis is considerably more efficient han carrying out p~irwis,comparisons on all the types in the hierarchy.90r 4 Fi le Edit  F ind Windows Toolslex -uncount -noxn  expanded~erents = lex.-noun-sigmlex-uncount-nounOR~: \[orth\]CAT: \[noun-o~CAT-TVPE: nM-FEATS: \[nominsi-m--/estsREG-MOR PH: beele=lmAGR: \[nomined-eorPERS: person ?HUM: number .%GENDER: gender\]NOMINAL-FORM: nominll-fermCASE: oqereCOUNT: hdse\]\]SEM: \[unery-formuli-entit y-erg !IND: (0>- entityPRED: <!
> = stringI ARG1."
<0>\]SENSE-ID:RGS: bomrqs\]P re ferences  Ldb Lkbnatura l  - de f in i t ion  ~=I~I|!
I/'l='entsmlturll = nomnls\[ ORIGIN: (string basic)\]Type  h ie rarchyr~'IRQSHRTURRL_ ,0 NRTURR .VS,CRLC~J~f f~ C_DIRT..SI_m~_ T CR/~E HRTURRL_ I rRl~I-M'l:lN RN I I'IRLFigure 2: Typesspecific-than", "is-subsumed-by") to express subsump-tion of FSs as well as the ordering on the type hierarchy.Thus if/'1 and F2 are FSs of types tl and t~ respectively,then F1 E F~ only if tl E t2.3.1 Const ra in tsOur system differs somewhat from that described byCarpenter in that we adopt a different notion of well-formedness of typed feature structures.
In our systemevery type must have exactly one associated FS whichacts as a constraint on all FSs of that type; by subsumingall well-formed FSs of that type.
The constraint also de-fines which features are appropriate for a particular type;a well-formed FS may only contain appropriate features.Constraints are inherited by all subtypes of a type, buta subtype may introduce new features (which will be in-herited as appropriate features by all its subtypes).
Aconstraint on a type is a well-formed FS of that type; allconstraints must therefore be mutually consistent.Features may only be introduced at one point in thetype hierarchy (cf Carpenter's minimal introduction).Because of the condition that any consistent set of typesmust have a unique greatest lower bound, it is also thecase that sets of features will become valid at uniquegreatest points in the type hierarchy.
This allows under-typed feature structures to be introduced into the systemby the user which are then given the most general possi-ble type.
The importance of this form of type inferencefor our application is discussed in Section 5.2, below.Constraints are given by the functionC: (TYPE, E:) --, .Z-where ~" is the set of FS.
C(t) denotes the constraint FSassociated with type t. We define the notion of appro-priate features as follows:Def in i t ion 1 / f  C(t) = (Q, qo, 6, O) we defineAppfeat(t) = reat(qo) where we define Feat(q) to bethe set of features labelling transitions from the node qsuch that f e Feat(q) if 6(f, q) is defined.The conditions on the constraint function are as fol-lows:Monoton ic i ty  Given types tl and t2, if tl ~ t2 thenC(tl) E_ C(t~)Type For a given type t, if C(t) is the FS (Q, q0, 6, 0)then O(qo) = t.91Consistency of constraints For all q E Q, we havethat F' = (Q',q,~,O) E C(O(q)) and Feat(q) =Appfeat(O(q)).We therefore disallow any occurrence of t in a sub-structure of C(t), thus if C(t) = (Q, q0, ~, 0) then forall q E Q, q ?
q0 implies that 0(q) # t. Since we dis-allow cycles in FSs such a constraint could only besatisfied by an infinite FS, which is also disallowed.Max imal  in t roduct ion  of  features  For every fea-ture f E FEAT there is a unique type t =Maztype( f )  such that f E Appfeat(t) andthere is no type s such that t F- s and f EAppfeat(s).
The maximal appropriate value of afeature Mazappval( f )  is the type t such that ifC(Maztype( f ) )  = (Q, qo, 6, 0> then t = 0(~(f, q0))Def in i t ion  2 We say that a given FS F = (Q, qo, 6, 0>is a well-formed FS iff for all q E Q, we have that F' =(Q', q, 6, 0) E C(O(q)) and Feat(q) = Appfeat(O(q)).Carpenter separates the notion of typing and con-straints.
This allows a more powerful constraint lan-guage, but complicates the system.
Since the users ofthe LKB were initially not familiar with feature struc-ture representations it was important o keep the sys-tem as simple as possible, and in practice we have notyet found the additional power of Carpenter's constraintlanguage necessary.Some relatively minor extensions to the formalism al-low the implementation of some cooccurrence restric-tions and the disjunction of atomic types.
It is necessaryto allow types with string values, representing orthogra-phy for example, to be introduced as needed rather thanpredefined; we therefore define an atomic type s t r ingwhich is allowed to have any string as a subtype withoutthese being explicitly specified.
All subtypes of s t r ingare taken to be disjoint.4 Defau l t  inher i tance  and  taxonomiesWe extend the typed FS system with default inheritance.FSs may be specified as inheriting by default from oneor more other (well-formed) FSs which we refer to inthis context as psorts.
Psorts may correspond to (partsof) lexical entries or be specially defined.
Since psortsmay themselves inherit information, default inheritance(notated by <, "inherits from") in effect operates over ahierarchy of psorts.
We prohibit cycles in the inheritanceordering.
Inheritance order must correspond to the typehierarchy order.Pl < P2 :=~ Typeof(pl )  E Typeof(p2)where Pl and P2 are psortsThe typing system thus restricts default inheritance s-sentially to the filling in of values for features which aredefined by the type system.Default inheritance is implemented by a version of de-fault unification, for a detailed discussion of which seeCarpenter (1991, forthcoming).
In default unification,unlike ordinary unification, inconsistent information isignored rather than causing failure; however the defini-tion is complicated by the need to consider the interac-tions between reentrant FSs.
The way we deal with thisis discussed in detail in Copestake(1991, forthcoming),but since the problematic ases seem to arise relativelyrarely in our particular application, we will not discussthe full definition here.
We use Iq< to signify default uni-fication, where A R< B means that A is the non-defaultand B the default FS.
When no reentrancy interactionsare involved the definition is:AM< B = AM \['3{?
E q/ I A~?
#?
}where @ is the set of all component FSs of B.The ordering on the psort hierarchy gives us an or-dering on defaults.
So for example, assume that thefollowing is the lexical entry for BOOK_L_I_I:lex-noun-slgn"artifact_physlcalR S TEL IC  \[ verb-sereQ = = \[PRED = read_L_l_ l \ ]PHYSICAL-STATE ---- solid_aThe following path specifications make the lexical entriesdefined inherit from BooK_L_I_I:autobiography <rqs> < book_L_l_l <rqs>dictionary <rqs> < book_L_l_l <rqs><rqs : relic : prod >= refer_to_L_O_2lexicon <rqs> < dictionary <rqs>AUTOBIOGRAPHY would thus have the same valuesBOoK_L_I_I for both telic and physical-state.
DIC-TIONARY will inherit the value solid_a for the featur~PHYSICAL-STATE but the value of TELIC overrides tha~inherited from BOOK_L_I_ 1.
LEXICON inherits its valu,for the telic role from DICTIONARY rather than fronBOOK_L_I_I:lex-noun-signartifact _physicalverl>-semRQS = TEL IC  = \]PRED = refer_to_L_0_2LPHYS ICAL-STATE = solid_aMultiple default inheritance is allowed but is restricte,to the case where the information from the parent psortdoes not conflict.
This is enforced by unifying all (full~expanded) immediate parent psorts before default un!fying the result with the daughter psort.
The type restriction on default inheritance means that all the psortmust have compatible types and the type of the daughtemust be the meet of those types.
We define inheritan?to operate top-down; that is a psort will be fully e~panded with inherited information before it is used fcdefault inheritance.
We adopted this approach asare primarily interested in default inheritance betweefully formed lexical entries; since we disallow conflictarising from multiple inheritance, distinctions betweetop-down and bottom-up inheritance only arise with tl~problematic cases of default unification alluded to abov,We also allow non-default inheritance from psorts, inplemented by ordinary unification.
This is a relative\]92recent addition to the LKB, prompted partly by issues inthe representation of the multilingual translation links.It also seemed to be desirable in the representation ofqualia structure, in order to allow the telic role of a nounto be specified directly in terms of a verb sense, withoutallowing other information in that lexical entry to con-flict.
Thus the entry for dictionary above would actuallyspecify:<rqs  : re l i c  > =-- re fe r_ to_L  0_2 < sem >where == indicates non-default inheritance.Although introducing psorts as well as types may seemunnecessarily complex there seem to be compelling rea-sons for doing so for this application, where we wishto use taxonomic information extracted from MRDs tostructure the lexicon.
The type hierarchy is not a suit-able way for representing taxonomic inheritance for sev-eral reasons.
Perhaps the most important is that taxo-nomically inherited information is defeasible, but typingand defaults are incompatible notions.
Types are neededto enforce an organisation on the lexicon - -  if this canbe overridden it is useless.
Furthermore the type systemis taken to be complete, and various conditions are im-posed on it, such as the greatest lower bound condition,which ensure that deterministic classification is possible.Taxonomies extracted from dictionaries will not be com-plete in this sense, and will not meet these conditions.Intuitively we would expect to be able to classify lexicalentries into categories uch as human,  a r t i fac t  and soon, and to be able to state that all c reatures  are eitherhumans  or animals ,  since in effect this is how we aredefining those types.
But we would not expect to beable to use the finer-grained, automatically acquired in-formation in this way; we will never extract all possiblecategories of horse for example.In implementational terms, using the type hierar-chy to provide the fine-grain of inheritance possiblewith taxonomic information would be very difficult.A type scheme should be relatively static; any alter-ations may affect a large amount of data and check-ing that the scheme as a whole is still consistent is anon-trivial process.
Because the inheritance hierarchiesare derived from taxonomies and thus are derived semi-automatically from MRDs, they will contain errors and itis important hat these can be corrected easily.
In prac-tise, deciding whether to make use of the type mecha-nism or the psort mechanism has been relatively straight-forward.
If we wish to use a feature which is particularto some group of lexical entries we have to introduce atype, otherwise, especially if the information might bedefeasible, we use a psort.Several of the decisions involved in designing the de-fault inheritance system were thus influenced by the ap-plication.
The condition that the default inheritance or-dering reflects the type ordering was partly motivatedby the desire to be able to provide an rqs type for lexicalentries on the basis of taxonomic data alone.
However italso seems intuitively reasonable as a way of restrictingdefault inheritance; without some such restriction it isdifficult to make any substantive claims when default in-heritance is used to model some linguistic phenomenon.5 Us ing  the  LKB5.1 Interface and implementationThe LKB as described here is fully implemented in Pro-cyon Common Lisp running on Apple Macintoshes.
Itis in use by all the academic groups involved in the AC-QUILEX project.
In total there are currently about 20users on five sites in different countries.
Interaction withthe LKB is entirely menu-driven.
Besides the obviousfunctions to load and view types, lexical entries, psorts,lexical rules and so on, there are various other facilitieswhich are necessary for the application.
A very simple(and inefficient) parser is included, to aid developmentof types and lexical entries.
There are tools for support-ing multilingual linked lexicons, described in Copestakeet al (1992).
The LKB is integrated with our LDBsystem so that information extracted from dictionaryentries stored in the LDB can be used to build LKBlexicons.The type system which has been developed for use onthe ACQUILEX project is fairly large (about 450 typesand 80 features).
Currently nearly 15,000 lexical entriescontaining syntactic and semantic information have beenstored in the LKB.
The bulk of these entries are currentlymade up of nouns for which the main semantic informa-tion is inherited down semi-automatically derived tax-onomies.
Sanfilippo and Poznanski (1992) describe thesemi-automatic derivation of entries for English psycho-logical predicates by augmenting LDOCE with thesaurusinformation derived from the Longman Lexicon.
Workhas begun on deriving multi-lingual linked lexicons.Given the complexity of the FSs for lexical entries, andthe size of the lexicons to be supported by the LKB, itis clearly not possible to store lexicons in main memory.Lexical entries are thus stored on disk, to be expandedas required.
Entries may be indexed by type of FS atthe end of user-defined paths, and also by the psort(s)from which they are defined to inherit, although pro-ducing such indices for large lexicons is time consuming.Checking lexical entries (for well-formedness, default in-heritance conflicts and presence of cycles) can be carriedout at the same time as indexing or acquisition.Efficiency gains arising directly from the use of typeswere not a major factor in our decision to use a typed sys-tem.
Although parsing with typed FSs is more efficientthan with untyped ones, since unification will fail whentype conflict occurs, this is not particularly important inthe LKB, since most unifications will be performed whileexpanding lexical entries, when the vast majority of uni-fications would be expected to succeed.
Since there issome overhead in typing the FSs, the use of types proba-bly decreases efficiency slightly, although the unificationsinvolved will be comparable to those needed if the sameinformation were conveyed by templates.
Since the LKBhas to cope with large lexicons, with thousands of com-plex lexical entries, space efficiency rather than speed isthe major consideration.
The most important factor inspace efficiency is the use of inheritance, both in the typesystem and the psort system, which allows unexpandedlexical entries to be very compact.935.2 Typ ing  and  automat ic  acquis i t ion  of  largelex iconsOur notion of typing of FSs can be regarded as a wayof getting the functionality of templates in untyped FSformalisms, with the added advantages of type checkingand type inference.
As a method of lexical organisation,types have significant advantages over templates, espe-cially for a large scale collaborative project.
Once anagreed type system is adopted, the compatabil ity of thedata collected by each site is guaranteed.
There may ofcourse be problems of differing interpretation of typesand features, but this applies to any representation; toameliorate them we associate short documentation i -formation with each type, accessible via the menu in-terface from any point where the type is displayed.
Inan untyped feature system, typographical errors and soon may go undetected, and debugging a large templatesystem can be extremely difficult; a type system makeserror detection much simpler.
Since a given FS has atype permanently associated with it, is also much moreobvious how information has come to be inherited thanif templates are used.Essentially the same advantages of safety and clarityapply to strict typing of FSs as to strict typing in pro-gramming languages.
Of course a reduction in flexibilityof representation has to be accepted, once a particulartype system is adopted.
It is possible to achieve a veryconsiderable degree of modularisation; we have foundthat we could develop the noun RQS type system almostcompletely independently of the verb type system, once asmall number of common types were agreed on, and thatname clashes were the only problem found when reinte-grating the two.
After approximately eight months ofuse we are now on the third version of both the verb andthe noun type systems; individual users have been ex-perimenting with various representations which are thenintegrated into the general system as appropriate.
En-coding the agreed representation i  terms of a type sys-tem, rather than by means of templates, makes globalalterations relatively easy because of the localisation ofthe information (for example, since a feature can only beintroduced at one point in the hierarchy, it is easy to findall types which will be affected by a change in featurename) and the error checking.
It is important hat re-processing of raw dictionary data is avoided when a typesystem is changed, particularly if user interaction is in-volved, but storing intermediate results in the LDB asa derived dictionary helps achieve this.
Even within theproject it has proved useful to have local type systemsand lexicons, and to derive entries for these automati-cally from the general LKB.
Currently this is achievedby ad-hoc methods; we intend to investigate the devel-opment of tools to make transfer of information easierand more declarative.Ageno et al (1992) describe one way in which the typesystem can be integrated with tools for semi-automaticanalysis of dictionary definitions.
Types are correlatedwith the templates used in a robust pattern matchingparser, and user interaction can be controlled by the typesystem.
The user is only allowed to introduce informa-tion appropriate for a particular type, and a menu-basedinterface can both inform the user of the possible valuesand preclude errors.The utility of typing for error checking when repre-senting automatically acquired data can be seen in thefollowing simple example.
The machine readable versionof LDOCE associates emantic codes with senses.
Ex-amples of such codes are P for plant, H for human, M formale human, K for male human or animal, and so on.When automatically acquiring information about nounsfrom LDOCE, we specify a value for the feature SEX,where this is possible according to the semantic odes.Thus the automatically created lexical entry for bull 1 1contains the line:< rqs  : sex  > = maleIn the current type system the feature sex is introducedat type c reature .
A few LDOCE entries have incor-rect semantic codes; I r i sh  s tew for example has codeK.
Since I r i sh  s tew has rtQs type c_art i fact ,  which isnot consistent with c reature ,  SEX was detected as aninappropriate f ature.
Attempts at expansion of the au-tomatically generated lexical entry caused an error mes-sage to be output, and the user had the opportunity tocorrect he mistake.
If the LKB were not a typed system,errors such as this would not be detected automaticallyin this way.In contrast, automatic lassification of lexical entriesby type, according to feature information, can be used toforce specification of appropriate information.
A lexicalentry which has not been located in a taxonomy will begiven the most general possible type for its RQS.
Howeveri fa value for the feature sex has been specified this forcesan rtQs type of c reature .
This would also force the valueof ANIMATE to be t rue ,  for example.5.3 The  psor t  inher i tance  mechan ism.Manual association of information with psorts hasproved to be a highly efficient method of acquiring in-formation, since many psorts have hundreds of daughtelentries.
Creating 'artificial' psorts, which can be usedwhere there is no simple lexicalisation of a concept, iaalso a powerful technique.
Disjunctions uch as persor,or animal,  for example, can be represented as the gener-alisation of the two psorts involved.
This and other case.,of more complex taxonomic inheritance are discussed b~Vossen and Copestake (1991, forthcoming).We adopted the most conservative approach to multi.pie default inheritance (i.e.
information inherited frorrmultiple parents has to be consistent) because we kne~we would have to cope with errors in extraction of in.formation from MRDs, and with the lexicographersoriginal mistakes.
We expected this to be overrestric.tive, but in fact our consistency condition seems to bemet fairly naturally by the data.
Taxonomies extractecfrom MRDs are in general tree-structured (once sense.disambiguation has been performed); there do not tencto be many examples of genuine conjunction, for exampie.
Multiple inheritance is mainly needed for crossclassification; artifacts for example may be defined principally in terms of their form or in terms of their function, but here different sets of features are typically specified, so the information is consistent.
Furthermore i94frequently turns out to be difficult to identify a secondpsort parent from the dictionary definition differentia.However type inference resulting from feature instantia-tion may still force a type to be assigned which representsthe cross-classification.AcknowledgementsSeveral people contributed in various ways to the design,implementation a d development of the LKB, especiallyValeria de Paiva, Antonio Sanfilippo, Ted Briscoe, JohnCarroll, John Bowler and Horacio Rodriguez.
We arevery grateful to Bob Carpenter for his detailed commentson our use of types and default unification.
We are grate-ful to the publishers Longman, Biblograf, Van Dale andGarzanti for allowing groups involved in ACQUILEX touse their dictionaries.Re ferencesA.
Ageno el al.. SEISD: An Environment for Extractionof Semantic Information from On-Line Dictionaries.
InProceedings of the 3rd Conference on Applied NaturalLanguage Processing, Trento, Italy, 1992.H.
Alshawi, B. Boguraev and D. Carter.
Placing the dic-tionary on-line.
In B. Boguraev and T. Briscoe (eds.
),Computational lexicography for natural anguage process-ing, pages 41-63, Longman, London, 1989.B.
Boguraev and B. Levin.
Models for lexical knowledgebases.
In Proceedings of the 6lh Annual Conference ofthe UW Center for the New OED, pages 65-78, Water-loo, 1990.T.
Briscoe.
Lexical Issues in Natural Language Process-ing.
In E. Klein and F. Veltman (eds.
), Natural Languageand Speech, pages 39-68, Springer-Verlag, 1991.T.
Briscoe, A. Copestake and B. Boguraev.
Enjoy thepaper: Lexical semantics via lexicology.
In Proceedingsof the 13th Coling, pages 42-47, Helsinki, 1990.T.
Briscoe, A. Copestake and V. de Paiva (eds.).
De-fault Inheritance in Unification based approaches to theLexicon.
Cambridge University Press, New York, forth-coming.N.
Calzolari.
The dictionary and the thesaurus can becombined.
In M. W. Evens (ed.
), Relational models ofthe lexicon, pages 75-96, Cambridge University Press,1988.B.
Carpenter.
Typed feature structures: Inheritance,(In)equality and Extensionality.
In Proceedings of theFirst International Workshop on Inheritance in NaturalLanguage Processing, pages 9-18, Tilburg, The Nether-lands, 1990.B.
Carpenter.
Skeptical and Credulous Default Unifica-tion with Applications to Templates and Inheritance.
InT.
Briscoe, A. Copestake and V. de Paiva (eds.
), De-fault Inheritance in Unification based approaches to theLexicon, CUP, New York, 1991, forthcoming.J.
Carroll and C. Grover.
The derivation of a large com-putational lexicon for English from LDOCE.
In B. Bogu-racy and T. Briscoe (eds.
), Computational lexicographyfor natural language processing, pages 117-134, Long-man, London, 1989.J.
Carroll.
Lexical Database System: User Manual.Esprit BRA-3030 ACQUILEX deliverable no.
2.3.3(c),April 1990.A.
Copestake.
An approach to building the hierarchicalelement of a lexical knowledge base from a machine read-able dictionary.
In Proceedings of the First InternationalWorkshop on Inheritance in Natural Language Process-ing, pages 19-29, Tilburg, The Netherlands, 1990.A.
Copestake.
Default Unification in the LKB.
In T.Briscoe, A. Copestake and V. de Paiva (eds.
), DefaultInheritance in Unification based approaches to the Lexi-con, CUP, New York, 1991, forthcoming.A.
Copestake and T. Briscoe.
Lexical Operations ina Unification Based Framework.
In Proceedings ofthe ACL SIGLEX Workshop on Lexical Semantics andKnowledge Representation, pages 88-101, Berkeley, Cal-ifornia, 1991.A.
Copestake, B. Jones, A. Sanfilippo, H. Rodriguez andP.
Vossen.
Multilingual lexical representation, ms Uni-versity of Cambridge, Computer Laboratory, 1992.W.
Daelemans.
Inheritance in Object-Oriented Natu-ral Language Processing.
In Proceedings of the FirstInternational Workshop on Inheritance in Natural Lan-guage Processing, pages 30-39, Tilburg, The Nether-lands, 1990.R.
Evans and G. Gazdar (editors).
The DATR papers.Cognitive Science Research Paper CSRP 139, School ofCognitive and Computing Sciences, University of Sussex,1990.P.
Procter (editor).
Longman Dictionary of Contempo-rary English.
Longman, England, 1978.J.
Pustejovsky.
Current issues in computational lexi-cal semantics.
In Proceedings of the 4th European ACL,pages xvii-xxv, Manchester, 1989.J.
Pustejovsky.
The Generative Lexicon.
ComputationalLinguistics, 17(4) 1991.A.
Sanfilippo.
Grammatical Relations, Thematic Rolesand Verb Semantics.
PhD thesis, Centre for CognitiveScience, University of Edinburgh, 1990.A.
Sanfilippo and V. Poznanski.
The Acquisition of Lex-ical Knowledge from Combined Machine-Readable Dic-tionary Sources.
In Proceedings of the 3rd Conferenceon Applied Natural Language Processing, Trento, Italy,1992.P.
Vossen.
Converting Data from a Lexical Database toa Knowledge Base.
ACQUILEX Working paper, No 27,1991.P.
Vossen and A. Copestake.
Untangling definitionstructure into knowledge representation.
I  T. Briscoe,A.
Copestake and V. de Paiva (eds.
), Default Inheritancein Unification based approaches to the Lexicon, CUP,New York, 1991, forthcoming.Y.
Wilks, D. Fass, C-M. Guo, J. McDonald, T. PlateT and B. Slator.
A tractable machine dictionary as aresource for computational semantics.
In B. Boguraevand T. Briscoe (eds.
), Computational lexicography fornatural language processing, pages 193-231, Longman,London, 1989.95
