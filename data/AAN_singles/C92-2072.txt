Towards Robust PATRShona Doug las*  and  Rober t  Da le  tCent re  for Cogn i t ive  Sc ienceUn ivers i ty  of  Ed inburghEd inburgh  EH8 9LW, Scot landAbst ractWe report on the initial stages of development of arobust parsing system, to be used as part of TheEditor's Assistant, a program that  detects and cor-rects textual errors and infelicities in the area ofsyntax and style.
Our mechanism extends the stan-dard PATR-n formalism by indexing the constraintson rules and abstracting away control of the appli-cation of these constraints.
This allows independentspecification of grouping and ordering of the con-straints, which can improve the efficiency of process-ing, and in conjunction with information specifyingwhether constraints are necessary or optional, allowsdetection of syntactic errors.In t roduct ionThe Editor's Assistant \[Dale 1989, 1990\] is a rule-based system which assists a copy editor in massag-ing a text to conform to a house style.
The centralidea is that publishers' tyle rules can be maintainedas rules in a knowledge base, and a special inferenceengine that  encodes trategies for examining text canbe used to apply these rules.
The program then op-erates by interactively detecting and, where possible,offering corrections for those aspects of a text whichdo not conform to the rules in the knowledge base.The expert-system-like architecture makes it easy tomodify the system% behaviour by adding new rulesor switching rule bases for specific purposes.Our previous work in this area has been oriented to-wards the checking of low-level details in text: forexample, the format and punctuation of dates, num-bers and numerical values; the punctuation and useof abbreviations; and the typefaces and abbrevia-tions to be used for words from foreign languages.In this paper, we describe some recent work we havecarried out in extending this mechanism to deal withsyntactic errors; this has led us to a general mecha-nism for robust parsing which is applicable outsidethe context of our own work.?
E-mail addeas i  S. Douslaa@ed.
ac.
uk.tAIso of the Department of Artificial Intelligenceat the University of Edinburgh; e-mail address isR,Dale?ed.
ac.uk.Syntact i c  E r rorsCategor ies  o f  E r rorsUltimately, the aim of The EdilorJs Assistant is todeal with real language~unrestr icted natural lan-guage text in all its richness, with all its idio~yn-cracies.
The system is therefore an experiment inwhat we call inte l l igent  text  process ing:  an in-tersection of techniques from natural anguage pro-cossing and from more mundane text processing ap-plications, with the intelligence being derived fromthe addition of language sensitivity to the basic textprocessing mechanisms.Many of the corrections made routinely in the courseof human proofreading require subleties of semanticand pragmatic expertise that  are simply beyond cur-rent resources to emulate.
However, examination ofcommon syntactic errors and infelicities, both as de-scribed in the literature (see, for example, \[Miller1986\]) and es appearing in data we have analysed,has led us to distinguish a number of tractable r-ror types, and we have based the development ofoursystem on the various requirements imposed by theseclasses.
The error types are defined very much withprocessing requirements in mind; orthogonal cate-gorisations are of course possible.
We give summarydescriptions of these c la .~s here; examples are pro-vided in Figure 1.Const ra in t  V io la t ion  Er rors :These involve what, in most contemporary syn-tactic theories, are best viewed as the violation ofconstraints on feature values.
All errors in agree-ment fall into this category.Lexlcal  Confus ion:  These involve the confusion ofone lexical item with another.
We specifically in-clude in this category cases where a word contain-ing an apostrophe is confused with a similar wordthat does not, or vice versa.Syntact i c  Awkwardness :  We include here caseswhere the problem is either stylistic or likely tocause processing problems for the reader.
Notethat  these 'errors' are not syntactically incorrect,but are constructions which, if overused, may re-sult in poor writing, and as such are often in-cluded in style-checker 'hit-lists'; thus, we wouldinclude multiple embedding constructions, poten-ACT, S DE COLING-92, NANTES, 23-28 AOIJT 1992 4 6 8 PROC.
OF COLING-92, NANTES, AUO.
23-28, 1992Constra int  Vio lat ion Errors:(l) Subject-verb number disagreement:a.
*John and Mary runs.b.
*The dogs runs.
(2) Premodifier-noun number disagreement:a.
*This dogs runs.b.
*All the dog run.
(3) Subject-complement number disagreement:a.
*There is live dogs here.h.
*There are a dog.
(4) Wrong pronoun case.:a.
*llc and me ran to the dog.b, *This stays between you and I,(5) Wrong indelblitc article:a.
*A apple and an rotten old pear.b.
A NeXT workstation and *a NEC laptop.
1Le.xical Confosion:(6) Confusion of its and it's:a.
*Its late.b.
*Tim dog ate it's bone.
(7) Confusion of that,, their, and they're:a.
*Their is a dog here.b, *They're is a dog here.e.
*Ttmrc dog was cohi.d.
*They're dog was cold.e.
*There }lere now.f.
*Ttmir here now.
(8) Confusion of p~ivc ' s  and plural s:a.
*The dog's are cold.b.
*3'lie boy ate the dogs biscuit.Syntact ic  Awkwardness :(9) ~\[bo many prepositional phraees:a. Tile boy gave the dog in the window at the endwith tile red collar with the address on the backof it a biscuit.
(10) i)a~'~ive constructions:a.
The boy wa.s seen by the dog.Miss ing or ext ra  e lements:(11) Unpaired delimiters:a.
*The dog, wllich was in tile garden was quiet.
(12) Missing delimiters:a.
*The dog, I think was in the garden.b.
*In the garden dog,s arc a menace.
(13) Missing list ~parators:a.
*There were two dog~ three cats and a canary.
(ld) Double syntactic function:a.
*it s~,cms to be is a dog.b.
*l think know Fve been there before.F igure 1 : Example's of Syntactic Errors:tally anlbiguous yntact ic  structures,  and gardenpath sentence~s in this category.
These problemsare detectable by simple count ing or recognitionof syntact ic forms.Miss ing  or  Ext ra  E lements :These arc c~mes where elements (either words orptmctuat ion symbols) arc omit ted or mistakelflyincluded in a text.
An interest ing sub-categoryhere, which is surpris ingly frequent, is the pres~ence of two constituents which serve the same ora similar purpose; by analogy with double-worderrors (where a word appears twice it, successionwhen only one occurrence was intended), we referto these as cas~ of dou l ) le  syntact i c  funct ion .The crrors dealt with in this paper all fall into thefirst class, i.e, thorn that  can be seen as breakingconstraint.s on feature values.
At  the end of the paperwe s lake sonte observations on how the mechanismcan bc.
extended lx) the other classes.
:P rev ious  WorkOf  course, there exists a signii icant body of workdealing with (xmlputational approaches to syntacticerrors like those just  discu~.scd.
Broadly, work deal-ing with ungrammat ica l  input falls into two cate-gor i c :  approaches where the principal objective isto determine what  meaning the speaker intended,and approach~ where the principal objective is tooonstruct ml appropr iate correction.
The first kindof approach is most appropr iate in the developmentof natural  language inLcrfaces, where syntact ic dys-flueneies can often be ignored if ti le ~mer~s intentionscan be determined by means of other evidence, tIow-ever, these, approach~ (in the s implest cases, basedon detecting content words) arc inappropr iate wherethe sysLma must  al.,~o propose a correction for thehypothcsised error.Of  the different edmiqucs  that  have been propo.~mdunder the second category, the most useful is thatusually referred to as re laxat ion .
Tiffs is a ratherelegant method for extending a grammar 's  coverageto include il l-formed input, while retaining a princi-pled connection between thc construct ions acceptedby the more restr ict ive grammar  and those acceptedby the extended one.
I f  a g rammar  exprt.~ses in-formaLion ill terms of constraints or conditions onfeatures, a sl ightly leas re,~trietivc g rammar  can beconstructed by re lax ing  some subset  of these con-strainLs.
Work commonly referred to in this corntext ine lud~ Kwasny and Sondheimer \[1981\] andWeischedel and Black \[1980\], but  very many systemsu.~e .some kind of relaxation process, whether of syn-tact ic or semant ic  onstraints.
The most  well knownis lnM'~q work on the Epistle and Crit ique systems\[tleidorn ct el.
1982; Jensen et at.
1983; Richardsonand Braden-t Iarder  1988\].lln British English, NEC is spelled out, rather thanbeing pronolmeed like the word neei4 thus, the correctform here is an NEC,Ae*rl~s DE COIANG-92, NAtCn.
:S, 23-28 AOI\]T 1992 4 6 9 PROC.
O1: COLING-92, N^I~rgs, AUG. 23-28, 1992Epistle parses text in a left-to-right, bottom-up fash-ion, using grammar rules written using an augmentedphrase structure grammar (APSG).
In APSG, eachgrammar ule looks like a conventional context-freephrase structure rule, but may have arbitrary testsand actions specified on both sides of the rule.
So,for example, we might have a rule like the follow-ing:(15) NO VP (NUMB.AGREE.NUMB(NP)) -~VP(SUBJECT = NP)This rule states that a noun phrase followed by a verbphrase together form a VP, 2 provided the number ofthe N\[  and the original VP agree.
The resulting VPstructure then has the original NP as the value of itsSUBJECT attribute.Using rules like the~e, the system attempts to parse asentence as if it were completely grammatical.
Then,if no parse is found, the system relaxes ome condi-tions on the rules and tries again; if a parse is nowobtained, the system can hypothesise the nature ofthe problem on the basis of the particular conditionthat was relaxed.
Thus, if the above rule was usedin analysing the sentence Either of the models areacceptable, no parse would be obtained, since thenumber of the NP Either of the models is singularwhereas the number of the VP are acceptable is plu-ral.
However, if the number agreement constraintis relaxed, a parse will be obtained; the system canthen suggest hat  the source of the ungran\]matical-ity is the lack of number agreement between subjectand verb.One thing that  must be borne in mind when con-sidering the merits and demerits of relaxation meth-ods is that  they depend crucially on how much ofthe particular grammar2s information is expressedas constraints on feature values.
Where the basicform of a grammar is, say, complex phrase struc-ture rules, the use of features may be confined tochecking of number and person agreement.
If, onthe other hand, more of the informative content ofthe grammar is represented as constraints, as in re-cently popular unification-based grammars \[Sheibcr1986\], relaxation can be used to transform grammarsto less closely related ones.In the remainder of this paper, we show how aunification-based formalism, PATR-II, may be ex-tended by a declarative specification of relaxationsso that it can be used flexibly for detecting syntacticerrors.
Under one view, what we are doing here isrationally reconstructing the Epistle system within aunification-based framework.
A useful consequenceof this exercise is that the adoption of a declarativeapproach to the specification of relaxations makes itmuch easier to explore different processing regimesfor handling syntactic errors.~This second, higher-level VP plays the role of what wewould normally think of as an S node.Y,O Xl X2(XO cat) = VP(Xl cat) = NP(X2 cat) = VP(X0subject) = Xl(Xl hum) = (X2 hum)Figure 2: PATti version of the Epistle ruleMak ing  PATR RobustThe  Bas ic  Mechan ismIn this section, we describe an experimental system,written in Prolog, that is designed to support themechanisms necessary to apply PATR-type rules tosolve constraints selectively.
The major componentsof the system are (a) the parsing mechanism; (b) theunderlying P^TR system; and (c) the rule applicationmechanism that mediates between these two.The parser encodes the chosen strategy for applyingparticular grammar ules in a particular order.
Atthis stage, the parser is not a crucial component ofthe system; all we require is that it apply rules ina bottom-up fashion.
Accordingly, we use a simpleshift-reduce mechanism.
The parser will be the focusfor many of the proposed extensions discussed later;in particular, we are in the process of implementinga chart-based mechanism to allow handling of errorsresulting from missing or extra elements.The basic PATR system provides a unification basedmechanism for solving sets of constraints on featurestructures.
A PATR rule corresponding to the gram-mar rule discussed in the context of Epistle above isshown in Figure 2.It is fairly obvious that, given some mechanism thatallows us to remove the final constraint in this rule,we can emulate the behaviour of the Epistle system.In our model, the rule application mechanism pro-vides the interface between the parsing mechanism,which accesses the lexicon and decides the order inwhich to try rules, and the PATR.
system.
To see howthis works, we will consider a slightly morn complexrule, shown in Figure 3; the use of the numbers onthe constraints will be explained below.Given this rule, a constituent of category NP will befound given two lexical items which axe respectivelya determiner and a noun, provided all the constraintsnumbered 1 through 6 are found to hold.
Note theconstraint numbered 4: we suppose that  the featuresaddressed by (X1 agr precedes) and (X2 agr begins)may have the values vowel and consonant.
This al-lows us to specify the appropriate r strictions on theuse of the two forms a and an.
3aOf course, the imp\]ication here that a is used be-fore words beginning with a vowel and an is used beforewords beginning with a consonant is an oversimplification.There are aiso, of course, other means by which this con-ACIT.S DE COL1NG-92, NANTES, 23-28 AOIYI' 1992 4 7 0 PROC.
OF COLING-92, NANTES, AUG. 23-28, 1992X0 Xl X21 (X0 cat)2 (Xl cat)3 (X2 cat)4 (Xl agr precedes)5 (Xl agr num)6 (X0 agr num):~ NP- -  Det- -  N(X2 agr begins)- -  (X2 agr hum)= (X2 agr hum)Figure 3: Simple NP tale in the PATR formalismRe lax ing  Const ra in tsGiven the rule in Figure 3, and a standard parsingmechanism, there will be no problem in parsing cor-rect NPS like these dogs.
tlowever, consider our targeterrors in (16a-e):(16) a.
*this dogsb.
*an dogc.
*an dogsExmnple (16a) exhibits premodifier noun numberdisgrecment; (16b) exhibits use of the wrong indefi-nite article; and (16c) cxmtains both of these errors.If the parser is to make any sense of thcse strings, wemust introduce a more elaborate control structure.Premodifier-noun number agreement is enforced byconstraint 5; constraint 4 enforces the use of theproper indefinite article.
We need to be able to relaxconstraint 5 to parse (16a), and to relax constraint 4to parse (16t)); to parse (16c), we want to relax both(xmstralnts 5 arid 4 at once.
"\[b deal with this, we make use of the notion ofa re laxat ion leve l  Instead of applying all constrafers associated with a rule, we specify for evcryrule, at any given relaxation level, those constraintsthat are necessary and those that are optional.At relaxation level 0, which is equivalent to thc bo-haviour of the standard PATR system, all constraintsare deemed nece.~ary.
At relaxation level 1, how-ever, constraints 4 and 5 are optional.
Optional con-straints, if violated, need not result in a failed parse,but do correspond to particular errors.The algorithm in Figure 4 applies all constraints ap-propriately, given a specification as just dcscribed.Here, N is the set of nccessary constraints and Ois the set of optional constraints, both for a givenrelaxation level L; R is the set of constraints whichhave to be relaxed in order for the rule to he used.R will always be a subset of O, of course; we r(.~turn the actual vahm of 1~ as a result of parsingwith the rule.
The outer conditional ensures thatall the necessary constraints are satisfied.
The innerconditional takes appropriate action for each relax-able constraint whether or not it is satisfied: if thestraint could be d~eckcd; however, we include it here asa constraint on the application of the rule for expositorypurp~c~.When applying rule r at relaxation level L:N ~- necessary constraints on r at LO *-- optional constraints on r at L;~ ~ {}if all n (: N can be solvedthen  incorporate any instantiations requiredfor eadl oi r50 doif o, can be solvedthen  incorporate instantiationselse R ?-- O ~ O o~endi fnextelse re turn  failureendifre turn  CFigure 4: The relaxation algorithm, version 1l~.claxation level 0:necessary constraints = {1,2,3,4,5,6}optional constraints = { }Relaxation level t:nec~sary coustraints -- {1,2,3,6}optional constraints = {5,4}Figure 5: The relaxation specification for the NP rule,version l: optional constraintsRelaxation level 1:necessary constraints: {1,2,3}relaxation packages:(a) {5, 6}: Premodifier-noun munber disagreement(b) {4}: ~/~errorFigure 6: The relaxation specification for the NP rule,version 2: grouped constraintsconstraint is satisfied, it has exactly thc same effectas a necc~ary constraint; if not, the constraint isrecorded as having been relaxed.Once paining is complete, the information in R canthen be used to generate an appropriate error mes-sage.The operation of this algorithm is supported by ex-plicitly indexing each constraint within a tale, asin Figure 3, and absl.racting out the specification ofwhieh vonstraint.s may be relaxed at a given relayation lewfl.
The constraint application specificationfor the NP rule is given ill Figure 5.Group ing  Const ra in tsThis is not the whole story, however.
Consider theNP this dogs, which would be correctly parsed at re-Acids DE COLING-92, NAN'Ir~.s, 23-28 AO~" 1992 4 7 1 PROC.
OF COLlNG-92, N^tCrEs, AUG. 23-28.
1992laxation level 1 as exhibiting premodifier-noun num-ber disagreement under the system described so far.The instantiation of X0 resulting from this rule ap-plication would be as follows:??
\]\] x0: I:;:: 0,uNote in particular that  (X0 agr num) has the valueplu.
This results from the solution of constraint 6,which is one of the necessary constraints at relax-ation level 1 as specified in Figure 5.
This 'featuretransport '  constraint propagates the number of thetread noun to tile superordinate noun phrase.
It isnot appropriate to perform such a propagation underthe current, cirolmstances, however, because once acase of prcmodifier-noun number disagreement hasbeen identified, we cannot ell whether it is the num-ber of the noun or the number of the determiner thatis in error.
One might argue that one of the twois more likely than the other, but such a heuristicbelongs in the mechanism that  offers replacementsrather than in the relaxation mechanism itself.
Ifthe number of the noun is always propagated to thenoun phrase, spurious error reports may emerge insubsequent parsing: for example, in the text Th/sdoys runs, a subject-verb number disagreement willbe flagged in addition to the premodifier-noun num-ber disagreement error.
This will be at best mislead-ing.We would like to be able to express the intuitionthat it is not really meaningful to apply constraint 5if constraint 5 has failed; these constraints should begrouped together, to be applied together or not atall.
So we introduce an addition to the specificationfor relaxation level 1, shown in Figure 6.We refer to a group of constraints to be relaxed to-gether or not at all, plus the error message that cor-responds to the failure of the group of constraints, asa re laxat ion  package.
The algorithm of Figure 4has been adapted to apply such relaxation packages,resulting in the algorithm in Figure 7.
Here, R isthe set of relaxation packages required in order tocomplete the parse.Note that  if all the constraints in a relaxation pack-age can be applied successfully, they have exactly thesame effect as necessary ones, in terms of contribut-ing to the building of structure.
Thus, if the numberagremnent condition constraint 5 is satisfied, as inthe case of the text an dogs, then the associated fea-ture percolation constraint, 6, will add the feature(agr nmn) to XO, with value (X2 agr hum).Order ing  Const ra in tsIn the previous section, we altered the mechanismto allow for the fact that  it is not meaningful toapply some coustraints if others have failed; in theworst case, this avoided confusing error diagnoses.Even if no such confusion would result, however, con-When applying rule r at relaxation level L:N *- necessary constraints on r at LO 4- relaxation packages for r at LR~-  {}if all n ?
N can be solvedthen  incorporate any instantiationsfor each relaxation package P~ E O doif  all constraints c4 ?
Pi can be solvedthen  incorporate any instantiationselse R *-- R + P~:end i fnextelse re turn  failureend i fre turn  RFigure 7: The relaxation algorithm, version 2siderable fficiency gains can be made by orderingconstraints in such a way as to minimise unneces-sary structure building.
A similar point is made byUszkoriet \[1991\], who talks of the need for a flex*ible control strategy for efficient unification basedparsers, to ensure that the conditions that  are mostlikely to fall are tried first.Ideally, the ordering of constraints would be derivedautomatically from other information; but it is un-clear how this would be done.
Currently, we makeuse of one central ordering principle:(18) Category constraints on RnS items come first.In the bottom-up parsing system we use, all RrlSitems will be instantiated with feature structures cor-responding to lexical entries, or to syntactic ate-gories built up by rule from lexical entries; it is adiscipline on our lexicon and our structure build-ing rules that all such feature structures will havea cat feature.
This means that a query about the catvalue will involve no structure building.
However,if, before checking the category, we were to enquireabout the (agr num) feature, we might involve our-selves in some unnecessary structure building, be-cause if applied to a feature structure that does nothave an (agr num) feature, what was thought of as aconditional constraint will in fact result in structurebuilding.
For example, the constraint in (19) ap-plied against he structure in (20) will result in thestructure shown in (21); this is clearly not desirable.
(19) (Xl agr num)= pluconjunction\](20) X1 = \[l':xt:: and Jcat: conjunction\]lex: and /AcrEs DE COLING-92, NA~fI~S, 23-28 AOt~r 1992 4 7 2 PROC, OF COLING-92, NANrES, AUG. 23-28, 1992Relaxation level 0:necessary c~mstraints: {2,3,5,4,1,6}relaxation packages: {}Relaxation level 1 :necessary constraints: {2,3,1relaxation packages:(a) {5, 6}: Premodifier-noun number disagreement(b) {4}: a/a,, er rorFigure 8: The relaxation specification for the Nr  rule,version 3: constraint orderingThese considerations give r i~ to the ordering of con-straints given in Figure 8; we assume that when thealgorithm in Figure 7 tests whether all members ofa constraint set can be solved, the constraints aresolved in the order given in the specification, and thetest halts as soon o.s any member of the constraintset cannot be solve&D iscuss ionWc have argued that combining the relaxation tech-nique for syntactic error correction with a grammar(such a.s is found in recent unification formalisms)that expresses most of its information in the form ofconstraints provides a good starting point for a llexi-ble mechanism for detecting and correcting syntacticerrors.
Our work in this area so far raises a numberof interesting (lUt.~tions which need to be pursuedlurther.Dependenc ies  betwcen Constra ints:  Aswe have seen, the ordering of constraints in therelaxation specifications i  very important.
How-ever, the particular ole a specific constraint per-h)rms will of course depend on the particular pars-ing strategy being used.
Ideally, we would like togenerate the ordering information antx)matically,although it is not entirely clear how this mightbe (lone.
One source of some ordering constraintsmight come from using typed feature structuresin tile lexicon, so that the rule application mech-anism can deterniine abead of time what the primary source of information is.
Another approachmight lie to require the grammar writer to spec-ify the c, onstraints on rules as belonging to specificcategories, and then to allow the rule applicationmechanisni to impose a predefined ordering be-tween categories; in particular, the most trouble-~)mc constraints are those which transport featurevalues around a structure, since ttmy may trans-port the wrong values, ms we saw in the examplediscussed earlier.Generat ion  of Rep lacement  Text: A topic wehave not addressed in the pr~ent paper is the gen-eration of corrections for hypothesiscd errors.
Theresult of parsing using relaxatkm provides ufli-cleat information to generate such replacements,but once again we need to maintain infurmatiouabout the dependencies between elements of astructure so that, when a new structure is created,any conflicts that ar i~ can be re=solved: for exam-ple, if generating a correction involves changingtile num feature of a noun from plural to singwlar, we need to encode the information that thelex feature is dependent upon the hum feature andsome specification of the root form, so that the re-tfiaeement mechanism knows which features takepriority and which may be overridden.Deciding between Er ror  lt:ypotheses: When aconstraint unifying two incompatible values vl midv~ has to be relaxed, then in tile absence of furtherinfi)rmation there are two equally likely error hy-pothers:  one, that vl is the correct value and t~ais wrong, mid the other that v~ is correct and Vlis wrong.
However, there are two typ~ of situa-tion in which further information available dm5ngparsing may ratable one hypothesis to be preferred.The first is where the absolute likelihood of oneerror seems greater thau that of the other, l, br ex-ample, in the case of the noun phro.?
?c these dog itmight prove to be much more likely for a writer tomistakenly omit the single letter s than to choosethe wrong determiner, which involvee a change oftwo letters there may be quantifiable differencebetween the assumptious behind the two hypothe-ses.
The second is where a number of possible r-rors are linked, for example if the whole sentencew~m "llJese dog are fie~vze, llere, two possible rrorsinvolving different rules are interdependent, midonce again it is possible to argue that one errorhypothesis requir~ a quantiliably dilferent set of~umpt ions;  here, both these and ant would haveto be wrong if dog were to be a.~sumed COrrect,.
"lb a certain extent, it may be possible to rely onunilication to deal with these confliet.~.
The relax-ation package dealing with the noun phr~ num-ber disagreement might 'hold its f i re ' -not  signalan error immediately- -leaving the number featureof the noun phrase uninstantiatcd.
Then there willbe no clash with the number of the verb phrmse,which will be propagated down to the noun phrase.It may be pix~sible to hook this value up to the subsequent t)rocc~ing el the error suggestion from thenolin phrase rule.Alternatively, the idea that there are a number ofa~sumptious behind a given error hypothc'sis couldbe formalised, perhaps by 1L~ing an A'rMS \[de Kleer1986a, 1986b\] to keep track of inconsistencies.
Ily-potimses could be weighted both by their absolutelikelihood and the contextual evidence (i.e., thenumber mid weight of related errors eonsis?ent midinco~mistent with the hypotheses).Much depends on where during the parsing pro~eess errors arise and are notified, and so detailedconsideration of this issue h~.u been deferred untilour eht~rt parser extension to this system has beenexplored.Acrl!s DE COLING-92.
NANTES.
23-28 hO(rr 1992 4 7 3 P~oc.
o~ COLING-92.
NArcri!s.
Aeo.
23 k28.
1992Levels o f  Re laxat ion :  The examples we have pro-vided have only explicitly mentioned one levelof relaxation, One can imagine situations whereother, further levels of relaxation are available.In particular, note that, since categorial informa-tion can be specified by means of constraints, wecan also consider handling instances of words mis-spelled as words of other syntactic ategories bymeans of the same mechanism; relaxing categoryfeature constraints might be an appropriate can-didate for a further level of relaxation.
There isof course the question of how one decides what re-laxations hould be available at what levels; deter-mining this requires more detailed statistical anal-ysis of the frequencies of different kinds of errors.It is also likely to bc required that individual errorrules, spread across a number of grammar rules, becapable of being treated as a unit, that is, switchedon or off together, orthogonal to the idea of relax-ation levels.D i f ferent  K inds  of  Re laxat ion :  In the forego-ing, we a~qumed that  relaxing a constraint sim-ply meant removing it.
There are other notions ofconstraint relaxation that could be used, of course;for example, if a constraint assigns a value to somefeature, we could relax this constraint by assigninga less specific value to that feature.
There may beother cases where we would want to generalise thenotion of relaxation to include the possibility thata constraint could be replaced by a quite differentconstraint.Conc lus ions  and  Future  WorkWe have described a simple extension to the PATR-n fornndism which allows us to provide declarativespecifications of possible relaxations on rules.
Thisprovides a good starting point for a flexible mech-anism for detecting and c~rrecting syntactic errors.One rea.~on for this is that  relaxation provides a pre-cise and systematic way of specifying the relation-ship t)etweeu errorflfl and 'CorrecU forms, making iteasier to generate suggestions for corrections.
A sec-ond reason is that the very uniform representationof linguistic information will allow flexible strategiesfor relaxation to be applied; this is particularly im-portant when dealing with text that may containunpredictable errors.As we have shown, the mechanism described here canbe applied straightforwarly to Constraint ViolationErrors as described at the beginning of the paper.At the moment wc have a rather ad hoe mechanismthat deals with cases of Lexical Confusion by pro-viding alternative l xical entries in the case of parsefailure, but this needs to be integrated better withthe relaxation mechanism.
Cases of Stylistic Awk-wardness imply require the addition of a critic thatwalks over the structures produced by the parser.The mQor  focus of our current work is the replace-ment of the shift-reduce parser by a chart parser, toenable us to handle cases of Missing or Extra Ele-ments.AcknowledgementsThis work was carried out as part  of lED Project1679, The EditorJ8 Assistan~ Douglas is supportedby SERC grant GRF 35654.
Much of our thinking onthis topic was inspired by conversations with PabloRomero-Mares, who constructed an early version ofthe parser as an MSe project.Re ferencestt Dale \[1989\] Computer-based E itorial Aids.
Pages12-20 in Recent Developments and Applications ofNatural Language Understanding, edited by JeremyPeckham.
Kogan Page, London.It Dale \[1990\] A Rule-based approach to Computer-Assisted Copy Editing.
Computer Assisted LanguageLearning, 2, 59-67.G E Heidorn, K Jensen, L A Miller, R J Byrd, andM S Chodorow \[1982\]\] The Epistle text-critiquingsystem.
IBM Systems Journal, 21, 305-326.J de Kleer {1986a\] An Assumption-based TruthMaintenance System.
Artificial Intelligence, 28,127-162.J de Kleer \[1986b\] Extending the TMS.
ArtificialIntelligence, 28, 163-196.S C Kwasny and N K Sondheimer \[1981\] RelaxationTheories for Parsing Ill-Formed Input.
AmericanJournal of Computational Linguistics, 7, 99-108.K Jensen, G E Heidorn, L A Miller, and Y Ravin\[1983\] Parse fitting and prose fixing: getting a holdon ill-formedness.
American Journal of Computa-tional Linguistics, 9, 147-160.L A Miller \[1986\] Computers for Composition: AStage Model Approach to Helping.
Visible Lan-guage, XX(2), 188 218.S D Richardson and L C Braden-Harder \[1988\] TheILxperience of Developing a Large-Scale Natural Lan-guage Text Processing System: CRITIQUE, In Pro-ceedings of the 2nd Applied Natural Lan ouage proHcessing Conference, pp195-202.S M Shiebcr I1986\] An Introduction to Unification-based Approaches to Grammar.
The University ofChicago Press, Chicago, Illinois.H Uszkoreit \[1990\] Strategies for Adding Control In-formation to Declarative Grammars.
In Proceedingsof the 29th Annual Meeting of the Association forComputational Linguistics, pp237-245,R M Weischedcl and J E Black \[1980\] Responding In-telligently to Unparsable Inputs.
American Journalof Computational Linguistics, 6, 87-109.AcrE.s DE COLING-92, NANTES, 23-28 AOUT 1992 4 7 4 PROC.
OF COLING-92, NANTES, AUG. 23-28, 1992
