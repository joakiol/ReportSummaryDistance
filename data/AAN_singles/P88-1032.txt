AN EAR.LEY-TYPE PAR.SING ALGOR.
ITHMFOR.
TR.EE ADJO IN ING GR_kMMAR.S  *Yves Schabes  and  Arav ind  K. JoshiDepartment ofComputer and Information ScienceUniversity of PennsylvaniaPhiladelphia PA 19104-6389 USAschabes~liac.cis.upenn.edu joshi~cis.upenn.eduABSTR.ACTWe will describe an Earley-type parser for TreeAdjoining Grammars (TAGs).
Although a CKY-type parser for TAGs has been developed earlier(Vijay-Shanker and :Icshi, 1985), this is the firstpractical parser for TAGs because as is well knownfor CFGs, the average behavior of Earley-typeparsers is superior to that of CKY-type parsers.The core of the algorithm is described.
Then wediscuss modifications of the parsing algorithm thatcan parse extensions of TAGs such as constraintson adjunction, substitution, and feature structuresfor TAGs.
We show how with the use of substi-tution in TAGs the system is able to parse di-rectly CFGs and TAGs.
The system parses unifi-cation formalisms that have a CFG skeleton andalso those with a TAG skeleton.
Thus it also al-lows us to embed the essential aspects of PATR-II.1 In t roduct ionAlthough formal properties of Tree AdjoiningGrammars (TAGs) have been investigated (Vijay-Shanker, 1987)--for example, there is an O(ns)-time CKY-like algorithm for TAGs (Vijay-Shankerand Joshi, 1985)--so far there has been no at-tempt to develop an Earley-type parser for TAGs.This paper presents an Earley parser for TAGsand discusses modifications to the parsing algo-rithm that make it possible to handle extensionsof TAGs such as constraints on adjunction, sub-*This work is partially supported by ARO grantDAA29-84-9-007, DARPA grant N0014-85-K0018, NSFgrants MCS-82-191169 and DCR-84-10413.
The authorswould like to express their gratitude to Vijay-Shankc~r fohis helpful comments relating to the core of the algorithm,Richard Billington and Andrew Chalnlck for their graphi-cal TAG editor which we integrated in our system and fortheir programming advice.
Tb,m~ are also due to AnneAbeill~ and Ellen Hays.stitution, and feature structure representation forTAGs.TAGs were first introduced by Joshi, Levy andTakahashi (1975) and Joshi (1983).
We describevery briefly the Tree Adjoining Grammar formal-ism.
For more details we refer the reader to Joshi(1983), Kroch and Joshi (1985) or Vijay-Shanker(1987).Defini t ion 1 (Tree Adjo in ing Grammar)  :A TAG is a 5-tuple G -- (VN, VT,S,I,A) whereVN is a finite set of non-terminal symbols, VT isa finite set of terminals, S is a distinguished non-terminal, I is a finite set of trees called init ialt rees and A is a finite set of trees called auxi l iarytrees.
The trees in I U A are called e lementarytrees.In i t ia l  t rees (see left tree in Figure 1) are char-acterized as follows: internal nodes are labeled bynon-terminals; leaf nodes are labeled by either ter-minal symbols or the empty string.SLi~minill$x / x \tofnflnld$ J Ltef rntnll|$Figure h Schematic initial and auxiliary treesAuxi l iary  t rees (see right tree in Figure 1)are characterized as follows: internal nodes are la-beled by non-terminals; leaf nodes are labeled bya terminal or by the empty string except for ex-actly one node (called the foot  node)  labeled bya non-terminal; furthermore the label of the footnode is the same as the label of the root node.We now define a composition operation calledadjo in ing or ad junct ion  which builds a new treefrom an auxiliary tree/9 and a tree ~ (~ is any tree,2$8initial, auxiliary or tree derived by adjunction).The resulting tree is called a derived tree.
Letc~ be a tree containing a node n labeled by X andlet fl be an auxiliary tree whose root node is alsolabeled by X.
Then the adjunction of fl to a atnode n will be the tree 7 shown in Figure 2.
Theresulting tree, 7, is built as follows:* The sub-tree of a dominated by n, call it t, isexcised, leaving a copy of n behind.?
The auxiliary tree fl is attached at n and its rootnode is identified with n.?
The sub-tree t is attached to the foot node of #and the root node n of t is identified with the footnode of ft.$%,(ct} (1~)$Figure 2: The mechanism of adjunctionThen define the tree set of a TAG G, T(G) tobe the set of all derived trees starting from initialtrees in I.
Furthermore, the str ing languagegenerated by a TAG, L(G), is defined to be theset of all terminal strings of the trees in T(G).TAGs factor recursion and dependencies by ex-tending the domain of locality.
They offer novelways to encode the syntax of natural languagegrammars as discussed in Kroch and Joshi (1985)and Abeill~ (1988).In 1985, Vijay-Shanker and Joshi introduced aCKY-like algorithm for TAGs.
They therefore s-tablished O(n 6) time as an upper bound for pars-ing TAGs.
The algorithm was implemented, butin our opinion the result was more theoretical thanpractical for several reasons.
First the algorithmassumes that elementary trees are binary branch-ing and that there are no empty categories on thefrontiers of the elementary trees.
Second, since itworks on nodes that have been isolated from thetree they belong to, it isolates them from theirdomain of locality.
However all important linguis-tic and computational properties of TAGs followfrom this extended omain of locality.
And mostimportantly, although it runs in O(n 6) worst time,it also runs in O(n s) best time.
As a consequence,the CKY algorithm is in practice very slow.Since the average time complexity of Earley'sparser depends on the grammar and in practiceruns much better than its worst time complex-ity, we decided to try to adapt Earley's parserfor CFGs to TAGs.
Earley's algorithm for CFGs(Earley, 1970, Aho and Ullman, 1973) is a bottom-up parser which uses top-down information.
Itmanipulates states of the form A -* a.fl\[i\] whileusing three processors: the predictor, the comple-tot and the scanner.
The algorithm for CFGs runsin O(IGl2n s) time and in O(IGI n2) space in allcases, and parses unambiguous grammars in O(n 2)time (n being the length of the input, IGI the sizeof the grammar).Given a context-free grammar in any form andan input string al " 'an ,  Earley's parser for CFGsmaintains the following invariant:The state A --* a./3\[i\] is in states et SkiffS ::b 6A'r, 6 :bal  " "ai and a ~ ai+l ""akThe correctness of the algorithm is a corollary ofthis invariant.Finding a Earley-type parser for TAGs was adifficult task because it was not clear how toparse TAGs bottom up using top-down informa-tion while scanning the input string from left toright.
In order to construct an Earley-type parserfor TAGs, we will extend the notions of dottedrules and states to trees.
Anticipating the proofof correctness and soundness of our algorithm, wewill state an invariant similar to Earley's originalinvariant.
Then we present he algorithm and itsmain extensions.2 Dot ted  symbols,  dottedtrees, tree traversalThe full algorithm is explained in the next section.This section introduces preliminary concepts thatwill be used by the algorithm.
We first show howdotted rules can be extended to trees.
Then weintroduce a tree traversal that the algorithm willmimic in order to scan the input from left to right.We define a dot ted symbol  as a symbol asso-ciated with a dot above or below and either to theleft or to the right of it.
The four positions of thedot are annotated by In, lb, ra, rb (resp.
left above,left below, right above, right below): laura lb  ~rb  ?Then we define a dot ted tree as a tree withexactly one dotted symbol.Given a dotted tree with the dot above and tothe left of the root, we define a tree traversal of adotted tree as follows (see Figure 3):259START "'~ f ENDi 'A,; oE F G H I2.1 2.2 2.3 &1 3.2Figure 3: Example of a tree traversal?
if the dot is at position la of an internal node,we move the dot down to position lb,?
if the dot is at position lb of an internal node,we move to position la of its leftmost child,?
if the dot is a t  position la of a leaf, we move thedot to the right to position ra of the leaf,?
if the dot is at position rb of a node, we movethe dot up to position ra of the same node,?
if the dot is at position ra of a node, there aretwo cases:- if the node has a right sibling, then move thedot to the right sibling at position la.- if the node does not have a right sibling, thenmove the dot to its parent at position rb.This traversal will enable us to scan the frontierof an elementary tree from left to right while try-ing to recognize possible adjunctions between theabove and below positions of the dot.3 The algorithmWe define an appropriate data structure for thealgorithm.
We explain how to interpret he struc-tures that the parser produces.
Then we describethe algorithm itself.3.1 Data  st ructuresThe algorithm uses two basic data structures:state and states set.A s ta tes  set S is defined as a set of states.
Thestates sets will be indexed by an integer: Si withi E N. The presence of any state in states set iwill mean that the input string al...al has beenrecognized.Any tree ~ will be considered as a function fromtree addresses to symbols of the grammar (termi-nal and non-terminal symbols): if z is a valid ad-dress in a, then a(z)  is the symbol at address zin the tree a.Def in i t ion  2 A s ta te  s is defined as a 10-tuple,\[a, dot, side,pos, l, ft, fr, star, t~, b~\] where:?
a: is the name of the dotted tree.?
dot: is the address of the dot in the tree a.?
side: is the side of the symbol the dot is on;side E {left, right}.?
pos: is the position of the dot;pos E {above, below}.?
star.
is an address in a.
The corresponding nodein a is called the starred node.?
!
(left), ft (foot left), fr  (foot right), t~ (top leftof starred node), b~ (bottom left of starred node)are indices of positions in the input string rangingover \[O,n\], n being the length of the input string.They will be explained further below.3.2 Invariant of the a lgor i thmThe states in a states et Si have a common prop-erty.
The following section describes this invariantin order to give an intuitive interpretation of whatthe algorithm does.
This invariant is similar toEarley's invariant.Before explaining the main characterization ofthe algorithm, we need to define the set of nodeson which an adjunction is allowed for a given state.Def in i t ion  3 The set of nodes 7~(s) on which anadjunction is possible for a given states - \[a, dot, side, pos, l, fh f i , s ta r ,  t~,b~\], is de-fined as the union of the following sets of nodesin a:?
the set of nodes that have been traversed on theleft and right sides, i.e., the four positions of thedot have been traversed;?
the set of nodes on the path from the root nodeto the starred node, root node and starred nodeincluded.
Note that if there is no star this set isempty.Def in i t ion  4 (Left  par t  o f  a dot ted  t ree)The left part of a dotted tree is the union of theset of nodes in the tree that have been traversedon the left and right sides and the set of nodesthat have been traversed on the left side only.We will first give an intuitive interpretation ofthe ten components of a state, and then give thenecessary and sufficient conditions for membershipof a state in a states set.We interpret informally a states = \[~, dot, side, pos, l, f~, f i ,  star, t~, b~\] in the fol-lowing way (see Figure 4):260"' 7C ~^"Tit!,al ... all atl+l .... ah'Figure 4: Meaning of s E Si?
l is an index in the input string indicating wherethe tree derived from a begins.?
ft is an index in the input string correspondingto the point just before the foot node (if any) inthe tree derived from a.?
f i  is an index in the input string correspondingto the point just after the foot node (if any) in thetree derived from a.The pair fi and f i  will meanthat the foot node subsumes the string al,+,...ay,.?
star:, is the address in a of the deepest node thatsubsumes the dot on which an adjunction has beenpartially recognized.
If there is no adjunction inthe tree a along the path from the root to the dot-ted node, star is unbound.?
t~ is an index in the input string correspondingto the point in the tree where the adjunction onthe starred node was made.
If star is unbound,then t~ is also unbound.?
b~ is an index in the input string correspondingto the point in the tree just before the foot node ofthe tree adjoined at the starred node.
The pair t~and b~ will mean that the string as far as the footnode of the auxiliary tree adjoined at the starrednode matches the substring alT+l...ab7 of the in-put string.
If star is unbound, then b~ is alsounbound.?
s E Si means that the recognized part of the dot-ted tree a, which is the left part of it, is consistentwith the input string from al to aa and from at toaI, and from ay.
to ai, or from a I to al and from azto al when the foot node is not in the recognizedpart of the tree.We are now ready to characterize the member-ship of s in S~:Invar iant  1A state s = \[a, dot, side,pos, l, fh fr, star, t~, b~\] isin Si if and only if there is a derived tree from aninitial tree such that (see Figure 4):1.
The tree a is part of the derivation.2.
The tree derived from a in the derivation tree,~, has adjunctions only on nodes in 7~(s).3.
The part of the tree to the left of the dot in thetree derived spans the string al ... ai.4.
The tree derived from a, E, has a yield thatstarts just after ah ends at ay, before the foot node(if ay, is defined), and starts after the foot nodejust after ay, (if aI, is defined).5.
If there are adjunctions on the path from thedotted node to the root of a, then star is the ad-dress of the deepest adjunction on that path andthe auxiliary tree adjoined at that node star hasa yield that starts just after a,~ and stops at itsfoot node at ab t.The proof of this invariant has as corollaries thesoundness, completeness, and therefore the cor-rectness of the algorithm.3 .3  The  recogn izerThe Earley-type recognizer for TAGs follows:Let G be a TAG.Let al..a, be the input string.program recognizerbeg~So = { \[a, O, left, above, 0 .
.
.
.
.
-\]\]a is an initial tree }For i := 0 to n dobeginProcess the states of Si, performing one ofthe fo l lowing seven operations on each states = \[c~, dot, side,pos, l, f,, fr, star, t~, b~\]until no more states can be added:I. Sc -~er2.
Move dot downS.
Move  dot  up4.
Left Predictor5.
Left Completor6.
Right Predictor7.
Right CompletorIf Si+1 is empty and i < n, return rejection.en~If there is in S. a states=\[a ,O,  right, above,O .
.
.
.
, - \ ]such that ~ is an initial treethen return acceptance.end.261The algorithm is a general recognizer for TAGs.Unlike the CKY algorithm, it requires no condi-tion on the grammar: the trees can be binary ornot, the elementary (initial or auxiliary) trees canhave the empty string as frontier.
It is an off-linealgorithm: it needs to know the length n of theinput string.
However we will see later that it canvery easily be modified to an on-line algorithm bythe use of an end-marker in the input string.We now describe one by one the seven processes.The current states et is presumed to be S /and  thestate to be processed iss = \[a, dot, side, pos, l, fZ, fr, star, tT\].Only one of the seven processes can be appliedto a given state.
The side, the position, and theaddress of the dot determine the unique processthat can be applied to the given state.Def in i t ion  5 (Adjunct(a, address)) Givena TAG G, define Adjunct(a,  address) as the setof auxiliary trees that can be adjoined in the ele-mentary tree ct at the node n which has the givenaddress.
In a TAG without any constraints onadjunction, if n is a non-terminal node, this setconsists of all auxiliary trees that are rooted by anode with same label as the label of n.3.3 .1  ScannerThe scanner scans the input string.
Suppose thatthe dot is to the left of and above a terminal sym-bol (see Figure 5).
Then if the terminal symbolmatches the next input token, the program shouldrecord that a new token has been recognized andtry to recognize the rest of the tree.Therefore "the scanner applies tos = \[a, dot, left,  above, 1, ft, L ,  star, t\[, b\[\]such that  ,',(dot) i s  a te rmina l  symbol and~(dot) = ~+I or ~(dot) is the empey symbol?
Case 1: a(dot) = ai+lThe scanner  adds\[~, dot, right, above, 1, f,, f i ,  star, t\[ , b\[ \] "coSI+I ??
Case 2: a(dot) =The scanner  adds\[tr, dot, right, above, l, ft, fr, star, t\[ , b\[ \] toS,.3.3.2 -Move  Dot  DownMove dot down (See Figure 6), moves the dotdown, from position lb of the dotted node to posi-C~e 1:a = a i ?
~\[1?1/T, tl*~l*\]C~le  2."
i m E~toSi+l\[1~1~,d',b1"\]Bjl~,tl'.bl'\]Figure 5: Scanner\[l,fl,fr,tl*,bi*\] \[l.flJr,tl*~ol*\]Figure 6: Move dot downtion la of its leftmost child.It there fore  applies ?os = \[~, d~,  left ,  below, l, ~,  f , ,  star, t\[, b\[\]such  that  ~he node  where  the  do~ i s  has ale f~most  ch i ld  at  address  u.I t  adds \[a, u, left ,  above, I, ~ , re, star, t\[ , b~ \] toS,.3.3.3 Move  DotUpMove dot up (See Figure 7), moves the dot "up",from position ra of the dotted node to position laof its right sibling if it has a right sibling, other-wise to position rb of its parent.It therefore applies tos = \[a, dot, ~ght,  above, l, ~, f i ,  star, t\[, b\[\]such that  the node on which the dot ishas a parent  node.?
Case 1: the node where the dot ishas a right sibling at address r.I t  adds \[ct, r, left,  above, l, fz, fr, star, t~ , b~\]~o S,.?
Case 2: the  node where the  dot  i s  i s~he rightmost child of the parentnode p.It adds\[~, p, right, below, l, f,, re, star, t~, bT\] to S,.262\[l~lJr, tl*,bl*\]add~mS/\[l,fl,f~',tl *,bl*\]Clme 92 X ii thv r lohlrn~ child\[l.fl,fi',tl',bl'\] \[l.fl,fr, tl*.bl'\]Figure 7: Move dot up3.3.4 Left  P red ic torSuppose that there is a dot to the left of and abovea non-terminal symbol A (see Figure 8).
Then thealgorithm takes two paths in parallel: it makes aprediction of adjunction on the node labeled byA and tries to recognize the adjunction (stepl)and it also considers the case where no adjunctionhas been done (step2).
These operations are per-formed by the Left  P red ic tor .It applies tos = \[~, dot, left,  above, 1, h ,  fr,  aar,  t~, b~\]such that ~(dot) is a non-terminal.?
Step I.
It adds the states(LS,0,1eft, above, i .
.
.
.
.
- \ ]\[B E Ad juna(~,  dot) } to Si.?
Step 2.- -  Case 1: the dot is not  on thefoot  node.I t  adds the s ta te\[~, dot, left,  below, 1, ~ , f i  , star, t~ ,b~ \]to  S,.- -  Case 2: the dot i s  on the footnode.
Necessar i l y ,  s ince  thefoot  node has not  been a l readyt raversed ,  ~ and fr areunspecified.It adds the state\[~, dot, left,  below, l, i, - ,  star, t~ , b~ \] toS,.3.3.5 Left  CompleterSuppose that the auxiliary that we left-predictedhas been recognized as far as its foot (see Fig-ure 9).
Then the algorithm should try to recognize\[I. n. fr.
tl.. bl.\] ~, (i.-.-.-.-\] J\[1, fl, fr, tl" ,bl*\] \[1, ft. fr, tl", bl*\]?---'A\[l.-.-.tl-~l.\] \[ki.-.tt.~l'\]Figure 8: Left Predictor\ [ r  , f l ' , f r ' , t l* ' ,b l* ' \ ]\[l.i.-.tl*,bl*\] \ [ r , f l ' , f r ' , l .
i \ ]Figure 9: Left completerwhat was pushed under the foot node.
(A star inthe original tree will signal that an adjunction hasbeen made and half recognized.)
This operationis performed by the Left  Completer .It applies tos = \[a, dot, left,  below, l, i, - ,  star, t~, b~\]such that  the  dot i s  on the  foot  node.For a l lI I I t I ,n St s = L 8, dot , left ,  above, l ,  f;, f~, s tar ,  t t , bt \] inSz such that  a E Adjunct(B, dot')Case I: dot' is on the foot node ofB.
Then necessary, f\[ and f~ areunbound.I t  adds the s ta teLS, dot' , left,  below, l ' , i , - ,dot ' , l ,~  to S,.Case 2: dot ~ i s  not on the foot  nodeof  B.I t  adds the s ta te~, dot', left,  below, l', f\[, f : ,  dot', l, ~ to S,.263Case l\[tl*,bl*,-,tl*',bl*'\]~*~1"1/--.--.
A .=..=~\[tI* ,bl" ,l,tl*',bl*'\]Case 2aldd to~Z.p.~.tl*.bl*\]Figure I0: Right Predictor3.3.6 R ight  P red ic torSuppose that there is a dot to the right of and be-low a node A (see Figure I0).
If there has beenan adjunction made on A (case I), the programshould try to recognize the right part of the aux-iliary tree adjoined at A.
However if there was noadjunction on A (case 2), then the dot should bemoved up.
Note that the star will tell us if an ad-junction has been made or not.
These operationsare performed by the Right predictor.The r ight  p red ic tor  app l ies  tos = \[a, dot, right, below, l, fz, fr,  star, tT, bT\]?
Case 1: dot = starFor all s ta tes  , t  $; s = \[/3, dot', left,  below, t~, bT, - ,  star ~-, tt , b t \].in Sb 7 such that  ~ ?
Adjunct(a,  dot),i t  adds the  s ta teL O, dot', right, below,tT, * " *' *' bz , , ,s tar ' , t  z ,b I \] tos,.?
Case  2: dot ~ starIt adds the  s ta te\[a, dot, right, above, l, fl, fr,  star, tT , bT \] toS,.3.3.7 Right  CompletorSuppose that the dot is to the right ot and abovethe root of an auxiliary tree (see Figure 11).
Thenthe adjunction has been totally recognized and theprogram should try to recognize the rest of the treein which the auxiliary tree has been adjoined.
Thisoperation is performed by the Right Completor.\[l',fl',fr',tl *'.bl *'\]\[I,fl,t~e,-I~addtd  to$i\[l',.~',~'r',tl*'.bl \]Figure 11: Right CompletorIt applies tos = \[a, 0, right, above, l, fz, L, -, -, -\]For  all statess!
= \[/3, dot', left, above, l', f\[ , fir, star', t~', b~'\]inS,and for all statesLS, dot',right, below, t',T,,~,dot',Z, fd in aS,such that a E Adjunct(E, dot')I t  addsLff , dot', right, above, l',-~l , 7~r, star', t;', 6;'\] toS,.Nhere 7 = f ,  i f  f i s  bound in s ta te  st,and f can have any va lue ,  i f  f i s  unboundin  s ta te  el.3.4 Handling constraints on adjunc-tionIn a TAG,  one can, for each node of an elementarytree, specify one of the following three constraintson adjunction (Joshi, 1987):?
Null adjunction (NA): disallow any adjunc-tion on the given node.?
Obligatory adjunction (OA): an auxiliarytree must be adjoined on the given node.?
Selective adjunction (SA(T)): a set T of aux-iliary trees that can be adjoined on the given nodeis specified.The algorithm can be very easily modified tohandle those constraints.
First, the functionAdjunct(a, address) must be modified as follows:?
Adjunct(a, address) = ~, if there is NA on thenode.?
A~unct (a ,  address) as previously defined, ifthere is OA on the node.?
Adjunct(a,  address) = T, if there is SA(T)  onthe node.Second, step 2 of the left predictor must be done264S~pl0s ?, .
.
i  ? '
s " d 3I ~ o  2.3(p)Figure 12: L = {a'~bnec"~ln >__O}make ma,~ tt~t no , .
, '~i~ po mblo  on tl~ root o f ~n inifi"~ ~m~S.I / \ - .
/ ' \$ ZFigure 13: Use of end marker in TAGonly if there is no obligatory adjunction on thenode at address dot in the tree a.3.5 An exampleWe give one example that illustrates how the rec-ognizer works.
The grammar used for the exam-ple generates the language L = {a"b"ecndn\]n >0}.
The input string given to the recognizeris: aabbeccdd.
The grammar is shown in Fig-ure 12.
The states sets are shown in Figure 14.Next to each state we have printed in paren-theses the name of the processor that was ap-plied to the state.
The input is recognized since\[a, O, right, above, 0. .
.
.
.
- \ ]  is in states setsg.3.6 RemarksUse of move dot up and move dot downMove dot down and move dot up can be eliminatedin the algorithm by merging the original dot andthe position it is moved to.
However for explana-tory purposes we chose to use these two processorsin this paper.Off-llne vs on-lineThe algorithm given is an off-line recognizer.
Itcan be very easily modified to work on line byadding an end marker to all initial trees in thegrammar (see Figure 13).Extracting a parseThe algorithm that we describe in section 3.3 is arecognizer.
However, if we include pointers froma state to the other states which caused it to heplaced in the states set, the recognizer can be mod-ified to produce all parses of the input string.3.7 CorrectnessThe correctness of the parser has been proven andis fully reported in Schahes and Joshi (1988).
Itconsists of the proof of the invariant given in sec-tion 3.2.
Our proof is similar in its concept to theproof of the correctness of Earley's parser given inAho and Ullman 1973.
The "ofily if" part of theinvariant is proved by induction on the number ofstates that have been added so far to all states sets.The "if" part is'proved by induction on a definedrank of a state.
The soundness (the algorithm rec-oguizes only valid strings) and the completeness (ifa string is valid, then the algorithm will recognizeit) are corollaries of this invariant.3.8 ImplementationThe parser has been implemented on SymbolicsLisp machines in Flavors.
More details of theactual implementation can be found in Schabesmad Joshi (1988).
The current implementationhas an O(IGlZn 9) worst case time complexity andO(IGln 6) worst case space complexity.
We havenot as yet been able to reduce the worst case timecomplexity to O(\[G\[Zn6).
We are currently at-tempting to reduce this bound.
However, the mainpurpose of constructing an Parley-type parser is toimprove the average complexity, which is crucial inpractice.4 Extens ionsWe describe how substitution is defined in a TAG.We discuss the consequences of introducing substi-tution in TAGs.
Then we show how substitutioncan be parsed.
We extend the parser to deal withfeature structures for TAGs.
Finally the relation-ship with PATR-II is discussed.4.1 Introducing substitution inTAGsTAGs use adjunction as their basic compositionoperation.
It is well known that Tree AdjoiningLanguages (TALs) are mildly context-sensitive.TALs  properly contain context-free languages.
Itis also possible to encode a context-free grammarwith auxiliary trees using adjunction only.
How-ever, although the languages correspond, the pos-sible encoding does not reflect directly the original265So.$1$2$aS4S5S6$7sss9\[a, O, left,  above, 0 .
.
.
.
.
- \ ]  (left predictor)\[?~, O, left,  below, O, - ,  - ,  - ,  - ,  -~ (move dot down)\[~!
Zp left,  ahoy% 01 - - , - - r - - , - - , - -2  (scanner)1, right, abo~e, 0, --, - ,  --, --, - \ ]  (move dot up)2, left,  below, 0, --, --, --, --, - \ ]  (move dot down)\[~, 2.1, left, above, O, - ,  - ,  - ,  - ,  - \ ]  (scanner)z, le / t t .bove ,  Z, , , , ,-\] ~sc~ner)l e f t  ?ha .
2 - - , -  - - i  ( l e f t\[/~, 2, left,  below, 1 .
.
.
.
.
- \ ]  (move dot down)O, left, below, 2, --, --, - ,  --, --\] (move dot down)\[~', 1, right, above, 1, - t  --1--, --,--\] ~move dot up)\[0, 2.2, left ,  below, 1, 3, --,--, --,--\] ~left completor)\[/~, 2.1, right, above, I, --, --, --, --, --\] (move dot up)\[~, O, left,  above, 0, - .
.
.
.
- \ ]  (left predictor)f/J, O, left,  below, 0, - ,  - ,  - ,  - ,  - \ ]  (move dot down) -\] ~scanner) \[ct, 11 le~t l aboo% 0 r -1 --I --P - ,  (left predictor) ,\[~, 2, left ,  above, O, - ,  - ,  - ,  - ,\[13, O, left,  above, 1, - ,  - ,  - ,  - ,  - \ ]  (left predictor)\[0, O, left, below, 1, - ,  --, --, - ,  --\] (move dot down)\[/~, 2.1, left,  aboue, 1, --, --, - ,  - ,  - \ ]  (scanner)\[B, 1, left,  above, 2, - ,  --, --, - ,  --\] (scanner)\[/~, 2, left,  above, 1, --, - ,  --, --, - \ ]  (left predictor)\[0, 2, left,  below, 0, - ,  - ,  2, 1,3\] (move dot down)\[~, 2.2, left,  above, 1, - ,  - ,  - ,  - ,  - \ ]  (left predictor)\[p, 2.1, le/t, abate, O, - ,  - ,  211, a I (scanne 0\[o, 1, left, above, O, --, --, O, O, 4\] (manner)\[~, 2.2, fe l l  abo~e, O, - ,  - ,  2, 1, 3\] (left predictor)\[~, 2.2, le)'t, below, O, 4, --, 2, 1,3\] ( left completor)\[0, 2.3, le f t ,  abooe, O, 4, 5, 2,1,3\]  (scanner)\[~, 2.2, right, above, 0, 4, 5, 2, 1, 3\] (move dot up)\[a~ 1, right, above t O r --t --w 01014\] (move dot up)\[0, 2.2, right, above, 1, 3, 6, - ,  - ,  - \ ]  (move dot up)\[~, 2.3, left ,  above, 1, 3, 6, --, - ,  - \ ]  (scanner)\[~, 2.2, right, below, 1~ 3~ 6~ -~ - r - \ ]  (right predictor case 2)\[0, 2, right, below, 1,3, 6 , - - , - , - - \ ]  (right predictor, case 2)B I 3, lep ,  above, 1,3, 6, - I  --I--1 (scanner)~, O, right, below, I ,  3, 6, --, --, - \ ]  (right predictor, case 2)\[~, 3, left,  above, 0, 4, 5, --, --, --\] (scanner)(move dot up) \[~1 21 fish'1 oh?re10, 41 51 --, --I -- (right predictor, case 2) \[~, O, right, below, O, 4, 5, - ,  - ,\[~, O, rlqht l above, O, 4, 5, --, --, --\] (right completor)\[a, 0, left,  beio~, 0, --, --, 0, 0, 4\] (move dot down)\[0, 2.1, right, above, 0, --, --, 2, 1,3\] (move dot up)\[\[3, 2.2, right, below, 0, 4, 5, 2,1,3\] (right predictor, case 2)\[a, 0, right, below, O, - ,  - ,  O, O, 4\] (right predictor, case 1)\[0, 2.8, right, above, 0, 4, 5, 2, 1, 3\] (move dot up)LS, 2, right, below, O, 4, 5, 2,1,3\] (right predictor, case 1)\[0, 2, right, above, 1,3, 6, --, --, --\] (move dot up)I B r 2.31 right I above, 113, 61 --I --~--\] (move dot up) /3, O, right, above, I, 3, 6, --, --, --\] (right completor)\[0, 3, right, abo~e, 1,3, 6, --, --, --\] (move dot up)\[o, O, right, above, O, --, --, --, - ,  - \ ]  (end test)\[~, 3, r ight ,  above, O, 4, 5, - ,  --, --\] (move dot up)Figure 14: States sets for the input aabbeccdd/\Figure 15: Mechanism of substitutioncontext free grammar since this encoding uses ad-junction.Substitution is the basic operation used in CFG.A CFG can be viewed as a tree rewriting system.It uses substitution as basic operation and it con-sists of a set of one-level trees.
Substitution is aless powerful operation than adjunction.However, recent linguistic work in TAG gram-mar development (Abeilld, 1988) showed the needfor substitution in TAGs as an additional opera-tion for obtaining appropriate structural descrip-tions in certain cases such as verbs taking two sen-tential arguments (e.g.
"John equates solving thisproblem with doing the impossible") or compoundcategories.
It has also been shown to be usefulfor lexical insertion (Schabes, Abeind and Joshi,1988).
It should be emphasized that the intro-duction of substitution in TAGs does not increasetheir generative capacity.
Neither is it a step backfrom the original idea of TAGs.Def in i t ion 6 (Subst i tu t ion  in TAG)  We de-$ VP NPFigure 16: Writing a CFG in TAGfine substitution in TAGs to take place on specifiednodes on the frontiers of elementary trees.
Whena node is marked to be substituted, no adjunctioncan take place on that node.
Furthermore, sub-stitution is always mandatory.
Only trees derivedfrom initial trees rooted by a node of the same la-bel can be substituted on a substitution node.
Theresulting tree is obtained by replacing the node bythe tree derived from the initial tree.
Substitutionis illustrated in Figure 15.We conventionally mark substitution nodes bya down arrow (1).As a consequence, we can now encode directlya CFG in a TAG with substitution.
The resultingTAG has only one-level initial trees and uses onlysubstitution.
An example is shown in Figure 16.4.2 Parsing subst i tut ionThe parser can be extended very easily to handlesubstitution.
We use Earley's original predictorand completor to handle substitution.266\[I, f l ,  ft .
fl*, bl*,subs~?\] ~ .
\[i,-.-,-.-.W~e\]Figure 17: Substitution PredictorThe left predictor is restricted to apply to nodesto which adjunction can be applied.A flag subst?
is added to the states.
When set,it indicates that the tree (initial) has been pre-dicted for substitution.
We use the index !
(asin Earley's original parser) to know where it hasbeen predicted for substitution.
When the initialtree that has been predicted for substitution hasbeen totally recognized, we complete the state asEarley's original parser does.A s tate  s is now an l l - tup le?
\[~, dot, side,poe, l, fl, fr, star, t~, b~, subst?\]:where subst?
is a boolean that indicates whetherthe tree has been predicted for substitution.
Theother components have not been changed.We add two more processors to the parser.Subst i tu t ion  P red ic torSuppose that there is a dot to the left of and abovea non-terminal symbol on the frontier A that ismarked for substitution (see Figure 17).
Then thealgorithm predicts for substitution all initial treesrooted by A and tries to recognize the initial tree.This operation is performed by the subst i tu t ionpredictor .It applies tos -  \[~, dot, left,  above, l, f l, fr , star, t~ i b~ ,subst?\]such that a(dot) is a non-terminal on thefrontier of ~ .hieh is marked forsubst itut ion:It adds the states{\[fl, O, left,  above, i, - ,  - ,  - ,  - ,  - ,  true\]\]/~ is  an Ln i t ia l  tree s .
t .#(O)  -- or(dot)}to Si.Subst i tu t ion  CompletorSuppose that the initial tree that we predicted forsubstitution has been recognized (see Figure 18).Then the algorithm should try to recognize therest of the tree in which we predicted a substitu-tion.
This operation is performed by the substi -tu t ion  completor .\[i'.fl',fr',tl*'.bl*',subst?
'\]_ .\[I.fl,fr.-.-,=uel \[r,fl',fr',tl*',bl *',subst?
'\]Figure 18: Substitution completorIt applies tos=\[a,O,  rioht,above, l, , , , , , t rue \ ]For all states s =\[/3, dot', left,  a~-v~o e,- l',jt,jr,star'," " t~', b~', subst?
'\]in  Sa s .
t .
#(dot') i s  marked fo rsubst i tu t ion  and l~(dot) = a(O).I t  adds the following stats to Si:\[/3, dot', right, above, 1', f\[ , f~, star', t~' ,b~ ', subst?
'\] .Complex i tyThe introduction of the substitution predictor andthe substitution completor does not increase thecomplexity of the overall TAG parser.I f  we encode a CFG with substitution in TAG,the parser behaves in O(IGl~n s) worst case timeand O(\[GIn 2) worst case space like Earley's orig-inal parser.
This comes from the fact that whenthere are no auxiliary trees and when only substi-tution is used, the indices f t , f i , t~,b~ of a statewill never be set.
The algorithm will use only thesubstitution predictor and the substitution eom-pletor.
Thus, it behaves exactly like Earley's orig-inal parser on CFGs.4.3 Pars ing feature structures forTAGsThe definition of feature structures for TAGs andtheir semantics was proposed by Vijay-Shanker(1987) and Vijay-Shanker and Joshi (1988).
Wefirst explain briefly how they work in TAGs andshow how we have implemented them.
We in-troduce in a TAG framework a language simi-lar to PATR-II which was investigated by Shieber(Shieber, 1984 and 1986).
We then show how onecan embed the essential aspects of PATR-II in thissystem.267t br tUu"mbrf t f..- I, UbrFigure 19: Updating of featuresANP Vp (a)I / \PRO V PP / \to go to the moviesS.top::gtsnsed> = +S,bottom::<tensed> = V.boRom::<tensed>V.bottom::<tensed> = -Feature s t ructures  in TAGsAs defined by Vijay-Shanker (1987) and Vijay-Shanker and 30shi(1988), to each adjunction odein an elementary tree two feature structures are at-tached: a top and a bottom feature structure.
Thetop feature corresponds to a top view in the treefrom the node.
The bottom feature correspondsto the bottom view.
When the derivation is com-pleted, the top and bottom features of all nodesare unified.
If the top and bottom features of anode do not unify, then a tree must be adjoinedat that node.This definition can be trivially extended to sub-stitution nodes.
To each substitution ode we at-tach two identical feature structures (top and bot-tom).The updating of features in case of adjunctionis shown in Figure 19.Unif icat ion equat ionsAs in PATR-II, we express with unification equa-tions dependencies between DAGs in an elemen-tary tree.
The system therefore consists of a TAGand a set of unification equations on the DAGsassociated with nodes in elementary trees.An example of the use of unification equationsin TAGs is given in Figure 20.
Note that the topand bottom features of node S in (~ can not be uni-fied.
This forces an adjunction to be performed onS.
Thus, the following sentence is not accepted:* to  go 1;o 1;he mov ies .The auxillm-y tree 81 can be adjoined at S in or:John wan1;s 1;o go 1;o 1;he mov ies .But since the bottom feature of S has tensed value- in c~ and since the bottom feature of S hastensed value -4- in/32, /31 can not be adjoined atnode S in a:"Bob 1;hinks 1;o go I;o 1;he movies.But/~2 can be adjoined in 81, which itself can beadjoined in a:Bob thinks John wan1;s 1;o go I;o 1;he$ANP VP (\[~1)A / \John V S 1IwltnuS.top::<tensed> .
+S.bottorn::<lensed=, .
V .bo l lom: :<tensed>S_ l .bonom: :<tensed>.
,  V .bot tom: :<tensed-S l>V .bot lom: :<tensed.S l> ,.
-V.boRom::<tensed> .
+SANP VP QB2)A / \Bob V S Il~ksS.top::<tensed> .
+S.bottom::<tensed> .
V.bot lom::<tensed>S 1.bottom::<lensed> .
V .bot tom: :< lensed-S l>V.bonom::<tensed-S l> .
+V.bonom::<lensed> ,.
?Figure 20: Example of unification equationsmovies .We refer the reader to Abeill6 (1988) and toSchabes, Abeill6 and 3oshi (1988) for further ex-planation of the use of unification equations andsubstitution in TAGs.268Pars ing and the relat ionship with PATr t - I IBy adding to each state the set of DAGs cor-responding to the top and bottom features ofeach node, and by making sure that the unifica-tion equations are satisfied, we have extended theparser to parse TAGs with feature structures.Since we introduced substitution and since weare able to encode a CFG directly, the systemhas the main functionalities of PATtt-II.
The sys-tem parses unification formalisms that have a CFGskeleton and a TAG skeleton.5 Conc lus ionWe described an Earley-type parser for TAGs.
Weextended it to deal with substitution and featurestructures for TAGs.
By doing this, we have builta system that parses unification formalisms thathave a CFG skeleton and also those that have aTAG skeleton.
The system is being used for TreeAdjoining Grammar development (AbeiU~, 1988).This work has led us to a new general parsingstrategy (Schabes, Abeill~ and Joshi, 1988) whichallows us to construct a two-stage parser.
In thefirst stage a subset of the elementary trees is ex-tracted and in the second stage the sentence isparsed with respect o this subset.
This strategysignificantly improves performance, specially asthe grammar size increases.ReferencesAbeill~, Anne, 1988.
A Computational Grammar forFrench in TAG.
In Proceeding of the 12 th InternationalConference on Computational Linguistics.Aho, A. V. and Ullman, J. D., 1973.
Theory ofParsing, Translation and Compiling.
Vol I: Parsing.Prentice-Hall, Englewood Cliffs, NJ.Earley, J., 1970.
An Efficient Context-Free ParsingAlgorithm.
Commun.
ACM 13(2):94-102.Joshi, Aravind K., 1985.
How Much Context-Sensitivity is Necessary for Characterizing StructuralDescriptions - -  Tree Adjoining Grammars.
In Dowry,D.
; Karttunen, L.; and Zwicky, A.
(editors), NaturalLanguage Processing- Theoretical, Computationaland Psychological Perspectives.
Cambridge UniversityPress, New York.
Originally presented in 1983.2oshi, Aravind K., 1987.
An Introduction to Tree Ad-joining Grammars.
In Manaster-Ramer, A.
(editor),Mathematics of Language.
John Benjamins, Amster-dam.Joshi, A. K.; Levy, L. S.; and Takahashi, M., 1975.T~ee Adjunct GraJnmars.
J. Comput.
Syst.
Sci.
10(1).Kroch, A. and Joshi, A. K., 1985.
Linguistic Relevanceof Tree Adjoining Grammars.
Technical Report MS-CIS-85-18, Department ofComputer and InformationScience, University of Pennsylvaain.Schabes, Yves and Joahi, Aravind K., 1988.
AnEarley.type Parser for Tree Adjoining Grammars.Technical Report, Department of Computer and In-formation Science, University of Pennsylvania.Schabes, Yves; Abeill~, Anne; and Joshi, Aravind K,1988.
New Parsing Strategies for Tree AdjoiningGrammars.
In Proceedings of the 12 th InternationalConference on Computational Linguistics.Shieber, Stuart M., 1984.
The Design of a ComputerLanguage for Linguistic Information.
In 22 ~ Meet-ing of the Association for Computational Linguistics,pages 362-366.Shieber, Stuart M., 1986.
An Introduction to Unifi-cation.Based Approaches to Grammar.
Center for theStudy of Language and Information, Stanford, cA.Vijay-Shanker, K., 1987.
A Study of Tree AdjoiningGrammars.
PhD thesis, Department ofComputer andInformation Science, University of Pennsylvania.Vijay-Shanker, K. and Joshi, A. K., 1985.
Some Com-putational Properties of Tree Adjoining Grammars.In 23 rd Meeting of the Association for ComputationalLinguistics, pages 82-93.Vijay-Shanker, K. and Joshi, A.K., 1988.
FeatureStructure Based Tree Adjoining Grammars.
In Pro-ceedings of the 12 ta International Conference on Com-putational Linguistic&269
