Restrictions on Monadic Context-Free Tree GrammarsAkio FujiyoshiDepartment of Computer and Information Sciences, Ibaraki University4-12-1 Nakanarusawa, Hitachi, Ibaraki, 316-8511, Japanfujiyoshi@cis.ibaraki.ac.jpAbstractIn this paper, subclasses of monadic context-free tree grammars (CFTGs) are compared.Since linear, nondeleting, monadic CFTGs gen-erate the same class of string languages astree adjoining grammars (TAGs), it is examinedwhether the restrictions of linearity and non-deletion on monadic CFTGs are necessary togenerate the same class of languages.
Epsilon-freeness on linear, nondeleting, monadic CFTGis also examined.1 IntroductionThe context-free tree grammars (CFTGs) were in-troduced by W. C. Rounds (1970) as tree gener-ating systems, the definition of which is a directgeneralization of context-free grammars (CFGs)from strings to rooted, ordered, labeled trees.
Forthe application of CFTGs to natural languages,many kinds of restrictions on CFTGs have beenconsidered because the string languages generatedby CFTGs are exactly indexed languages, whoseemptiness problem and uniform membership prob-lem are exponential time complete, i.e., nonre-stricted CFTGs are formidable.
One approach todefine subclasses of CFTGs is to restrict the ranksof nonterminals.
The rank of a nonterminal is a nat-ural number assigned to each nonterminal by whichthe number of children of the node labeled by thenonterminal is fixed.
Through this approach, thesimplest model of CFTGs is regular tree grammars(RTGs) (Brainerd, 1969), where the ranks of non-terminals are all 0.
The string languages generatedby RTGs are the languages generated by context-free grammars (CFGs).
Since recent research onnatural languages has suggested that formalisms fornatural languages need to generate a slightly largerclass of languages than CFGs, this paper focuses onmonadic CFTGs, where the ranks of nonterminalsare either 0 or 1.Another formalism of tree generating systems istree adjoining grammars (TAGs) (Joshi et al, 1975;Joshi and Schabes, 1996; Abeille?
and Rambow,2000).
TAGs have been widely studied relatingthem to natural languages, and it was shown thatTAGs have the same generative power of string lan-guages as other formalisms for natural languagesdeveloped independently such as head grammars,combinatory categorial grammars and linear in-dexed grammars (Vijay-Shanker and Weir, 1994).It is also noteworthy that there are recognitionalgorithms for the string languages generated byTAGs that run in O(n6) and O(M(n2)) time (Ra-jasekaran, 1996; Rajasekaran and Yooseph, 1998).From the view point of CFTG, the languages gener-ated by TAGs were examined (Fujiyoshi and Kasai,2000; Fujiyoshi, 2004; Mo?ennich, 1997), and it wasshown that linear, nondeleting, monadic CFTGsgenerate the same class of string languages as TAGsand a strictly larger class of tree languages thanTAGs.
Linearity is a restriction on CFTGs thatrequires the number of occurrences of every vari-able in the right-hand side of a rule be no morethan 1, and nondeletion requires all variables in theleft-hand side of a rule occur at least once in theright-hand side.
In other words, linear, nondelet-ing, monadic CFTGs are those with nonterminals ofrank 0 and 1 only and with exactly one occurrenceof a variable in every right-hand side of a rule for anonterminal of rank 1.In this paper, the subclasses of monadic CFTGsare compared to examine whether the restrictionsof linearity and nondeletion on monadic CFTGs arenecessary to generate the same class of string lan-guages as TAGs.
It is shown that nondeletion is un-necessary since for any linear, monadic CFTG, thereexists an equivalent linear, nondeleting, monadicCFTG.
On the other hand, it is shown that linearityis necessary since there exists a non-linear, monadicCFTG which is not weakly equivalent to any linear,monadic CFTG.For the development of parsing algorithm, theproperty of epsilon-freeness is very important, andin this paper, epsilon-freeness on linear, monadicCTFGs is also considered.
Epsilon-freeness is arestriction on grammars that requires no use ofepsilon-rules, that is, rules defined with the emptystring.
It is shown that for any linear, monadicCFTG, there exists an epsilon-free, linear, nondelet-ing, monadic CFTG that generate the same stringlanguage.2 PreliminariesIn this section, some terms, definitions and formerresults which will be used in the rest of this paperare introduced.2.1 Ranked Alphabets, Trees and SubstitutionA ranked alphabet is a finite set of symbols in whicheach symbol is associated with a natural number,called the rank of a symbol.
Let ?
be a ranked al-phabet.
For n ?
0, it is defined that ?n = {a ?
?| the rank of a is n}.The set T?
(trees over ?)
is the smallest set ofstrings over ?, parentheses and commas such that(1) ?0 ?
T?
and (2) if ?1, ?2, .
.
.
, ?n ?
T?
anda ?
?n for some n ?
1, then a(?1, ?2, .
.
.
, ?n) ?T?.Let ?
be the empty string.
Let ?
be the specialsymbol that may be contained in ?0.
The yield ofa tree is a function from T?
into ??
defined as fol-lows.
For ?
?
T?, (1) if ?
= a ?
(?0 ?
{?}),yield(?)
= a, (1?)
if ?
= ?, yield(?)
= ?, and(2) if ?
= a(?1, ?2, .
.
.
, ?n) for some a ?
?nand ?1, ?2, .
.
.
, ?n ?
T?, yield(?)
= yield(?1) ?yield(?2) ?
?
?
yield(?n).Let X be the fixed countable set of variablesx1, x2, .
.
..
It is defined that X0 = ?
and for n ?
1,Xn = {x1, x2, .
.
.
, xn}.
x1 is situationally denotedby x.
T?
(Xn) is defined to be T?
?Xn taking theranks of elements in X are all 0.
For ?
?
T?
(Xn)and ?1, ?2, .
.
.
, ?n ?
T?
(X), ?
[?1, ?2, .
.
.
, ?n] isdefined to be the result of substituting each ?i (1 ?i ?
n) for the occurences of the variable xi in ?.A tree ?
?
T?
(Xn) is linear if no variable occursmore than once in ?, and nondeleting if all variablesin Xn occur at least once in ?.
The set of all lineartrees and all nondeleting trees in T?
(Xn) are de-noted by T?
(dXne) and T?
(bXnc), respectively.In this papaer, the conventional way of illus-trating trees is used.
See Figure 1.
The treeA(b(a), a, B(E, d)) is illustrated as (1).
An arbi-trary tree ?
?
T?
is illustrated as (2).
When thevariables of a tree ?
?
T?
(X3) occur in the order ofx1, x2, x3, x1, the tree is illustrated as (3).2.2 Context-Free Tree GrammarsThe context-free tree grammars (CFTGs) were in-troduced by W. C. Rounds (1970) as tree generatingsystems.
The definition of CFTGs is a direct gener-alization of context-free grammars (CFGs).$E D %(D G?
?x1 x2 x3 x1(1) (2)(3)Figure 1: TreesA context-free tree grammar (CFTG) is a four-tuple G = (N,?, P, S), where:?
N and ?
are disjoint ranked alphabets of non-terminals and terminals, respectively.?
P is a finite set of rules of the formA(x1, x2, .
.
.
, xn) ?
?with n ?
0, A ?
Nn and ?
?
TN??(Xn).
ForA ?
N0, rules are written as A ?
?
instead ofA() ?
?.?
S, the initial nonterminal, is a distinguishedsymbol in N0.For a CFTG G, the one-step derivationG?
isthe relation on TN??
?
TN??
such that for a tree?
?
TN?
?, if ?
= ??
[A(?1, ?2, .
.
.
, ?n)] for some??
?
TN??
(dX1e) ?
TN??
(bX1c), A ?
Nn and?1, ?2, .
.
.
, ?n ?
TN?
?, and A(x1, x2, .
.
.
, xn) ??
is in P , then ?G?
??[?
[?1, ?2, .
.
.
, ?n]].
Figure 2is an example of a one-step derivation where the ruleA(x) ?
?
is applied to the tree ?
= ??[A(???)]
andthe tree ??[?[???]]
is obtained.An (n-step) derivation is a finite sequence oftrees ?0, ?1, .
.
.
, ?n ?
TN??
such that n ?
0 and?0 G?
?1 G?
?
?
?
G?
?n.
When there exists a deriva-tion ?0, ?1, .
.
.
, ?n, it is writen that ?0 Gn?
?n or?0 G??
?n.The tree language generated by G is the setL(G) = {?
?
T?
| S G??
?}.
The string languagegenerated by G is LS(G) = {yield(?)
| ?
?
L(G)}.Note that LS(G) ?
(?0 ?
{?})?.??$????????
????
?x x$*xFigure 2: One-step derivationLet G and G ?
be CFTGs.
G and G ?
are equivalentif L(G) = L(G ?).
G and G?
are weakly equivalent ifLS(G) = LS(G?
).2.3 Restrictions on CFTGsA CFTG G = (N,?, P, S) is monadic if therank of any nonterminal is 0 or 1, i.e., N =N0 ?
N1 and Nn = ?
for n ?
2.
G is lin-ear if for any rule A(x1, x2, .
.
.
, xn) ?
?
in P ,?
?
TN??
(dXne), and nondeleting if for any ruleA(x1, x2, .
.
.
, xn) ?
?
in P , ?
?
TN??
(bXnc).A CFTG G = (N,?, P, S) is epsilon-free if forany rule A(x1, x2, .
.
.
, xn) ?
?
in P , the symbol ?doesn?t occur in ?.When G is monadic, all rules are either of theform A(x) ?
?
with A ?
N1 and ?
?
TN??
(X1)or of the form B ?
?
with B ?
N0 and ?
?
TN?
?.When G is monadic, linear and nondeleting, for anyrule A(x) ?
?
with A ?
N1 in P , there existsexactly one occurrence of x in ?.For linear, nondeleting, monadic CFTGs, the fol-lowing results are known.Theorem 2.1 (Fujiyoshi and Kasai, 2000) Theclass of string languages generated by linear, non-deleting, monadic CFTGs coincides with the classof string languages generated by TAGs.Theorem 2.2 (Fujiyoshi and Kasai, 2000) For anylinear, nondeleting, monadic CFTG, there existsa weakly equivalent linear, nondeleting, monadicCFTG G = (N,?, P, S) that satisfies the followingconditions:?
For any a ?
?, the rank of a is either 0 or 2.?
For each A ?
N0, if A ?
?
is in P , then either?
= a with a ?
?0, or ?
= B(C) with B ?N1 and C ?
N0.
See (1) and (2) in Figure 3.$ D $%&$x$x%&x$xEx &Ex&(1) (2)(3)(4) (5)Figure 3: Strong normal form?
For each A ?
N1, if A(x) ?
?
is in P , then ?is one of the following forms:?
= B(C(x)) with B,C ?
N1,?
= b(C, x) with b ?
?2 and C ?
N0, or?
= b(x,C) with b ?
?2 and C ?
N0.See (3),(4) and (5) in Figure 3.If a linear, nondeleting, monadic CFTG satisfies thecondition of Theorem 2.2, it is said that the grammaris in strong normal form1.3 Linearity and Nondeletion on MonadicCFTGsBecause linear, nondeleting, monadic CFTGs gen-erate the same class of string languages as TAGs,the question is whether the restrictions of linearityand nondeletion on monadic CFTGs are necessaryto generate the same class of languages.
First, itwill be shown that nondeletion is unnecessary.Theorem 3.1 For any linear, monadic CFTG G,there exists an equivalent linear, nondeleting,monadic CFTG G ?.Proof.
Let G = (N,?, P, S) be a linear, monadicCFTG.
An equivalent linear, nondeleting, monadicCFTG G?
= (N ?,?, P ?, S) can be constructed asfollows.The set of nonterminal is N ?
= N ?0 ?
N ?1 suchthat N ?0 = N0 ?
{A |A ?
N1} and N ?1 = N1.For the preparation of the definition of P ?, for ?
?TN??
(X1) we define ?(?)
?
TN ???
(X1) as thesmallest set satisfying the following conditions:?
?
?
?(?
)D1We say ?strong?
because a grammar in this normal formonly preserves weak equivalence.x*??
?
* ?(1)?????x????
*?
* ?(2)^???????
*?*?(3)^???
??
?Figure 4: The three different cases?
If ?
?
?(?)
and ?
= ?
?[B(???)]
for some B ?N1, ??
?
TN ???
(dX1e) ?
TN ???
(bX1c) and???
?
TN ??
?, then ??
[ B ] ?
?(?
).The set of rules is defined as follows.P ?
= {A ?
??
| A ?
N0, A ?
?
?
P , ??
?
?(?)}?
{A(x) ?
??
| A ?
N1, A(x) ?
?
?
P ,??
?
?(?)
?
TN ???(bX1c)}?
{A ?
??
| A ?
N1, A(x) ?
?
?
P ,??
?
?(?)
?
TN ???
}Because of the construction of N ?
and P ?, G?
ismonadic and nondeleting.To show the equivalence of G and G ?, we provethe following statement holds for any ?
?
TN?
?and ?
?
T?
by induction on the length of deriva-tions:?G??
?
if and only if there exitsts ??
??(?)
such that ??G???
?.We start with proving ?only-if?
part.
Let ?Gk?
?.If k = 0, then clearly ?
= ?, ?
?
?(?)
and?G???
?.
For k ?
1, assume that the statementholds for any derivation of length less than k. Ifa rule of the form A ?
?
with A ?
N0 isused at the first step, the proof is rather simple,so we only prove the other case.
Suppose thata rule A(x) ?
?
with A ?
N1 is used at thefirst step and ?
= ??[A(???)]G?
??[?[???]]G??
?
forsome ??
?
TN??
(dX1e) ?
TN??
(bX1c) and ???
?TN??.
By the induction hypothesis, there exist?
?
?(??[?[???]])
such that ?G???
?.
Here, we have tothink of the three different cases: (1) ?
?
?(??
), (2)?
can be written as ??[??]
for some ??
?
?(??)
and??
?
?(?
), and (3) ?
can be written as ?
?[??[???]]
forsome ??
?
?(??
), ??
?
?(?)
and ???
?
?(???).
SeeFigure 4.
In the case (1), ?
?
?(?)
and ?G???
?.In the case (2), A ?
??
is in P ?
and therefore,??
[ A ] ?
?(?)
and ??
[ A ]G??
??[??]G???
?.
And inthe case (3), A(x) ?
??
is in P ?
and therefore,??[A(???)]
?
?(?)
and ??[A(???)]G??
??[??[???]]G???
?.The ?if?
part is proved as follows.
Let ??G?k?
?for some ??
?
?(?).
If k = 0, then clearly??
= ?, ?
= ??
and ?G??
?.
For k ?
1, as-sume that the statement holds for any derivation oflength less than k. The rule used at the first stepis one of the following forms: (1) A ?
??
withA ?
N0, (2) A(x) ?
??
with A ?
N1, or (3)A ?
??
with A ?
N ?0 ?
N0.
The proof of thecase (1) is similar to the proofs of the other cases,so we start proving the case (2).
In the case (2),??
= ???[A(????)]G??
???[??[????]]G???
?
for some ???
?TN ???
(dX1e)?TN ???
(bX1c) and ????
?
TN ???.
Bythe definition of P ?, A(x) ?
?
is in P such that??
?
?(?).
By the induction hypothesis, for any?
?
TN??
such that ???[??[????]]
?
?(?
), ?
G??
?.
Bythe definition of ?, there exists ??
?
TN??
(X1) and???
?
TN??
such that ?
= ??[A(???)]
G?
??[?[???
]],and ???[??[????]]
?
?(??[?[???]]).
Therefore, ?G??
?.And in the case (3), ??
= ???
[ A ]G??
???[??]G???
?for some ???
?
TN ???
(dX1e) ?
TN ???(bX1c).
Bythe definition of P ?, A(x) ?
?
is in P such that??
?
?(?).
By the induction hypothesis, for any?
?
TN??
such that ???[??]
?
?(?
), ?
G??
?.
By thedefinition of ?, there exists ??
?
TN??
(X1) and???
?
TN??
such that ?
= ??[A(???)]
G?
??[?[???
]],and ???[??]
?
?(??[?[???]]).
Therefore, ?G??
?.Because ?
(S) = {S}, L(G) = L(G ?
).Next, consideration will be given to whetherthe restriction of linearity can be removed frommonadic CFTGs to generate the same class of lan-guages.
The answer is negative.
The following ex-ample is a non-linear, monadic CFTG that generatesa string language that no linear, monadic CFTG cangenerate.Example 3.2 The following is an example of amonadic CFTG that generates the string languageLw4 = {wwww | w ?
{a, b}+}.
G = (N,?, P, S)where N = {S,A}, the ranks of S and A are 0 and1, respectively, ?
= {a, b, c, d}, the ranks of a, b, cand d are 0, 0, 2 and 4, respectively, and P consistsof the following rules:S ?
A(a), S ?
A(b), A(x) ?
d(xxxx),A(x) ?
A(c(xa)), and A(x) ?
A(c(xb)).Because G has the rule A(x) ?
d(xxxx), G is notlinear.Theorem 3.3 There exists a monadic CFTG whichis not weakly equivalent to any linear, monadicCFTG.Proof.
It is known that the string language Lw4in Example 3.2 cannot be generated by any TAG.
Itcannot be generated by any linear, monadic CFTG,neither.4 Epsilon-Freeness on Linear, MonadicCFTGsAccording to our definition of CFTGs, they are al-lowed to generate trees with the special symbol ?,which is treated as the empty string while takingthe yields of trees.
In this section, it will be seenthat for any linear, monadic CFTG, there exists aweakly equivalent epsilon-free, linear, nondeleting,monadic CFTG.
Because any epsilon-free CFTGcannot generate a tree with ?, it is clear that fora CFTG with epsilon-rules, there generally doesn?texist an equivalent epsilon-free CFTG.Theorem 4.1 For any linear, monadic CFTG G =(N,?, P, S), if ?
6?
LS(G), then there exists aweakly equivalent epsilon-free, linear, nondeleting,monadic CFTG G ?.
If ?
?
LS(G), then there existsG?
whose epsilon-rule is only S ?
?.Proof.
Since it is enough to show the existence ofa weakly equivalent grammar, without loss of gen-erality, we may assume that G is in strong normalform.
We may also assume that the initial nonter-minal S doesn?t appear in the right-hand side of anyrule in P .We first construct subsets of nonterminals E0 andE1 as follows.
For initial values, we set E0 = {A ?N0|A ?
?
?
P} and E1 = ?.
We repeat the fol-lowing operations to E0 and E1 until no more oper-ations are possible:?
If A ?
B(C) with B ?
E1 and C ?
E0 is inP , then add A ?
N0 to E0.?
If A(x) ?
b(C, x) with C ?
E0 is in P , thenadd A ?
N1 to E1.?
If A(x) ?
b(x,C) with C ?
E0 is in P , thenadd A ?
N1 to E1.?
If A(x) ?
B(C(x)) with B,C ?
E1 is in P ,then add A ?
N1 to E1.In the result, E0 satisfies the following.E0 = {A ?
N0|??
?
T?, A G??
?, yield(?)
= ?
}We construct G ?
= (N ?,?
?, P ?, S) as follows.The set of nonterminals is N ?
= N ?0 ?
N ?1 such thatN ?0 = N0 ?
{A|A ?
N1} and N ?1 = N1.
The setof terminal is ??
= ?
?
{c}, where c is a new sym-bol of rank 1.
The set of rules P ?
is the smallest setsatisfying following conditions:?
P ?
contains all rules in P except rules of theform A ?
?.?
If S ?
E0, then S ?
?
is in P ?.?
If A ?
B(C) is in P and C ?
E0, then A ?B is in P ?.?
If A(x) ?
B(C(x)) is in P , then A ?
B(C )is in P ?.?
If A(x) ?
b(C, x) or A(x) ?
b(x,C) is in Pand C ?
E0, then A(x) ?
c(x) is in P ?.?
If A(x) ?
b(C, x) or A(x) ?
b(x,C) is in P ,then A ?
c(C) is in P ?.To show LS(G?)
= LS(G), we prove the follow-ing (i), (ii) and (iii) hold by induction on the lengthof derivations:(i) For A ?
N0, A G???
??
and ??
?
T?
if andonly if AG??
?
for some ?
?
T?
such thatyield(?)
= yield(??)
6= ?.
(ii) For A ?
N1, A(x) G???
??
and ??
?
T?
(X1)if and only A(x)G??
?
for some ?
?
T?
(X1)such that yield(?)
= yield(??).
(iii) For A ?
N ?0 ?N0, A G???
??
and ??
?
T?
if andonly if A(x)G??
?
for some ?
?
T?
(X1) suchthat yield(?[?])
= yield(??)
6= ?.We start with ?only if?
part.
For 0-step deriva-tions, (i), (ii) and (iii) clearly hold since theredoesn?t exists ??
?
T?
nor ??
?
T?
(X1) for eachstatement.We consider the cases for 1-step derivations.
[Proof of (i)] If AG??
??
and ??
?
T?, then ??
= afor some a ?
?0 and the rule A ?
a in P ?
has beenused.
Therefore, A ?
a is in P and AG?
a.
[Proof of (ii)] If A(x)G??
??
and ??
?
T?
(X1),then ??
= c(x) and the rule A(x) ?
c(x)in P ?
has been used.
By the definition of P ?,A(x) ?
b(C, x) or A(x) ?
b(x,C) is in P forsome C ?
E0.
There exists ?
?
T?
such thatCG??
?
and yield(?)
= ?.
Therefore, A(x)G?b(C, x)G??
b(?, x) or A(x)G?
b(x,C)G??
b(x, ?
),and yield(b(?, x))= yield(b(x, ?
))= yield(c(x)).
[Proof of (iii)] There doesn?t exists ??
?
T?
suchthat AG??
?
?.For k ?
2, assume that (i), (ii) and (iii) holds forany derivation of length less than k.[Proof of (i)] If AG?k?
?
?, then the rule used atthe first step is one of the follwoing form: (1)A ?
B(C) or (2) A ?
B.
In the case(1), AG??B(C)G???
??[??]
= ??
for some ?
?
?T?
(X1) and ??
?
T?
such that B(x) G???
??
andCG???
??.
By the induction hypothesis of (ii), thereexists ?
?
T?
(X1) such that B(x) G??
?
andyield(?)
= yield(?
?).
By the induction hypoth-esis of (i), there exists ?
?
T?
such that C G??
?and yield(?)
= yield(?
?).
By the definition of P ?,A ?
B(C) is in P .
Therefore, AG?B(C)G??
?[?
]and yield(?[?])
= yield(?
?[??]).
In the case (2),AG??BG???
??.
By the definition of P ?, A ?
B(C)is in P for some C ?
E0.
There exists ?
?
T?
suchthat CG??
?
and yield(?)
= ?.
By the induction hy-pothesis of (iii), there exists ?
?
T?
(X1) such thatB(x)G??
?
and yield(?[?])
= yield(??).
Therefore,AG?B(C)G??
?[?]
and yield(?[?])
= yield(??).
[Proof of (ii)] If A(x)G?k?
?
?, then the rule usedat the first step is one of the follwoing form: (1)A(x) ?
B(C(x)), (2) A(x) ?
b(C, x) or (3)A(x) ?
b(x,C).
Becasue these rule are in P , theproofs are direct from the induction hypothesis likethe proof of the case (1) of (i).
[Proof of (iii)] If AG?k?
?
?, then the rule used atthe first step is one of the follwoing form: (1)A ?
B(C) or (2) A ?
c(C).
In the case (1),AG??B(C)G???
??[??]
= ??
for some ?
?
?
T?
(X1)and ??
?
T?
such that B(x) G???
??
and CG???
?
?.By the induction hypothesis of (ii), there exists?
?
T?
(X1) such that B(x) G??
?
and yield(?)
=yield(??).
By the induction hypothesis of (iii),there exists ?
?
T?
(X1) such that C(x) G??
?and yield(?[?])
= yield(?
?).
By the definitionof P ?, A(x) ?
B(C(x)) is in P .
Therefore,A(x)G?B(C(x))G??
?[?]
and yield(?[?[?]])
=yield(??[??]).
In the case (2), AG??
c(C)G???
c(??)
=??
for some ?
?
?
T?
such that C G???
??.
By the in-duction hypothesis of (i), there exists ?
?
T?
suchthat CG??
?
and yield(?)
= yield(?
?).
By the def-inition of P ?, A(x) ?
b(C, x) or A(x) ?
b(x,C)is in P .
Without loss of generality, we may as-sume that A(x) ?
b(C, x) is in P .
Therefore,A(x)G?
b(C, x)G??
b(?, x) and yield(b(?, x)[?])
=yield(c(?
?
)).The ?if?
part is similarly proved as follows.
For0-step derivations, (i), (ii) and (iii) clearly hold sincethere doesn?t exists ?
?
T?
nor ?
?
T?
(X1) foreach statement.The cases for 1-step derivations are proved.
[Proof of (i)] If AG?
?
and ?
?
T?, then ?
= afor some a ?
?0 and the rule A ?
a in P has beenused.
Therefore, A ?
a is in P ?
and AG??
a.
[Proof of (ii) and (iii)] There doesn?t exists ?
?
T?such that AG?
?.For k ?
2, assume that (i), (ii) and (iii) holds forany derivation of length less than k.[Proof of (i)] If AGk?
?, then the rule used at thefirst step must be of the form A ?
B(C).
Thus,AG?B(C)G??
?[?]
= ?
for some ?
?
T?
(X1)and ?
?
T?
such that B(x) G??
?
and CG??
?.Here, we have to think of the two cases: (1)yield(?)
6= ?
and (2) yield(?)
= ?.
In thecase (1), by the induction hypothesis of (ii), thereexists ??
?
T?
(X1) such that B(x) G???
??
andyield(??)
= yield(?
), and by the induction hypothe-sis of (i), there exists ?
?
?
T?
such that C G???
??
andyield(??)
= yield(?).
By the definition of P ?, A ?B(C) is in P .
Therefore, AG??B(C)G??
??[??
]and yield(?
?[??])
= yield(?[?]).
In the case (2),C ?
E0.
Thus, A ?
B is in P ?.
By the inductionhypothesis of (iii), there exists ?
?
?
T?
(X1) suchthat BG??
??
and yield(?
?)
= yield(?[?]).
There-fore, AG??BG???
??
and yield(?
?)
= yield(?[?]).
[Proof of (ii)] If A(x)Gk?
?, then the rule used atthe first step is one of the follwoing form: (1)A(x) ?
B(C(x)), (2) A(x) ?
b(C, x) or (3)A(x) ?
b(x,C).
The proof of the case (1) is di-rect from the induction hypothesis.
In the case (2),A(x)G?
b(C, x)G??
b(?, x) = ?
for some ?
?
T?such that CG??
?.
Here, we have to think of the twocases: (a) yield(?)
6= ?
and (b) yield(?)
= ?.
(a) If yield(?)
6= ?, then by the induction hy-pothesis of (i), there exists ?
?
?
T?
such thatCG???
??
and yield(?
?)
= yield(?).
By the defini-tion of P ?, A(x) ?
b(C, x) is in P ?.
Therefore,A(x)G??
b(C, x)G???
b(?
?, x) and yield(b(?
?, x)) =yield(b(?, x)).
(b) If yield(?)
= ?, then C ?
E0and A(x) ?
c(x) is in P ?.
Therefore, A(x)G??
c(x)and yield(c(x)) = yield(b(?, x)).
The proof of thecase (3) is similar to that of the case (2).
[Proof of (iii)] If A(x)Gk?
?, then the rule usedat the first step is one of the follwoing form:(1) A(x) ?
B(C(x)), (2) A(x) ?
b(C, x)or (3) A(x) ?
b(x,C).
In the case (1),A(x)G?B(C(x))G??
?[?]
= ?
for some ?, ?
?T?
(X1) such that B(x) G??
?
and C(x)G??
?.
Bythe definition of P ?, A ?
B(C) is in P ?.
Bythe induction hypothesis of (ii), there exists ?
?
?T?
(X1) such that B(x) G???
??
and yield(?
?)
=yield(?).
By the induction hypothesis of (iii), thereexists ??
?
T?
such that C G???
??
and yield(?
?)
=yield(?[?]).
Therefore, AG??
B(C)G???
??[??]
andyield(??[??])
= yield(?[?[?]]).
In the case (2),A(x)G?
b(C, x)G??
b(?, x) = ?
for some ?
?T?
such that C G??
?
and yield(?)
6= ?.
Bythe definition of P ?, A ?
c(C) is in P ?.
Bythe induction hypothesis of (i), there exists ?
?
?T?
such that C G???
??
and yield(?
?)
= yield(?
).Therefore, AG??
c(C)G???
c(??)
and yield(c(?
?))
=yield(b(?, x)[?]).
The proof of the case (3) is simi-lar to that of the case (2).By (i), we have the result LS(G?)
= LS(G).5 ConclusionsIn this paper, the desirable features of linearmonadic CFTGs have been discovered: the re-striction of nondeletion doesn?t affect their gener-ative power of tree languages, and the restriction ofepsilon-freeness can be assumed when their gener-ation of string languages is considered.
The key tothe proofs of this paper was the simplicity of the def-inition of linear, monadic CFTGs and their normalform.Recently, the class of grammars called mildlycontext-sensitive grammars has been studied veryactively, to which TAGs and other well-establishedformalisms for natural languages belong.
Since itis not difficult to study formal properties of linear,monadic CFTGs, they are helpful tools for the studyof mildly context-sensitive grammars.ReferencesAnne Abeille?
and Owen Rambow, editors.
2000.Tree adjoining grammars: formalisms, linguis-tic analysis and processing.
CSLI Publications,Stanford, California.Walter S. Brainerd.
1969.
Tree generating regularsystems.
Information & Control, 14(2):217?231.Akio Fujiyoshi and Takumi Kasai.
2000.
Spinal-formed context-free tree grammars.
Theory ofComputing Systems, 33(1):59?83.Akio Fujiyoshi.
2004.
Epsilon-free grammars andlexicalized grammars that generate the class ofthe mildly context-sensitive languages.
In 7th In-ternational Workshop on Tree Adjoining Gram-mar and Related Formalisms: Proceedings of theWorkshop, Vancouver, pages 16?23.Aravind K. Joshi and Yves Schabes, 1996.
Hand-book of Formal Languages, volume 3, chap-ter Tree-adjoining grammars, pages 69?124.Springer, Berlin.Aravind K. Joshi, Leon S. Levy, and Masako Taka-hashi.
1975.
Tree adjunct grammars.
J. Com-puter & System Sciences, 10(1):136?163.Uwe Mo?ennich.
1997.
Adjunction as substitution:an algebraic formulation of regular, context-freeand tree adjoining languages.
In G. V. Morrill G-J.
Kruijff and R. T. Oehrle, editors, Formal Gram-mars 1997: Proceedings of the Conference, Aix-en-Provence, pages 169?178.Sanguthevar Rajasekaran and Shibu Yooseph.1998.
TAL recognition in O(M(n2)) time.
J.Computer & System Sciences, 56(1):83?89.Sanguthevar Rajasekaran.
1996.
Tree-adjoininglanguage parsing in O(n6) time.
SIAM J.
Com-put., 25(4):862?873.William C. Rounds.
1970.
Mapping and gram-mars on trees.
Mathematical Systems Theory,4(3):257?287.K.
Vijay-Shanker and David J. Weir.
1994.The equivalence of four extensions of context-free grammars.
Mathematical Systems Theory,27(6):511?546.
