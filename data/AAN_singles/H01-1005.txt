The Annotation Graph Toolkit:Software Components forBuilding Linguistic Annotation ToolsKazuaki Maeda, Steven Bird, Xiaoyi Ma and Haejoong LeeLinguistic Data Consortium, University of Pennsylvania3615 Market St., Philadelphia, PA 19104-2608 USAfmaeda, sb, xma, haejoongg@ldc.upenn.eduABSTRACTAnnotation graphs provide an efficient and expressive data modelfor linguistic annotations of time-series data.
This paper reportsprogress on a complete software infrastructure supporting the rapiddevelopment of tools for transcribing and annotating time-seriesdata.
This general-purpose infrastructure uses annotation graphsas the underlying model, and allows developers to quickly createspecial-purpose annotation tools using common components.
Anapplication programming interface, an I/O library, and graphicaluser interfaces are described.
Our experience has shown us that itis a straightforward task to create new special-purpose annotationtools based on this general-purpose infrastructure.Keywordstranscription, coding, annotation graph, interlinear text, dialogueannotation1.
INTRODUCTIONAnnotation graphs (AGs) provide an efficient and expressivedata model for linguistic annotations of time-series data [2].
Thispaper reports progress on a complete software infrastructure sup-porting the rapid development of tools for transcribing and anno-tating time-series data.
This general-purpose infrastructure usesannotation graphs as the underlying model, and allows developersto quickly create special-purpose annotation tools using commoncomponents.
This work is being done in cooperation with thedevelopers of other widely used annotation systems, Transcriberand Emu [1, 3].The infrastructure is being used in the development of a seriesof annotation tools at the Linguistic Data Consortium.
Severalsuch tools are shown in the paper: one for dialogue annotation,one for telephone conversation transcription, and one for interlineartranscription aligned to speech.This paper will cover the following points: the application pro-gramming interfaces for manipulating annotation graph data andimporting data from other formats; the model of inter-component.communication which permits easy reuse of software components;and the design of the graphical user interfaces, which have beentailored to be maximally ergonomic for the tasks.The project homepage is: [http://www.ldc.upenn.edu/AG/].
The software tools and software components described inthis paper are available through a CVS repository linked from thishomepage.2.
ARCHITECTURE2.1 General ArchitectureExisting annotation tools are based on a two level model (Fig-ure 1 Top).
The systems we demonstrate are based around a threelevel model, in which annotation graphs provide a logical levelindependent of application and physical levels (Figure 1 Bottom).The application level represents special-purpose tools built on topof the general-purpose infrastructure at the logical level.The system is built from several components which instantiatethis model.
Figure 2 shows the architecture of the tools currentlybeing developed.
Annotation tools, such as the ones discussedbelow, must provide graphical user interface components for signalvisualization and annotation.
The communication between compo-nents is handled through an extensible event language.
An appli-cation programming interface for annotation graphs (AG-API) hasbeen developed to support well-formed operations on annotationgraphs.
This permits applications to abstract away from file formatissues, and deal with annotations purely at the logical level.2.2 The Annotation Graph APIThe complete IDL definition of the AG-API is provided in theappendix (also online).
Here we describe a few salient features ofthe API.The API provides access to internal objects (signals, anchors,annotations etc) using identifiers.
Identifiers are strings which con-tain internal structure.
For example, an AG identifier is quali-fied with an AGSet identifier: AGSetId:AGId.
Annotations andanchors are doubly qualified: AGSetId:AGId:AnnotationId,AGSetId:AGId:AnchorId.
Thus, it is possible to determine fromany given identifiers, its membership in the overall data structure.The functioning of the API will now be illustrated with a seriesof examples.
Suppose we have already constructed an AG and nowwish to create a new anchor.
We might have the following API call:CreateAnchor( "agSet12:ag5", 15.234, "sec" );This call would construct a new anchor object and return itsidentifier: agSet12:ag5:anchor34.
Alternatively, if we alreadyPhysicalLevelApplicationLevelQuerySystemsEvaluationSoftwareAnnotationToolsExtractionSystemsVisualization& ExplorationConversionToolsRDBFormat XML Tab delimitedflat filesAutomaticAlignersPhysicalLevelApplicationLevelLogicalLevelTab delimitedflat filesRDBFormatXMLQuerySystemsAutomaticAlignersConversionToolsExtractionSystemsVisualization& ExplorationEvaluationSoftwareAnnotationToolsAG-APIFigure 1: The Two and Three-Level Architectures for SpeechAnnotationFigure 2: Architecture for Annotation Systemshave an anchor identifier that we wish to use for this new anchor(e.g.
because we are reading previously created annotation datafrom a file and do not wish to assign new identifiers), then we couldhave the following API call:CreateAnchor( "agset12:ag5:anchor34", 15.234, "sec" );This call will return agset12:ag5:anchor34.Once a pair of anchors have been created it is possible to createan annotation which spans them:CreateAnnotation( "agSet12:ag5","agSet12:ag5:anchor34","agSet12:ag5:anchor35","phonetic" );This call will construct an annotation object and return an iden-tifier for it, e.g.
agSet12:ag5:annotation41.
We can now addfeatures to this annotation:SetFeature( "agSet12:ag5:annotation41","date", "1999-07-02" );The implementation maintains indexes on all the features, andalso on the temporal information and graph structure, permittingefficient search using a family of functions such as:GetAnnotationSetByFeature( "agSet12:ag5","date", "1999-07-02" );2.3 A File I/O LibraryA file I/O library (AG-FIO) to support creation and export of AGdata has been developed.
This will eventually handle all widelyused annotation formats.
Formats currently supported by the AG-FIO library include the TIMIT, BU, Treebank, AIF (ATLAS Inter-change Format), Switchboard and BAS Partitur formats.2.4 Inter-component CommunicationFigure 3 shows the structure of an annotation tool in terms ofcomponents and their inter-communications.Main program - a small scriptWaveformdisplayTranscriptioneditorInternalrepresentationFile input/ outputAG-GUI-APIAG-GUI-API AG-APIAG-FIO-APIFigure 3: The Structure of an Annotation ToolThe main program is typically a small script which sets up thewidgets and provides callback functions to handle widget events.In this example there are four other components which are reusedby several annotation tools.
The AG and AG-FIO componentshave already been described.
The waveform display component(of which there may be multiple instances) receives instructions topan and zoom, to play a segment of audio data, and so on.
The tran-scription editor is an annotation component which is specialized fora particular coding task.
Most tool customization is accomplishedby substituting for this component.Both GUI components and the main program support a com-mon API for transmitting and receiving events.
For example, GUIcomponents have a notion of a ?current region?
?
the timespanwhich is currently in focus.
A waveform component can changean annotation component?s idea of the current region by sending aSetRegion event (Figure 4).
The same event can also be used inthe reverse direction.
The main program routes the events betweenGUI components, calling the AG-API to update the internal repre-sentation as needed.
With this communication mechanism, it is astraightforward task to add new commands, specific to the annota-tion task.Main programWaveform display AG-API Transcription editorUser types Control-G Update DisplaySetRegion t1 t2 AG::SetAnchorOffset SetRegion t1 t2UpdateInternal RepresentationFigure 4: Inter-component Communication2.5 Reuse of Software ComponentsThe architecture described in this paper allows rapid develop-ment of special-purpose annotation tools using common compo-nents.
In particular, our model of inter-component communica-tion facilitates reuse of software components.
The annotation toolsdescribed in the next section are not intended for general purposeannotation/transcription tasks; the goal is not to create an ?emacsfor linguistic annotation?.
Instead, they are special-purpose toolsbased on the general purpose infrastructure.
These GUI com-ponents can be modified or replaced when building new special-purpose tools.3.
GRAPHICAL USER INTERFACES3.1 A Spreadsheet ComponentThe first of the annotation/transcription editor components wedescribe is a spreadsheet component.
In this section, we show twotools that use the spreadsheet component: a dialogue annotationtool and a telephone conversation transcription tool.Dialogue annotation consists of assigning a field-structured recordto each utterance in each speaker turn.
A key challenge is tohandle overlapping speaker turns and back-channel cues withoutdisrupting the structure of individual speaker contributions.
Thetool solves these problems and permits annotations to be alignedto a (multi-channel) recording.
The records are displayed in aspreadsheet.
Clicking on a row of the spreadsheet causes the corre-sponding extent of audio signal to be highlighted.
As an extendedrecording is played back, annotated sections are highlighted (bothwaveform and spreadsheet displays).Figure 5 shows the tool with a section of the TRAINS/DAMSLcorpus [4].
Figure 6 shows another tool designed for transcribingtelephone conversations.
This latter tool is a version of the dialogueannotation tool, with the columns changed to accommodate theneeded fields: in this case, speaker turns and transcriptions.
Bothof these tools are for two-channel audio files.
The audio channelcorresponding to the highlighted annotation in the spreadsheet isalso highlighted.3.2 An Interlinear Transcription ComponentInterlinear text is a kind of text in which each word is anno-tated with phonological, morphological and syntactic information(displayed under the word) and each sentence is annotated with afree translation.
Our tool permits interlinear transcription alignedto a primary audio signal, for greater accuracy and accountability.Whole words and sub-parts of words can be easily aligned withthe audio.
Clicking on a piece of the annotation causes the corre-sponding extent of audio signal to be highlighted.
As an extendedrecording is played back, annotated sections are highlighted (bothwaveform and interlinear text displays).The following screenshot shows the tool with some interlineartext from Mawu (a Manding language of the Ivory Coast, WestAfrica).Figure 7: Interlinear Transcription Tool3.3 A Waveform Display ComponentThe tools described above utilize WaveSurfer and Snack devel-oped by Ka?re Sjo?lander and Jonas Beskow [7, 8].
WaveSurferallows developers to specify event callbacks through a plug-inarchitecture.
We have developed a plug-in for WaveSurfer thatenables the inter-component communication described in this paper.In addition to waveforms, it is also possible to show spectrogramsand pitch contours of a speech file if the given annotation taskrequires phonetic analysis of the speech data.4.
FUTURE WORK4.1 More GUI ComponentsIn addition to the software components discussed in this paper,we plan to develop more components to support various annotationtasks.
For example, a video component is being developed, and itwill have an associated editor for gestural coding.
GUI componentsfor Conversation Analysis (CA) [6] and CHAT [5] are also planned.4.2 An Annotation Graph ServerWe are presently designing a client-side component which presentsthe same AG-API to the annotation tool, but translates all callsFigure 5: Dialogue Annotation Tool for the TRAINS/DAMSL CorpusFigure 6: Telephone Conversation Transcription Tool for the CALLFRIEND Spanish Corpusinto SQL and then transmits them to a remote SQL server (seeFigure 8).
A centralized server could house a potentially largequantity of annotation data, permitting multiple clients to collabo-ratively construct annotations of shared data.
Existing methods forauthentication and transaction processing will be be used to ensurethe integrity of the data.AG-APIMapping to SQLSQLRDB server andpersistent storageMain program - a small scriptWaveformdisplayTranscriptioneditorFile input/ outputAG-GUI-APIAG-GUI-APIAG-FIO-APInetworkFigure 8: Annotation Tool Connecting to Annotation Server4.3 Timeline for DevelopmentA general distribution (Version 1.0) of the tools is planned for theearly summer, 2001.
Additional components and various improve-ments will be added to future releases.
Source code will beavailable through a source code distribution service, SourceForge([http://sourceforge.net/projects/agtk/]).
Furtherschedule for updates will be posted on our web site: [http://www.ldc.upenn.edu/AG/].5.
CONCLUSIONThis paper has described a comprehensive infrastructure fordeveloping annotation tools based on annotation graphs.
Our expe-rience has shown us that it is a simple matter to construct newspecial-purpose annotation tools using high-level software compo-nents.
The tools can be quickly created and deployed, and replacedby new versions as annotation tasks evolve.
The components andtools reported here are all being made available under an opensource license.6.
ACKNOWLEDGMENTThis material is based upon work supported by the NationalScience Foundation under Grant No.
9978056 and 9983258.7.
REFERENCES[1] C. Barras, E. Geoffrois, Z. Wu, and M. Liberman.
Transcriber:development and use of a tool for assisting speech corporaproduction.
Speech Communication, 33:5?22, 2001.
[2] S. Bird and M. Liberman.
A formal framework for linguisticannotation.
Speech Communication, 33:23?60, 2001.
[3] S. Cassidy and J. Harrington.
Multi-level annotation ofspeech: An overview of the emu speech database managementsystem.
Speech Communication, 33:61?77, 2001.
[4] D. Jurafsky, E. Shriberg, and D. Biasca.
SwitchboardSWBD-DAMSL Labeling Project Coder?s Manual, Draft 13.Technical Report 97-02, University of Colorado Institute ofCognitive Science, 1997.
[http://stripe.colorado.edu/?jurafsky/manual.august1.html].
[5] B. MacWhinney.
The CHILDES Project: Tools for AnalyzingTalk.
Mahwah, NJ: Lawrence Erlbaum., second edition, 1995.[http://childes.psy.cmu.edu/].
[6] E. Schegloff.
Reflections on studying prosody intalk-in-interaction.
Language and Speech, 41:235?60, 1998.[http://www.sscnet.ucla.edu/soc/faculty/schegloff/prosody/].
[7] K. Sjo?lander.
The Snack sound toolkit, 2000.[http://www.speech.kth.se/snack/].
[8] K. Sjo?lander and J. Beskow.
WaveSurfer ?
an open sourcespeech tool.
In Proceedings of the 6th InternationalConference on Spoken Language Processing, 2000.[http://www.speech.kth.se/wavesurfer/].APPENDIXA.
IDL DEFINITION FOR FLAT AG APIinterface AG {typedef string Id; // generic identifiertypedef string AGSetId; // AGSet identifiertypedef string AGId; // AG identifiertypedef string AGIds;// AG identifiers (space separated list)typedef string AnnotationId;// Annotation identifiertypedef string AnnotationType; // Annotation typetypedef string AnnotationIds;// Annotation identifiers (list)typedef string AnchorId; // Anchor identifiertypedef string AnchorIds;// Anchor identifiers (list)typedef string TimelineId; // Timeline identifiertypedef string SignalId; // Signal identifiertypedef string SignalIds;// Signal identifiers (list)typedef string FeatureName; // feature nametypedef string FeatureNames; // feature name (list)typedef string FeatureValue; // feature valuetypedef string Features;// feature=value pairs (list)typedef string URI;// a uniform resource identifiertypedef string MimeClass; // the MIME classtypedef string MimeType; // the MIME typetypedef string Encoding; // the signal encodingtypedef string Unit; // the unit for offsetstypedef string AnnotationRef;// an annotation referencetypedef float Offset; // the offset into a signal//// AGSet ////// Id is AGSetId or AGIdAGId CreateAG( in Id idin TimelineId timelineId );boolean ExistsAG( in AGId agId );void DeleteAG( in AGId agId );AGIds GetAGIds( in AGSetId agSetId );//// Signals ////TimelineId CreateTimeline( in URI uri,in MimeClass mimeClass,in MimeType mimeType,in Encoding encoding,in Unit unit,in Track track );TimelineId CreateTimeline( in TimelineId timelineId,in URI uri,in MimeClass mimeClass,in MimeType mimeType,in Encoding encoding,in Unit unit,in Track track);boolean ExistsTimeline( in TimelineId timelineId );void DeleteTimeline( in TimelineId timelineId );// Id may be TimelineId or SignalIdSignalId CreateSignal( in Id id,in URI uri,in MimeClass mimeClass,in MimeType mimeType,in Encoding encoding,in Unit unit,in Track track );boolean ExistsSignal( in SignalId signalId );void DeleteSignal( in SignalId signalId );SignalIds GetSignals( in TimelineId timelineId );MimeClassGetSignalMimeClass( in SignalId signalId );MimeTypeGetSignalMimeType( in SignalId signalId );Encoding GetSignalEncoding( in SignalId signalId );string GetSignalXlinkType( in SignalId signalId );string GetSignalXlinkHref( in SignalId signalId );string GetSignalUnit( in SignalId signalId );Track GetSignalTrack( in SignalId signalId );//// Annotation ////// Id may be AGId or AnnotationIdAnnotationId CreateAnnotation( in Id id,in AnchorId anchorId1,in AnchorId anchorId2,in AnnotationType annotationType );boolean ExistsAnnotation(in AnnotationId annotationId );void DeleteAnnotation(in AnnotationId annotationId );AnnotationId CopyAnnotation(in AnnotationId annotationId );AnnotationIds SplitAnnotation(in AnnotationId annotationId );AnnotationIds NSplitAnnotation(in AnnotationId annotationId, in short N );AnchorIdGetStartAnchor( in AnnotationId annotationId);AnchorId GetEndAnchor(in AnnotationId annotationId);void SetStartAnchor( in AnnotationId annotationId,in AnchorId anchorId );void SetEndAnchor( in AnnotationId annotationId,in AnchorId anchorId );OffsetGetStartOffset( in AnnotationId annotationId );Offset GetEndOffset(in AnnotationId annotationId );void SetStartOffset( in AnnotationId annotationId,in Offset offset );void SetEndOffset( in AnnotationId annotationId,in Offset offset );// this might be necessary to package up an id// into a durable referenceAnnotationRef GetRef( in Id id );//// Features ////// this is for both the content of an annotation,// and for the metadata associated with AGSets,// AGs, Timelines and Signals.void SetFeature( in Id id,in FeatureName featureName,in FeatureValue featureValue );boolean ExistsFeature( in Id id,in FeatureName featureName );void DeleteFeature( in Id id,in FeatureName featureName );string GetFeature( in Id id,in FeatureName featureName );void UnsetFeature( in Id id,in FeatureName featureName );FeatureNames GetFeatureNames( in Id id );void SetFeatures( in Id id,in Features features );Features GetFeatures( in Id id );void UnsetFeatures( in Id id );//// Anchor ////// Id may be AGId or AnchorIdAnchorId CreateAnchor( in Id id,in Offset offset,in Unit unit,in SignalIds signalIds );AnchorId CreateAnchor( in Id id,in SignalIds signalIds );AnchorId CreateAnchor( in Id id );boolean ExistsAnchor( in AnchorId anchorId );void DeleteAnchor( in AnchorId anchorId );void SetAnchorOffset( in AnchorId anchorId,in Offset offset );Offset GetAnchorOffset( in AnchorId anchorId );void UnsetAnchorOffset( in AnchorId anchorId );AnchorId SplitAnchor( in AnchorId anchorId );AnnotationIds GetIncomingAnnotationSet(in AnchorId anchorId );AnnotationIds GetOutgoingAnnotationSet(in AnchorId anchorId );//// Index ////AnchorIds GetAnchorSet( in AGId agId );AnchorIds GetAnchorSetByOffset( in AGId agId,in Offset offset,in float epsilon );AnchorIds GetAnchorSetNearestOffset(in AGId agId,in Offset offset );AnnotationIdsGetAnnotationSetByFeature( in AGId agId,in FeatureName featureName );AnnotationIdsGetAnnotationSetByOffset( in AGId agId,in Offset offset );AnnotationIdsGetAnnotationSetByType( in AGId agId,in AnnotationType annotationType );//// Ids ////// Id may be AGId, AnnotationId, AnchorIdAGSetId GetAGSetId( in Id id );// Id may be AnnotationId or AnchorIdAGId GetAGId( in Id id );// Id may be AGId or SignalIdTimelineId GetTimelineId( in Id id );};
