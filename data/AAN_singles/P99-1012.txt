Preserving Semantic Dependenc ies  inSynchronous Tree Adjoining Grammar*Wi l l iam Schu lerUniversity of Pennsylvania200 South 33rd StreetPhi ladelphia, PA 19104 USAschu ler@l inc ,  c i s .
upenn,  eduAbst rac tRambow, Wier and Vijay-Shanker (Rainbow etal., 1995) point out the differences between TAGderivation structures and semantic or predicate-argument dependencies, and Joshi and Vijay-Shanker (Joshi and Vijay-Shanker, 1999) de-scribe a monotonic compositional semanticsbased on attachment order that represents thedesired ependencies of a derivation without un-derspecifying predicate-argument relationshipsat any stage.
In this paper, we apply the Joshiand Vijay-Shanker conception of compositionalsemantics to the problem of preserving seman-tic dependencies in Synchronous TAG transla-tion (Shieber and Schabes, 1990; Abeill~ et al,1990).
In particular, we describe an algorithmto obtain the semantic dependencies on a TAGparse forest and construct a target derivationforest with isomorphic or locally non-isomorphicdependencies in O(n 7) time.1 In t roduct ionThe primary goal of this paper is to solve theproblem of preserving semantic dependencies inIsomorphic Synchronous Tree Adjoining Gram-mar (ISTAG) (Shieber, 1994; Shieber and Sch-abes, 1990), a variant of Tree Adjoining Gram-mar (Joshi, 1985) in which source and targetelementary trees are assembled into isomorphicderivations.
The problem, first described inRambow, Wier and Vijay-Shanker (Rainbow etal., 1995), stems from the fact that the TAGderivation structure - even using a flat adjunc-tion of modifiers (Schabes and Shieber, 1994)- deviates from the appropriate dependency*The author would like to thank Karin Kipper,Aravind Joshi, Martha Palmer, Norm Badler, andthe anonymous reviewers for their valuable comments.This work was partially supported by NSF GrantSBP~8920230 and ARO Grant DAAH0404-94-GE-0426.structure in certain cases.
This can result intranslation errors.For example, if we parse sentence (1),(1) X is supposed to be able to fly.using the trees in Figure 1, we get the followingderivation:la:flyI131 :be-able-to(VP)Ij32:is-supposed-to(VP)with the auxiliary is-supposed-to adjoining atthe VP to predicate over be-able-to and the aux-iliary be-able-to adjoining at the VP to predi-cate over fly.
If we then try to assemble an iso-morphic tree in a language such as Portuguese(which makes less use of raising verbs) usingthe ISTAG transfer ules in Figure 2, we will beforced into an ill-formed derivation:: voarI;31 :~-capaz-de (VP)I/~2 :~-pressuposto-que (S ?
)because the raising construction is-supposed-to translates to a bridge construction d-pressuposto-que and cannot adjoin anywhere  inthe tree for ~-capaz-de (the translation of be-able-to) because there is no S-labeled adjunct ionsite.The  correct target derivation:a:voar~l:~-capaz-de(VP) ~2:~-pressuposto-que(S)1The subject is omitted to simplify the diagram.88VP VPVo VP Vo VPis Vo VP \[\[ ~ able Vo VP*supposed Vo VP* \[\[ to toSNP$ VPIVoIflyFigure 1: Sample elementary trees for "supposed to be able to fly"which yields the translation in sentence (2),(2) t~ pressuposto que X 6 capaz de voar.is not isomorphic to the source.
Worse, thisnon-isomorphism is unbounded, because thebridge verb pressuposto may have to migrateacross any number of intervening raising verbsto find an ancestor that contains an appropriateadjunction site:a:fly a:voarIfll :able(VP)\[ fll :capaz(VP) fln:press?(S)?
, .
lI , o .fin--1 :going(VP) I\[ fin--1 :vai(VP)fln:supp.
(VP)This sort of non-local non-isomorphic transfercannot be handled in a synchronous TAG thathas an isomorphism restriction on derivationtrees?
On the other hand, we do not wish toreturn to the original non-local formulation ofsynchronous TAG (Shieber and Schabes, 1990)because the non-local inheritance of links onthe derived tree is difficult to implement, andbecause the non-local formulation can recog-nize languages beyond the generative power ofTAG.
Rambow, Wier and Vijay-Shanker them-selves introduce D-Tree Grammar (Rambow etal., 1995) and Candito and Kahane introducethe DTG variant Graph Adjunction Grammar(Candito and Kahane, 1998b) in order to solvethis problem using a derivation process thatmirrors composition more directly, but both in-volve potentially significantly greater recogni-tion complexity than TAG.2 Overv iewOur solution is to retain ISTAG, but movethe isomorphism restriction from the deriva-tion structure to the predicate-argument at-tachment structure described in (Joshi andVijay-Shanker, 1999).This structure represents the composition ofsemantic predicates for lexicalized elementarytrees, each of which contains a 'predicate' vari-able associated with the situation or entity thatthe predicate introduces, and a set of 'argument'variables associated with the foot node and sub-stitution sites in the original elementary tree.The predicates are composed by identifying thepredicate variable in one predicate with an ar-gument variable in another, so that the two vari-ables refer to the same situation or entity.Composition proceeds from the bottom up onthe derivation tree, with adjuncts traversed inorder from the lowest to the highest adjunctionsite in each elementary tree, in much the sameway that a parser produces a derivation.
When-ever an initial tree is substituted, its predicatevariable is identified in the composed structurewith an argument variable of the tree it substi-tutes into.
Whenever an auxiliary tree is ad-joined, the predicate variable of the tree it ad-joins into is identified in the composed struc-ture with one of its own argument variables.
Incases of adjunction, an auxiliary tree's seman-tics can also specify which variable will becomethe predicate variable of the composed struc-ture for use in subsequent adjunctions at higheradjunction sites: a modifier auxiliary will re-turn the host tree's original predicate variable,and a predicative auxiliary will return its ownpredicate variable.
2 Since the traversal must2See (Schabes and Shieber, 1994) for definitions ofmodifier and predicative auxiliaries.89VPVo VPis Vo VPsupposed Vo VP*ItoVPVo VPbe Vo VPable Vo VP*ItoSVo SVo Spressuposto Vo S*IqueVPVo VPVo VPcapaz Vo VP*IdeSNP$ VPIVotflySNP.I.
VPIVoivoarFigure 2: Synchronous tree pairs for "supposed to be able to fly"proceed from the bottom up, the attachment ofpredicates to arguments is neither destructivenor underspecified at any stage in the interpre-tation.For example, assume the initial tree a:fly hasa predicate variable s\], representing the situa-tion of something flying, and an argument vari-able xl, representing the thing that is flying;and assume the predicative auxiliary tree/31 :be-able-to has a predicate variable s2, represent-ing the situation of something being possible,and an argument variable s3, representing thething that is possible.
If fll is now adjoinedinto a, the composed structure would have slidentified with s3 (since the situation of flyingis the thing that is possible), and s2 as an over-all predicate variable, so if another tree lateradjoins into this composed structure rooted ona, it will predicate over s2 (the situation thatflying is possible) rather than over a's originalpredicate variable sl (the situation of flying byitself).
Note that Joshi and Vijay-Shanker donot require the predicate and modifier distinc-tions, because they can explicitly specify thefates of any number of predicate variables ina tree's semantic representation.
For simplicity,we will limit our discussion to only the two pos-sibilities of predicative and modifier auxiliaries,using one predicate variable per tree.If we represent each such predicate-argumentattachment as an arc in a directed graph, we canview the predicate-argument at achment struc-ture of a derivation as a dependency graph, inmuch the same way as Candito and Kahaneinterpret he original derivation trees (Canditoand Kahane, 1998a).
More importantly, we cansee that this definition predicts the predicate-argument dependencies for sentences (1) and (2)to be isomorphic:?0:supposed-to ?0:~-pressuposto-quei i?1 :be-able-to ?1 :&capaz-de?2:flY ?2:voareven though their derivation trees are not.This is because the predicative auxiliary for&capaz-de returns its predicate variable to thehost tree for subsequent adjunctions, o the aux-iliary tree for g-pressuposto-que canattach it asone of its arguments, just as if it had adjoineddirectly to the auxiliary, as supposed-to does inEnglish.It is also important o note that Joshi andVijay-Shanker's definition of TAG composi-tional semantics differs from that of Shieber9{)and Schabes (Shieber and Schabes, 1990) usingSynchronous TAG, in that the former preservesthe scope ordering of predicative adjunctions,which may be permuted in the latter, alteringthe meaning of the sentence.
3 It is preciselythis scope-preserving property we hope to ex-ploit in our formulation of a dependency-basedisomorphic synchronous TAG in the next twosections.
However, as Joshi and Vijay-Shankersuggest, the proper treatment of synchronoustranslation to logical form may require a multi-component Synchronous TAG analysis in orderto handle quantifiers, which is beyond the scopeof this paper.
For this reason, we will focus onexamples in machine translation.3 Obta in ing  Source  Dependenc iesIf we assume that this attachment structurecaptures a sentence's emantic dependencies,then in order to preserve semantic dependenciesin synchronous TAG translation, we will need toobtain this structure from a source derivationand then construct a target derivation with anisomorphic structure.The first algorithm we present obtains se-mantic dependencies for derivations by keep-ing track of an additional field in each chartitem during parsing, corresponding to the pred-icate variable from Section 2.
Other than theadditional field, the algorithm remains essen-tially the same as the parsing algorithm de-scribed in (Schabes and Shieber, 1994), so itcan be applied as a transducer during recogni-tion, or as a post-process on a derivation forest(Vijay-Shanker and Weir, 1993).
Once the de-sired dependencies are obtained, the forest maybe filtered to select a single most-preferred treeusing statistics or rule-based selectional restric-tions on those dependencies.
4For calculating dependencies, we define afunction arg(~) to return the argument posi-tion associated with a substitution site or footnode ~?
in elementary tree V. Let a dependencybe defined as a labeled arc (?, l, ~b), from predi-cate ?
to predicate ?
with label I.?
For each tree selected by ?, set the predi-cate variable of each anchor item to ?.3See (Joshi and Vijay-Shanker, 1999) for a completedescription.4See (Schuler, 1998) for a discussion of statisticallyfiltering TAG forests using semantic dependencies.?
For each subst i tu t ion  of initial tree a?with predicate variable w into "),?
at nodeaddress U, emit (?, arg(v ,r/), w)?
For each mod i f ie r  ad junct ion  of auxil-iary tree/3?
into tree V?
with predicate vari-able X, emit (?, arg(p, FOOT), X) and setthe predicate variable of the composed itemto X.?
For each pred icat ive  ad junct ion  of aux-iliary tree /3?
with predicate variable winto tree "),?
with predicate variable X, emit(?, arg(/3, FOOT), X) and set the predicatevariable of the composed item to w.?
For all other productions, propagate thepredicate variable up along the path fromthe main anchor to the root.Since the number of possible values for theadditional predicate variable field is boundedby n, where n is the number of lexical itemsin the input sentence, and none of the produc-tions combine more than one predicate variable,the complexity of the dependency transducingalgorithm is O(nT).This algorithm can be applied to the examplederivation tree in Section 1,a:flyI/31 :be-able-to(VP)I/32 :is-supposed-to(VP)which resembles the stacked derivation tree forCandito and Kahane's example 5a, "Paul claimsMary said Peter left.
"First, we adjoin/32 :is-supposed-to at node VPof/31 :be-able-to, which produces the dependency(is-supposed-to,0,be-able-to}.
Then we adjoin~31:be-able-to at node VP of a:fly, which pro-duces the dependency (be-able-to,0,fly).
Theresulting dependencies are represented graphi-Cally in the dependency structure below:?0 :supposed-toI?\] :be-able-to(0)I?2:fly(0)This example is relatively straightforward,simply reversing the direction of adjunction de-pendencies as described in (Candito and Ka-hane, 1998a), but this algorithm can transduce91the correct isomorphic dependency structure forthe Portuguese derivation as well, similar to thedistributed erivation tree in Candito and Ka-hane's example 5b, "Paul claims Mary seems toadore hot dogs," (Rambow et al, 1995), wherethere is no edge corresponding to the depen-dency between the raising and bridge verbs:c~:voar81:~-capaz-de(VP) ~2:fi-pressuposto-que(S)We begin by adjoining ~1 :g-capaz-de at nodeVP of c~:voar, which produces the dependency(~-capaz-de, 0 voar), just as before.
Then we ad-join p2:~-pressuposto-que at node S of c~:voar.This time, however, we must observe the predi-cate variable of the chart item for c~:voar whichwas updated in the previous adjunction, andnow references ~-capaz-de instead of voar.
Be-cause the transduction rule for adjunction usesthe predicate variable of the parent instead ofjust the predicate, the dependency produced bythe adjunetion of ~2 is (~-pressuposto-que, 0,~-capaz-de), yielding the graph:As Candito and Kahane point out, thisderivation tree does not match the dependencystructure of the sentence as described in Mean-ing Text Theory (Mel'cuk, 1988), because thereis no edge in the derivation corresponding tothe dependency between surprise and have-to(the necessity of Paul's staying is what surprisesMary, not his staying in itself).
Using the abovealgorithm, however, we can still produce the de-sired dependency structure:?1 :surprise?2:have-to(0) Cs:Mary(1)ICa:stay(0)I?4:Paul(0)by adjoining fl:have-to at node VP of c~2:stayto produce a composed item with have-to asits predicate variable, as well as the depen-dency (have-to, 0,stay/.
When a2:stay substi-tutes at node So of c~l:surprise, the resultingdependency also uses the predicate variable ofthe argument, yielding (surprise, 0,have-to).
?0 :~-pressuposto-queI?1 :~-capaz-de(0)I?2:voar(0)The derivation examples above only addressthe preservation of dependencies through ad-junction.
Let us now attempt to preserveboth substitution and adjunction dependenciesin transducing a sentence based on Candito andKahane's example 5c, "That Paul has to staysurprised Mary," in order to demonstrate howthey interact.
5 We begin with the derivationtree:al :surprisec~2 :stay(S0) c~4 :Mary(NPl)c~a:Paul(NP0) ~:have-to(VP)5We have replaced want to in the original examplewith have to in order to highlight he dependency struc-ture and set aside any translation issues related to PROcontrol.4 Obta in ing  Target  Der ivat ionsOnce a source derivation is selected from theparse forest, the predicate-argument dependen-cies can be read off from the items in the forestthat constitute the selected erivation.
The re-sulting dependency graph can then be mappedto a forest of target derivations, where eachpredicate node in the source dependency graphis linked to a set of possible lementary trees inthe target grammar, each of which is instanti-ated with substitution or adjunction edges lead-ing to other linked sets in the forest.
The el-ementary trees in the target forest are deter-mined by the predicate pairs in the transfer lex-icon, and by the elementary trees that can re-alize the translated targets.
The substitutionand adjunction edges in the target forest aredetermined by the argument links in the trans-fer lexicon, and by the substitution and adjunc-tion configurations that can realize the trans-lated targets' dependencies.Mapping dependencies into substitutions irelatively straightforward, but we have seen inSection 2 that different adjunction configura-tions (such as the raising and bridge verb ad-92junctions in sentences (1) and (2)) can corre-spond to the same dependency graph, so weshould expect that some dependencies in ourtarget graph may correspond to more than oneadjunction configuration in the target deriva-tion tree.
Since a dependency may be realizedby adjunctions at up to n different sites, an un-constrained algorithm would require exponen-tial time to find a target derivation in the worstcase.
In order to reduce this complexity, wepresent a dynamic programming algorithm forconstructing a target derivation forest in timeproportional to O(n 4) which relies on a restric-tion that the target derivations must preservethe relative scope ordering of the predicates inthe source dependency graph.This restriction carries the linguistic implica-tion that the scope ordering of adjuncts is partof the meaning of a sentence and should notbe re-arranged in translation.
Since we exploita notion of locality similar to that of Isomor-phic Synchronous TAG, we should not expectthe generative power of our definition to exceedthe generative power of TAG, as well.First, we define an ordering of predicates onthe source dependency graph corresponding to adepth-first traversal of the graph, originating atthe predicate variable of the root of the sourcederivation, and visiting arguments and modi-fiers in order from lowest to highest scope.
Inother words, arguments and modifiers will beordered from the bottom up on the elementarytree structure of the parent, such that the footnode argument of an elementary tree has thelowest scope among the arguments, and the firstadjunct on the main (trunk) anchor has the low-est scope among the modifiers.Arguments, which can safely be permutedin translation because their number is finitelybounded, are traversed entirely before the par-ent; and modifiers, which should not be per-muted because they may be arbitrarily numer-ous, are traversed entirely after the parent.This enumeration will roughly correspond tothe scoping order for the adjuncts in the sourcederivation, while preventing substituted treesfrom interrupting possible scoping configura-tions.
We can now identify all the descendantsof any elementary tree in a derivation becausethey will form a consecutive series in the enu-meration described above.
It therefore providesa convenient way to generate a target derivationforest that preserves the scoping information inthe source, by 'parsing' the scope-ordered stringof elementary trees, using indices on this enu-meration instead of on a string yield.It is important o note that in defining thisalgorithm, we assume that all trees associatedwith a particular predicate will use the sameargument structure as that predicate.
6 We alsoassume that the set of trees associated with aparticular predicate may be filtered by transfer-ring information such as mood and voice fromsource to target predicates.Apart from the different use of indices, thealgorithm we describe is exactly the reverse ofthe transducer described in Section 3, takinga dependency graph 79 and producing a TAGderivation forest containing exactly the set ofderivation trees for which those dependencieshold.
Here, as in a parsing algorithm, we defineforest items as tuples of (~/?, 'q, _1_, i, j, X) wherea, ~, and 7 are elementary trees with node'O, ?and ?
are predicates, X and w be predicate vari-ables, and T and _1_ are delimiters tbr openingand closing adjunction, but now let i, j , and krefer to the indices on the scoping enumerationdescribed above, instead of on an input string.In order to reconcile scoping ranges for substi-tution, we must also define a function f irst(C)to return the leftmost (lowest) edge of the ?
'srange in the scope enumeration, and last(C) toreturn the rightmost (highest) edge of the ?
'srange in the scope enumeration.?
For each tree 7 mapped from predicate ?at scope i, introduce (~,?, f irst(C), i + 1, ?}.?
If (?,arg(7,~),co) E 79,try subst i tu t ion  of c~ into 3':(c~?, ROOT, T, first(co), last(co), co)7, ?, , , - )~Although this does not hold for certain relativeclause elementary trees with wh-extractions as substi-tutions sites (since the wh-site is an argument of themain verb of the clause instead of the foot node), Can-dito and Kahane (Candito and Kahane, 1998b) suggestan alternative analysis which can be extended to TAGby adjoining the relative clause into its wh-word as apredicative adjunct, and adjoining the wh-word into theparent noun phrase as a modifier, so the noun phrase istreated as an argument of the wh-word rather than ofthe relative clause.93?
If (?, arg(/3, FOOT), X) E 79,try mod i f ie r  ad junct ion  of fl into -),:(V~,~h_l_,i,j,x) (/3?,ROOT, T, j ,k,w)(V?, ~, -l-, i, k, x)?
If (?, arg(/3, FOOT), X) E 79,try pred icat ive  ad junct ion  of/3 into V:(V?,~,_I_,i,j,x) (/3?,ROOT, T, j ,k,w)(V?,~,T,i,k,w)?
Apply productions for nonterminal projec-tion as in the transducer algorithm, prop-agating index ranges and predicative vari-ables up along the path from the main an-chor to the root.Since none of the productions combine morethan three indices and one predicate variable,and since the indices and predicate variable mayhave no more than n distinct values, the algo-r ithm runs in O(n 4) time.
Note that one ofthe indices may be redundant with the predi-cate variable, so a more efficient implementationmight be possible in dO(n3).We can demonstrate this algorithm by trans-lating the English dependency graph from Sec-tion 1 into a derivation tree for Portuguese.First, we enumerate the predicates with theirrelative scoping positions:\[3\] ?0:is-supposed-toI\[2\] ?l:be-able-toI \[i\] ?2:flyThen we construct a derivation forest basedon the translated elementary trees a:voar,/31 :d-capaz-de, and /32 :d-pressuposto-que.
Beginningat the bottom, we assign to these constituentsthe relative scoping ranges of 1-2, 2-3, and 3-$,respectively, where $ is a terminal symbol.There is also a dependency from is-supposed-to to be-able-to allowing us to adjoin /32:d-pressuposto-que to /31:d-capaz-de to make itcover the range from 2 to $, but there wouldbe no S node to host its adjunction, so this pos-sibility can not be added to the forest.
We can,however, adjoin/32:d-pressuposto-que to the in-stance of a:voar extending to/31 :d-capaz-de thatcovers the range from 1 to 3, resulting in a com-plete analysis of the entire scope from 1 to $,(from (~:voar to/32:pressuposto) r oted on voar:(O~voar, l ,2,.
.)
(/3capaz, 2, 3, ..) (/3press, 3, $, ..)<O~voar ' 1, 3, capaz)<avoar, 1, $, press}which matches the distributed derivation treewhere both auxiliary trees adjoin to roar.\[1-$\]a:voar\[2-3\]/31:6-capaz-de(VP) \[3-$\]~2:6-pressup.-que(S)Let us compare this to a translation using thesame dependency structure, but different words:\[3\] ?0 :is-going-toI\[2\] ?l:be-able-toI \[1\] ?2:flyOnce again we select trees in the target lan-guage, and enumerate them with scoping rangesin a pre-order traversal, but this time the con-struction at scope position 3 must be translatedas a raising verb (vai) instead of as a bridge con-struction (d-pressuposto-que):(avoar, l,2,..> (/3capaz,2,3,..> (/3vai,3,$,..>(avoar, l,2,..) (/3capaz,2,3,..> (/3press, 3 $,..>Since there is a dependency from be-able-to tofly, we can adjoin/31:d-capaz-de to a:voar suchthat it covers the range of scopes from 1 to 3(from roar to d-capaz-de), so we add this possi-bility to the forest.Although we can still adjoin/31 :ser-capaz-de atthe VP node of a:voar, we will have nowhereto adjoin /32:vai, since the VP node of a:voaris now occupied, and only one predicative treemay adjoin at any node.
7(avoar, 1, 2,..) (t3capaz, 2, 3, ..) (/3vai, 3, $, ..)(avoar, 1, 3, capaz>(avoar , l, 2, ..) (/3capaz, 2, 3, -.)
(/3;ress, 3,$,..)(avoar, 1, 3, capaz)7See (Schabes and Shieber, 1994) for the motivationsof this restriction.94Fortunately, we can also realize the depen-dency between vai and ser-capaz-de by adjoin-ing/32 :vai at the VP.<avo r, l, 2, ..) <13capaz, 2, 3, ..) (/3va , 3, $, ..)< capaz, 2, $, vai)The new instance spanning from 2 to $ (from~1 :capaz to/32 :vai) can then be adjoined at theVP node of roar, to complete the derivation.
( avoar , 1, 2, ..) (flcapaz, 2, 3,..) (~vai, 3, $,..)(~cap~z, 2 $, vai)(Olvoar , 1, $, vai)This corresponds to the stacked derivation,with p2:vai adjoined to t31:ser-capaz-de and1~1 :ser-capaz-de adjoined to a:voar:\[1-$\] a:voarI\[2-$\] ~1 :ser-capaz-de(VP)I\[3-$\] ~2 :vai(VP)5 Conc lus ionWe have presented two algorithms - one for in-terpreting a derivation forest as a semantic de-pendency graph, and the other for realizing asemantic dependency graph as a derivation for-est - that make use of semantic dependencies aadapted from the notion of predicate-argumentattachment in (Joshi and Vijay-Shanker, 1999),and we have described how these algorithms canbe run together in a synchronous TAG trans-lation system, in CO(n 7) time, using transferrules predicated on isomorphic or locally non-isomorphic dependency graphs rather than iso-morphic or locally non-isomorphic derivationtrees.
We have also demonstrated how sucha system would be necessary in translating areal-world example that is isomorphic on de-pendency graphs but globally non-isomorphicon derivation trees.
This system is currentlybeing implemented as part of the Xtag projectat the University of Pennsylvania, and as nat-ural language interface in the Human Modelingand Simulation project, also at Penn.Re ferencesAnne Abeill6, Yves Schabes, and Aravind K. Joshi.1990.
Using lexicalized tree adjoining grammarsfor machine translation.
In Proceedings of the13th International Conference on Coraputatio'nalLinguistics (COLING '90), Helsinki, Finland, Au-gust.Marie-Helene Candito and Sylvain Kahane.
1998a.Can the TAG derivation tree represent a semanticgraph?
In Proceedings of the TAG+4 Workshop,University of Pennsylvania, August.Marie-Helene Candito and Sylvain Kahane.
1998b.Defining DTG derivations to get semantic graphs.In Proceedings of the TAG+~ Workshop, Univer-sity of Pennsylvania, August.Aravind Joshi and K. Vijay-Shanker.
1999.
Com-positional Semantics with Lexicalized Tree-Adjoining Grammar (LTAG): How Much Under-specification is Necessary?
In Proceedings of the2nd International Workshop on ComputationalSemantics.Aravind K. Joshi.
1985.
How much context sensitiv-ity is necessary for characterizing structural de-scriptions: Tree adjoining grammars.
In L. Kart-tunen D. Dowty and A. Zwicky, editors, Naturallanguage parsing: Psychological, computationaland theoretical perspectives, pages 206-250.
Cam-bridge University Press, Cambridge, U.K.Anthony S. Kroch.
1989.
Asymmetries in long dis-tance extraction in a TAG grammar.
In M. Baltinand A. Kroch, editors, Alternative Conceptionsof Phrase Structure, pages 66-98.
University ofChicago Press.Igor Mel'cuk.
1988.
Dependency syntax: theory andpractice .
State University of NY Press, Albany.Owen Rainbow and Giorgio Satta.
1996.
Syn-chronous Models of Language.
In Proceedings ofthe 34th Annual Meeting of the Association forComputational Linguistics (A CL '96).Owen Rambow, David Weir, and K. Vijay-Shanker.1995.
D-tree grammars.
In Proceedings of the33rd Annual Meeting of the Association for Com-putational Linguistics (A CL '95).Yves Schabes and Stuart M. Shieber.
1994.
An al-ternative conception of tree-adjoining derivation.Computational Linguistics, 20(1):91-124.William Schuler.
1998.
Expoiting semantic depen-dencies in parsing.
Proceedings of the TAG+4Workshop.Stuart M. Shieber and Yves Schabes.
1990.
Syn-chronous tree adjoining rammars.
In Proceedingsof the 13th International Conference on Compu-tational Linguistics (COLING '90), Helsinki, Fin-land, August.Stuart M. Shieber.
1994.
Restricting the weak-generative capability of synchronous tree adjoin-ing grammars.
Computational Intelligence, 10(4).K.
Vijay-Shanker and D.J.
Weir.
1993.
The use ofshared forests in tree adjoining grammar parsing.In Proceedings of EA CL '93, pages 384-393.95
