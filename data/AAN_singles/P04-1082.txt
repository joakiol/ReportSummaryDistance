Using linguistic principles to recover empty categoriesRichard CAMPBELLMicrosoft ResearchOne Microsoft WayRedmond, WA 98052USArichcamp@microsoft.comAbstractThis paper describes an algorithm fordetecting empty nodes in the Penn Treebank(Marcus et al, 1993), finding theirantecedents, and assigning them function tags,without access to lexical information such asvalency.
Unlike previous approaches to thistask, the current method is not corpus-based,but rather makes use of the principles of earlyGovernment-Binding theory (Chomsky,1981), the syntactic theory that underlies theannotation.
Using the evaluation metricproposed by Johnson (2002), this approachoutperforms previously published approacheson both detection of empty categories andantecedent identification, given eitherannotated input stripped of empty categoriesor the output of a parser.
Some problems withthis evaluation metric are noted and analternative is proposed along with the results.The paper considers the reasons a principle-based approach to this problem shouldoutperform corpus-based approaches, andspeculates on the possibility of a hybridapproach.1 IntroductionMany recent approaches to parsing (e.g.
Charniak,2000) have focused on labeled bracketing of theinput string, ignoring aspects of structure that arenot reflected in the string, such as phonetically nullelements and long-distance dependencies, many ofwhich provide important semantic informationsuch as predicate-argument structure.
In the PennTreebank (Marcus et al, 1993), null elements, orempty categories, are used to indicate non-localdependencies, discontinuous constituents, andcertain missing elements.
Empty categories arecoindexed with their antecedents in the samesentence.
In addition, if a node has a particulargrammatical function (such as subject) or semanticrole (such as location), it has a function tagindicating that role; empty categories may alsohave function tags.
Thus in the sentence below,who is coindexed with the empty category *T* inthe embedded S; the function tag SBJ indicates thatthis empty category is the subject of that S:[WHNP-1 who] NP want [S [NP-SBJ-1*T*] to VP]Empty categories, with coindexation and functiontags, allow a transparent reconstruction ofpredicate-argument structure not available from asimple bracketed string.In addition to bracketing the input string, a fullyadequate syntactic analyzer should also locateempty categories in the parse tree, identify theirantecedents, if any, and assign them appropriatefunction tags.
State-of-the-art statistical parsers(e.g.
Charniak, 2000) typically provide a labeledbracketing only; i.e., a parse tree without emptycategories.
This paper describes an algorithm forinserting empty categories in such impoverishedtrees, coindexing them with their antecedents, andassigning them function tags.
This is the firstapproach to include function tag assignment as partof the more general task of empty categoryrecovery.Previous approaches to the problem (Collins,1997; Johnson, 2002; Dienes and Dubey, 2003a,b;Higgins, 2003) have all been learning-based; theprimary difference between the present algorithmand earlier ones is that it is not learned, butexplicitly incorporates principles of Government-Binding theory (Chomsky, 1981), since that theoryunderlies the annotation.
The absence of rule-based approaches up until now is not motivated bythe failure of such approaches in this domain; onthe contrary, no one seems to have tried a rule-based approach to this problem.
Instead it appearsthat there is an understandable predispositionagainst rule-based approaches, given the fact thatdata-driven, especially machine-learning,approaches have worked so much better in manyother domains.1Empty categories however seem different, inthat, for the most part, their location and existenceis determined, not by observable data, but byexplicitly constructed linguistic principles, which1Both Collins (1997: 19) and Higgins (2003: 100) areexplicit about this predisposition.were consciously used in the annotation; i.e.,unlike overt words and phrases, which correspondto actual strings in the data, empty categories are inthe data only because linguists doing theannotation put them there.
This paper thereforeexplores a rule-based approach to empty categoryrecovery, with two purposes in mind:  first, toexplore the limits of such an approach; and second,to establish a more realistic baseline for future(possibly data-driven or hybrid) approaches.Although it does not seem likely that anyapplication trying to glean semantic informationfrom a parse tree would care about the exact stringposition of an empty category, the algorithmdescribed here does try to insert empty categoriesin the correct position in the string.
The mainreason for this is to facilitate comparison withprevious approaches to the problem, whichevaluate accuracy by including such information.In Section 5, however, a revised evaluation metricis proposed that does not depend on string positionper se.Before proceeding, a note on terminology is inorder.
I use the term detection (of emptycategories) for the insertion of a labeled emptycategory into the tree (and/or string), and the termresolution for the coindexation of the emptycategory with its antecedent(s), if any.
The termrecovery refers to the complete package:detection, resolution, and assignment of functiontags to empty categories.2 Empty nodes in the Penn TreebankThe major types of empty category in the PennTreebank (PTB) are shown in Table 1, along withtheir distribution in section 24 of the Wall StreetJournal portion of the PTB.Emptycategory typeCount DescriptionNP * 1044 NP trace or PRONP *T* 265 Trace of WHNP*U* 227 Empty unit0 178 Empty complementizerADVP *T* 97 Trace of WHADVPS *T* 76 Trace of topicalizedquoted SWHNP 0 43 Null WHNPSBAR 41 Trace of topicalizednon-quoted SWHADVP 0 25 Null WHADVPothers 95Total: 2091Table 1:  Common empty categories and theirdistribution in section 24 of the PTBA detailed description of the categories and theiruses in the treebank is provided in Chapter 4 of theannotation guidelines (Bies et al, 1995).Following Johnson (2002) and Dienes and Dubey(2003a), the compound empty SBAR consisting ofan empty complementizer followed by *T* ofcategory S is treated as a single item for purposesof evaluation.
This compound category is labeledSBAR in Table 1.The PTB annotation in general, but especiallythe annotation of empty categories, follows amodified version of Government-Binding (GB)theory (Chomsky, 1981).
In GB, the existence andlocation of empty categories is determined by theinteraction of linguistic principles.
In addition, thetype of a given empty category is determined by itssyntactic context, with the result that the varioustypes of empty category are in complementarydistribution.
For example, the GB categories NP-trace and PRO (which are conflated to a singlecategory in the PTB) occur only in argumentpositions in which an overt NP could not occur,namely as the object of a passive verb or as thesubject of certain kinds of infinitive.3 Previous workPrevious approaches to this task have all beenlearning-based.
Collins?
(1997) Model 3 integratesthe detection and resolution of WH-traces inrelative clauses into a lexicalized PCFG.
Collins?results are not directly comparable to the workscited below, since he does not provide a separateevaluation of the empty category detection andresolution task.Johnson (2002) proposes a pattern-matchingalgorithm, in which the minimal connected treefragments containing an empty node and itsantecedent(s) are extracted from the trainingcorpus, and matched at runtime to an input tree.As in the present approach, Johnson inserts emptynodes as a post-process on an existing tree.
Heproposes an evaluation metric (discussed furtherbelow), and presents results for both detection anddetection plus resolution, given two different kindsof input:  perfect trees (with empty nodes removed)and parser output.Dienes and Dubey (2003a,b), on the other hand,integrate their empty node resolution algorithminto their own PCFG parser.
They first locateempty nodes in the string, taking a POS-taggedstring as input, and outputting a POS-tagged stringwith labeled empty nodes inserted.
The PCFGparser is then trained, using the enhanced strings asinput, without inserting any additional emptynodes.
Antecedent resolution is handled by aseparate post-process.
Using Johnson?s (2002)evaluation metric, Dienes and Dubey presentresults on the detection task alone (i.e., insertingempty categories into the POS-tagged string), aswell as on the combined detection and resolutiontasks in combination with their parser.2Higgins (2003) considers only the detection andresolution of WH-traces, and only evaluates theresults given perfect input.
Higgins?
method, likeJohnson?s (2002) and the present one, involvespost-processing of trees.
Higgins?
results are notdirectly comparable to the other works cited, sincehe assumes all WH-phrases as given, even thosethat are themselves empty.4 The recovery algorithm4.1 The algorithmThe proposed algorithm for recovering emptycategories is shown in Figure 1; the algorithmwalks the tree from top to bottom, at each node Xdeterministically inserting an empty category of agiven type (usually as a daughter of X) if thesyntactic context for that type is met by X.  Itmakes four separate passes over the tree, on eachpass applying a different set of rules.1   for each tree, iterate over nodes from top down2       for each node X3 try to insert NP* in X4 try to insert 0 in X5 try to insert WHNP 0  or WHADVP 0 in X6 try to insert *U* in X7 try to insert a VP ellipsis site in X8 try to insert S*T* or SBAR in X9 try to insert trace of topicalized XP in X10 try to insert trace of extraposition in X11   for each node X12 try to insert WH-trace in X13   for each node X14 try to insert NP-SBJ * in finite clause X15   for each node X16 if X = NP*, try to find antecedent for XFigure 1:  Empty category recovery algorithmThe rules called by this algorithm that try toinsert empty categories of a particular type specifythe syntactic context in which that type of emptycategory can occur, and if the context exists,specify where to insert the empty category.
Forexample, the category NP*, which conflates theGB categories NP-trace and PRO, occurs typically32 It is unclear whether Dienes and Dubey?s evaluationof empty category detection is based on actual tagsprovided by the annotation (perfect input), or on theoutput of a POS-tagger.3 NP* is used in roles that go beyond the GB notionsof NP-trace and PRO, including e.g.
the subject ofas the object of a passive verb or as the subject ofan infinitive.
The rule which tries to insert thiscategory and assign it a function tag is called inline 3 of Figure 1 and given in pseudo-code inFigure 2.
Some additional rules are given in theAppendix.if X is a passive VP & X has no complement Sif there is a postmodifying dangling PP Ythen insert NP* before all postmodifiers of Yelse insert NP* before all postmodifiers of Xelse if X is a non-finite S and X has no subjectthen insert NP-SBJ* after all premodifiers of XFigure 2:  Rule to insert NP*This rule, which accounts for about half theempty category tokens in the PTB, makes no use oflexical information such as valency of the verb,etc.
This is potentially a problem, since in GB theinfinitives that can have NP-trace or PRO assubjects (raising and control infinitives) aredistinguished from those that can have overt NPsor WH-trace as subjects (exceptional-Case-marked, or ECM, infinitives), and the distinctionrelies on the class of the governing verb.Nevertheless, the rules that insert empty nodesdo not have access to a lexicon, and very littlelexical information is encoded in the rules:reference is made in the rules to individualfunction words such as complementizers,auxiliaries, and the infinitival marker to, but neverto lexical properties of content words such asvalency or the raising/ECM distinction.
In fact, theonly reference to content words at all is in the rulewhich tries to insert null WH-phrases, called inline 5 of Figure 1:  when this rule has found arelative clause in which it needs to insert a nullWH-phrase, it checks if the head of the NP therelative clause modifies is reason(s), way(s),time(s), day(s), or place(s); if it is, then it insertsWHADVP with the appropriate function tag, ratherthan WHNP.The rule shown in Figure 2 depends for itssuccessful application on the system?s being ableto identify passives, non-finite sentences, heads ofphrases (to identify pre- and post-modifiers), andfunctional information such as subject; similarinformation is accessed by the other rules used inthe algorithm.
Simple functions to identifypassives, etc.
are therefore called by theimplemented versions of these rules.
Functionalinformation, such as subject, can be gleaned fromthe function tags in the treebank annotation; therules make frequent use of a variety of functiontags as they occur on various nodes.
The output ofimperatives; see below.Charniak?s parser (Charniak, 2000), however, doesnot include function tags, so in order for thealgorithm to work properly on parser output (seeSection 5), additional functions were written toapproximate the required tags.
Presumably, theaccuracy of the algorithm on parser output wouldbe enhanced by accurate prior assignment of thetags to all relevant nodes, as in Blaheta andCharniak (2000) (see also Section 5).Each empty category insertion rule, in additionto inserting an empty node in the tree, also mayassign a function tag to the empty node.
This isillustrated in Figure 2, where the final line insertsNP* with the function tag SBJ in the case where itis the subject of an infinitive clause.The rule that inserts WH-trace (called in line 12in Figure 1) takes a WHXP needing a trace asinput, and walks the tree until an appropriateinsertion site is found (see Appendix for a fullerdescription).
Since this rule requires a WHXP asinput, and that WHXP may itself be an emptycategory (inserted by an earlier rule), it is handledin a separate pass through the tree.A separate rule inserts NP* as the subject insentences which have no overt subject, and whichhave not had a subject inserted by any of the otherrules.
Most commonly, these are imperativesentences, but calling this rule in a separate passthrough the tree, as in Figure 1, ensures that anysubject position missed by the other rules is filled.Finally, a separate rule tries to find anantecedent for NP* under certain conditions.
Theantecedent of NP* may be an empty node insertedby rules in any of the first three passes through thetree, even the subject of an imperative; thereforethis rule is applied in a separate pass through thetree.
This rule is also fairly simple, assigning thelocal subject as antecedent for a non-subject NP*,while for an NP* in the subject position of a non-finite S it searches up the tree, given certainlocality conditions, for another NP subject.All the rules that insert empty categories arefairly simple, and derive straighforwardly fromstandard GB theory and from the annotationguidelines.
The most complex rule is the rule thatinserts WH-trace when it finds a WHXP daughterof SBAR; most are about as simple as the ruleshown in Figure 2, some more so.
Representativeexamples are given in the Appendix.4.2 Development methodAfter implementing the algorithm, it was run oversections 1, 3, and 11 of the WSJ portion of thePTB, followed by manual inspection of the trees toperform error analysis, with revisions made asnecessary to correct errors.
Initially sections 22and 24 were used for development testing.However, it was found that these two sectionsdiffer from each other substantially with respect tothe annotation of antecedents of NP* (which isdescribed somewhat vaguely in the annotationguidelines), so all of sections 2-21 were used as adevelopment test corpus.
Section 23 was usedonly for the final evaluation, reported in Section 5below.5 EvaluationFollowing Johnson (2002), the system wasevaluated on two different kinds of input:  first, onperfect input, i.e., PTB annotations stripped of allempty categories and information related to them;and second, on imperfect input, in this case theoutput of Charniak?s (2000) parser.
Each isdiscussed in turn below.5.1 Perfect inputThe system was run on PTB trees stripped of allempty categories.
To facilitate comparison toprevious approaches, we used Johnson?s label andstring position evaluation metric, according towhich an empty node is identified by its label plusits string position, and evaluated the detection taskalone.
We then evaluated detection and resolutioncombined, identifying each empty category asbefore, plus the label and string position of itsantecedent, if any, again following Johnson?swork.The results are shown in Table 2.
Precision hereand throughout is the percentage of empty nodesproposed by the system that are in the goldstandard (section 23 of the PTB), recall is thepercentage of empty nodes in the gold standardthat are proposed by the system, and F1 is balancedf-measure; i.e., 2PR/(P+R).Task Prec.
Rec.
F1Detection only 94.9 91.1 93.0Detection + resolution 90.1 86.6 88.4Table 2:  Detection and resolution of empty cate-gories given perfect input (label + string positionmethod), expressed as percentageThese results compare favorably to previouslyreported results, exceeding them mainly byachieving higher recall.
Johnson (2002) reports93% precision and 83% recall (F1 = 88%) for thedetection task alone, and 80% precision and 70%recall (F1 = 75%) for detection plus resolution.
Incontrast to Johnson (2002) and the present work,Dienes and Dubey (2003a) take a POS-taggedstring, rather than a tree, as input; they report86.5% precision and 72.9% recall (F1 = 79.1%) onthe detection task.
For Dienes and Dubey, thefurther task of finding antecedents for emptycategories is integrated with their own PCFGparser, so they report no numbers directly relevantto the task of detection and resolution given perfectinput.5.2 Parser outputThe system was also run using as input the outputof Charniak?s parser (Charniak, 2000).
Theresults, again using the label and string positionmethod, are given in Table 3.Task Prec.
Rec.
F1Detection only 85.2 81.7 83.4Detection + resolution 78.3 75.1 76.7Table 3:  Detection and resolution of emptycategories on parser output (label + string positionmethod), expressed as percentageAgain the results exceed those previously reported.Johnson (2002) reports 85% precision and 74%recall (F1 = 79%) for detection and 73% precisionand 63% recall (F1 = 68%) for detection plusresolution on the output of Charniak?s parser.Dienes and Dubey (2003b) integrate the results oftheir detection task into their own PCFG parser,and report 81.5% precision and 68.7% recall (F1 =74.6%) on the combined task of detection andresolution.5.3 Perfect input with no function tagsThe lower results on parser output obviouslyreflect errors introduced by the parser, but mayalso be due to the parser not outputting functiontags on any nodes.
As mentioned in Section 4, it isbelieved that the results of the current method onparser output would improve if that output werereliably assigned function tags, perhaps along thelines of Blaheta and Charniak (2000).Testing this hypothesis directly is beyond thescope of the present work, but a simple experimentcan give some idea of the extent to which thecurrent algorithm relies on function tags in theinput.
The system was run on PTB trees with allnodes stripped of function tags; the results aregiven in Table 4.Task Prec.
Rec.
F1Detection only 94.1 89.5 91.7Detection + resolution 89.5 85.2 87.3Table 4:  Detection and resolution of emptycategories on PTB input without function tags(label + string position method), expressed aspercentageWhile not as good as the results on perfect inputwith function tags, these results are much betterthan the results on parser output.
This suggeststhat function tag assignment should improve theresults shown on parser output, but that the greaterpart of the difference between the results on perfectinput and on parser output is due to errorsintroduced by the parser.5.4 Refining the evaluationThe results reported in the previous subsections arequite good, and demonstrate that the currentapproach outperforms previously reportedapproaches on the detection and resolution ofempty categories.
In this subsection somerefinements to the evaluation method areconsidered.The label and string position method is useful ifone sees the task as inserting empty nodes into astring, and thus is quite useful for evaluatingsystems that detect empty categories without parsetrees, as in Dienes and Dubey (2003a).
However,if the task is to insert empty nodes into a tree, thenthe method leads both to false positives and tofalse negatives.
Suppose for example that thesentence When do you expect to finish?
has thebracketing shown below, where ?1?
and ?2?indicate two possible locations in the tree for thetrace of the WHADVP:When do you [VP expect to [VP finish 1 ] 2 ]Suppose position 1 is correct; i.e.
it represents theposition of the trace in the gold standard.
Since 1and 2 correspond to the same string position, if asystem inserts the trace in position 2, the stringposition evaluation method will count it as correct.This is a serious problem with the string-basedmethod of evaluation, if one assumes, as seemsreasonable, that the purpose of inserting emptycategories into trees is to be able to recoversemantic information such as predicate-argumentstructure and modification relations.
In the aboveexample, it is clearly semantically relevant whetherthe system proposes that when modifies expectinstead of finish.Conversely, suppose the sentence Who (besidesme) cares?
has the bracketing shown:Who [S 1 (besides me) 2 [VP cares]]Again suppose that position 1 represents theplacement of the WHNP trace in the gold standard.If a system places the trace in position 2 instead,the string position method will count it as an error,since 1 and 2 have different string positions.However it is not at all clear what it means to saythat one of those two positions is correct and theother not, since there is no semantic, grammatical,or textual indicator of its exact position.
If the taskis to be able to recover semantic information usingtraces, then it does not matter in this case whetherthe system inserts the trace to the left or to the rightof the parenthetical.Given that both false positives and falsenegatives are possible, I propose that futureevaluations of this task should identify emptycategories by their label and by their parentcategory, instead of, or perhaps in addition to,doing so by label and string position.
Since theparent of an empty node is always an overt node4,the parent could be identified by its label and stringposition (left and right edges).
Resolution isevaluated by a natural extension, by identifying theantecedent (which could itself be an emptycategory) according to its label and its parent?slabel and string position.
This would serve toidentify an empty category by its position in thetree, rather than in the string, and would avoid thefalse positives and false negatives described above.In addition to an evaluation based on treeposition rather than string position, I propose toevaluate the entire recovery task, i.e., includingfunction tag assignment, not just detection andresolution.The revised evaluation is still not perfect:  wheninserting an NP* or NP*T* into a double-objectconstruction, it clearly matters semanticallywhether it is the first or second object, though bothpositions have the same parent.5  Ideally, we wouldevaluate based on a richer set of grammaticalrelations than are annotated in the PTB, or perhapsbased on thematic roles.
However, it is difficult tosee how to accomplish this without additionalannotation.
It is probable that constructions of thissort are relatively rare in the PTB in any case, sofor now the proposed evaluation method, howeverimperfect, will suffice.The result of this revised evaluation, givenperfect input, is presented in Table 5.
The first tworows are comparable to the string-based results inTable 2; the last row, showing the results of thefull recovery task (i.e., including antecedents andfunction tags), is not much lower, suggesting thatlabeling empty categories with function tags doesnot pose any serious difficulties.4  The only exception is the 0 complementizer andS*T* daughters of the SBAR category in Table 1; butsince the entire SBAR is treated as a single empty nodefor evaluation purposes, this does not pose a problem.5 I am indebted to two ACL reviewers for calling thisto my attention.Task Prec.
Rec.
F1Detection only 95.6 91.9 93.7Detection + resolution 90.8 87.3 89.0Recovery(det.+res.+func.
tags)89.8 86.3 88.0Table 5:  Detection, resolution and recovery ofempty categories given perfect input (label +parent method), expressed as percentageThree similar evaluations were also run, usingparser output as input to the algorithm; the resultsare given in Table 6.Task Prec.
Rec.
F1Detection only 78.4 75.2 76.7Detection + resolution 72.3 69.3 70.8Recovery(det.+res.+func.
tags)69.7 66.8 68.2Table 6:  Detection, resolution and recovery ofempty categories on parser output (label + parentmethod), expressed as percentageThe results here are less impressive, no doubtreflecting errors introduced by the parser in thelabeling and bracketing of the parent category, aproblem which does not affect a string-basedevaluation.
However it does not seem reasonableto have an effective evaluation of empty nodeinsertion in parser output that does not depend tosome extent on the correctness of the parse.
Thefact that our proposed evaluation metric dependsmore heavily on the accuracy of the input structuremay be an unavoidable consequence of using atree-based evaluation.6 DiscussionThe empty category recovery algorithm reportedon here outperforms previously publishedapproaches on the detection and resolution tasks; italso does well on the task of function tagassignment to empty categories, which has notbeen considered in other work.
As suggested inthe introduction, the reason a rule-based approachworks so well in this domain may be that emptycategories are not naturally in the text, but are onlyinserted by the annotator, who is consciouslyfollowing explicit linguistic principles, in this case,the principles of early GB theory.As a result, the recovery of empty categories is,for the most part, more amenable to a rule-basedapproach than to a learning approach.
It makeslittle sense to learn, for example, that NP* occursas the object of a passive verb or as the subject ofcertain infinitives in the PTB, if that information isalready explicit in the annotation guidelines.This is not to say that learning approaches havenothing to contribute to this task.
Informationabout individual lexical items, such as valency, theraising/ECM distinction, or subject vs. objectcontrol, which is presumably most robustlyacquired from large amounts of data, wouldprobably help in the task of detecting certain emptycategories.Consider for example an input structure V [S toVP].
GB principles, which are enforced in theannotation guidelines, dictate that an emptycategory must be inserted as the subject of theinfinitival S; but exactly which empty category,NP* or NP*T*, depends on properties of thegoverning verb, including whether it is a raising orcontrol verb, such as seem or try, or an ECM verb,such as believe.
In the present algorithm, the rulethat inserts NP* applies first, without access tolexical information of any kind, so NP* is inserted,instead of NP*T*, regardless of the value of V.This leads to some errors which might be correctedgiven learned lexical information.
Such errors arefewer than might have been expected, however:the present system achieved 97.7% precision and97.3% recall (F1 = 97.5%) on the isolated task ofdetecting NP*, even without lexical knowledge(see Table 7).A combined learning and rule-based algorithmmight stand to make a bigger gain in the task ofdeciding whether NP* in subject position has anantecedent or not, and if it does, whether theantecedent is a subject or not.
The annotationguidelines and the theory that underlies it are lessexplicit on the principles underlying this task thanthey are on the other subtasks.
As a result, theaccuracy of the current system drops considerablywhen this task is taken into account, from 97.5%F1 to 86.9% (see Table 7).
Dienes and Dubey(2003a), on the other hand, claim this as one of thestrengths of their learning-based system.EmptycategorytypeDetectiononly (F1)Detection+ resolution (F1)NP* 97.5 86.9NP*T* 96.2 96.0*U* 98.6 -0 98.5 -ADVP*T* 79.9 79.9S*T* 92.7 92.7WHNP 0 92.4 -SBAR 84.4 84.4WHADVP 0 73.3 -Table 7:  F1 for detection and resolution of emptycategories by type, using perfect input (label +parent method), expressed as percentage7 ConclusionIn this paper I have presented an algorithm for therecovery of empty categories in PTB-style treesthat otherwise lack them.
Unlike previousapproaches, the current algorithm is rule-basedrather than learning-based, which I have argued isappropriate for this task, given the highlytheoretical nature of empty categories in the PTB.Moreover, the algorithm has no access to lexicalinformation such as valency or verb class.Using the string-based evaluation metricproposed by Johnson (2002), the current systemoutperforms previously published algorithms ondetection alone, as well as on detection combinedwith resolution, both on perfect input and incombination with parsing.
In addition, we haveperformed additional evaluation using a tree-basedmetric, and including an evaluation of function tagassignment as well.8 AcknowledgementsI would like to thank Simon Corston-Oliver, MarkJohnson, and Hisami Suzuki for their helpful input.ReferencesBies, A., M. Ferguson, K. Katz and R. MacIntyre.1995.
Bracketing Guidelines for Treebank IIstyle Penn Treebank Project.
Linguistic DataConsortium.Blaheta, D. and E. Charniak.
2000.
AssigningFunction Tags to Parsed Text.
In Proceedings ofthe North American Chapter of the Associationfor Computational Linguistics, pages 234-240.Charniak, E.  2000.
A maximum-entropy-inspiredparser.
In In Proceedings of the North AmericanChapter of the Association for ComputationalLinguistics, pages 132-139.Chomsky, N.  1981.
Lectures on Government andBinding.
Foris Publications, Dordrecht.Collins, M.  1997.
Three Generative, LexicalisedModels for Statistical Parsing.
In Proceedings ofthe 35th Annual Meeting of the Association forComputational Linguistics, pages 16-23.Dienes, P. and A. Dubey.
2003a.
Deep SyntacticProcessing by Combining Shallow Methods.
InProceedings of the 41st Annual Meeting of theAssociation for Computational Linguistics, pages431-438.Dienes, P. and A. Dubey.
2003b.
AntecedentRecovery:  Experiments with a Trace Tagger.
InProceedings of the Conference on EmpiricalMethods in Natural Language Processing, pages33-40.Higgins, D.  2003.
A machine-learning approachto the identification of WH gaps.
In Proceedingsof the 10th Conference of the European Chapterof the Association for Computational Linguistics,pages 99-102.Johnson, M.  2002.
A simple pattern-matchingalgorithm for recovering empty nodes and theirantecedents.
In Proceedings of the 40th AnnualMeeting of the Association for ComputationalLinguistics, pages 136-143.Marcus, M., B. Santorini and M.A.Marcinkiewicz.1993.
Building a large annotated corpus ofEnglish:  The Penn Treebank.
ComputationalLinguistics, 19(2):313-330.Appendix:  Sample rulesTo insert 0 Comp:if X=SBAR & !Comp(X) & !WHXP daughter(X)& ?
S daughter Y of X& !
(parent(X)=NP & sister(X)=NP)then insert 0 to left of YTo insert WHNP/WHADVP:if X=SBAR & parent(X)=NP& sister(X)=NP & !Comp(X)& !WHXP daughter(X) & ?
S daughter Y of Xif head(parent(X)) in {reason(s) way(s)time(s) day(s) place(s)}then insert WHADVP to left of Yelse insert WHNP to left of YTo insert *U*:insert *U* / $ CD+ _To insert WH-trace:if X=SBAR & ?
S daughter Y of X& ?
WHXP daughter W of Xthen find trace(W) in YTo find trace(W) in X:insert trace:(for W = WHXP, insert XP*T*)if X has conjunctsthen find trace(W) in each conjunct of Xelse if X has a PP daughter Y with no object& W=WHNPthen insert *T* to right of Pelse if X=S and !subject(X) & W=WHNPthen insert *T* as last pre-mod of Xelse if X contains a VP Ythen find trace(W) in Yelse if X contains ADJP or clausal complement Y& W=WHNPthen find trace(W) in Yelse if W=WHNP& ?
infinival rel.
clause R, R=sister(W)& X=VP & X has an object NP& subject(R) is an empty node Ethen insert *T* as last pre-mod of Rthen delete Eelse if W=WHNPthen insert *T* as first post-mod of Xelse insert *T* as last post-mod of Xassign function tag:if W = WHNP & *T* a pre-mod of Sthen assign ?SBJ?
to *T*if W = WHADVP & W is not emptyif W = ?why?then assign ?PRP?
to *T*if W = ?when?then assign ?TMP?
to *T*if W = ?where?then assign ?LOC?
to *T*if W = ?how?then assign ?MNR?
to *T*else if W = WHADVP & parent(parent(W)) =NPif head(sister(parent(W))) = ?reason(s)?then assign ?PRP?
to *T*if head(sister(parent(W)))=?time(s)?
or ?day(s)?then assign ?TMP?
to *T*if head(sister(parent(W))) = ?place(s)?then assign ?LOC?
to *T*if head(sister(parent(W))) = ?way(s)?then assign ?MNR?
to *T*
