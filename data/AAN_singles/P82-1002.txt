LINGUISTIC AND COMPUTATIONAL SEMANTICS*Brian Cantwell SmithXEROX Palo Alto Research Center3333 Coyote Hill Road, Palo Alto, CA 94304ABSTRACTWe argue that because the very concept of computation rests onnotions of interpretation, the semantics of natural anguages and thesemantics of computational formalisms are in the deepest sense thesame subject.
The attempt to use computational formalisms in aid ofan explanation of natural language semantics, therefore, is anenterprise that must be undertaken with particular care.
We describea framework for semantical analysis that we have used in thecomputational realm, and suggest hat it may serve to underwritecomputadonally-oriented linguistic ser.antics as well.
The majorfeature of this framework is the explicit recognition of both thedeclarative and the procedural import of meaningful expressions; weargue that whereas these two viewpoints have traditionally beentaken as alternative, any comprehensive semantical theory mustaccount for how both aspects of an expression contribute to itsoverall significance.We have argued elsewhere 1 that the distinguishing mark ofthose objects and processes we call computational has to do withattn'buted semantics."
we humans find computational processescoherent exactly because we attach semantical significance to theirbehaviour, ingredients, and so forth.
Put another way, computers,on our view, are those devices that we understand by deploying ourlinguistic faculties.
For example, the reason that a calculator is acomputer, but a car is not, is that we take the ingredients of thecalculator to be symbolic (standing, in this particular case, fornumbers and functions and so forth), and understand the interactionsand organisation of the calculator in terms of that interpretation (thispart divides, this part represents he sum, and so on).
Even thoughby and large we are able to produce an explanation of the behaviourthat does not rest on external semantic attribution (this is theformality condition mentioned by Fodor, Haugeland.
and othersz),we nonetheless peak, when we use computational terms, in terms ofthis semantics.
These semantical concepts rest at the foundations ofthe discipline: the particular organisations that computers havetheir computational raison d'etre ~ emerge not only from theirmechanical structure but also from their semantic interpretability.Similarly, the terms of art employed in computer science - -  program,compiler, implementation, i terpreter, and so forth - -  will ultimatelyhe definable only with reference to this attributed semantics; theywill not, on our view, ever be found reducible to non-semanticalpredicates?This is a ramifying and problematic position, which we cannotdefend here.
4 We may simply note, however, the overwhelmingevidence in favour of a semantical approach manifested by everydaycomputational language.
Even the simple view of computer scienceas the study of symbol manipulation s reveals this bias.
Equallytelling is the fact that programming languages are called languages.In addition, language-derived concepts like name and reference andsemantics permeate computational jargon (to say nothing ofinterpreter, value, variable, memory, expression, identifier and so on)- -  a fact that would be hard to explain if semantics were notcrucially involved.
It is not just that in discussing computation weuse language; rather, in discussing computation we use words thatsuggest that we are also talking about linguistic phenomena.The question we will focus on in this paper, very briefly, isthis: if computational rtefacts are fundamentally inguistic, and if,therefore, it is appropriate to analyse them in terms of formaltheories of semantics (it is apparent that this is a widely held view),then what is the proper relationship between the so-calledcomputational semantics that results, and more standard linguisticsemantics (the discipline that studies people and their naturallanguages: how we mean, and what we are talking about, and all of.that good stuff)?
And furthermore, what is it to use computationalmodels to explain natural language semantics, if the computationalmodels are themselves in need of semantical analysis?
On the faceof it, there would seem to be a certain complexity that should hesorted out.In answering these questions we will argue approximately asfollows: in the limit computational semantics and linguistic semanticswill coincide, at least in underlying conception, if not in surfacedetail (for example some issues, like ambiguity, may arise in one caseand not in the other).
Unfortunately, however, as presently used incomputer science the term "semantics" is given such an operationalcast that it distracts attention from the human attribution ofsignificance to computational structures.
6 In contrast, the mostsuccessful models of natural language semantics, embodied forexample in standard model theories and even in Montague'sprogram, have concentrated almost exclusively on referential ordenotational aspects of declarative sentences.
Judging only bysurface use, in other words, computational semantics and linguisticsemantics appear almost orthogonal in concern, even though they areof course similar in so'le (for example they both use meta-theoreticmathematical techniques - -  functional composition, and so forth - -to recursively specify the semantics of complex expressions from agiven set of primitive atoms and formation rules).
It is striking,however, to observe two facts.
First, computational semantics isbeing pushed (by people and by need) more and more towardsdeclarative or referential issues.
Second, natural anguage semantics,particularly in computationally-based tudies, is focusing more andmore on pragmatic questions of use and psychological import.
Sincecomputational linguistics operates under the computationalhypothesis of mind, psychological issues are assumed to be modelledby a field of computational structures and the state of a processorrunning over them; thus these linguistic oncerns with "use" connectnaturally with the "operational" flavour of standard programminglanguage semantics.
It seems not implausible, therefore - -  we betrayour caution with the double negative - -  that a unifying frameworkmight be developed.It will be the intent of this paper to present a specific, ifpreliminary, proposal for such a framework.
First, however, someintroductory comments.
In a general sense of the term, semanticscan be taken as the study of the relationship between entities orphenomena in a syntactic domain s and corresponding entities in asemantic domain t).
as pictured in the following diagram.I S2ntactic Domain Si @ Semantic Domain D,, IWe call the function mapping dements from the first domain intoelements of the second an interpretation function (to be sharplydistinguished 7 from what in computer science is called an interpreter,which is a different beast altogether).
Note that the question ofwhether an element is syntactic or semantic is a function of the pointof view; the syntactic domain for one interpretation function canreadily be the semantic domain of another (and a semantic domainmay of course include its own syntactic domain).Not all relationships, of course, count as semantical; the"grandmother" elationship fits into the picture just sketched, butstakes no claim on being semantical.
Though it has often beendiscussed what constraints on such a relationship characterisegenuinely semantical ones (compositionality or recursivespecifiability, and a certain kind of formal character to the syntacticdomain, are among those typically mentioned), we will not pursuesuch questions here.
Rather, we will complicate our diagram asfollows, so as to enable us to characterise a rather large class ofcomputational and linguistic formalisms:\[ )?otation )?l \] \] )~otation ~2 \]t ~ua and N2 are intended to be notational or communicationalexpressions, in some externally observable and consensuallyestablished medium of interaction, st!21 an strings of characters,streams of words, or sequences of display images on a computerterminal.
The relationship O is an interpretation function mappingnotations into internal elements of some process over which theprimary semantical and processing regimens are defined.
In first-order logic, sl and s2 would be something like abstract derivationtree types of first-order formulae; if the diagram were applied to thehuman mind, under the hypothesis of a formally encoded mentalese,s~ and s2 would be tokens of internal mentalese, and e would be thefunction computed by the "linguistic" faculty (on a view such as thatof Fodora).
In adopting these terms we mean to be speaking verygenerally; thus we mean to avoid, for example, any claim that tokensof English are internalised (a term we will use for o) intorecognisable tokens of mentalese.
In particular, the proper accountof e for humans could well simply describe how the field ofmentalese structures, in some configuration, is transformed into someother configuration, upon being presented with a particular Englishsentence; this would still count, on our view, as a theory of o.In contrast, ~ is the interpretation function that makes explicitthe standard enotational significance of linguistic terms, relating, wemay presume, expressions in $ to the world of discourse.
Therelationship between my mental token for T. S. Eliot, for example,and the poet himself, would he formulated as pan of ~.
Again, wespeak very broadly; ?
is intended to manifest what, paradigmatically,expressions are about, however that might best be formulated (,1,includes for example the interpretation functions of standard modeltheories), q,, in contrast, relates ome internal structures or states toothers - -  one can imagine it specifically as the formally computedderivability relationship in a logic, as the function computed by theprimitive language processor in a computational machine (i.e., astzsP'S EVAL), or more generally as the function that relates oneconfiguration of a field of symbols to another, in terms of themodifications engendered by some internal processor computing overthose states.
(~ and q, are named, for mnemonic onvenience, byanalogy with philosophy and psychology, since a study of ?
is a studyof the relationship between expressions and the world - -  sincephilosophy takes you "out of your mind", so to speak - -  whereas astudy of ~v is a study of the internal relationships between symbols.all of which, in contrast, are "within the head" of the person ormachine.
)Some simple comments.
First` N~, N2, Sl, S~, o~, and oz neednot all necessarily be distinct: in a case where sl is a self-referentialdesignator, for example, D~ would he the same as s~; similarly, in acase where ~, computed a function that was designation-preserving,then D~ and o 7 would be identical.
Secondly, we need not take astand on which of x~ and ?
has a prior claim to being the semanticsof sl.
In standard logic, q, (i.e., derivability: }-) is a relationship, hutis far from a function, and there is little tendency to think of it assemantical; a study of ,I, is called proof theory.
In computationalsystems, on the other hand, q, is typically much more constrained,and is also, by and large, analysed mathematically in terms offunctions and so forth, in a manner much more like standard modeltheories.
Although in this author's view it seems a little far-fetchedto call the internal relationships (the "use" of a symbol) semantical,it is nonetheless true that we are interested in characterising both,and it is unnecesary to express a preference.
For discussion, we willrefer to .he ",-semantics of a symbol or expression as its declarative/mp0rt, and refer to its *-semantics as its procedural consequence.We have heard it said in other quarters that "procedural" and"declarative" theories of semantics are contenders; 9 to the extent hatwe have been able to make sense of these notions, it appears that weneed both.l0It is possible to use this diagram to characterise a variety ofstandard formal systems.
In the standard models of the k-calculus,for example, the designation function ~, takes h-expressions ontofunctions; the procedural regimen % usually consisting of =- and/l-reductions, can be shown to be ~,-preserving.
Similarly, if in astandard predicate logic we take ?
to be (the inverse of the)satisfaction relationship, with each element of S being a sentence orset of sentences, and elements of o being those possible worlds inwhich those sentences are true, and similarly take ,I, as thederivability relationship, then soundness and completeness can heexpressed as the equation 'l'(sl,s2) m \[ o~ C_ D~ \].
As for all formalsystems (these presumably subsume the computational ones), i t  iscrucial that ,t, he specifiable independent of ,l,.
The h-calculus andpredicate logic systems, furthermore, have no notion of a processorwith state; thus the appropriate ?
involves what we may call localprocedural conse.quence, r lating a simple symbol or set of symbolsto another set.
In a more complex computational circumstance, aswe will see below, it is appropriate to characterise a more complexf~rll procedural consequence involving not only simple expressions,but fuller encodings of the state of various aspects of thecomputational machine (for example, at least environments andcontinuations in the typical computational easel0).An important consequence of the analysis illustrated in thelast figure is that it enables one to ask a question ot typically askedit" computer science, about the (q,-) semantic character of thefunction computed by ~,.
Note that questions about soundness andcompleteness in logic are exactly questions of this type.
In separateresearch, 11 we have shown, by subjecting it to this kind of analysis,tJ~at computational formalisms can be usefully analysed in theseterms as well.
In particular, we demonstrated that the universallya:cepted LISP evaluation protocol is semantically Confused, in thefbllowing sense: sometimes it preserves ?
(i.e.
~(,I,(S)) = ~,(s)), andsometimes it embodies ?
(i.e., ,l,(s) = ,l,(s)).
The traditional LISPnotion of evaluation, in other words, conflates simplification andreference relationships, to its peril (in that report we propose someLISP dialects in which these two are kept strictly separate).
Thecurrent moral, however, is merely that our approach allows thequestion of the semantical import of ,~ to be asked.As well as considering LISP.
we may use our diagram toc~laracterise the various linguistically oriented projects carried onunder the banner of "semantics".
Model theories and formaltheories of language (we include Tarski and Montague in one sweep)have concentrated primarily on ~,.
Natural language semantics insome quarters 12 focuses on o ~ on the translation into an internalmedium ~ although the question of what aspects of a givensentence must be preserved in such a translation are of course ofconcern (no translator could ignore the salient properties, emanticaland otherwise, of the target language, be it mentalese or predicatelogic, since the endeavour would otherwise be without constraint).l.ewis (for one) has argued that the project of articulating O ~ an?ndeavour he calls markerese semantics - -  cannot really be calledsemantics at all, 13 since it is essentially a translation relationship,zlthough it is worth noting that e in computational formalisms is notz.lways trivial, and a case can at least be made that many superficialaspects of natural language use, such as the resolution of indexicals,raay be resolved at this stage (if for example you say I am warmthen I may internalise your use of the first person pronoun into myiaternal name for you).Those artificial intelligence researchers working in knowledgerepresentation, perhaps without too much distortion, can be dividedinto two groups: a) those whose primary semantical allegiance is to~, and who (perhaps as a consequence) typically use an encoding offirst-order logic as.their representation language, and b) those whoconcern themselves primarily with ,~, and who therefore (legitimatelyenough) reject logic as even suggestive (* in logic - -  derivabilityis a relatively unconstrained relationship, for one thing; secondly, therelationship between the entailment relationship, to whichderivability is a hopeful approximation, and the proper "~," ofrational belief revision, is at least a matter of debatel4).Programming language semantics, for reasons that can at leastbe explored, if not wholly explained, have focused primarily on q,,although in ways that tend to confuse it with ~.
Except for PROLOG,which borrows its ?
straight from a subset of first-order logic, andthe LIsPs mentioned earlier, is we have never seen a semanticalaccount of a programming language that gave independent accountsof ?
and ,1,.
There are complexities, furthermore, in knowing justwhat the proper treatment of general anguages hould be.
In aseparate paper 16 we argue that the notion program is inherentlydefined as a set of expressions whose (~-) semantic domain includesdata structures (and set-theoretic entities built up over them).
Inother words, in a computational process that deals with finance, say,the general data structures will likely designate individuals andmoney and relationships among them, but the terms in that pan ofthe process called a program will not designate these people andtheir money, but will instead designa:~' the data ztructures thatdesignate people and money (plus of course relationships andfunctions over those data structures).
Even on a declarative view likeours, in other words, the appropriate semantic domain for programsis built up over data structures - -  a situation strikingly like thestandard semantical accounts that take abstract records or locationsor whatever as elements of the otherwise mathematical domain forprogramming language semantics.
It may be that this fact that allbase terms in programs are meta-syntactic that has spawned theconfusion between operations and reference in the computationalsetting.Although the details of a general story remain to be workedout, the LiSP case mentioned earlier is instructive, by way ofsuggestion as to how a more complete computational theory oflanguage semantics might go.
In particular, because of the contextrelativity and non-local effects that can emerge from processing aLISP expression, ~, is not specifiable in a strict compositional way.
,~- -  when taken to include the broadest possible notion that mapsentire configurations of the field of symbols and of the processoritself onto other configurations and states - -  is of course recursivelyspecifiable (the same tact, in essence, as saying that LISP is adeterministic formal calculus).
A pure characterlsation f ,I, withouta concomitant account of $, however, is unmotivated - - as empty asa specification of a derivability relationship would be for a calculusfor which no semantics had been given.
Of more interest is theability to specify what we call a general significance .function 2, thatrecursively specifies ,I, and ,~ together (this is what we were able todo for LZSP).
In particular, given any expression s~, anyconfiguration of the rest of the symbols, and any state of theprocessor, the function z will specify the configuration and state thatwould result (i.e.. it will specify the use of sx), and also therelationship to the world that the whole signifies.
For example,1tgiven a LISP expression of the form (+ z (PROG (SETQ A 2) A)), ~gwould specify that the whole expression designated the numberthree, that it would return the numeral "3", and that the machinewould be left in a state in which the binding of the variable A waschanged to the numeral "z".
A modest result; what is important ismerely a) that both declarative import and procedural significancemust be reconstructed in order to tell .a full story about LISP; and b)that they must be formulated together.Rather than pursue this view in detail, it is helpful to set outseveral points that emerge from analyses developed within thisframework:a.
In most programming languages, o can be specifiedcompositionally and independently of 4, or * - -  this amountsto a formal statement of Fodor's modularity thc~m forlanguage, z7 In the ease of formal systems, O is often contextfree and compositional, but not always (reader macros canrender it opaque, or at least intensional, and some languagessuch as ALGOL ale apparently context-sensitive).
It isnoteworthy, however, that there have been computationallanguages for which e could not be specified indepently of *a fact that is often stated as the fact that the programminglanguage "cannot be parsed except at runtime" (TEC0 and thefirst versions of SHALLTALK had this character).b.
Since LISP is computational, it follows that a full account ofits * can be specified independent of 4,; this is in essence theformality condition.
It is important o bring out, however,that a local version of * will typically not be compositional ina modem computational formalism, even though such localityholds in purely extensional context-free side-effect freelanguages uch as the h-calculus.c.
It is widely agreed that * does not uniquely determine ,I, (thisis the "psychology narrowly construed" and the concomitantmethodological solipsism of Putnam and Fodor and othemlS).However this fact is compatible with our foundational claimthat computational systems are distinguished in virtue ofhaving some version of 4, as part of their characterisation.
Avery similar point can be made for logic: although any givenlogic can (presumably) be given a mathematically-specifiedmodel theory, that theory doesn't ypically tie down what isoften called the standard model or interpretation - -  theinterpretation that we use.
This fact does not release us,however, from positing as a candidate logic only a formalismthat humans can interpret.d.
The declarative interpretation 4, cannot be wholly determinedindependent of *, except in purely declarative languages ( uchas the x-calculus and logic and so forth).
This is to say thatwithout some account of the effect on the processor of onefragment of a whole linguistic structure, it may be impossibleto say what that processor will take another fragment asdesignating.
The use of StTQ in LISP is an example; naturallanguage instances will be explored, below.This last point needs a word of explanation.
It is of course possibleto specify 4, in mathematical terms without any explicit mention of a?
-like function; the approach we use in LISP defines both .
andin terms of the overarching function ?
mentioned above, and wecould of course simply define 4, without defining .
at all.
Ouri~oint, rather, is that any successful definition of ~, will effectivelyhave to do the work of *, more or less explicidy, either by definingsome identifiable relationship, or else by embedding that relationshipwithin the recta-theoretic machinery.
We are arguing, in otherwords, only that the subject we intend * to cover must be treated insome fashion or other.What is perhaps urprising about aII of this machinery is thatit must be brought to bear on a purely procedural language - -  allthree relationships (O, 4,, and . )
figure crucially in an account evenof LISP.
we  are not suggesting that LzsP is like natural anguages:to point out just one crucial difference, there is no way in LISP or inany other programming language (except PROLOG) tO say anything,whereas the ability to say things is clearly a foundational aspect ofany human language.
The problem in the procedural languages isone of what we may call assertional force; although it is possible toconstruct a sentence-like expression with a clear declarative semantics(such as some equivalent of "x ?
3"), one cannot use it in such away as to actually mean it - -  so as to have it carry any assertionalweight.
For example, it is trivial to set some variable x to a, or toask whether x is 3, but there is no way to state that x is 3, It shouldbe admitted, however, that computational anguages bearingassertional force are under considerable current investigation.
Thisgeneral interest is probably one of the reasons for PaOLOG'S emergentpopularity; other computational systems with an explicit declarativecharacter include for example specification languages, data basemodels, constraint languages, and knowledge representationlanguages in A.I.
We can only assume that the appropriatesemantics for all of these formalisms will align even more closelywith an illuminating semantics for natural language.What does all of this have to do with natural language, andwith computational linguistics?
The essential point is this: tf thischaracterisation f formal systems is tenable, and if the techniques ofstandard programming language semantics can be fit into this mould,then it may be possible to combine those approaches with thetechniques of programming language semantics and of logic andmodel theories, to construct complex and interacting accounts of *and of 4,.
To take just one example, the techniques that are used toconstruct mathematical ccounts of environments and continuationsmight be brought o bear on the issue of dealing with the complexcircumstances involving discourse models, theories of focus indealing with anaphora, and so on; both cases involve an attempt oconstruct a recursively specifiable account of non-local interactionsamong disparate fragments of a composite text.
But thecontributions can proceed in the other direction as well: even from avery simple application of this framework to this circumstance ofLISP, for example, we have been able to show how an acceptedcomputational notion fails to cohere with our attributed linguisticallybased understanding, involving us in a major reconstruction of LZSP'Sfoundations.
The similarities are striking.Our claim, in sum, is that similar phenomena occur inprogramming languages and natural languages, and that eachdiscipline could benefit from the semantical techniques developed inthe other.
Some examples of these similar phenomena will help tomotivate this view.
The first is the issue ~ t,,.
appropriate use ofnoun phrases: as well as employing a noun phrase in a standarde .~,lnmnal position, natural language semantics has concerned itselfwith more difficult cases such as intensional contexts (as in theunderlined esignator in I didn't know The Big Apple was an island.where the co-designating term New York cannot be substitutedwithout changing the meaning), the so-called attributive~referential12distinction of Donellan z9 (the difference, roughly, between using anoun phrase like "the man with a martini" to inform you thatsomeone is drinking a martini, as Opposed to a situation where oneuses the heater's belief or assumption that someone is drinking amartini to refer to him), and so on.
Another example different fromeither of these is provided by the underlined term in For the next 20years let's re~trict he president's alary to $20,000, on the reading inwhich after Reagan is defeated he is allowed to earn as much as hepleases, but his successor comes under our constraint.
The analagouscomputational cases include for example the use of an expressionlike (the formal analog of) make the sixth array element be 10 (i.e.,A(B) ::~ 10).
where we mean not that the current sixth elementshould be 10 (the current sixth array element might at the momenttie 9, and 9 can't be 10), but rather that we would like thedescription "the sixth array element" to refer to 10 ~so-called "L-values", analogous to HACI.ISP'S serf construct).
Or, to take a,:lifferent case, suppose we say set x to the sixth array element (i.e., x:: = A(B)), where we mean not that x should be set to the currentsixth array element, but that it should always be equal to thatelement (stated computationaUy this might be phrased as saying that:~ should track a(6); stated linguistically we might say that X shouldmean "the sixth array element").
Although this is not a standardtype of assignment, he new constraint languages provide exactlysuch facilities, and macros (classic computational intensionaloperators) can be used in more traditional languages for suchpurposes, Or, for a final example, consider the standard ec~ation:z~r\[GeA x, in which the term "x" refers neither to the variable itself(variables are variables, not numbers), nor to its current designation,but rather to whatever will satisfy the description "the value of x" atany point in the course of a computation.
All in all, we cannotignore the attempt on the computationalists' part to provide complexmechanisms so strikingly similar to the complex ways we use nounphrases in English.A very different sort of lingusitic phenomenon that occurs inboth programming languages and in natural language are what wemight call "premature xits": cases where the processing of a localfragment aborts the standard interpretation of an encompassingdiscourse.
If for example I say to you I was walking down the streetthat leads to the house that Mary's aunt used to ... forget it; \[ wastaking a walk, then the "forget it" must be used to discard theanalysis of some amount of the previous entence.
The grammaticalstructure of the subsequent phrase determines how much has beendiscarded, of course; the sentence would still be comprehensible ifthe phrase "an old house I like" followed the "forget it".
We arenot accustomed to semantical theories that deal with phenomena likethis, of course, but it is clear that any serious attempt o model reallanguage understanding will have to face them.
Our present point ismerely that continuations z?
enable computational formalisms to dealexactly with the computational analogs of this: so-called escapeoperators like I, IACLISP'S THROW and CATCH and QUIT.In addition, a full semantics of language will want to dealwith such sentences as I f  by "flustrated" you mean what I think, thenshe was certainly fluslrated.
The proper treatment of the first clausein this sentence will presumably involve lots of ",t," sorts ofconsiderations: its contribution to the rcmainder of the sentence hasmore to do with the mental states of speaker and hearer than withthe world being describe by the presumed conversation.
Once again,the overarching computational hypothesis uggests that the way thesepsychological effects must be modelled is in terms of alterations in:he state of an internal process running over a field of computationalstructures.As well as these specific examples, a couple of more generalmorals can be drawn, important in that they speak directly to stylesof practice that we see in the literature.
The first concerns thesuggestion, apparently of some currency, that we reject the notion oflogical form, and "do semantics directly" in a computational modelOn our account his is a mistake, pure and simple: to buy into thecomputational framework is to believe that the ingredients in anycomputational process are inherently linguistic, in need ofinterpretation.
Thus they too will need semantics; the internalisationof English into a computer (O) is a translation relationship (in thesense of preserving ~, presumably) - -  even if it is wildly contextual,and even if the internal anguage is very different in structure fromthe st.rucmre of English.
It has sometimes been informallysuggested, in an analogous vein, that Montague semantics cannot betaken seriously computationally, because the models that Montagueproposes are "too big" - -  how could you possibly carry these infinitefunctions around in your head, we are asked to wonder.
But ofcourse this argument comits a use/mention mistake: the only validcomputational reading of Montague would mean that mentalse (,~)would consist of designators of the functions Montague propose~and those designators can of course be a few short formulae,It is another consequence of our view that any semanticistwho proposes ome kind of "mental structure" in his or her accountof language is commited to providing an interpretation of thatstructure.
Consider for example a proposal that posits a notion of"focus" for a discourse fragment.
Such a focus might be viewed as a(possibly abstracO entity in the world, or as a element ofcomputational structure playing such-and-such role in thebehavioural model of language understanding.
It might seem thatthese are alternative accounts: what our view insists is that aninterpretation of the latter must give it a designation (e~); thus therewould be a computational structure (being biased, we will call it thefocus-designator), and a designation (that we call the focus.itsel\]).The complete account of focus would have to specify both of these(either directly, or else by relying on the generic declarativesemantics to mediate between them), and also tell a story about howthe focus-designator plays a causal role (,I,) in engendering theproper behaviour in the computational model of languageunderstanding.There is one final problem to be considered: what it is todesign an internal folvnatism S (the task, we may presume, of anyonedesigning a knowledge representation language).
Since, on our view,we must have a semantics, we have the option either of having thesemantics informally described (or, even worse, tacitly assumed), orelse we can present an explicit account, either by defining such astory ourselves or by borrowing from someone lse.
If the LIsp casecan be taken as suggestive, a purely declarative model theory will beinadequate to handle the sorts of comptuational interactions thatprogramming languages have required (and there is no a priorireason to assume that successful computational models for naturallanguage will be found that are simpler than the programminglanguages the community has found necessary for the modest sonsof tasks computers are presently able to perform).
However it is alsoreasonable to expect hat no direct analog to programming languagesemantics will suffice, since they have to date been so concernedwith purely procedural (behavioural) consequence.
It seems at least13reasonable to suppose that a general interpretation function, of the zsort mentioned earlier, may be required.Consider for example the ZLONE language presented byBrachman et aL 21 Although no semantics for KLONE has beenpresented, either procedural or declarative, its proponents haveworked both in investigating the o-sehaantics (how to translateEnglish into KLONE), and in developing an informal account of theprocedural spects.
Curiously, recent directions in that project wouldsuggest hat its authors expect o be able to provide a "declarative-only" account of KLONE semantics (i.e., expect o be able to presentan account of ~, independent of ~,), in spite of our foregoingremarks.
Our only comment is to remark that independence ofprocedural consequence is not a pre-requisite to an adequatesemantics; the two can be recursively specifiable together; thus thisapparent position is stronger than formally necessary ~ which makesit perhaps of considerable interest.In sum, we claim that any semantical account of either naturallanguage or computational language must specify O, ,I,, and ,~; if anyare leR out, the account is not complete.
We deny, furthermore, thatthere is any fundamental distinction to be drawn between so-calledprocedural languages (of which LISP is the paradigmatic example inA.I.)
and other more declarative languages (encodings of logic, orrepresentation languages).
We deny as well, contrary to at leastsome popular belief, the view that a mathcmatically well-specifiedsemantics for a candidate "mcntalese" must bc satisfied by giving anindependently specified declarative semantics (as would be possiblefor an encoding of logic, for example).
The designers of zat, zz forexample, for principled reasons denied the possibility of giving asemantics indcpendent of the procedures in which the Kat structuresparticipated; our simple account of LISP has at least suggested thatsuch an approach could be pursued on a mathematically soundfooting.
Note however, in spite of our endorsement of what mightbe called a procedural semantics, that this in no way frees one fromfrom giving a declarative semantics as well; procedural semantics anddeclarative semantics are two pieces of a total story; they are notalternatives.NOTES* I am grateful to Barbara Grosz and Hector Levesque for theircomments on an earlier draft of this short paper, and to JaneRobinson for her original suggestion that it be written.1.
Smith (19821o)2.
Fodor (1978), Fodor (1980), Haugeland (forthcoming)3.
At least until the day arrives - -  if ever - -  when a successfulpsychology of language is presented wherein all of humansemantieity is explained in non-semantical terms.4.
Problematic because it defines computation i a manner that isderivative on mind (in that language is fundamentally a mentalphenomenon), thus dashing the hope that computationalpsyc.~,:!c, td will offer a release from the semantic irreducibilityof previous accounts of human cognition.
Though we state thisposition and explore some of its consequences in Smith (1982b),a considerably fuller treatment will be provided in Smith(forthcoming).5.
See for example Newelt (1980)6.
The term "semantics" is only one of a large collection of terms,unfortunately, that are technical terms in computer science andin the attendant cognitive disciplines (including logic, philosophyof language, linguistics, and psychology), with differentmeanings and different connotations.
Reference, interpretation,memory, and value are just a few examples of the others.
It isour view that in spite of the fact that semantical vocabulary isused in different ways, the fields are both semantical infundamentally the same ways: a unification of terminologywould only be for the best.7.
An example of the phenomenon noted in foomote 6.8.
Fodor (forthcoming)9.
Woods (1981)10.
For a discussion of continuations see Gordon (1979), Steele andSussman (1978), and Smith (1982a); the formal device isdeveloped in Strachey & Wadsworth (1974).H.
Smith (1982a).12.
A classic example is Katz and Postal (1964), but much of therecent A.I.
research in natural language in A.L can be viewed inthis light.13.
Lewis (1972).14.
Israel (1980).15.
For a discussion of P~OLOG see Clocksin & Mellish (198l); theLtSPS are described in Smith (1982a)?16.
Smith (forthcoming).17.
Fodor (forthcoming).18.
The term "methodological solipsism" is from Putnam (1975); seealso Fodor (1980).19.
Donnellan (1966).20.
See note 10, above.21.
Brachman (1979).22.
Bobrow and Winograd (1977).REFERENCESBobrow, Daniel G.. and Winograd, Terry, "An Overview of KRL: AKnowledge Representation Language", Cognitive Science 1 pp.
3-46, 1977.Brachman, Ronald, "On the Epistemological Status of SemanticNetworks", in Findlerl Nicholas V.
(ed.
), Associative Networks:Representation a d Use of Knowledge by Computers, New York:Academic Press, 1979.Clocksin.
W. F., and Mellish, C. S., Programming in Prolog, Berlin:Springer-Verlag, 1981.Donnellan, K., "Reference and Definite Descriptions", PhilosophicalReview 75:3 (1966) pp.
281-304; reprinted in Rosenberg andTravis (eds.
), Readings in the Philosophy of Language, Prentice-Hall, 1971.Fodor, Jerry, "Tom Swift and his Procedural Grandmother",Cognition 6, 1978; reprinted in Fodor (1981).
"Methodological Solipsism Considered as a ResearchStrategy in Cognitive Psychology", The Behavioral and BrainSciences, 3:1 (1980) pp.
63-73; reprinted in Haugeland (ed.
),Mind Design, Cambridge: Bradford, 1981, and in Fodor (1981).14Israel, David, "What's Wrong with Non-Monotonic Logic?
",Proceedings of the First Annual Conference of the AmericanAssociation for Artificial Intelligence, Stanford, California, 1980,pp.
99-101.Katz, Jerrold, and Postal, Paul, An Integrated Theory of LinguisticDescriptions, Cambridge: M.I.T.
Press, 1964.Lewis, David, "General Semantics", in Davidson and Harman (eds.
),Semantics of Natural Langauges, Dordrecht, Holland: D. Reidel,1972, pp.
169-218.NeweU, Alien, "Physical Symbol Systems", Cognitive Science 4, pp.135-183, 1980.Putnam, Hilary, "The meaning of 'meaning'", in Putnam, Hilary,Mind Language and Reality, Cambridge, U.K.: CambridgeUniversity Press, 1975.Smith.
Brian C., Reflection and Semantics in.
a Procedural Language,Laboratory for Computer Science Report LCS-TR-272, M.I.T.,Cambridge, Mass., 1982 (a)., "Semantic Attribution and the Formality Condition",presented at the Eighth Annual Meeting of the Society forPhilosophy and Psychology, London, Ontario, Canada, May 13-16, 1982 (b)., The Computational Metaphor, Cambridge: Bradford(forthcoming).Steele, Guy, and Sussman, Gerald J., "The Art of the Interpreter, orthe Modularity Complex (parts Zero, One, and Two)", M.LT.Artificial Intelligence Laboratory Mcmo AIM-453, Cambridge,Mass, 1978.Strachey, C., and Wadsworth, C. P., "Continuations -- aMathematical Semantics for Handling Full Jumps", PRG-I1,Programming Rcsearch Group, University of Oxford, 1974.Woods, William A., "Procedural Semantics as a Thcory of Meaning",Report No.
4627, Bolt Beranek and Newman, 50 Moulton St.,Cambridge, Mass., 02138; reprinted in Joshi, A., Sag, I., andWebber, B., Computational Aspects of Linguistic Structures andDiscourse Settings, Cambridge, U.K.: Cambridge UniversityPress, 1982.15
