F-PATR: FUNCTIONAL CONSTRAINTS FORUNIFICATION-BASED GRAMMARSKent WittenburgBel lcore445 South St., MRE 2A-347Morr i s town,  NJ  07962-1910,  USAInternet:  kentw@bel l core .comAbstractMotivation for including relational constraints otherthan equality within grammatical formalisms has comefrom discontinuous constituency and partially free wordorder for natural languages as well as from the need todefine combinatory operations at the most basic levelfor languages with a two-dimensional syntax (e.g.,mathematical notation, chemical equations, and variousdiagramming languages).
This paper presents F-PATR,a generalization of the PATR-II unification-based for-malism, which incorporates relational constraintsexpressed as user-defined functions.
An operationalsemantics i  given for unification that is an adaptationand extension of the approach taken by Ait-Kaci andNasr (1989).
It is designed particularly for unification-based formalisms implemented in functional program-ming environments such as Lisp.
The application ofunification in a chart parser for relational set languagesis discussed briefly.1.
INTRODUCTIONFor the most part, unification-based grammar for-malisms (e.g., Kaplan and Bresnan 1982; Pereira andWarren 1980; Shieber 1984) have adopted stringrewriting conventions from context-free grammar rules,assuming string concatenation as the basic combiningoperator external to the unification process itself.
Kay'sFunctional Unification Grammar (Kay 1979), while notborrowing the conventions of CFG rewriting rules, stillassumed concatenation of strings as the underlyingcombining operation.
However, recent work in HPSG(e.g., Pollard and Sag 1987, Reape 1990, Carpenter et al1991) and elsewhere has sought to incorporate con-straints for combining operations into the unification-based representation directly.
Part of the motivation fordoing so is to accommodate partially free word orderand discontinuous constituency without the complica-tion of passing along intermediate "threading" informa-tion within derivations.
Such exensions to unificationgrammars require the use of nonequational constraints,i.e., constraints on values other than simple conditionsof equality and the logical connectives built with them.Reape (1990) has proposed, for example, the relationspermutation and sequence union to constrain wordsequences in his HPSG fragment for German.A different motivation for extending the constraintlanguage for combination within unification grammarscomes from languages with a two-dimensional syntax(e.g., mathematical notation, chemical equations, andvarious diagramming languages).
Approaching suchdomains from a linguistic perspective requires thatgrammars be capable of dealing with a richer source ofdata types than just strings and also with specifying aricher set of combinatory operations than simple stringconcatenation.
The approach taken by Helm and Marri-ott (1986, 1990) and Wittenburg, Weitzman, and Talley(1991) \[hereafter WWT\] is to augment declarative, uni-fication-based grammars with relational constraints.Combinatory operations can then be defined out of thesets of relational constraints present in rule bodies.
Theapproach in WWT includes a set-valued attribute calledcover in feature structures.
Relations such as above,below, north-east-of, and connected-to are examplesthat may be incorporated into cover constraints used ingrammars for two-dimensional languages.
These con-straints apply to sets of the basic input vocabulary,whose members may themselves be complex objects.The use of sets in these grammars takes the place ofstrings, or sequences of words, as used in grammars fornatural languages.This paper presents a generalization f the PATR-IIunification-based grammar formalism to incorporaterelational constraints.
The extension has been primarilymotivated by the demands of combinatory operations inthe syntax for two-dimensional l nguages although suchconstraints can be used to express more complex com-binatory relations on strings as well as for other pur-poses (see, for example, work in CLG (Damas andVarile 1989; Balari et al 1990)).The approach described here arose as a result ofextending a Lisp-based implementation of PATR-IIused with a chart parser.
A natural path was provided by216Ait-Kaci and Nasr (1989), who proposed integratinglogic and functional programming by allowing con-straints to be specified with applicative xpressions.This work has subsequently become one of the threecornerstones of the programming language Life (Ait-Kaci 1990).
The key idea is to allow interpreted func-tional expressions toappear as bonafide arguments inlogical statements.
Unification operations then mustallow for delaying the evaluation of functional expres-sions until such time as argument variables becomegrounded, a process that leads to what Ait-Kaci andNasr call residuation.For the most part, the adaptation of Ait-Kaci andNasr's methods to an extension of PATR-II proved tobe straitforward.
However, there are two points onwhich the operational semantics of F-PATR unifica-tion as defined here differs from theirs.
The first, avariation on dereferencing applicative values, wasmotivated by the demands of caching intermediateresults imposed by chart parsing.
The second, atomicdisjunction, allows for more expressiveness in thegrammar and also, again, was motivated by the parsingalgorithm we assumed.
We will return to these pointsin Section 6.2.
FUNCTIONAL CONSTRAINTSFrom the graph perspective, the basic vocabulary ofPATR-II (Shieber 1984) consists of a set of arc labelsand a set of terminal (leaf) node labels, the latterincluding a variable (or null) value.
The graphs canhave reentrancies atthe leaf levels or higher up, whichexpress identity (or unification) of structure.Following Ait-Kaci and Nasr (1989), we incorpo-rate applicative expressions (function specificationfollowed by zero or more argument specifications),into our constraint language.
Two uses of applicativeexpressions in the Ait-Kaci/Nasr language Le Funconcern us here.
The first allows variables to equate toan (eventual) evaluation of some applicative xpres-sion whose arguments may contain variables.
Forexample,X = (union Y Z)(Our convention will be to write applicative xpres-sions using Lisp s-expression syntax, i.e, functionname followed by zero or more arguments all enclosedin parentheses.)
The second allows Le Fun clauses tobe formed from arbitrary ground,decidable predicates,i.e., applicative xpressions whose arguments alsomay start out as variables.
For example, given theuser-defined boolean function sw-of (south-west of),the following would be an acceptable statement: (sw-of X Y).The analogous PATR-II extension to the first ofthese allows leaf nodes to be labeled with an applica-tive expression.
Any "unbound" arguments in theseapplicative xpressions will point to variable nodeselsewhere in the graph.
Equations uch as the follow-ing example will then be allowed in the language.<mother cover> = (union <daughtl cover><daught2 cover>)In F-PATR, we restrict he types of nodes repre-sented by paths to those that may appear as leaf values,i.e., atomic, a disjunction of atoms, null (variable), oranother applicative value.
This restriction is signifi-cant: it does not allow for arguments in functional con-straints to be of the complex attribute-value type.The second use of applicative xpressions, as pred-icates, allows the inclusion of functional expressionsinto feature specifications as independent conditionson successful nification.
So here the evaluation of theexpression is not associated with a leaf node's value.The statement below is an example of a such a con-straint on the value of a node that might be included ingraph.
This predicate sw-of will be taken to be a con-dition on successful unification.
(sw-of <daughtl cover> <daught2 cover>)The two statements above taken together wouldthen correspond to the graph shown in Figure 1, a firstapproximation for a rule for forming exponent expres-sions in a grammar of mathematical notation.
Theunlabeled arcs linking arguments in applicativeexpressions to the variable nodes are a notational con-venience, indicating a forwarding pointer.
The argu-ments to these expressions are in fact the nodesthemselves.mother J ~I cover r c?ver _ ) ~cover~(union J ~(sw-of ~.
/')Figure 1 An F-PATR GraphOur proposal for F-PATR feature structures beginswith a vocabulary of the following types suitable for217interpretive, functionally oriented programming lan-guages uch as Lisp.Atom Symbol or numberFun-exp Function, i.e, symbol pointing to a function,or lambda expression i terpretable asafunction, of typeAtom X Atom ?
... Atom ---> Atomor elseAtom ?
Atom X ... Atom ---> List-of-atoms(where List-of-atoms will be interpreted asa logical disjunction of atomic values)S-expression Any complete valuatable expression with-out internal references to F-PATR nodesThe following then is a BNF grammar for F-PATRequations representing feature structures:Feat-struct ::= Statement +Statement ::= Atom I Equation I ApplEquation :'= Path = Path I Path = Val I Path =ApplPath ::= < Atom + >Val ::= Atom I { Atom Atom + }Appl ::= ( Fun-exp Arg* )Arg ::= Path I Appl I S-expressionWe will assume the existence of a familiar equiva-lent notation for these feature equations, in whichgraph reentrancies (or path equivalences) areexpressed by a matrix with integers used for sharedreference.
Predicates will follow the core attribute-value matrix.
For example,\[a: 1\[\]b: 2(foo <1>)\](fie <1> <2>)is equivalent to<b> = (foo <a>)(fie <a> <b>).In addition to functional values and constraints, weaugment the original PATR-II notation with atomicdisjunction (interpreted as exclusive OR) as a possiblevalue of leaf nodes.
Such values are written with curlybraces surrounding two or more atoms.
Atomic dis-junction is one of the most basic extensions to thePATR-II unification language and is in common use.If atomic values are considered to be singleton sets,unification of atomic disjunctions with other disjunc-tions or atoms can be operationally treated as set inter-section.
In F-PATR, atomic disjunctions may appearnot only independently but also as arguments and val-ues of applicative xpressions.3.
DATA TYPESIn Ait-Kaci and Nasr (1989), functional expres-sions in feature structures are evaluated as soon astheir arguments become bound.
Otherwise, data struc-tures will become residuated, a state representingincompletion with respect o determining constraintson unification.
Ait-Kaci and Nasfs algorithms thusdelay the resolution of functionally-specified values orpredicates until all variables are bound, but thenresolve them as early as possible once bindings occur.Here we follow this same general approach for predi-cates only, but not for applicative values, which arechecked for readiness to evaluate only when derefer-enced.
Further, we expand the routines to deal withatomic disjunction.We assume the following data types for nodes in afeature structure graph::Arc-list a set of attribute labels and associated val-ues, the latter of which may be of any type:null the uninstantiated "variable" type:atomic a singleton set of one symbol or number:disjunct a set of 2 or more atomic values:appl an applicative xpression:res-var a residuated variable, i.e., a :null type thatappears as an argument in at least onepredicate:res-disjunct a residuated disjunction, i.e., a :disjuncttype that appears as an argument inat leastone predicateThe node types that may acquire residuationsinclude :null, :disjunct, and :appl (a type for which wedo not distinguish residuated from nonresiduated sub-types).
There are two kinds ofresiduations: predicatesnot ready for evaluation and delayed unifications asso-ciated with the :appl type.
Predicate residuations arisewhen a predicate contains any arguments of type :nullor :appl, or else when a predicate has more than oneargument of type :disjunct.
During unification, anysuch arguments mutate to a residuated type (if they areurtresidutated to start with), and the predicate ispushedonto their residuation list.The second kind of residuation arises when unifica-tion is called for between a node of type :appl that isnot ready for evaluation and any other non-:null type.The unification call itself must be delayed until suchtime as the function is ready for evaluation, and so aform that will provoke the unification is pushed ontothe residuation list of the :appl node.2184.
DEREFERENCINGThe notion of dereferencing a data structure repre-senting a feature value (or node) is common to mostunification implementations.
A field in the data struc-ture indicates whether the value is to be found locallyor else by following pointers to other data structuresthat may have been introduced through prior unifica-tion.
Introducing residuations into the data structuresadds the wrinkle that, during dereferencing, applica-tive expressions will be evaluated if they are ready.
InF-Patr, dereferencing an :appl type node is in fact theonly point at which to evaluate an applicative xpres-sion.
This is a change from Le Fun--there argumentsin applicative xpressions may acquire applicativeexpressions as residuations that can be evaluated asargument terms become grounded uring unification.This design change will be motivated in Section 6.For each node type, the dereference function fol-lows pointers in the usual way until no pointersremain.
In addition, if the resulting node is of :appltype, we check to see if all its arguments are atomic orelse lisp s-expressions, an indication that the functionis ready to be evaluated.
If  the function evaluates to anon-nil atom or a disjunctive list of atoms, then anyresiduations (delayed unifications) on the node arealso called.
Note then that dereferencing can itself failas a result of provoking unifications that fail, which thetop-level unification routines need to take account of.5.
UNIF ICAT IONThe types associated with successful unifications ofdereferenced leaf node types are shown in Table 1.Some cells contain more than one type since residua-tions and disjunctions may or may not be reduced inthe result term.
Note that an :appl type unified withany other type always yields another :appl type.
Thisis a bit misleading, however, since the table does nottake into account he effects of dereferencing, which,as we have just described, can provoke a chain ofdelayed unifications involving any types.During unification, the evaluation of functionsused in predicates and :appl nodes each may producedisjunctive values, but in different ways.
Predicatescan be evaluated when there is at most one disjunctiveargument node, in which case we map the predicateOver each of the disjunctions in the disjunctive argu-ment, and collect successful results.
I f  there is morethan one successful result, then the result is a disjunc-tion.
Alternatively, for functions appearing in :applnodes only, the function itself may produce a disjunc-tive value as directed by the internal definition of thefunction.
But note that functions used in F-PATRgraphs do not themselves take disjunctive argumentsdirectly, as indicated in the discussion of data typesabove.Table 1: Unification for leaf types:r-dis:null :null :atom :disju :appl :r-var:atom I :atom :atom :atom :appl :atom:r-dis:atom:disju:r-dis:disju :disju :atom :atom :appl :atom :atom:disju :disju :disju:r-dis :r-dis:appl :appl :appl :appl :appl :appl :appl:r-var :r-var :atom :atom :appl :r-var :atom:disju :disju:r-dis :r-dis:r-dis :atom:disju:r-disThere are a number of pairings in Table 1 that arecapable of producing either residuated isjunctions,disjunctions, or atoms.
These all involve a residuatedpredicate appearing in at least one of the leaf nodearguments.
If the initial intersection of the node's con-tents (independently from residuations) yields a valuethat still does not provoke valuation of the predicate,then the result is a residuated isjunction.
If the pred-icate is evaluated, then the unification process mayyield an atomic value or a disjunctive value, asexplained in the previous paragraph.Space precludes us from further discussion of theunification algorithms here.
With refej-ence to Ait-Kaci and Nasr (1989) and Table 1, however, thedetails should emerge.
See also the examples in theAppendix, which are taken from program output.6.
APPL ICAT ION TO PARSINGThe two significant design changes that we haveintroduced were motivated by our application of F-PATR to parsing of relational set grammars for graph-ical languages, which is discussed in detail in WWT.Initial experiments adopted the Ait-Kaci/Nasr219approach of evaluating the functions of :appl nodes assoon as possible, which meant residuating the argu-ment nodes of these functions.
However, thisapproach led to difficulties in our chart parsing algo-rithm, which needed to cache the feature structures ofactive edges before any of the destructive ffects ofunification involving what we call expander functionstook place.
The root of the issue is that with the Ait-Kaci/Nasr approach, the control of function evaluationis within unification rather than with some externalalgorithm.
In our approach, it was most natural to useexternal co n~0| to implement chart parsing.
Thispoint may be c.larified by considering an example, forwhich we need to summarize F-PATR relational setgrammars.
(See also Wittenburg (1992a 1992b).
)The feature structures for grammatical constituentsinclude the primary attributes cover, syntax, andsemantics.
The attribute cover takes as value a refer-ence to a subset of input objects.
This scheme is anal-ogous to HPSG feature structures, where the string-valued phonology attribute is replaced by the set-val-ued cover attribute.
Rules have the form\[mother: \[cover: \[\]syntax: \[\]semantics: \[\]\]daughtl: \[cover: \[\]syntax: \[\]semantics: \[\]\]daughtn: \[cover: \[\]syntax: \[\]semantics: \[\]\]\]with the condition that for the daughter elements of arule D1...Dn, there must exist at least one expanderrelation between covers of each daughter Di, 2 < i < n,and a cover of daughter Dj where j < i.The expander relations are a subclass of relationalconstraints among sets of input objects used to definethe combinatory possibilities of rules.
For parsing, theconstraints are expressed as functions from cover-setsto cover-sets and appear as a functional value of coverattributes.\[mother: \[syntax: Expcover: (union-covers <2> <3> <4>)semantics: (divide <6> <7>)\]daughtl: \[syntax: horizontal-linecover: 2\[\]\]daught2: \[syntax: Expcover: 3(what-is-above <2>)semantics: <6>\]daught3: \[syntax: Expcover: 4(what-is-below <2>)semantics: <7>\]\](contains-in-x <2> <4>)(contains-in-x <2> <3>)The example above is the rule for vertical infixationfor fractions, used in a grammar of mathematical nota-tion.Let us consider now what the feature structure foran active chart-parsing edge for the fraction rule wouldlook like after the first daughter had been unified in.The cover attribute would acquire a set-referencevalue (we will use a number in binary suggestive of theuse of bit vectors to represent subsets).Active edge feature structure:\[mother: \[syntax: Expcover: (union-covers 0001 <3> <4>)semantics: (divide <6> <7>)\]daughtl: \[syntax: horizontal-linecover: 0001\]daught2: \[syntax: Expcover: 3(what-is-above 0001)semantics: <6>\]daught3: \[syntax: Expcover: 4(what-is-below 0001)semantics: <7>\]\](contains-in-x 0001 <4>)(contains-in-x 0001 <3>)At this point the Ait-Kaci/Nasr algorithm for unifi-cation would provoke the evaluation of the what-is-above and what-is-below functions, since their argu-ments are now "grounded".
However, this is not whatwe want for a chart parser since the features of theactive edge graph shown here must be kept indepen-dent from each of its future advancements.
That is, wewant to evaluate these two functions at separate cyclesin the parsing algorithm at the points when we areready to extend this edge with the daughters in ques-tion.
The more conservative approach to derefencingand evaluation of :appl nodes and also the extension ofdisjunctions as possible values of expander functionsprovides an elegant solution.
!
The functions what-is-above and what-is-below ill be evaluated in indepen-dent expand steps of the WWT algorithm.
In eithercase, the function is capable of returning adisjunctionof values.
But any such values must also meet he con-straints of the predicate contains-in-x, the applicationof which may have the effect of reducing the set of val-1.
Hassan Ait-Kaci (personal communication) has pointed outthat a solution to the control problem is available in the Le Fun/LIFEframework.
An extra unbound argument could be added toexpander functions uch as what-is-above so that evaluation wouldnot be provoked at undesired times.
A binding for this extra variablecould later be offered when evaluation was wanted.220ues and perhaps eliminating all of them, leading to aunification failure.
All this happens as it should withthe approach to unification outlined above.7.
CONCLUDING REMARKSOne of the goals of this paper is to bring the workof Ait-Kaci and Nasr to the attention of the computa-tional linguistics community.
Their techniques formarrying declarative and functional programming par-adigms are an important avenue to explore in expand-ing the expressiveness of formalisms for linguisicapplications.
The design issues encountered in build-ing an implementation f F-PATR should be of inter-est to implementors of such a paradigm.
Of course wedo not address here issues in the logic of such featurestructures or their declarative semantics.
The signifi-cant differences of F-Patr from Le Fun include analternative approach to dereferencing certain datatypes, a change motivated by an environment in whichparsing control is outside the unification process, andalso an extension to a simple form of disjunction.
Incontrast to the research projects that implement unifi-cation-based grammar formalisms on top of Prolog,this implementation has built a unification environ-ment on top of Lisp.
The job of integrating the declar-ative and functional paradigms i  made considerablyeasier by relying on Lisp for lambda conversion andfunction evaluation.In the by now extensive literature on unificationgrammar f ameworks, the current proposal figures as asomewhat conservative, and yet radically expressive,extension to PATR-II.
It is conservative in that thelogic of feature structures includes only minimal dis-junction and no negation or conditionalization.
Butthe extension leads to unlimited expressive power bybringing in the full power of function evaluation.
Itappears to be an extension appropriate for the repre-sentational problems we encountered, but it also hasled to unanticipated uses.
For example, in writing thesemantics for graphical grammars we have been ableto use functions in feature structures as a way of build-ing forms that can simply be evaluated to invoke theappropriate operations for applications.
Here again,having more control over when evaluation takes placeexternal to the unification process has proved to beimportant.There are limitations, however, to the expressivepower of F-PATR as it stands.
It cannot directly sup-port some of the constraints envisioned in currentHPSG literature, for example, because of F-PATR'srestrictions on arguments to functional constraints.
InHPSG, relations constrain ot just atomic values butalso general feature structures incuding lists and sets.Such an extension to F-PATR is not planned by theauthor but it may be of interest.
From the logic gram-mar point of view, the work reported on here may berelevant as a source of ideas for efficiency.
Con-straints expressed as relations in frameworks uch asZajac (1992) could instead be expressed inF-PATR ascompiled functions, leading perhaps to improvedruntime speeds.The MCC/Bellcore implementation of F-PATRincludes both destructive and nondestructive rsionsof unification.
The destructive version is, as expected,more straightforward to implement but more expen-sive computationally given that over copying and earlycopying are profligate (see Wroblewski 1987).
Thealgorithms for nondestructive unification have beeninfluenced by Tomabechi (1991), but applicativeexpressions and residuations change the landscape sig-nificantly.
There tends to be extensive circularity inthe data structures: residuated argument nodes point topredicates that in turn point back to their arguments;residuations in applicative-valued nodes point to unifi-cation forms that in turn point back to the applicativenodes.
There is a need for future work to address issuesof space and time efficiency for extensions representedby F-PATR just as there has been such a need for otherPATR-II extensions.A line of research that the author is pursuing cur-rently (Wittenburg 1992b) is to design a more spe-cialized grammar formalism that finesses ome of thecomplexity of residuation and unification through aversion of "pseudo-unification" (Tomita 1990).
Incontrast to residuation, which manages function eval-uation at runtime, the idea is to manage the order ofevaluation for functional constraints at compile time.In grammar formalisms and parsers under investiga-tion, it is possible for a compiler to order constraintswithin rule data structures such that evaluation readi-ness is a deterministic matter, circumventing the needfor runtime checks and extra data structures requiredfor delaying evaluation dynamically.ACKNOWLEDGEMENTSThis research was carded out at MCC under thesponsorship of Bellcore and MCC.
Louis Weitzmanand Jim Talley worked closely with the author inexploring the use of F-PATR grammars in visual lan-guage applications.
Roger Nasr was very helpful inconsultations on the Le Fun unification algorithms.Thanks to Phil Cannata nd Jim Hollan for their sup-port of the project and to the anonymous ACL review-ers for their helpful comments on the manuscript.221REFERENCESAit-Kaci, H. (1991) An Overview of LIFE.
In J.W.Schmidt and A.A. Stogny (eds.
), Next Generation I forma-tion System Technology, Proceedings of the 1st Interna-tional East/West Data Base Workshop, Lecture Notes inComputer Science 504, Springer Verlag, pp.
42-58.Ait-Kaci, H., and R. Nasr (1989) Integrating Logic andFunctional Programming.
Lisp and Symbolic Computation2:51-89.Balari, S., L. Damas, and G. B. Varile (1989) CLG: Con-straint Logic Grammars, Proceedings of the 13th Interna-tional Conference on Computational Linguistics, Helsinki,vol.
3, pp.
7-12.Carpenter, B., C. Pollard, and A. Franz (1991) The Spec-ification and Implementation f Constraint-Based Unifica-tion Grammars.
In Proceedings IWPT 91, SecondInternational Workshop on Parsing Technologies, pp.
143-153.Damas, L. and G. Varile (1989) CLG: A Grammar For-malism based on Constraint Resolution.
In E.M. Morgadoand J.P. Martins (eds.
), EPIA '89, Lecture Notes in ArtificialIntelligence 390, Springer Verlag.Helm, R., and K. Marriott (1986) Declarative Graphics.In Proceedings of the Third International Conference onLogic Programming, Lecture Notes in Computer Science225, pp.
513-527.
Springer-Veflag.Helm, R., and K. Marriott (1990) Declarative Specifica-tion of Visual Languages.
In 1990 IEEE Workshop onVisual Languages (Skokie, Illinois), pp.
98-103.Kaplan, R., and J. Bresnan (1982) Lexical-FunctionalGrammar: A Formal System for Grammatical Representa-tion.
In J. Bresnan (ed.
), The Mental Representation fGrammatical Relations, MIT Press, pp.
173-281.Kay, M. (1979) Functional Grammar.
In Proceedings ofthe Fifth Annual Meeting of the Berkeley Linguistic Society.Pereira, F.C.N., and D. Warren (1980) Definite ClauseGrammars for Language Analysis--A Survey of the Formal-ism and a Comparison with Augmented Transition Net-works.
Artificial Intelligence 13:23 lr278.Pollard, C., and I.
Sag (1987) Information-based Syntaxand Semantics: Volume 1.
Center for the Study of Languageand Information.Reape, M. (1990) Getting Things in Order.
In Proceed-ings of the Symposium on Discontinuous Constituency,Institute for Language Technology and Artificial Intelli-gence, Tilburg University, The Netherlands, pp.
125-137.Tomabechi, H. (1991) Quasi-Destructive Graph Unifica-tion.
In Proceedings IWPT 91, Second International Work-shop on Parsing Technologies, pp.
164-171.Tomita, M. (1990) The Generalized LR Parser/CompilerV8-4: A Software Package for Practical NL Projects.
In:COLING-90, Volume 1, 59-63.Wittenburg, K. (1992a) Earley-style Parsing for Rela-tional Gramars.
In Proceedings ofIEEE Workshop on VisualLanguages, Sept, 15-18, 1992, Seattle, Washington, pp.192-199.Wittenburg, K. (1992b) The Relational Language Sys-tem, Bellcore Technical Memorandum TM-ARH-022353.Wittenburg, K., L. Weitzman, and J. Talley (1991) Unifi-cation-Based Grammars and Tabular Parsing for GraphicalLanguages.
Journal of Visual Languages and Computing2:347-370.Wroblewski, D. (1987) Nondestructive Graph Unifica-tion.
In Proceedings ofAAAI 87, pp.
582-587.Zajac, R. (1992) Inheritance and Constraint-Based Gram-mar Formalisms.
Computational Linguistics 18:159-182.APPENDIX: Unification ExamplesExample I :appl with :atom\[ obj: \[ length: 25\]\]{.J \[ obj: \[ length: (+ 1\[\] 2\[\])\]obj2: \[length: <2>\]objl: \[length: <1>\]\]= \[ obj: \[ length: 1(+ 2\[\] 3\[\])\]obj2: \[ length: <3>\]objl: \[ length: <2>\]\](Unify <1> 25)U \[ objl: \[ length: 20\]\]= \[ obj: \[ length: 1(+ 20 2\[\])\]obj2: \[ length: <2>\]objl: \[ length: 20\]\](Unify <1> 25)U \[ obj2: \[ length: 5\]\]= \[ obj: \[ length: 1(+ 20 5)\]obj2: \[ length: 5\]objl: \[ length: 20\]\](Unify <1> 25)Example 2 :res-var with :atom\[ obj: \[ length: 1\[\]\]objl: \[length: 2\[\]\]\](EQ <1> <2>)\[.J \[ obj: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[length: 1\[\]\]\](EQ 55 <1>)U \[ objl: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[ length: 55\]\]Example 3 :res-var with :disjunct\[ obj: \[ length: 1\[\]\]objl: \[length: 2\[\]\]\](EQ <1> <2>)U \[ obj: \[ length: {55 36\]\]\]= \[obj: \[length: I{5536\]\]objl: \[length: 2\[\]\]\](EQ <1> <2>)U \[ objl: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[ length: 55\]\]Example 4 :appl with :res-var\[ obj 1: \[ length: (+ 5 1\[\])\]obj2: \[ length: <1>\]\]222U \[ obj 1: \[ length: 1 \[\]\]obj2: \[ length: \[\]\]\](>= <1> 54)= \[ objl: \[ length: 1(+ 5 2\[\])\]obj2: \[ length: <2>\]\](>= <1> 54)13 \[ obj2: \[ length: 50\]\]= \[ objl: \[ length: 1(+ 5 50)\]obj2: \[ length: 50\]\](>= <1> 54)U \[ objl: \[ length: \[\]\]\]= \[ objl: \[ length: 55\]obj2: \[ length: 50\]\]Example 5 :res-var with :res-var\[ obj: \[ length: 1\[\]\]\](<= <1> 60)13 \[obj: \[length: 1\[\]\]\](>= <1> 54)= \[ obj: \[ length: 1\[\]\]\](>= <1> 54)(<= <1> 60)O \[ obj: \[ length: 55\]\]= \[ obj: \[ length: 55\]\]Example 6 :res-disjunct with :atom and :disjunct\[ obj: \[ length: 1 {55 43 44}\]objl: \[length: 2\[\]\]\](EQ <1> <2>)U \[obj: \[length: {43 55}\]\]= \[obj: \[length: 1{5543}\]objl: \[length: 2\[\]\]\](EQ <1> <2>)U \[ obj: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[length: 1\[\]\]\](EQ 55 <1>)U \[ obj 1: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[ length: 55\]\]Example 7 :appl with :res-disjunct\[ objl: \[ length: (+ 5 1\[\])\]obj2: \[length: <1>\]\]U \[objl: \[length: 1{554342}\]obj2: \[ length: 2\[\]\]\](> <1> <2>)= \[ objl: \[ length: 1(+ 5 2\[\])\]obj2: \[ length: <2>\]\](Unify <1> {55 43 42})(> <1> <2>)13 \[ obj2: \[ length: 50\]\]= \[ objl: \[ length: 1(+ 5 50)\]obj2: \[ length: 50\]\](> <1> 50)(Unify <1> {55 43 42})U \[ objl: \[ length: \[\]\]\]--- \[ obj 1: \[ length: 55\]obj2: \[ length: 50\]\]Example 8 :res-var with :res-disjunct\[obj: \[length: 1{554342}\]objl: \[length: 2\[\]\]\](EQ <1> <2>)U \[obj: \[length: 1\[\]\]objl: \[length: 2\[\]\]\]((LAMBDA (X Y) (EQ (+ X Y) 110)) <1> <2>)= \[obj: \[length: 1{554342}\]objl: \[length: 2\[\]\]\]((LAMBDA (X Y) (EQ (+ X Y) 110)) <1> <2>)(EQ <1> <2>)U \[ objl: \[ length: 55\]\]= \[ obj: \[ length: 55\]objl: \[ length: 55\]\]Example 9 :appl with :appl\[ obj: \[ length: (+ 5 1\[\])\]obj2: \[ length: <1>\]\]U \[ obj: \[ length:((LAMBDA (X) (- (+ X 10) 5)) 1\[\])\]obj2: \[ length: <1>\]\]= \[ obj: \[ length: 1(+ 5 2\[\])\]obj2: \[ length: <2>\]\](Unify <1>((LAMBDA (X) (- (+ X 10) 5)) <2>))U \[ obj2: \[ length: 55\]\]= \[ obj: \[ length: 1(+ 5 55)\]obj2: \[ length: 55\]\](Unify <1> ((LAMBDA (X) (- (+ X 10) 5)) 55))U \[ obj: \[ length: \[\]\]\]= \[ obj: \[ length: 60\]obj2: \[ length: 55\]\]Example 10 :res-disjunct with res-disjunct\[objl: \[length: 1{554342}\]obj2: \[length: 2\[\]\]\](EQ <1> <2>)U \[objl: \[length: 1{45 5543}\]obj2: \[length: 2\[\]\]\]((LAMBDA (X Y) (EQ (+ X Y) 110)) <1> <2>)= \[objl: \[length: 1{5543}\]obj2: \[ length: 2\[\]\]\](EQ <1> <2>)((LAMBDA (X Y) (EQ (+ X Y) 110)) <1> <2>)U \[ obj2: \[ length: 55\]\]= \[ objl: \[ length: 55\]obj2: \[ length: 55\]\]223
