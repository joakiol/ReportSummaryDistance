Proceedings of the ACL 2007 Demo and Poster Sessions, pages 85?88,Prague, June 2007. c?2007 Association for Computational LinguisticsPoliqarpAn open source corpus indexer and search engine with syntactic extensionsDaniel JanusSentivision Polska Sp.
z o.o.Marynarska 19a, 02-674 Warsaw, Polandnathell@korpus.plAdam Przepi?rkowskiInsitute of Computer SciencePolish Academy of SciencesOrdona 21, 01-237 Warsaw, Polandadamp@ipipan.waw.plAbstractThis paper presents recent extensions toPoliqarp, an open source tool for index-ing and searching morphosyntactically an-notated corpora, which turn it into a tool forindexing and searching certain kinds of tree-banks, complementary to existing treebanksearch engines.
In particular, the paper dis-cusses the motivation for such a new tool,the extended query syntax of Poliqarp andimplementation and efficiency issues.1 IntroductionThe aim of this paper is to present extensionsto Poliqarp,1 an efficient open source indexerand search tool for morphosyntactically annotatedXCES-encoded (Ide et al, 2000) corpora, withquery syntax based on that of CQP (Christ, 1994),but extending it in interesting ways.
Poliqarphas been in constant development since 2003(Przepi?rkowski et al, 2004) and it is currently em-ployed as the search engine of the IPI PAN Cor-pus of Polish (Przepi?rkowski, 2004) and the Lis-bon corpus of Portuguese (Barreto et al, 2006),as well as in other projects.
Poliqarp has a typi-cal server-client architecture, with various Poliqarpclients developed so far, including GUI clients fora variaty of operating systems (Linux, Windows,MacOS, Solaris) and architectures (big-endian andlittle-endian), as well as a PHP client.
Since March2006, the 1st stable version of Poliqarp (Janus and1Polyinterpretation Indexing Query And RetrievalProcessorPrzepi?rkowski, 2006) is available under GPL.2 Aversion of Poliqarp that implements various statisti-cal extensions is at the beta-testing stage.Although Poliqarp was designed as a tool for cor-pora linguistically annotated at word-level only, theextensions described in this paper turn it into an in-dexing and search tool for certain kinds of treebanks,complementary to existing treebank search engines.Section 2 briefly introduces the basic query syn-tax of Poliqarp, section 3 presents extensions ofPoliqarp aimed at the processing of treebanks, sec-tion 4 discusses implementation and efficiency is-sues, and section 5 concludes the paper.2 Query SyntaxIn the Poliqarp query language, just as in CQP, reg-ular expressions may be formulated over corpus po-sitions, e.g.
: [pos="adj"]+, where any non-emptysequence of adjectives is sought, or within valuesof attributes, e.g.
: [pos="a.
*"], concerning forms(henceforth: segments) tagged with POSs whosenames start with an a, e.g., adj and adv.Parts of speech and morphosyntactic cate-gories may be queried separately, e.g., the query[gend=masc] could be used to search for masculinesegments, regardless of the POS or other categories,while the query [pos="subst|ger"&gend!=masc]can be used to find nominal and gerundive segmentswhich are not masculine.A unique feature of Poliqarp is that it may beused for searching corpora containing, in addition todisambiguated interpretations, information about all2Cf.
http://poliqarp.sourceforge.net/.85possible morphosyntactic interpretations given bythe morphological analyser.
For example, the query[case~acc] finds all segments with an accusativeinterpretation (even if this is not the interpretationselected in a given context), while [case=acc] findssegments which were disambiguated to accusative ina given context.Moreover, Poliqarp does not make the assump-tion that only one interpretation must be correct forany given segment; some examples of sentencescontaining an ambiguous segment which cannot beuniquely disambiguated even given unlimited con-text and all the linguistic and encyclopaedic knowl-edge are cited in (Przepi?rkowski et al, 2004).
Insuch cases, the = operator has the existential mean-ing, i.e., [case=acc] finds segments with at leastone accusative interpretation marked as correct inthe context (?disambiguated?).
On the other hand,the operator == is universal, i.e., [case==acc] findssegments whose all disambiguated interpretationsare accusative: segments which were truly uniquelydisambiguated to one (accusative) interpretation, orsegments which have many interpretations correct inthe context, but all of them are accusative.3 For com-pleteness, the operator ~~ is added, which univer-sally applies to all morphosyntactic interpretations,i.e., [case~~acc] finds segments whose all interpre-tations as given by a morphological analyser (beforedisambiguation) are accusative.The most detailed presentation of the orig-inal query syntax of Poliqarp is available in(Przepi?rkowski, 2004), downloadable fromhttp://korpus.pl/index.php?page=publications.3 Syntactic Extensions(Przepi?rkowski, 2007) argues for the explicit rep-resentation of both a syntactic head and a seman-tic head for each syntactic group identified in a(partially parsed) constituency-based (as opposed todependency-based) treebank.
For example, for thePolish syntactic group tuzin bia?ych koni, ?a dozenof white horses?, lit.
?dozen-NOM/ACC white-GENhorses-GEN?, the syntactic head is tuzin ?dozen?,3In Polish this may happen, for example, in case of somegerund forms which are homographs of true nouns, wheremeaning does not make it possible to decide on the nominal /gerundive interpretation of the form.while the semantic head is koni ?horses?.
The seg-ment koni is also both the syntactic head and thesemantic head of the embedded nominal group bi-a?ych koni ?white horses?.
In general, following(Przepi?rkowski, 2007), a given segment is a syn-tactic head of at most one group (e.g., tuzin and koniin the example above), but it may be a semantic headof a number of groups (e.g., koni above is a semantichead of bia?ych koni and of tuzin bia?ych koni).This kind of representation is problematic for gen-eral search tools for constituency-based treebanks,4such as TIGERSearch (Lezius, 2002),5 which usu-ally assume that the set of edges within a syntacticrepresentation of a sentence is a tree, in particular,that it has a single root node and that each leaf has(at most) one incoming edge.6 While the former as-sumption is not a serious problem (an artificial sin-gle root may always be added), the latter is fatal forrepresentations alluded to above, as a single segmentmay be a semantic head of a number of syntacticgroups, i.e., it may have several incoming edges.The extension of Poliqarp presented here makesit possible to index and search for such (partial)syntactic-semantic treebanks.
Specifications of syn-tactic constructions in the extended Poliqarp querylanguage syntax are similar to specifications of par-ticular segments, but they use a different repertoireof attributes, non-overlapping with the attributesused to specify single segments.
Two main at-tributes to be used for querying for syntactic groupsare: type and head.
The attribute type spec-ifies the general syntactic type of the group, so[type=Coordination] will find coordinated con-structions, while [type="[PN]G"] will find prepo-sitional and nominal groups.The syntax of values of the attribute head differsfrom that of the other attributes; its values must beenclosed in a double or a single set of square brack-ets, as in: [head=[...][...]] or [head=[...]].In the first case, the first brackets specify the syntac-tic head and second brackets specify the semantic4It seems that it would also be problematic for depen-dency tools such as Netgraph, cf.
(Hajic?
et al, 2006) andhttp://quest.ms.mff.cuni.cz/netgraph/doc/netgraph_manual.html.5Cf.
http://www.ims.uni-stuttgart.de/projekte/TIGER/.6In TIGER tools, there is a special mechanism for adding asecond edge, e.g., in order to represent control.86head, as in the following query which may be usedto find elective constructions of the type najstarszyz koni ?
(the) oldest of horses?, which are syntacti-cally headed by the adjective and semantically bythe semantic head of the dependent of that adjective:[head=[pos=adj][pos=noun]].In the second case, the content of the single brack-ets specifies both the syntactic head and the se-mantic head and, additionally, makes the require-ment that they be the same segment.
This meansthat the queries [head=[case=gen][case=gen]]and [head=[case=gen]] have a slightly differentsemantics: the first will find syntactic groups wherethe two heads may be different or the same, but theymust be genitive; the second will find groups withthe two heads being necessarily the same genitivesegment.The usefulness of such queries may be illus-trated with a query for verbs which co-occur withdative dependents denoting students; the firstapproximation of such a query may look like this:[pos=verb][head=[case=dat][base=student]].This query will find not only dative nominal groupsheaded by a form of STUDENT, but also dativenumeral groups whose main noun is a form ofSTUDENT, appropriate dative adjectival electivegroups, etc.As syntactic sugar, the constructs synh=[...]and semh=[...] can be used to enforce a con-straint only on, respectively, syntactic or semantichead of a group.It may seem that, given the possibility to specifythe syntactic head of the construction, the attributetype is redundant; in fact, we are not currentlyaware of cases where the specification type="PG"or type="NG" could not be replaced by an ap-propriate reference to the grammatical class (part ofspeech) of the syntactic head.
However, the typeattribute is useful for finding constructions which arenot defined by their heads, for example, oratio rectaconstructions, and it is also useful for dealing withcoordinate structures.4 Implementation IssuesTo allow for fast searching, the original Poliqarpuses its own compact binary format for corpora,described in detail in (Janus, 2006) and briefly in(Janus and Przepi?rkowski, 2006).
Because thenumber of syntactic groups can easily grow verylarge and be on par with total number of words in afully-tagged corpus, the representation of syntacticgroups should be space-efficient, yet alow for fastdecoding and random access.The key observation to achieving this goal is that,due to the tree nature of the group set, any twogroups can be either mutually disjoint or completelycontained in each other.
Thus, it is possible to seri-alize the tree into a list, sorted by the lower bound ofa group,7 such that each group is immediately fol-lowed by its direct subgroups.More precisely, the on-disk representation of atreebank is a bit vector that contains the followingdata for each group: 1) synchronization bit (see be-low), usually 0; 2) the difference between the lowerbound of the previous group and the lower boundof the one in question, encoded in ?-code;8 3) ?-encoded length of current group in segments; 4)?-encoded number of type of this group (the map-ping of numbers to type names is stored in a sepa-rate on-disk dictionary in which two type numbersare reserved: 0 for coordinated groups and 1 forconjunctions); 5) if this is a coordinated construct(i.e., type = 0) ?
?-encoded number of subsequentgroups (excluding the current one but including in-direct subgroups) that are part of the coordination;9or 6) if this is not a coordinated construct (i.e., it isan ordinary group) ?
offset of syntactic and seman-tic head of this group, in that order, each representedby a binary number of log l bits, where l stands forthe length of the group.One drawback of this representation is that it doesnot allow for random access: the ?-code and headoffsets have variable length, thus it is not possible todetermine which bit one should start with to decodethe group sequence for a certain segment.
To miti-gate this, a synchronization mechanism is employed.7The corpus proper is represented by one large vector offixed-size structures denoting segments; here, the bounds of agroup mean offsets into that vector.8The ?-code is a prefix-free variable-length code that en-codes arbitrary integers so that the representation of small num-bers takes few bits; see (Witten et al, 1999) for details.9Special treatment of coordination is caused by the fact that,as argued in (Przepi?rkowski, 2007), coordinate structures arebest treated as multi-headed constructions, with each conjunctbringing its own syntactic and semantic head.87For every k-th segment (k is a constant defined forthe corpus, usually 1024), the bit offset of start ofthe description of the earliest group that intersectsthis segment is stored as an unsigned little-endian32-bit integer in a separate file.
In the description ofthis group, the synchronization bit is set to 1, and thelower bound is spelled in full (as an unsigned 32-bitbinary integer) so that it is not necessary to know theprevious lower bound to start decoding.This synchronization lines up with the sparse in-verted indexing mechanism used by Poliqarp for ef-ficient searching.
Poliqarp artificially splits the cor-pus into fixed-size chunks and remembers whichsegments occur in which chunks; if the search en-gine makes random access to the corpus, the ac-cessed segments?
offsets are multiplies of the chunksize.
It is best, thus, to ascertain that the constant kis also equal to this chunk size.In a typical scenario with many mostly smallgroups occurring close to each other, this encodingschema is capable of achieving the ratio of well un-der two bytes per group and does not incur a signifi-cant overhead in corpus size (which is usually in therange of 10?12 bytes times the number of segmentsfor a morphosyntactically but not structurally taggedcorpus).
This is important, since disk access is thekey factor in Poliqarp?s performance.5 ConclusionsIn this paper, we presented an extension of Poliqarp,a tool for indexing and searching morphosyntacti-cally annotated corpora, towards the management ofsyntactically annotated corpora.
An interesting fea-ture of thus extended Poliqarp is its ability to dealwith treebanks which do not adopt the ?at most oneincoming edge?
assumption and which distinguishbetween syntactic heads and semantic heads.
Wealso sketched the original and efficient method ofindexing such treebanks.
The implementation ofthe extensions currently approaches the alpha stage.By the time of ACL 2007, we expect to release thesources of a relatively stable beta-stage version.ReferencesFlorbela Barreto, Ant?nio Branco, Eduardo Ferreira,Am?lia Mendes, Maria Fernanda Nascimento, FilipeNunes, and Jo?o Silva.
2006.
Open resources andtools for the shallow processing of Portuguese: TheTagShare project.
In Proceedings of the Fifth Interna-tional Conference on Language Resources and Evalu-ation (LREC 2006).Oli Christ.
1994.
A modular and flexible architecture foran integrated corpus query system.
In COMPLEX?94,Budapest.Jan Hajic?, Eva Hajic?ov?, Jaroslava Hlav?c?ov?, V?clavKlime?, Jir??
Mirovsk?, Petr Pajas, Jan ?te?p?nek, Bar-bara Vidov?
Hladk?, and Zdene?k ?abokrtsk?, 2006.PDT 2.0 ?
Guide.
Charles University, Prague.
June20, 2006.Nancy Ide, Patrice Bonhomme, and Laurent Romary.2000.
XCES: An XML-based standard for linguisticcorpora.
In Proceedings of the Linguistic Resourcesand Evaluation Conference, pages 825?830, Athens,Greece.Daniel Janus and Adam Przepi?rkowski.
2006.
Poliqarp1.0: Some technical aspects of a linguistic search en-gine for large corpora.
In Jacek Walin?ski, KrzysztofKredens, and Stanis?aw Goz?dz?-Roszkowski, editors,The proceedings of Practical Applications of Linguis-tic Corpora 2005, Frankfurt am Main.
Peter Lang.Daniel Janus.
2006.
Metody przeszukiwania i obrazowa-nia jego wynik?w w duz?ych korpusach tekst?w.
Mas-ter?s thesis, Uniwersytet Warszawski, Wydzia?
Matem-atyki, Informatyki i Mechaniki, Warsaw.Wolfgang Lezius.
2002.
TIGERSearch ?
ein Suchw-erkzeug f?r Baumbanken.
In Stephan Busemann, ed-itor, Proceedings der 6.
Konferenz zur Verarbeitungnat?rlicher Sprache (KONVENS 2002), Saarbr?cken.Adam Przepi?rkowski, Zygmunt Krynicki, ?ukaszDe?bowski, Marcin Wolin?ski, Daniel Janus, and Pi-otr Ban?ski.
2004.
A search tool for corpora withpositional tagsets and ambiguities.
In Proceedingsof the Fourth International Conference on LanguageResources and Evaluation, LREC 2004, pages 1235?1238, Lisbon.
ELRA.Adam Przepi?rkowski.
2004.
The IPI PAN Corpus: Pre-liminary version.
Institute of Computer Science, Pol-ish Academy of Sciences, Warsaw.Adam Przepi?rkowski.
2007.
On heads and coordina-tion in valence acquisition.
In Alexander Gelbukh,editor, Computational Linguistics and Intelligent TextProcessing (CICLing 2007), Lecture Notes in Com-puter Science, pages 50?61, Berlin.
Springer-Verlag.Ian H. Witten, Alistair Moffat, and Timothy C. Bell.1999.
Managing Gigabytes: Compressing and Index-ing Documents and Images.
Morgan Kaufmann Pub-lishers Inc., San Francisco, CA, 2nd edition.88
