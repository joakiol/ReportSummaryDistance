A Computational Approach to Binding Theory*Alessandra Giorgi, Fabio Pianesi, Giorgio Satta**Istituto per la Ricerca Scientifica eTecnologica, 38050 Povo (Trento), Italye-mail: satta@irst.it ; satta@irst.uucpAbstractThis paper is a first step towards acomputational ccount of Binding Theory (BT).Two algorithms that compute, respectively,Principle A and B have been provided.
Particularattention has been devoted to possibleinteractions of BT with other modules of thelinguistic theory, such as those rulingargumental chains.
Finally, the computationalcomplexity of the algorithms has been studied.1 IntroductionThis work is a contribution to the computational studyof the referential properties of Noun Phrases (NPs).
Inparticular, it focuses on the disjoint reference constraintfor pronouns, and on the binding requirement foranaphors.
1 Unlike other attthors, we do not output actualreferences for pronouns.
2 The reasons for such a movewill be discussed below.In pursuing these goals, we will refer to BindingTheory (henceforth BT), as developed within theGovernment and Binding framework by Chomsky andhis collaborators (see Chomsky, 1981, 1986); inparticular, algorithms will be presented that computePrinciples A and B of BT.Section 2 presents a brief introduction to BT.
InSection 3, we will introduce a formal (computational)apparatus, which will then be used to formulate thealgorithms.
Finally, some considerations about theirformal properties will be discussed.
Section 4illustrates, by means of an example, how the algorithmswork.
Finally, in Section 5, our approach and resultswill be compared with those already present in theliterature.
*Every part of this work has been elaborated jointly by the threeauthors.
However, as far as legal requirements are concerned,A.Giorgi takes responsability of Sections 1 and 2, F.Pianesi ofSections 4 and 5 and G.Satta of Section 3.
**This work has been done while G.Satta was completing hisDoctoral Dissertation at the University of Padova (Italy).1This work is part of a larger one providing a computationalaccount of Binding Theory.
See Giorgi, Pianesi, Satta (1989a), inwhich the present approach is extended to principle C of BindingTheory and weak-crossover core cases, and Giorgi, Pianesi, Satta(1989b), where the general problems of Binding Theoryverification and satisfiability are addressed.2See Berwick and Weinberg (1984), Correa (1988), htgria andStallard (1989), Berwick (1989); for a different approach see Ristad(1989).2 Introduction to Binding TheoryBinding Theory (BT) is a module of the Governmentand Binding theory ruling the distribution and thereferential properties of anaphors (such as himself),pronouns (such as him and his) and R(eferential)-expressions ( uch as John, the man I met yesterday, mysister, etc).
Here we will briefly illustrate its scope,without entering into a detailed analysis.It is a well known fact that lexical items, such asNoun Phrases, must undergo an interpretation processby which they are assigned a referent.
Such a process isruled by principles that vary according to the nature ofthe item in question, i.e.
anaphor, pronoun or R-expression.
A first generalization can be stated asfollows: anaphors must have an antecedent in thesyntax, i.e.
in the same sentence where they appear;pronouns can directly identify a referent in the world orin the previous discotu'se; R-expressions are intrinsicallyreferential, i.e.
they need no antecedent?
Consider thefollowing examples:(1)a. Johni loves himself ib.
*I love himselfIn (1)a. the anaphor himself takes John as an antecedent,i.e.
in technical terms, it is bound by it; irt (1)b, formorphological reasons, I cannot work as an antecedentfor himself, so that the whole sentence is ruled out.
4Consider now what happens in the case of pronouns:(2) John thinks that Mary likes himhim can either refer to John or to someone lse in theworld, for instance to someone mentioned in theprevious discourse.
The conclusion up to this point canbe summarized as follows: an anaphor must have anantecedent, a pronoun can have one, an R-expressioncannot.
However further properties must be taken intoaccount; let us consider pronouns again:(3) Johni likes him,itt im cannot be interpreted as John, contrary to whathappens in (2): there is a "negative" condition on3For reasons of space, the referential properties of quantifiedexpressions and those of the so-called epithets are not consideredhere.4R-expressions cannot be coindexed with any c-commandingitem (see below for a definition of c-command).
Consider thefollowing example:(i) John likes JohnIn this case, given that the first R-expression c-commands thesecond one, the two occurrences of John must refer to differentpersons.120 lpronouns, since they cannot have an antecedent lyingwithin a certain contexl:.
Technically speaking, apronoun must be free in its local domain; a similarlocality condition holds with respect o anaphors, since~tll anaphor must have an antecedent inside a certaindomain:(.4)a.
*John i thinks that Mary likes himselfib.
Mary thinks that John i likes himselfi(4)a. is ungrammatical because the intended antecedent,John, lies too far away.The local domain is the so-called CompleteFunctional Complex (CFC) pertaining to the item inquestion, i.e.
containing both the item itself and itsgovernor: 5(5) ?,is a Complete Functional Complex iff one ofthe lollowing holds:a) y is the (minimal) domain in which all the0-roles pertaining to a lexical head m'e realized;b) y is the (minimal) domain in which all thegrammatical functions pertaining to that headm'e realized.Finally, an important structural condition must hold,namely c-comm~md: (of.
Chomsky, 1981; 1986):(6) cx c-commands fi iff 0'~\]3, a does not dominate\]3 and the first node, y, dominating cx alsodominates \]3.
"1-'o be bound by a given item actually means: to becoindexed and c-commanded bythat item; whereas to befree means: not to be coindexed with a c-cormnandingitem (non c-commanding items might work, on theolher hand, as possible antecedents).
The principles ofb:iuding can be expressed as follows:(7) A: An anaphor is bound in its local domainB: A pronoun is free in its local domainC: An R-expression is fleeNote that, as will be shown below, in our system wecan also handle constructions involving the so-calledpro-drop phenomena, found in languages like Italian,Spanish and so on.
Consider the following Italianex ample: 6(8) proi arriva lui ilit: at:rives heThe system must know that the coindexation i  (8), i.e.the fact that the pronoun lui is coindexed with a c-commanding empty category (the expletive pro), is nota Principle B violation.3 The  A lgor i thmsWith respect o the two principles considered here, i.e.Principles A and B, the output of BT can be represented"hi'he definition in the text is Ihe one foand in Giorgi (1987); cfralso Chomsky (1986).
Note that, in most cases, the CFC coincideswilh the first Senience or Noun Phrase dominating the ilem inqudstion.
However, this is not always the case and the systemsdefining the binding domain this way often nm into trouble; thispoint will be fnrther considc~cd in Seclion 5; sue also Giorgi,Plainest, Satta (1989a).61npro-drop languages (sec Chomsky 1981) typically, lhesubieet can be noJl lexica\[, i.e.
can be an empty calegory, or can bcexpressed postvel%ally, leaving an cxpletive empty category insubject position.as a lomml language Lv.
More precisely, given asentence w, let T be the set of all tuples t=<z'w, (x, fit,.... /7,~>, n_>0, where "cw is a parse tree for w,  a is eitheran anaphor or a pronoun and the components fll ... finrepresent any set of NPs.
v Let us define Le c T to bethe set of all tuples such that the following conditionshold:(i) if o: is an anaphor, \]31...fin are all and only theitems that can be antecedents for c~, according toPrinciple A of BT;(it) if c~ is a pronoun, then ill...fin are all and onlythe items disjoint from ~x, according to Principle Bof BT.The algorithms to be presented can be seen asrecogniscrs for L s.3.1 Def in i t ionsLet N : (n l  ..... nq}, q>_l, be the set of all nodes in rw.We will also assume the following functions andpredicates:  a function father from N to Nu  {_t_}; afunction siblings from N to '/'(30; a binary predicateagreement, defined on NxN,  such that agreement(n1,n2)=TRUE iff the agreement features of n 1 and n2 aremutually compatible; a unary predicate pt-antecedent,defined in -N, such that pt-antecedent(n)=TRUE iff n isa maximal projection of a head N o (a Noun) within T~.Definition 1 A binary predicate domain is defined inN?N in such a way that domain(ha, hal=TRUE if f:(i) n,~ is the least constituent such that either all theO-roles pertaining to a lexical head are realized, or allthe grammatical functions pertaining to the samelexical head are realized;(it) ny is the lexical governor of na  andfilther(n ~)~filther(n,4).9 0Condition (it) has been explicitely introduced in order tolake care of cases of government across the boundaries(see Section 3.3).To account for the interaction of BT with pro-drop (cf.ex.
(8) above), we also need the following definitions.Let ch-mark be a procedure defined on Nx&(: wheneverch-mark(n,nm) is invoked, if n is a landing-site of achain ~?
c within rw, every node nc such that nc belongsto c, gets marked with a distinctive mm'ker, which willbe assumed to be the second argument node n m. Thismarking relation will hold until a new call to theprocedure takes place for any node corresponding tothesame chain as n, with a different node-marker.
We need7We assume lhat all the principles of the theory have alreadybeen applied to tile sentence.
Such an asstimption is reasonable,given the modular nature of tile theory; see Chorasky (1981,1986).8In tim following, the symbol .L is meant o denote the undefinedelement.
Also, for a generic set .~l, ~v(51) denotes the set of allt?
)ssible subsets of .a (the power set of A).9The exact meaning of linguistic notions such as: 0-roles,functional-.roles, lexical governor and government can be found inChomsky (1981, 1986).
A computaliona\] account of fl~e no,.iov, of\]ocal domain can be found in Giorgi, Pianesi and Satta (1989a),along with some tbrmal properties of the predica'.e domain.10l(oughly, tim notion of chain can be defined (cf.
Chomsky,1986) as the set of coindexed positions (landing sites) pertainingto the same syntactic object (uhetv only one of sLicl't posili'.,ns islexically filled).2 121also a function ch-marker, from 5% to Nvo (?\], definedsuch that ch-marker(n)=nm iff n is a landing-site of achain c within ~,,, and a previous call to the procedurech-mark has m~ked each node in c with the marker-noden m .3.2 Algorithm SchemataThe two algorithms behave in a very similar way; theytake as input a node in N corresponding to an NP inVw, and analyse some specific relations between theinput node and each node in N that c-commands theinput node, up to certain specific domain.
The c-commanding relation is implicitly encoded in the way inwhich the algorithms apply the two flmctionsfather andsiblings.An Algorithm for Principle AGiven an input node n which corresponds to ananaphor in l:w, the algorithm outputs a list of nodescorresponding to "actual antecedents" for the anaphoritself.
The algorithm looks for a "potential antecedent"of the input anaphor, starting from node n andproceeding from bottom-to-top.
As soon as a potentialantecedent is found, the algorithm restricts its search tothe local domain it has just identified.
Note that eachpotential antecedent must pass the agreement check tobe considered an actual antecedent nWe also consider some cases of referential circularity;in particular, problems arising in pro-dropconstructions.
More specifically, a node which belongsto the chain also containing the anaphor, cannot becollected as a potential antecedent.
The followingcircularity check is therefore included: every chain whoselanding-sites dominate the input anaphor, up to thedomain of interest, is marked by the procedure ch-markusing the input-node as a marker.
In this way a node c-comnmnding the input node and corresponding to alanding-site of a chain marked by the latter, cannot betaken as a potential antecedent for the input-node itself(for more discussion, see Section 5).
The samemechanism also ensures that, for every possible chain,only one of its landing-sites is ever considered as apotential matezedent.Algorithm 1input-node: A node corresponding to an anaphor in 'r~.Output: A list of nodes in N corresponding to actualantecedents for the input anaphor.Method.Step 1: Let input-node be the value of the programvariable present-node, hfitialize also the programvariable local .domain-flag to the value FALSE andinvoke the procedure ch-mark(present-node, input-node).Step 2: For each value of the program variable present-sibling in siblings(t)resent-node), if ch-marker(present-sibling)veinput-node and pt-antecedent(present-sibling)=TRUE, perform the following actions.
Setthe program variable local-domain-flag toTRUE if itis FALSE and invoke the procedure ch-mark(present-l lAccording to Chomsky (1986), the existence of the potentialanlecedent for an anaphor is crucial in defining its local domain.Note timt such an item is not necessarily the actual antecedenl,sibling, input-node); fur thermore,  ifagreement(present-sibling, i put-node)=TRUE thenoutput present-sibling.Step 3: If father(present-node)=L, go to Step 4,otherwise let father(present-node) be assigned as thevalue of present-node.
Invoke the procedure ch-mark(present-node, input-node).
If local-domain-flag=FALSE then restart at Step 2.
Otherwise thereare two possibilities: if domain(present-node, input-node )=FALSE then restart at Step 2; ifdomain(present-node, input-node)=TRUE go to Step4.Step 4: Stop.
caAn Algorithm for Principle BThe algorithm starts from an input node thatcorresponds toa pronoun in rw.
The algorithm visits allnodes in Nwhich correspond to elements c-commandingthe input pronoun and lie inside the local domain;finally, it outputs a list of disjoint elements.
Indee(1 thealgorithm is procedurally very similar to the one givenfor Principle A, with minor changes due to thedifferences in the definitions of the local domain.Algorithm 2 considers each chain only once, as doesAlgorithm 1.
Observe that if a pronoun belongs to acertain chain, it cannot be disjoint from other elementsof the same chain.
An identity check is then carried outby the algorithm in the following way: the chain, whichthe input-node belongs to, is mitiatly marked by theprocedure ch-mark.
Then, every node that c-commandsthe input-node inside its local domain, corresponding toa landing-site of this marked chain, will not be insertedin the output list of Algorithm 2 (see Section 5).
Thedetails are the lbllowing:Algorithm 2Input-node: A node corresponding to a pronoun in r,.Output: A list of nodes in N corresponding to thedisjoint elements for the input pronoun.Method?Step 1: Let input-node be the value of the programvariable present-node.
Invoke the procedure chain-mark(present-node, input-node).Step 2: For each value of the program variable present-sibling in siblings(present-node), perform thefollowing action.
If ch-marker(present-sibling)~-input-node and pt-antecedent(present-sibling)=TRUE, outputpresent-sibling and invoke the procedure ch-mark(present-sibling, put-node).Step 3: Iffather(present-node)=Z, go to Step 4,otherwise let father(present-node) be assigned as thevalue of present-node.
If domain(present-node, input-node)=FALSE then restart at Step 2, otherwise go toStep 4.Step 4: Stop.3.3 Some Formal  ResultsSome properties of Algorithms 1 and 2 will be stated;see also Giorgi, Pianesi and Satin (198%).Theorem 1 The predicate domain(present..node, input-node) holds true at Step 3 in Algorithms 1 and 2 iffpresent-node corresponds in rw to the minimal CFCcontaining both input-node and n~, where n 7 is thelexical governor of input-node.122 3Proof'Only if Condition (i) in Definition 1 guaranties thatpresent-node is a CFC, as defined in (5).
Furthermorepresenbnode dominates input-node at Step 3, as it iseasy to show.
It remains to demonstrate hat present-node dominates n.?.
A government relation between 7and input-node can only be attained within the followingthree structural configurations.
In the first, governmentis realize.d under sisterhood; thus, every node thatdominates the governee will also dominate the governor.In the second configuration the govcrnee is attachedhigher than its governor, within the maximal projectionof the latter; again, every node that dominates the formerwill also dominate the latter.
The third possibilityconcerns the so called government across boundaries:when a maximal projection ZP (or a Small Clause) is insisterhood relation with a lexical category X?, then thelatter can govern the specifier position of Ihe former (orthe subjex:t position, in the case of a Small Clause).
ZPmay well be a CFC, in the sense of (5), but it does notcontain the governor X ?.
Condition (it) in Definition 1explicitely rules out this case, so the claim is proved.
'If' The proof immediately follows from the givenanalysis of the possible configurations of governmentbetween the nodes n 7 and input-node, and fromDefinition 1.XP /)',X ?
=n yp  = input-node yFigure 1XPyp = input-nodeX 0 = n 7 ...Figure 2Theorem 2 Let "Cw be an X-.bar description for somesentence w such that all the principles of GB hold trttefor it, apart from the BT principles, and let N be the set(~f all nodes ill "~w.
When input-node is assigned a value,which corresponds to an anaphor a in "rw, Algorithm 1computes the whole list of nodes in N that correspondsto the antecedents of a, in the sense of Principle A ofBT.f:'roof Omitted.
LaTheorem 3 Let "Cw and N be as in Theorem 2.
Givenas input a node that corresponds to a pronoun ~ in "cw,Algorithm 2 computes the whole list of nodes in Nthat must be disjoint from a, in the sense of PrincipleB of BT.Proof Omitted.
c)Questions about ime complexity are now addressed forAlgorithms 1 and 2 (we assume, as the reference modelfor comi)utation, a RAM).X*YP = input-node Z'Figure 3Theorem 4 The running times of Algorithms 1 and 2are given by two functions fAz andfA2, such thatf4 ~,fa2e O(n), where n is the length of the sentence underanalysis.
',2Proof (outline) From elementary considerations aboutX-bar Theory, ~3 it can be argued that set N has .
'dzebounded by an expression of the form cxn+c2, It is easyto show that no node in N is visited more than once byAlgorithms l and 2 and that a constant amount of timeis spent in visiting each node; then the result follows.4 A running exampleLet us see how Algorithm 1 works with the followingsentence, giving, as input node, the one correspondingto the anaphor herself:(9) lIP Mary \[r \[vt' \[v' sees herself \ [pp in theminvr\]\]\]\]\] 14At the beginning, the variable present-node is set to thevalue of input-node, i.e.
the anaphor node, while thevariable local-domain-flag is set to FALSE.
ThenAlgorithm 1 enters Step 2, where it scans the anaphor'ssiblings.
Once present-sibling is set to the PP node, pt-antecedentQ)resent-sibling)=FALSE.
At this point,Algorithm 1 exits Step 2 and enters Step 3, wherepresent-node is set to the value of father(present-node),in this case, the V' node.
Given that local-domain-.flag=FALSE, Algorithm 1 enters Step 2 again.
We donot follow the whole computation but directly skip tothe point where Algorithm 1 enters Step 2 with present-12The standard notation g(n)c Off(n)) means that there exist apositive constant M and an integer n o such that g(~,)<Mf(n) for all?~?t 0.13See J ackendoff (l 977).ldAnother possible analysis of this sentence hypothesises, asthe argument of see, a Small Chmse inchlding herself and thepredicate PP.4 123node=I'.
The only sibling of I' is the subject NP and,setting present-sibling to it, one has that pt-antecedent(present-sibling)=TRUE.
Algorithm 1 thensets local-domain-flag to TRUE; furthermore,agreement(present-sibling, present-node)=TRUE, so thatthe value of present-sibling is output.
After that,Algorithm 1 enters Step 3 and sets present-node tofather(present-node), i. .
to the topmost (IP) node.
Nowlocal-domain-flag=TRUE and domain(present-node,input-node)=TRUE (i.e.
IP is the local domain for theinput anaphor); therefore Algorithm 1 enters Step 4 andthen stops.5 D iscuss ionBy fixing an upper bound, it has been shown that thecomputational complexity of the recognition problem ofa language that encodes Principles A and B of BT is inp.~S These results are similar to those obtained by allauthors who have studied BT from a computationalpoint of view (Correa, 1988; Ingria and Sta\[lard, 1989;Berwick and Weinberg, 1984; Berwick, 1989).Nevertheless, with respect o such works we have bothtaken a rather different perspective and paid moreattention to the subtleties of the linguistic theory.Previous works were mainly concerned with providingactual referents (actual indexations) for the NPs of asentence.
We claim, on the contrary, that Principles A,B and C per se are not sufficient for this puq~ose, sinceBT only restricls the search space for indices selection,and does not actually provide them.
For instance, Correa(1988) proposes an algorithm that builds lists ofantecedents for pronouns and anaphors, andcomplements it with a Binding Rule, that selects, foreach item, an indexation from such lists.
However, theselection of an antecedent for a certain item could affectthe indexation of other nodes, leading to violations ofPrinciple B.
16 In tb.is framework, a related problemarises considering split antecedents for pronouns; in fact,a pronoun can be coindexed with a set of items, providedthat each of them has a different hematic roleJ 7 Thispoint has never been explicitely addressed incomputational works; nevertheless, if the purpose is tooutput actual indexations, it seems to us that the onlypossibility, in order to consider split antecedents, wouldbe to compute lists of possible antecedents for pronounsand then to consider their power set; this way, however,the search space becomes exponentially large.Furthermore, the interactions of the referential properties15?o denotes the class of languages recognizable in polynomialtime by a deterministic Turing machine.16Consider, for instance, the following sentence:(i) Mary says that she saw herin this case both embedded pronouns can take Mary as anantecedent, according to Correa's Binding Rule, leading to aviolation of Principle B.
In our opinion, to avoid this incorrectresult, it is necessary to put together the constraints that have beenseparately computed for each item according to Principles A and B(and C); this way we can account for the interactions betweencoindexations and disjointness.
A possible way to do it, is to posethe problem of BT verification, i.e.
whether a given indexassignment for the NPs of a sentence complies with therestrictions of BT.
See Giorgi, Pianesi, Satta (1989b).17For instance, in Mary tom John that they should go home thepronoun they can refer to the complex antecedent constituted byMary plus John.of a split antecedent with those of other items (,possiblyother split antecedents) would thereby hardly beaddressable.
TMFinally, given the referential properties of pronouns,it seems that there is no point in trying to use thegrammatical knowledge of BT to hypothesiseintrasentential antecedenks, t9Another crucial aspect concerns the treatment of localdomains, whose importance has often beenmisconsidered in computational works on BT.
Such anotion has been mainly seen as a static one, whereas, inour interpretation, the value of the actual domaindepends on the interaction of structural and lexicalproperties of at least two different positions in thederivation tree.
For example, in Ingria and Stallard(1989), an S node is taken to be the binding domain forevery node it dominates.
Consider, however, the cases inwhich government of the specifier position of amaximal projection is obtained through an externalhead; this situation arises, for instance, in exceptionalcase marking examples, as in John believed him to beintelligent.
Ingria and Stallard's tatic definition of localdomain would lead to the conclusion that the pronoun,being dominated by an S type node (the embeddedsentence), is free in that category and, thus, could becoindexed outside, for instance with the R-expressionJohn.
But this is ungrammatical; according to thedefinition adopted here, the domain of binding for him isthe matrix clause, so that the pronoun must, correctly,be free in it, i.e, disjoint from John.
Our approach alsoimproves on Ingria and Smllard's treatment of NP as abinding domain.
If a node NP containes a possessivethen they consider it a binding domain for all the nodesit dominates, except he possessive itself.
There are atleast two problems, though.
First, they do not predictthat a pronoun subcategorized for by the head cannot bebound in the domain of the NP; second the well-knownnot complementary distribution of pronouns andanaphors in the specifier position of an NP cannot beaccounted for.
The definition of binding domain adoptedin (5) and the way it is computezt allow our algorithmsto avoid these problems; see Giorgi, Pianesi, Satta(1989a).As a final remark, note that in this work theinteraction with A-chains has been explicitelyconsidered.
This problem is particularly important inItalian which, being a pro-drop language, admitssentences like (8) and (10):(10) Giannii ha detto che proj arriver~t \[la propriaimadre\]jlit.
: Gianni told that will arrive self'smotherGianni told that his mother will arrive18Also the so called weak crossover phenomena may raise someproblems.
Roughly, pronouns cannot be coindexed with non c-commanding quantified expressions, as in *His imother loves\[every boY\]i , where the embedded pronoun cannot be taken to referto the quantified expression.
But this fact raises some problems forboth Correa's and Ingria's approach.19pronouns can refer intersententially or deictically; note thatthis property is shared with certain R-expressions, like theepithets, which obey Principle C (see Ha'ik, 1984).124 5in (8) the postverbal s ibject pronoun is coindexed withthe expletive pro, but a procedure looking for disjointelements would output a list containing pro (it lies inthe local domain of the pronoun) thereby giving rise toa contradiction: the pronoun is coindexed with theexpletive pro but must be disjoint fi'om it.
In (10), wemust avoid the anaphoric possessive proprio beingcoindexed with the c-commanding expletive pro, in orderto rule out circular interpretations.
The circularity andidentity checks, discussed in Section 3.2, explicitly takecare of these cases.ReferencesBerwick R.,(1989) , Natural Language ComputationalComplexity and Generative Capacity, to appear onComputers and Artificial IntelligenceBerwick R. and Weinberg A., (1984), The GrammaticalBasis of Linguistic Pe(\[ormance, MIT Press,Cambridge MAChomsky N., (1981), Lectures o~l Government andBindMg, Foris, DordrechtChomsky N., (1986), Knowledge of Language, Praeger,New YorkCorrea N., (1988), A binding Ru!e for Government-binding Parsing, Proceedirlgs of COLING, BudapestGiorgi A., (1987), The notion of Complete FunctionalComplex: Some Evidence fi'om Italian, Lb~guisticInquiry, 18,3iGiorgi A., Piancsi F., Satta G.,(1989a), Towards aComplexity Analysis of Bindiz:g Theory, TechnicalReport n.8911-06, IRST, Trcnto, It.Giorgi A., Piancsi F., Satta G.,(1989b), TheCompat~tional Conlpiexity of Binding Theory'sSatisfiability and Verification, ms, IRST, Trento, Itl ia?k I., (1984), Indirect Binding, LiJTguistic l, zquiry, 15,2\]ngria R.P.J., Stallard 1),(1989), A ComputationalMechanism for Pronominal Reference, Proceedingsof the 271h Anmml Meeting of the Association forComptltational Linguistics, VancouverJackendoff R., (1977), X-bar 5)ntax."
A study of l)hraseStructure, MIT Press, Cambridge MA6 125
