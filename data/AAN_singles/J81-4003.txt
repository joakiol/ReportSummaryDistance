Extraposition GrammarsFernando Pere i raDepar tment  of Arch i tec tureUn ivers i ty  of Ed inburghEd inburgh EH1 1JZ SCOTLANDExtraposition grammars are an extension of definite clause grammars, and are similarlydefined in terms of logic clauses.
The extended formalism makes it easy to describe leftextraposition of constituents, an important feature of natural language syntax.1.
IntroductionThis paper presents a grammar formalism for natu-ral language analysis, called extraposition grammars(XGs), based on the subset of predicate calculusknown as definite, or Horn, clauses.
It is argued thatcertain important linguistic phenomena, collectivelyknown in transformational grammar as left extra-position, can be described better in XGs than in earliergrammar formalisms based on definite clauses.The XG formalism is an extension of the definiteclause grammar (DCG) \[6\] formalism, which is itself arestriction of Colmerauer's formalism of metamorphosisgrammars (MGs) \[2\].
Thus XGs and MGs may beseen as two alternative xtensions of the same basicformalism, DCGs.The argument for XGs will start with a comparisonwith DCGs.
I should point out, however, that themotivation for the development of XGs came fromstudying large MGs for natural anguage \[4,7\].The relationship between MGs and DCGs is analo-gous to that between type-0 grammars and context-free grammars.
So, some of the linguistic phenomenawhich are seen as rewriting one sequence of constitu-ents into another might be described better in a MGthan in a DCG.
However, it will be shown that re-writings such as the one involved in left extrapositioncannot easily be described in either of the two formal-isms.Left extraposition has been used by grammarians todescribe the form of interrogative sentences and rela-tive clauses, at least in languages uch as English,French, Spanish and Portuguese.
The importance ofthese constructions, even in simplified subsets of natu-ral language, such as those used in database interfaces,suggests that a grammar formalism should be able toexpress them in a clear and concise manner.
This is thepurpose of XGs.2.
Grammars in LogicThis section summarises the concepts of definiteclause grammars (DCGs), and of the underlying sys-tem of logic, definite clauses, needed for the rest of thepaper.
A fuller discussion can be found elsewhere \[6\].A definite clause has either the formP:-QI,"',Qn"to be read as "P  is true if Q 1 .
.
.
.
.
Qn are true", or theformP .to be read as "P  is true".
P is the head of the clause,Q1 .
.
.
.
.
Qn are goals, forming the body of the clause.The symbols P, Q 1 .. .
.
.
Qn stand for literals.
A literalhas a predicate symbol, and possibly some arguments(in parentheses, eparated by commas), e.g.father(X,Y) false number(O)A literal is to be interpreted as denoting a relationbetween its arguments; e.g.
"father(X,Y)" denotes therelation 'father' between X and Y.Arguments are terms, standing for partially speci-fied objects.
Terms may be?
variables, denoting unspecified objects(variable names are capitalised):X Case Agreement?
atomic symbols, denoting specific objects:plural \[ \] 3?
compound terms, denoting complex objects:s(NP,VP) succ(succ(O))A compound term has a functor and some arguments,which are terms.
Compound terms are best seen asCopyright 1981 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial dvantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires afee and/or specific permission.0362-613X/81/040243-14501.00American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 243Fernando Pereira Extraposit ion Grammarstrees, e.g./NPS SUCC\ IVP succI0A particular type of term, the list, has a simplifiednotation.
The binary functor ' ' makes up non-empty lists, and the atom '\[ \]' denotes the empty list.In the special ist notation,\ [a,b\]  \[X I Y\]represent respectively the terms.
(a , .
(b , \ [  3) .
(X,Y)Putting these concepts together, the clausegrandfather(X,Z) :- father(X,Y),  parent(Y,Z).may be read as "X is grandfather of Z if X is father ofY and Y is a parent of Z"; the clausefather(john ,mary).may be read as " John is father of Mary" (note the useof lower case for the constants in the clause).A set of definite clauses forms a program.
A pro-gram defines the relations denoted by the predicatesappearing on the head of clauses.
When using a defi-nite clause interpreter, such as PROLOG \[9\], a goalstatement?-19 .specifies that the relation instances that match P arerequired.Now, any context-free rule, such assentence --> noun_phrase, verb_phrase.
(I use ', ' for concatenation, and '.'
to terminate a rule)may be translated into a definite clausesentence(50,S)  :-  n0un_phrase(S0,S1) ,verb_phrase ( S1 ,S ).which says: "there is a sentence between points SOand S in a string if there is a noun phrase betweenpoints SO and S1, and a verb phrase between points S1and S".
A context-free rule likedeterminer- -> \ [ the\ ] .
(where the square brackets mark a terminal) can betranslated intodeterminer(SO,S) :- connects(SO,the,S).which may be read as "there is a determiner betweenpoints SO and S in a string if SO is joined to S by theword 'the'".
The predicate 'connects' is used to relateterms denoting points in a string to the words whichjoin those points.
Depending on the application, differ-ent definitions of 'connects' might be used.
In particu-lar, if a point in a string is represented by the list ofwords after that point, 'connects' has the very simpledefinitionconnects(\[Word I 53,Word,S).which may be read as "a string point represented by alist of words with first element Word and rest S isconnected by the word Word to the string point repre-sented by list S."DCGs are the natural extension of context-freegrammars (CFGs) obtained through the translationinto definite clauses outlined above.
A DCG non-terminal may have arguments, of the same form asthose of a predicate, and a terminal may be any term.For instance, the rulesentence(s(NP,VP)) --> noun_phrase(NP,N),verb_phrase(VP,N).states: "A  sentence with structures/ \NP VPis made of a noun phrase with structure NP and num-ber N (which can be either 'singular' or 'plural'), fol-lowed by a verb phrase with structure VP agreeingwith the number N".
A DCG rule is just "syntacticsugar" for a definite clause.
The clause for the exam-ple above issentence(s(NP,VP),SO,S) :-noun phrase(NP,N,SO,S1),verb_phrase(VP,N,Sl ,S).In general, a DCG non-terminal with n arguments istranslated into a predicate of n+2 arguments, the lasttwo of which are the string points, as in the translationof context-free rules into definite clauses.The main idea of DCGs is then that grammar sym-bols can be general logic terms rather than just atomicsymbols.
This makes DCGs a general-purpose gram-mar formalism, capable of describing any type-0 lan-guage.
The first grammar formalism with logic termsas grammar symbols was Colmerauer's metamorphosisgrammars \[2\].
Where a DCG is a CFG with logicterms for grammar symbols, a MG is a somewhat re-stricted type-0 grammar with logic terms for grammarsymbols.
However, the very simple translation ofDCGs into definite clauses presented above does notcarry over directly to MGs.3.
Left ExtrapositionRoughly speaking, left extraposition occurs in anatural language sentence when a subconstituent ofsome constituent is missing, and some other constitu-ent, to the left of the incomplete one, represents themissing constituent in some way.
It is useful to thinkthat an empty constituent, the trace, occupies the"hole" left by the missing constituent, and that theconstituent o the left, which represents the missingpart, is a marker, indicating that a constituent o itsright contains a trace \[1\].
One can then say that theconstituent in whose place the trace stands has beenextraposed to the left, and, in its new position, is rep-244 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981Fernando Pereira Extraposition Grammarssentence --> noun_phrase, verb phrase.noun_phrase --> proper_noun.noun_phrase --> determiner, noun, re lat ive.noun_phrase --> determiner, noun, prep_phrase.noun_phrase --> trace.trace --> \[ \].verb_phrase --> verb, noun_phrase.verb_phrase --> verb.re lat ive --> \[ \].re lat ive --> rel_pronoun, sentence.prep_phrase --> preposition, noun_phrase.Figure 4.1.
CFG for relative clauses.
(1)resented by the marker.
For instance, relative clausesare formed by a marker, which in the simpler cases isjust a relative pronoun, followed by a sentence wheresome noun phrase has been replaced by a trace.
Thisis represented in the following annotated surface struc-ture:The man that/ \[sdohn met t i\] is a grammarian.In this example, t stands for the trace, ' that'  is thesurface form of the marker, and the connection be-tween the two is indicated by the common index i.The concept of left extraposition plays an essentialrole, directly or indirectly, in many formal descriptionsof relative and interrogative clauses.
Related to thisconcept, there are several "global constraints", the"island constraints", that have been introduced torestrict the situations in which left extraposition canbe applied.
For instance, the Ross complex-NP con-straint \[8\], implies that any relative pronoun occurringoutside a given noun phrase cannot be bound to atrace occurring inside a relative clause which is a sub-constituent of the noun phrase.
This means that it isnot possible to have a configuration likeXl " "  \ [np  "'" \ [ re l  X2 \ [s  "'" t2 "'" tl "'" 3\] "'" \]Note that here I use the concept of left extraposi-tion in a loose sense, without relating it to transforma-tions as in transformational grammar.
In XGs, and alsoin other formalisms for describing languages (for in-stance the context-free rule schemas of Gazdar \[5\]),the notion of transformation is not used, but a concep-tual operation of some kind is required for instance torelate a relative pronoun to a "hole" in the structuralrepresentation of the constituent following the pro-noun.4.
Limitations of Other FormalismsTo describe a fragment of language where left ex-traposition occurs, one might start with a CFG whichgives a rough approximation of the fragment.
Thegrammar may then be refined by adding arguments tofu l l  sentence --> sentence(nil).sentence(HoleO) -->noun_phrase(HoleO,Holel), verb_phrase(Holel).noun_phrase(Hole,Hole) --> proper_noun.noun_phrase(Hole,Hole) -->determiner, noun, re lat ive.noun_phrase(HoleO,Hole) -->determiner, noun, prep_phrase(HoleO,Hole).noun_phrase(trace,nil) --> trace.trace --> \[ \].verb_phrase(Hole) -->verb, noun_phrase(Hole,nil).verb_phrase(nil) --> verb.re lat ive --> \[ \].re lat ive -->rel_pronoun, sentence(trace).prep_phrase(HoleO,Hole) -->preposit ion, noun_phrase(HoleO,Hole).Figure 4.2.
DCG for relative clauses.
(2)non-terminals, to carry extraposed constituents acrossphrases.
This method is analogous to the introductionof "derived" rules by Gazdar \[5\].
Take for examplethe CFG in Figure 4.1.
In this grammar it is possibleto use rule (1) to expand a noun phrase into a trace,even outside a relative clause.
To prevent this, I willadd arguments to all non-terminals from ~vhich a nounphrase might be extraposed.
The modified grammar,now a DCG, is given in Figure 4.2.
A variable'Hole... '  will have the value 'trace' if an extraposednoun phrase occurs somewhere to the right, 'nil' other-wise.
The parse tree of Figure 4.3 shows the variablevalues when the grammar of Figure 4.2 is used to ana-lyse the noun phrase "the man that John met".Intuitively, we either can see noun phrases movingto the left, leaving traces behind, or traces appearingfrom markers and moving to the right.
In a phrase"noun phrase(Holel ,Hole2)" ,  Holel  will have thevalue 'trace' when a trace occurs somewhere to theright of the left end of the phrase.
In that case, Hole2will be 'nil' if the noun phrase contains the trace,'trace' if the trace appears to the right of the right endof this noun phrase.
Thus, rule (2) in Figure 4.2 speci-fies that a noun phrase expands into a trace if a traceappears from the left, and as this trace is now placed,it will not be found further to the right.The non-terminal 'relative' has no arguments, be-cause the complex-NP constraint prevents noun phras-es from moving out of a relative clause.
However, thatconstraint does not apply to prepositional phrases, so'p repphrase '  has arguments.
The non-terminal'sentence' (and consequently 'verb phrase') has asingle argument, because in a relative clause the traceAmerican Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 245Fernando Pereira Extraposition Grammarsnoun_phrase(ntl,ntl)determiner noun relat ivere l_pronoun sentence (trace)noun_ p hrase (trace ,trace)Iproper_nounthe man that Johnverb_phrase(trace)verb noun_phrase(trace,ntl)ItraceImet \[\]Figure 4.3.
DCG parse tree.must occur in the sentence immediately to the right ofthe relative pronoun.It is obvious that in a more extensive grammar,many non-terminals would need extraposition argu-ments, and the increased complication would make thegrammar larger and less readable.Colmerauer's MG formalism allows an alternativeway to express left extraposition.
It involves the useof rules whose left-hand side is a non-terminal fol-lowed by a string of "dummy" terminal symbols whichdo not occur in the input vocabulary.
An example ofsuch a rule is:re l _marker ,  \ [ t \ ]  - -> re l _pronoun.Its meaning is that 'rel pronoun' can be analysed as a'rel marker' provided that the terminal 't' is added tothe front of the input remaining after the rule applica-tion.
Subsequent rule applications will have to copeexplicitly with such dummy terminals.
This methodhas been used in several published grammars \[2, 4, 7\],but in a large grammar it has the same (if not worse)problems of size and clarity as the previous method.It also suffers from a theoretical problem: in general,the language defined by such a grammar will containextra sentences involving the dummy terminals.
Forparsing, however, no problem arises, because the inputsentences are not supposed to contain dummy termi-nals.
These inadequacies of MGs were the main moti-vation for the development of XGs.5.
In formal  Descr ipt ion  of XGsTo describe left extraposition, we need to relatenon-contiguous parts of a sentence.
But neither DCGsnor MGs have means of representing such a relation-ship by specific grammar rules.
Rather; the relation-ship can only be described implicitly, by adding extrainformation to many unrelated rules in the grammar.That is, one cannot look at a grammar and find a setof rules specific to the constructions which involve leftextraposition.With extraposition grammars, I attempt to providea formalism in which such rules can be written.In this informal introduction to the XG formalism,I will avoid the extra complications of non-terminalarguments.
So, in the discussion that follows, we maylook at XGs as an extension of CFGs.Sometimes it is easier to look at grammar ules inthe left-to-right, or synthesis, direction.
I will say thenthat a rule is being used to expand or rewrite a string.In other cases, it is easier to look at a rule in the right-to-left, or analysis, direction.
I will say then that therule is being used to analyse a string.Let us first look at the following XG fragment:sentence - -> noun_phrase,  verb_phrase .noun phrase - -> determiner ,  noun, re la t ive .noun_phrase - -> t race .re la t ive  - -> \[ \ ] .re la t ive  - -> re l  marker ,  sentence.re l _marker  .
.
.
t race  - -> re l _pronoun.246 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981Fernando Pereira Extraposition Grammarsthe mousetherel_marker the cat chased tracemouse re l _pronoun the cat chasedsqueakssqueaksFigure 5.1.
Applying an XG rule.Al l  rules but  the last are context- f ree.
The last rule~xpresses the extrapos i t ion  in simple relat ive clauses.It states that a relat ive pronoun is to be analysed as amarker ,  fo l lowed by some unknown const i tuents(denoted  by ' .
.
. '
) ,  fo l lowed by a trace.
This is shownin F igure 5.1.
As in the DCG example of the previoussection, the ext raposed noun phrase is expanded into atrace.
However ,  instead of the trace being rewr i t teninto the empty  string, the trace is used as part  of theanalysis of 'rel marker ' .The di f ference between XG rules and DCG rules isthen that the le f t -hand side of an XG rule may conta inseveral  symbols.
Where  a DCG rule is seen as ex-pressing the expans ion of a single non- termina l  into astring, an XG rule is seen as expanding together severalnon-cont iguous ymbols  into a string.
More  precisely,an XG rule has the general  forms 1 .
.
.
s  2 etc.
Sk_ 1 .
.
.
s  k --> r. (3)Here each segment si (separated f rom other  segmentsby ' .
.
. '
)  is a sequence of terminals  and non- termina ls(wr i t ten in DCG notat ion,  with ' , '  for concatenat ion) .The first symbol  in s 1, the leading symbol, is restr ictedto be a non-terminal .
The r ight -hand side r is as in aDCG rule.Leaving aside the constra ints  discussed in the nextsection, the meaning of a rule like (3) is that  any se-quence of symbols  of the formSlXqS2X 2 etc.
sk_qXk_ lS  kwith arb i t rary  xi's, can be rewr i t ten into rxqx2.
.
.x  k_ 1.Think ing procedura l ly ,  one can say that a non-terminal  may be expanded by matching it to the lead-ing symbol  on the le f t -hand side of a rule, and the restof the le f t -hand side is "put  as ide"  to wait  for theder ivat ion of symbols  which match each of its symbolsin sequence.
This sequence of symbols  can be inter-rupted by arb i t rary  strings, pa i red to the occurrencesof ' .
.
. '
on the le f t -hand side of the rule.6.
XG Der ivat ionsWhen several  XG rules are involved, the der ivat ionof a surface string becomes more compl icated than inthe single rule example  of the prev ious  sect ion,  be-cause rule appl icat ions interact  in the way now to bedescr ibed.To represent  he intermediate  stages in an XG de-r ivat ion,  I will use bracketed strings, made up of?
terminal  symbols?
non- termina l  symbols?
the open bracket <?
the close bracket >A bracketed  str ing is balanced if the brackets  in itba lance in the usual way.Now, an XG ruleu 1 .
.
.u  2.
.. etc .
.
.
.
u n --> v.can be appl ied to bracketed  str ing s ifs = xOUlXlU 2 etc.
Xn_qUnX nand each of the gaps x 1 .
.
.
.
.
Xn-1 is balanced.
Thesubstr ing of s between x 0 and x n is the span of therule appl icat ion.
The appl icat ion rewri tes s into newstr ing t, replacing Ul by v fo l lowed by n-1 open brack-ets, and replacing each of u 2 .
.
.
.
.
u n by a close brack-et; in short,  s is rep laced byx0v<< ... <x  1>x2> ... Xn_ l>x  nThe re lat ion between the original  str ing s and theder ived str ing t is abbrev ia ted  as s => t. In the newstr ing t, the substr ing between x 0 and x n is the resultof the appl icat ion.
In part icular ,  the appl icat ion of arule with a single segment in its le f t -hand side is nod i f ferent  f rom what  it would be in a type-0  grammar.Tak ing again the rulerel_marker .
.
.
t race - -> rel_pronoun.its appl icat ion tore l  marker John likes traceproducesrel_pronoun < John likes >After  this rule appl icat ion,  it is not poss ib le to applyany rule with a segment  match ing inside a bracketedport ion and another  segment  match ing outs ide it.
Theuse of the above rule has div ided the string into twoisolated port ions,  each of which must be independent lyexpanded.G iven an XG with init ial  symbol  s, a sentence t isin the language def ined by the XG if there is a se-American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 247Fernando Pereira Extraposition GrammarsaS bsaSas\[\]bs~x b "I~J xcbs\[\]CSCSiXC  laConventions:o= rule application(node)x = non- termina lx = te rmina l\ [ \ ]=  emptg str ingcs\[\]a a b b c cFigure 7.1.
Derivation graph for "aabbcc".quence of rule applications that transforms into astring from which t can be obtained by deleting allbrackets.I shall refer to the restrictions on XG rule applica-tion which I have just described as the bracketingconstraint.
The effect of the bracketing constraint isindependent of the order of application of rules, be-cause if two rules are used in a derivation, the brack-ets introduced by each of them must be compatible inthe way described above.
As brackets are added andnever deleted, it is clear that the order of applicationis irrelevant.
For similar reasons, any two applicationsin a derivation where the rules involved have morethan one segment in their left-hand sides, one and onlyone of the two following situations arises:?
the span of neither application intersects the resultof the other;?
the result of one of the applications is containedentirely in a gap of the other application - the ap-plications are nested.If one follows to the letter the definitions in thissection, then checking, in a parsing procedure, whetheran XG rule may be applied, would require a scan ofthe whole intermediate string.
However, we will see inSection 10 that this check may be done "on the fly"as brackets are introduced, with a cost independent ofthe length of the current intermediate string in thederivation.7.
Der ivat ion GraphsIn the same way as parse trees are used to visualisecontext-free derivations, I use derivation graphs torepresent XG derivations.In a derivation graph, as in a parse tree, each nodecorresponds to a rule application or to a terminal sym-bol in the derived sentence, and the edges leaving anode correspond to the symbols in the right-hand sideof that node's rule.
In a derivation graph, however, anode can have more than one incoming edge - in fact,one such edge for each of the symbols on the left-248 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981Fernando Pereira Extraposition Grammarshand side of the rule corresponding to that node.
Ofthese edges, only the one corresponding to the leadingsymbol is used to define the left-to-right order of thesymbols in the sentence whose derivation is represent-ed by the graph.
If one deletes from a derivation graphall except the first of the incoming edges to everynode, the result is a tree analogous to a parse tree.For example, Figure 7.1 shows the derivation graphfor the string "aabbcc"  according to the XG:S - ->  as ,  bs ,  cs .as - ->  \[ \ ] .as .
.
.
xb  - ->  \ [a \ ] ,  as .bs - ->  \[ \ ] .bs .
.
.
xc  - ->  xb ,  \ [b \ ] ,  bs .cs - ->  \[ \ ] .CS --> XC, \ [C\ ] ,  CS.This XG defines the language formed by the set of allstringsanbncn for n_> 0.The example shows, incidentally, that XGs, even with-out arguments, are strictly more powerful than CFGs,since the language described is not context-free.The topology of derivation graphs reflects clearlythe bracketing constraint.
Assume the following twoconventions for the drawing of a derivation graph,which are followed in all the graphs shown here:?
the edges entering a node are ordered clockwisefollowing the sequence of the corresponding sym-bols in the left-hand side of the rule for that node;?
the edges issuing from a node are ordered counter-clockwise following the sequence of the corre-sponding symbols in the right-hand side of the rulefor the node.Then the derivation graph obeys the bracketing const-raint if and only if it can be drawn, following the con-ventions, without any edges crossing.
1 The example ofFigure 7.2 shows this clearly.
In this figure, the closedpath formed by edges 1, 2, 3, and 4 has the same ef-fect as a matching pair of brackets in a bracketedstring.It is also worth noting that nested rule applicationsappear in a derivation graph as a configuration like theone depicted in Figure 7.3.8.
XGs  and Lef t  Ext rapos i t ionWe saw in Figure 4.2 a DCG for (some) relativeclauses.
The XG of Figure 8.1 describes essentiallythe same language fragment, showing how easy it is todescribe left extraposition in an XG.
In that grammar,the sentence1 In some of the examples of this article, edges cross to makethe graphs more readable, but such crossings could be triviallyavoided.5 - ->  a ,  b ,  c ,a .
.
.
c - ->  \ [x \ ] .b ... d - ->  \ [g \ ] .d.sa b c dx yS -~>S -T_>a b c d => x < b > d => ?
(blocks)a b c d => a g < c > => ?Figure 7.2.
Relating derivations to derivation graphs.Figure 7.3.
Nested rule applications.The mouse that the cat chased squeaks.has the derivation graph shown in Figure 8.2.
The leftextraposition implicit in the structure of the sentenceis represented in the derivation graph by the applica-American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 249Fernando Pereira Extraposition GrammarsSdet noun relrEr sI e-.-----lpnp vpdet noun rel  verb+ i ?\[\] tTverbdetnprre\[re lp5tvp= determiner= noun_phrase= re I _marker= re la t ive= re l _pronoun= sentence= trace= verb_phrasethe mouse that the cat chased  squeaksFigure 8.2.
Example of derivation graph for the XG in Figure 8.1.sentence --> noun_phrase, verb_phrase.noun_phrase --> proper_noun.noun_phrase --> determiner,  noun, re la t ive .noun_phrase --> determiner,  noun, prep_phrase.noun_phrase --> trace.verb_phrase --> verb, noun_phrase.verb_phrase --> verb.re la t ive  --> \[ \] .re la t ive  --> re\]  marker, sentence.rel_marker .
.
.
t race --> rel_pronoun.prep_phrase --> prepos i t ion ,  noun_phrase.Figure 8.1.
XG for relative clauses.
(4)tion of the rule for 'rel__marker' ,  at the node marked(*) in the figure.
One can say that the left extraposi-tion has been "reversed" in the derivation by the useof this rule, which may be looked at as repositioning' trace' to the right, thus "reversing" the extrapositionof the original sentence.In the rest of this paper, I often refer to a constitu-ent being repositioned into a bracketed string (or into afragment of derivation graph), to mean that a rulehaving that constituent as a non-leading symbol in theleft-hand side has been applied, and the symbolmatches some symbol in the string (or corresponds tosome edge in the fragment).
For example, in Figure8.2 the trace 't '  is repositioned into the subgraph withroot 's'.9.
Using the Bracketing ConstraintIn the example of Figure 8.2, there is only oneapplication of a non-DCG rule, at the place marked(*).
However,  we have seen that when a derivationcontains several applications of such rules, the applica-tions must obey the bracketing constraint.
The use ofthe constraint in a grammar is better explained with anexample.
From the sentencesThe mouse squeaks.The cat l i kes  f i sh .The cat chased the mouse.250 Amer ican  Journa l  o f  Computat iona l  L inguist ics ,  Vo lume 7, Number  4, October -December  1981Fernando Pereira Extraposition GrammarsSdet noun te lthe mouser sdet noun relr srelpIthat the+trelp- - I  ~ l  ~eat that chasedverb nptlikesverb npdet nounI\[1Fishvpverbtel\[\]squeaksFigure 9.1.
Violation of the complex-NP constraint.the grammar of Figure 8.1 can derive the followingstring, which violates the complex-NP constraint:* The mouse that  the cat  that  chased l i kes  f i sh  squeaks.The derivation of this ungrammatical string can bebetter understood if we compare it with a sentenceoutside the fragment:The mouse, that  the cat  which chased i t  l i kes  f i sh ,squeaks.where the pronoun 'it' takes the place of the incorrecttrace.The derivation graph for that un-English string isshown in Figure 9.1.
In the graph, (*) and (**) marktwo nested applications of the rule for 'rel marker'.The string is un-English because the higher 'relative'(marked (+)  in the graph) binds a trace occurringinside a sentence which is part of the subordinated'noun___.phrase' (+ +).Now, using the bracketing constraint one can neat-ly express the complex-NP constraint.
It is only neces-sary to change the second rule for 'relative' in Figure8.1 tore la t ive  - -> open, re l _marker ,  sentence,  c lose .
(5)and add the ruleopen .
.
.
c lose  - -> \[ \ ] .
(6)With this modified grammar, it is no longer possible toviolate the complex-NP constraint, because no constit-uent can be reposit ioned from outside into the gapcreated by the application of rule (6) to the result ofapplying the rule for relatives (5).The non-terminals 'open'  and 'close' bracket a sub-derivation.
.
.
open X c lose  .
.
.
=> < X > .
.
.preventing any constituent from being reposit ionedfrom outside that subderivation into it.
Figure 9.2shows the use of rule (6) in the derivation of the sen-tenceThe mouse that  the cat  that  l i kes  f i sh  chased squeaks.This is based on the same three simple sentences asthe ungrammatical  string of Figure 9.1, which theAmerican Journal of Computational Linguistics, Vo lume 7, Number  4, October -December  1981 251Fernando Pereira Extraposition Grammarsdet  nounopentels__....----,0---.---_.det noun "-"--"T'elthe mouseopen r s\[\]t /:\[pJthat the cat thal ttke~verbdet noun relverbClose\[\]_ ____ .
_ i !Jl JFish chasedcl,i PJvpverbpsesqueaksFigure 9.2.
Implementation f the complex-NP constraint.reader can now try to derive in the modified grammar,to see how the bracketing constraint prevents the de-rivation.10.
XGs as Logic ProgramsIn the previous sections, I avoided the complicationof non-terminal arguments.
Although it would be pos-sible to describe fully the operation of XGs in terms ofderivations on bracketed strings, it is much simpler tocomplete the explanation of XGs using the translationof XG rules into definite clauses.
In fact, a rigorousdefinition of XGs independently of definite clauseswould require a formal apparatus very similar to theone needed to formalise definite clause programs inthe first place, and so it would fall outside the scopeof the present paper.
The interested reader will find afull discussion of those issues in two articles by Col-merauer \[2,3\].Like a DCG,  a general XG is no more than a con-venient notation for a set of definite clauses.
An XGnon-terminal of arity n corresponds to an n+4 placepredicate (with the same name).
Of the extra fourarguments, two are used to represent string positionsas in DCGs,  and the other two are used to representpositions in an extraposition list, which carries symbolsto be repositioned.Each element of the extraposition list represents asymbol being repositioned as a 4-tuplex(context, type, symbol, xlist)where context is either 'gap',  if the symbol was preced-ed by '... ' in the rule where it originated, or 'nogap',  ifthe symbol was preceded by ','; type may be 'terminal 'or 'nonterminal' ,  with the obvious meaning; symbol isthe symbol proper; xlist is the remainder of the extra-position list (an empty list being represented by '\[ \]').252 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981Fernando Pereira Extraposition GrammarsAn XG rule is translated into a clause for the pred-icate corresponding to the leading symbol of the rule.In the case where the XG rule has just a single symbolon the left-hand side, the translation is very similar tothat of DCG rules.
For example, the rulesentence --> noun_phrase, verbphrase.translates intosentence(S0,S,X0,X) :-noun_phrase(S0,S1 ,X0,Xl ),verb_phrase(S1 ,S,Xl ,X).A terminal t in the right-hand side of a rule translatesinto a call to the predicate 'terminal', defined below,whose role is analogous to that of 'connects' in DCGs.For example, the rulerel_pronoun --> \[that\]  .translates intore\]_pronoun (S0,S,X0,X) :-terminal (that ,SO ,S ,XO ,X ).The translation of a rule with more than one symbol inthe left-hand side is a bit more complicated.
Informal-ly, each symbol after the first is made into a 4-tuple asdescribed above, and fronted to the extraposition list.Thus, for example, the rulerel_marker .
.
.
trace --> rel_pronoun.translates intorel_marker(SO,S,XO,x(gap,nonterminal ,trace,X)) :-rel_pronoun ( SO, S, XO, X ).Furthermore, for each distinct non-leading non-terminal nt (with arity n) in the left-hand side of a ruleof the XG, the translation includes the clausen/(Vl .
.
.
.
.
Vn,S,S,XO,X) :-v i r tual  (n/(Vl .
.
.
.
.
Vn) ,XO,X).where 'virtual(C,X0,X)', defined later, can be read as"C is the constituent between X0 and X in the extra-position list", and the variables Vi transfer the argu-ments of the symbol in the extraposition list to thepredicate which translates that symbol.For example, the rulemarker(Var), \[the\] .
.
.
\[of.whom\], trace(Var) -->\[whose\].which can be used in a more complex grammar ofrelative clauses to transform "whose X" into "the X ofwhom", corresponds to the clauses:marker(Var,SO,S,XO,x ( nogap, terminal, the,x(gap,terminal ,of,x(nogap ,terminal ,whom,x(nogap,nonterminal ,trace(Var),x ) ) ) )  ) : -termi hal (whose ,SO, S ,XO, X ).trace(Var,S,S,XO,X) :- virtual(trace(Var),XO,X).Finally, the two auxiliary predicates 'virtual' and'terminal' are defined as follows:-virtual(NT, x(C,nonterminal,NT,X), X).terminal(T, SO, S, X, X) :-gap(X), connects(SO, T, S).terminal(T, S, S, x(C,terminal,T,X),  X).gap(x(gap,T,S,X)).gap(\[ \ ] ) .where 'connects' is as for DCOs.These definitions need some comment.
The firstclause for 'terminal' says that, provided the currentextraposition list allows a gap to appear in the deriva-tion, terminal symbol T may be taken from the posi-tion SO in the source string, where T connects SO tosome new position S. The second clause for 'terminal'says that if the next symbol in the current extraposi-tion list is a terminal T, then this symbol can be takenas if it occurred at S in the source string.
The clausefor 'virtual' allows a non-terminal to be "read offfrom" the extraposition list.
* relative(6,9,X,X)* open(6,6,x(gap,nt,trace,x(gap,nt,close,\[\])) ,x(gap,nt,close,x(gap,nt,trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) )* rel_marker(6,7,x(gap,nt,close,x(gap,nt,trace,x(gap,nt,closex(gap,nt,tracex(gap,nt,tracerel_pronoun(6,7,X\[that\]sentence(7,9,x(gapx(gap,nt,tracex(gap,nt,close, \ [ \ ] ) ) ) ,,x(gap,nt,close,,x(gap,nt ,c lose, \ [ \ ] ) ) ) ) ),X),nt,trace,x(gap,nt,close,,x(gap,nt ,c lose, \ [ \ ] ) ) ) ) ,,x(gap,nt,trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) )* noun_phrase(7,7,x(gap,nt,trace,x(gap,nt,close,x(gap,nt , trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) ) ,x(gap,nt,close,x(gap,nt,trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) )* trace(7,7,x(gap,nt,trace,x(gap,nt,close,x(gap,nt , trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) ) ,x(gap,nt,close,x(gap,nt,trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) )* verb_phrase(7,9,X,X)* verb(7,8,X,X)\ [ l ikes\ ]* noun_phrase(8,9,X,X)* determiner(8,8,X,X)* noun(8,9,X,X)\ [ f ish\ ]* relative(9,9,X,X)* close(9,9,x(gap,nt,close,x(gap,nt,trace,x(gap,nt ,c lose, \ [ \ ] ) ) ) ,x(gap,nt,trace,x(gap,nt,c lose,\[ \ ])))Figure 10.1.
Derivation of "that likes fish".Figure 10.1 shows a fragment of the analysis inFigure 9.2, but now in terms of the translation of XGrules into definite clauses.
Points on the sentence arelabelled as follows:American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 253Fernando Pereira Extraposition Grammarsthe mouse that the cat that l ikes f ish chased squeaksI 2 3 4 5 6 7 8 9 10 11The nodes of the analysis fragment, for the relativeclause "that likes fish", are represented by the corre-sponding goals, indented in proport ion to their dis-tance from the root of the graph.
The following con-ventions are used to simplify the figure:?
The leaves (terminals) of the graph are listeddirectly;?
the values of the extraposit ion arguments areexplictly represented only for those goals thatadd or delete something to the extraposition list;for the other goals, the two identical values arerepresented by the variable 'X' ;?
the goals for 'terminal'  and 'virtual' are left outas they can be easily reconstructed from theother goals and the definitions above;?
'nonterminal '  is abbreviated as 'nt'.The definite clause program corresponding to thegrammar for this example is listed in Appendix II.The example shows clearly how the bracketingconstraint works.
Symbols are placed in the extraposi-tion list by rules with more than one symbol in theleft-hand side, and removed by calls to 'virtual', on afirst-in-last-out basis; that is, the extraposition list is astack.
But this property of the extraposition list isexactly what is needed to balance "on the f ly" theauxiliary brackets in the intermediate steps of a deri-vation.Being no more than a logic program, an XG can beused for analysis and for synthesis in the same way asa DCG.
For instance, to determine whether a string swith initial point initial and final point final is in thelanguage defined by the XG of Figure 8.1, one tries toprove the goal statement?-sentence(initial, final,\[ 3,\[ 3).As for DCGs, the string s can be represented in sever-al ways.
If it is represented as a list, the above goalwould be written?-sentence(s,\[ \ ] , \ [  \ ] , \ [  \]).The last two arguments of the goal are '\[ \]' to meanthat the overall extraposit ion list goes from '\[ \]' to'\[ \]'; i.e., it is the empty list.
Thus, no constituent canbe repositioned into or out of the top level 'sentence'.11.
Conc lus ions  and Further WorkIn this paper I have proposed an extension ofDCGs.
The motivation for this extension was to pro-vide a simple formal device to describe the structure ofsuch important natural language constructions as rela-tive clauses and interrogative sentences.
In transforma-tional grammar, these constructions have usually beenanalysed in terms of left extraposition, together withglobal constraints, such as the complex-NP constraint,which restrict the range of the extraposition.
Globalconstraints are not explicit in the grammar ules, butare given externally to be enforced across rule applica-tions.
These external global constraints cause theoret-ical difficulties, because the formal properties of theresulting systems are far from evident, and practicaldifficulties, because they lead to obscure grammarsand prevent the use of any reasonable parsing algor-ithm.DCGs,  although they provide the basic machineryfor a clear description of languages and their struc-tures, lack a mechanism to describe simply left extra-position and the associated restrictions.
MGs canexpress the rewrite of several symbols in a single rule,but the symbols must be contiguous, as in a type-0grammar ule.
This is still not enough to describe leftextraposit ion without complicating the rest of thegrammar.
XGs are an answer to those limitations.An XG has the same fundamental  property as aDCG,  that it is no more than a convenient notationfor the clauses of an ordinary logic program.
XGs andtheir translation into definite clauses have been de-signed to meet three requirements: (i) to be a princi-pled extension of DCGs,  which can be interpreted as agrammar formalism independently of its translationinto definite clauses; (ii) to provide for simple descrip-tion of left extraposition and related restrictions; (iii)to be comparable in efficiency with DCGS when exec-uted by PROLOG.
It turns out that these requirementsare not contradictory, and that the resulting design isextremely simple.
The restrictions on extraposition arenaturally expressed in terms of scope, and scope isexpressed in the formalism by "bracketing out" sub-derivations corresponding to balanced strings.
Thenotion of bracketed string derivation is introduced inorder to describe extraposit ion and bracketing inde-pendently of the translation of XGs into logic pro-grams.Some questions about XGs have not been tackledin this paper.
First, from a theoretical point of view itwould be necessary to complete the independent char-acterisation of XGs in terms of bracketed strings, andshow rigorously that the translation of XGs into logicprograms correctly renders this independent character-isation of the semantics of XGs.
As pointed out be-fore, this formalisation does not offer any substantialproblems.Next, it is not clear whether XGs are as general asthey could be.
For instance, it might be possible toextend them to handle right extraposition of constitu-ents, which, although less common than left extraposi-tion, can be used to describe quite frequent Englishconstructions, such as the gap between head noun andrelative clause in:What f i l es  are there that were created today?254 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981Fernando Pereira Extraposition GrammarsIt may however be possible to describe such situationsin terms of left extraposition of some other constituent(e.g.
the verb phrase "are there" in the exampleabove).Finally, I have been looking at what transforma-tions should be applied to an XG developed as a cleardescription of a language, so that the resulting gram-mar could be used more efficiently in parsing.
In par-ticular, I have been trying to generalise results on det-erministic parsing of context-free languages into ap-propriate principles of transformation.AcknowledgementsDavid Warren and Michael McCord read drafts ofthis paper, and their comments led to many improve-ments, both in content and in form.
The comments ofthe referees were also very useful.
A British CouncilFellowship partly supported my work in this subject.The computing facilities I used to experiment withXGs and to prepare this paper were made available byBritish Science Research Council grants.Appendix I. Translating XGsThe following PROLOG program (for the DEC-10PROLOG system) defines a predicate 'grammar(Fi le) 'which translates and stores the XG rules contained inFile.
The symbol ' ' as a predicate or functor argu-ment denotes an "anonymous"  variable, i.e.
each suchoccurrence stands for a separate variable with a singleoccurrence.% Definit ion of the grammar ule operators?
- op(1OO1,xfy,(...)).?
- op(t2OO,xfx,(-->)).% Process the XG in Filegrammar(File) :-seeing(Old),see(File),consume,seen,see(Old).% Loop unti l  end of f i l econsume :-repeat,read(X),( X=end of f i l e ,  !
;process(X),fa i l  ).% Process a grammar uleprocess((L-->R)) :- !,expandlhs(L,SO,S,HO,H,P),expandrhs(R,SO,S,HO,H,Q),assertz((P :- Q)), !.% Execute a commandprocess(( :- G)) :- !,G.% Store a normal clauseprocess((P :- Q)) :-assertz((P :- Q)).% Store a unit clauseprocess(P) :-assertz(P).% Translate an XG rule% Translate the left-hand sideexpandlhs(T,SO,S,HO,HI,Q) :-f l a t ten(T , \ [P IL \ ] , \ [ \ ] ) ,front(L,HI,H),tag(P,SO,S,HO,H,Q).f latten((X.. .Y),LO,L) :- !,f latten(X,LO,\[gapl L I \ ] ) ,f lat ten(Y,L I ,L) .f latten((X,Y),LO,L) :- !,flatten(X,LO,\[nogap IL I \ ] ) ,f lat ten(Y,L I ,L) .f l a t ten(X , \ [X lL \ ] , L ) .f ront(\[ \ ] ,H,H).front(\[K,X I L\],HO,H) :-case(X,K,HI,H),front(L,HO,H1).case(\[TITs\],K,HO,x(K,terminal,T,H)) :- !,unwind(Ts,HO,H).case(Nt,K,H,x(K,nonterminal,Nt,H)) :-v i r tual_rule(Nt) .% Create the clause% Nt(S,S,XO,X) :- virtual(Nt,XO,X)% for extraposed symbol Ntv irtual  rule(Nt) :-functor(Nt,F,N),functor(Y,F,N),tag(Y,S,S,Hx,Hy,P),( clause(P,virtual( , , ), ), !
;asserta((P :- virtual(Y,Hx,Hy))) .% Translate the right-hand sideexpandrhs((XI,X2),SO,S,HO,H,Y) :- !,expandrhs(XI,SO,SI,HO,HI,Y1),expandrhs(X2,SI,S,HI,H,Y2),and(YI,Y2,Y).expandrhs((X1;X2),SO,S,HO,H,(Y1;Y2)) :- !,expandor(X1,SO,S,HO,H,Y1),expandor(X2,SO,S,HO,H,Y2).expandrhs({X},S,S,H,H,X) :- .expandrhs(L,SO,S,HO,H,G) :- i s l i s t (L ) ,  !,expandlist(L,SO,S,HO,H,G).expandrhs(X,SO,S,HO,H,Y) :-tag(X,SO,S,HO,H,Y).expandor(X,SO,S,HO,H,Y) :-expandrhs(X,SOa,S,HOa,H,Ya),( S\==SOa, !, SO=SOa, Yb=Ya; and(SO=SOa,Ya,Yb) ,( H\==HOa, !, HO=HOa, Y=Yb; and(HO=HOa,Yb,Y) .expandlist(\[\],S,S,H,H,true).expandlist(\[X\],SO,S,HO,H,terminal(X,SO,S,HO,H) ) :- !.expandlist(\[XIL\],SO,S,HO,H,American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981 255Fernando Pereira Extraposition Grammars(terminal(X,SO,SI,HO,H1),Y)) :-expandlist(L,S1,S,HI,H,Y).tag(P,AI,A2,A3,A4,Q) :-P=..\[FIArgsO\],conc(ArgsO,\[AI,A2,A3,A4\],Args),Q=..\[FIArgs\].and(true,P,P) :- !.and(P,true,P) :- !.and(P,Q,(p,Q)).i s l i s t ( \ [  I \])-i s l i s t ( \ [ \ ] ) .unwind(\[\],H,H) :- !.unwind(\[TITs\],HO,x(nogap,terminal ,T,H))unwind(Ts,HO,H).conc(\[\],L,L) :- !.conc(\[XlL1\],L2,\[XIL3\]) :-conc(LI,L2,L3).Append ix  II.
Def in i te  c lauses for the grammarused in Figure 9.2sentence(SO,S,XO,X) :-noun_phrase(SO,Sl,XO,X1),verb_phrase(SI,S,X1,X).noun_phrase(SO,S,XO,X) :-proper_noun(SO,S,XO,X).noun_phrase(SO,S,XO,X) :-determiner(SO,SI,XO,Xl),noun(S1,S2,X1,X2),relative(S2,S,X2,X).noun_phrase(SO,S,XO,X) :-determiner(SO,S1,XO,Xl),noun(SI,S2,XI,X2),prep_phrase(S2,S,X2,X).noun_phrase(SO,S,XO,X) :-trace(SO,S,XO,X).verb_phrase(SO,S,XO,X) :-verb(SO,Sl,XO,X1),noun_phrase(SI,S,Xl,X).verb_phrase(SO,S,XO,X) :-verb(SO,S,XO,X).relative(SO,SO,X,X).relative(SO,S,XO,X) :-open(SO,Sl,XO,Xl),rel_marker(Sl,S2,Xl,X2),sentence(S2,S3,X2,X3),close(S3,S,X3,X).trace(SO,SO,XO,X) :-virtual(trace,XO,X).rel_marker(SO,S,XO,x(gap,nonterminal,trace,X)) :-rel_pronoun(SO,S,XO,X).prep_phrase(SO,S,XO,X) :-preposition(SO,S1,XO,Xl),noun_phrase(S1,S,XI,X).open(SO,SO,X,x(gap,nonterminal,close,X)).close(SO,SO,XO,X) :-virtual(close,XO,X).References1.
Chomsky,  N. Reflections onLanguage.
Pantheon, 1975.2.
Colmerauer, A.
"Metamorphosis  Grammars . "
In Natural Lan-guage Communication with Computers, L .Bolc (ed.).
Springer-Verlag, 1978.
First appeared as an internal report, 'Les Gram-maires de Metamorphose' ,  in November 19753.
Colmerauer, A.
"Les  Bases Th6oriques de PROLOG."
Grouped'Intell igence Artificielle, U. E. R. de Luminy, Universit6 d'Aix-Marseille II, 1979.4.
Dahl, V. "Un  Syst6me D6ductif d' Interrogation de Banques deDonn6es en Espagnol."
Groupe d'Intell igence Artificielle, U.E.
R. de Luminy, Universit6 d'Aix-Marseil le II, 1977.5.
Gazdar, G. "Engl ish as a Context-Free Language."
School ofSocial Sciences, University of Sussex, April, 1979.6.
Pereira, F. and Warren, D. H. D. "Definite Clause Grammarsfor Language Analysis - A Survey of the Formal ism and aComparison with Augmented Transit ion Networks."
ArtificialIntelligence 13 (1980) 231-278.7.
Pique, J. F. " Interrogation en Francais d 'une Base de Donn6esRelationnelle."
Groupe d'Intell igence Artificielle, U. E. R. deLuminy, Universit6 d'Aix-Marseil le II, 1978.8.
Ross, J. R. Excerpts from 'Constraints on Variables in Syntax'.In G. Harman (ed.
): On Noam Chomsky: Critical Essays, An-chor Books, 1974.9.
Roussel, P. "PROLOG : Manuel  de R6ference et Uti l isation.
"Groupe d'Intell igence Artificielle, U.E.R.
de Luminy, Universit6d'Aix-Marseil le II, 1975.Fernando C.N.
Pereira is a research associate in theDepartment of  Architecture at Edinburgh University, andalso a graduate student in the Department of  ArtificialIntelligence.
He received the M.Sc.
degree in mathemat-ics from Lisbon University in 1975.256 American Journal of Computational Linguistics, Volume 7, Number 4, October-December 1981
