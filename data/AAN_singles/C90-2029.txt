Constraining Tree Adjoining Grammars by UnificationKarin HarbuschDeutsches Forschungszentrum fiir Kiinstl iche lntel l igenzStuhlsatzenhausweg 3, 6600 Saarbr i icken 11F .R .G .Phone: (+49 681) 302 5271, Fax: (+49 681) 302 4261E-Mail :  harb usch@dfki .uni -sb.deAbstractIn a proposal, Vijay-Shanker and Joshi presented a definition for combining ttw two formalisms TreeAdjoining Grammars and PATR unification.
The essential idea for that combination is the separationof the two recursion operations - adjoining and unification - to preserve all properties of bothformalisms which is not desirable for natural anguage applications.
In this paper, a definition for theintegrated use of both processes i  given and the remaining properties of the resulting formalism arediscussed - especially weighing the appropriateness ofthis d~finition for natural anguage processing.i1 Introductioniln the field of natural anguage analysis, UnificationGrammars are a main research topic.
Presently,Unification is defined as extension of context-fleegrmnm~s.Knowing th, e formalism of Tree Adjoining Grammars(in the following called TAGs in short), which isclosely related to context-free gr,'tmmars (in theI611owing abbreviated CFG), the idea arises to replacethe context-free grammar in a Unification Grammar by;t TAG.
The advantage of TAGs is that completecontext-fl'ee derivation trees or parts of them build therqles of that grammar type (e.=.,, with the intention of~epresenting a whole linguistic phenomenon).
The~ecursion operation for TAGs allows the replacement ofnodes by a tree (defined by a TAG-rule), so that largert;tructure u'ees are processed.In the literature, a first definition for combining thesetwo formalisms was proposed, where the main idea isIo sepwate the two recursion processes - adjoining andunification - to preserve all properties of both Here adifferent approach is chosen, where both recursionprocesses are integrated.
The main point to emphasizehere is that the different approaches not only represent a.
';witch between two modes of interpreting the samedefinition, but a change in the properties of theresulting formalism.This can be sirnply demonstrated by the property ofmonotonicity of the unification.
Associated with eachlree of a TAG all sp?ification rules for the unificationare interpreted at once (e.g., represented as linksbetween the DAG representation of the specificationrules at each node in the tree).
If now the recursionprocess of TAGs, the adjoining operation, combinestwo trees, which both have DAGs, a strategy forreinterpretation of specification information must bedefined, because an adjoining modifies inner nodes,where links still are installed.la the following, the two formalisms are brieflyrevisited to have a common terminological basis withrite reader, before the existing definition of TreeAdjoining Grammars with Unification is presented.
Incontrast to this approach, the new definition ismotivated and its properties are discussed.
Finally, ourexperience with an implementation f that definition inthe application domain of syntax analysis (e.g., in anatural language dialogue system) is summarized.2 The Two Basic  Formal i sms  TAGand PATRIn this section, the formalism of TAGs is motivated tobe appropriate to replace a context-free grammar innatural language description.
Weighing thedisadvantages remaining for TAGs, which are the seaneas for CFGs, the same extending formalism as forCFGs - Unification Grammars - has been chosen toresolve these disadvantages for TAGs.2.1 A Short  Out l ine of Tree AdjoiningGrammarsIn 1975, the formalism of Tree Adjoining Grammars(TAGs) was introduced by Aravind K. Joshi, Leon S.Levy and Masako Takahashi (see \[Joshi et al 75\]).Since then, a wide variety of properties - formalproperties as well as linguistically relevant ones - werestudied (see, e.g., \[Joshi 85\] for a good overview).The following example describing the crosseddependencies in Dutch should illustrate the formalism(see Figure 1, where the node numbers written inslanted font should be ignored here, they make sense incombination with Figure 3).
A TAG is a treegeneration system.
It consists of two different sets oftrees, which are combinable.
Intuitively, the set ofinitial trees can be seen as context-free derivation trees.This means, the start symbol is the root node, all innernodes are nonterminals and all leaves are terminals(e.g., in Figure 1 tree ~).
The second set, the auxiliarytrees, which can replace a node in an initial tree (whichis possibly modified by further adjoinings) during theprocess of adjoining, must have a form that again aderivation tree results.
The trees ~31 and \[~2 demonstratethat restriction.
A special leaf (the foot node) mustexist, labelled with the same nonterminal as the rootnode is labelled with.
Further, it is obligatory that anauxiliary tree derives at least one terminal.
The union ofthe initial mid the auxili~u:y trees, so to speak the set ofrules of a 'FAG, is called lhe set of elementary trees.1 16 7Tree y in Figure 1 shows a TAG derivation tree, whichis an initial tree with an arbitrary number of adjoinings(here \[51 is adjoined at the node S* in ct and ~2 in thenode S* in the adjoined tree 131).or: So0vr?NlPol 1 VP zwern-iol2men~0111~30121Marie13x: Slo ~=: S~oA("/XyN $1121V121122 Jan zag 1111 \[ IPiet~.
S ooI too?
~ latenJan NP111 VP_ zagIMarieFigure 1: A small sample TAG demonstrating theprocess of adjoiningThe most obvious property of TAG rules (elementarytrees), which arises from the close relation withcontext-free derivation trees - with which linguists arefamiliar - is the easy way to write and understand suchrules.
The advantage instead of a context-free grammarproducing the derivation trees is that related facts can bedescribed in one rule.
E.g., in Figure 1, each treecontains exactly the dependent pieces without anyfurther processing (for more examples see, e.g., \[Kroch,Joshi 85\]).With the close relation between TAGs and CFGs, onecan think that both formalisms are equivalent.
ButTAGs are more powerful.
In the linguistic community,it is discussed controversially, how powerful alinguistic formalism should be (see, e.g., Pullum 84\]or \[Shieber 85\]).
TAGs are mildly context-sensitive,which means that they can describe some context-sensitive languages, but not all (e.g., www with w e{a,b} , but ww is acceptable for a TAG).
There is thethesis that natural anguage can be described very wellby a mildly context-sensitive formalism.
But this canonly be empirically confirmed by describing difficultlinguistic phenomenons (here, the example in Figure 1can only give an idea for the appropriateness of TAGsfbr natural language description).If an efficient implementation f a parser for TAGs isdesired (e.g., in a natural anguage access ystem to anexpert system), the existence of polynomial timeacceptors for the word problem of TAGs becomesrelevant (upper time bound O(n 4 log n), see \[Harbusch89\]).
On the basis of thi~ efficient algorithm the newdefinition has been implemented which is mentionedlater in the summary.With this short impression of some advantages of theTAG formalism, the disadvantages sbould now betackled.
The main property, which has its roots in theclose relation to context-free grammars, is the sameproblem with subcategorisation.
Further informationencoded in the category name leads to combinatoryexplosion of the grammar.
In the framework of CFGs,this disadvantage is removed by defining a UnificationGr~Jnrnar c?
tending acontext-free grcunmar.2.2 PATR Unification Briefly RevisitedA Unification Grammar U (brief!y called UG or PATRgrammar) consists of a CFG G, where each rule isextended by a possibly empty set of specification rules(for a good introduction to Unification Grammars, e.g.,see \[Shieber 87\]).
Such a rule consists of two pathswhich ,are unified.
A path consists of a number uniquelyreferring to a constituent in the context-free ruletogether with a list of feature names and/or an atomicvalue.A pair (context-free rule, list of specification rules) iscalled unification rule.
E.g.,((S NP VP)) (((0 fset)(1fset))((lfset syntax)(2 fset syntax))((2 fset syntaxverbform) active)))) is such a rule.
Anotherrepresentation of the specification rules is a DAG(d i rected acyc l ic  graph).
Figure 2 shows thisrepresentation forthe above described exauaple rule.
It isbuilt by representing the numbers, feature names andvalues as nodes which are connected in the way riley areput together in the string representation.
Commonprefixes are represented only once.0 ---?set ~,)1 - - f se t  -Lsyntax~2 - - f se t  - - syntax-X-ver  b form - - 'act iveFigure 2: Example of a DAG representation168 2.The pro~'ess of recursion - called un i f i ca t ion  - is definedas an operation of union on all specification rulesaccording to a context-free derivation, loosely spoken.More h)rmally, the result of the unification of twoDAGs x and y (UNIFY(x,y)) is defined inductively as anew DAG z, where- z=x ,  i fx=y,- z = x, if x is atomic and y is empty, and vice versaz = y, if y is atomic and x is empty,- if neither x nor y is atomic, then V features I suchthat II,ul ~ x, II,vl e y, I1,UNIFY(u,v)I e z andV features I such that II,wl ~ (u u v) - (u r~ v),II,wl e z.It is easy to see that this extension of the context-freeformalism allows us to introduce various additionalinformation by specification rules.
The main problemof the formalism is that it has Turing capacity - and soall disadvan 'tages inherited with this power.
Informally,this paper shows that the combination with TAGsrestricts the power of unification.3 The Two Different Definitionsof TAGs with UnificationAlthough Turing capacity is not a wishful property,unification seems to be a good extension for TAGs asspeeif iation rules :(((10(11((11well.
In this section, two different definitions for TAGswith Unification (UTAGs) are presented in a commonterminology to simplify their comparison.3.1 T i le  Def in i t ion  o f  t i le  Grammar  forTAGs  w i th  Un i f i ca t ionSame as to define specification rules according to acontext-free rule, where the relation between both setsis represented by unique node numbers to refer to thedifferent constituents in a rule.
Here, according to an in-itial or an auxiliary tree, these specifications are definedbetween father and sons or between brothers via uniquenode numbers all over the trees.
The trees c~, 131 and ~2in Figure 1 (now interpreting the unique node numbersof the elementary trees) together with the accordingspecifications in Figure 3 describe an example TAGwith Unification, which produces the propagation ofsome syntactic and senmntic information from the lexi-cal items to the root node of the different subsentences.Note that the unique node numbers are also helpful toidentify the individual adjoined trees in the derivationtree.
To prevent he ambiguity resulting from adjoiningthe same tree more than once, the node number of theeliminated node is taken as a prefix for all new nodes.
(((00 fset)(01 fset))((01 fset)(02 fset))((01 fset)(012 set))((011 fset)(012 fset))((012 fset)(0121 fset))((011 fset)(0111 fset)))fset sem_role dep sent action) (((20 fset sere_role dep_sent action)fset sem_role action)) (22 fset sere_role action))fset)(12 fset)) ((20 fset sem role dep_sent dep_sent action)((11 fset)(112 fset))((111 fset)(112 fset))((111 fset)(1111 fset))((11 2 fset)(1121 fset)((112 fset sem_role dep_sent actor)(1121 fset sem_role actor)))Lexicon(22 fset sem__role dep_sent action))((21 fset)(22 fset))((211 fset)(211 fset))((22 fset)(222 fset))((22 fset sem_role dep_sent dep sent actor)(221 fset sem_role dep sent actpr))((22 fset sere_role dep sent actor)(221 fset sem_role actor))): (Marie ((N ((syntax hum) sing)((syntax case) nom)((syntax pers) 3)((synt_role subject) Marie)(sem_role actor) Marie)))((N ((syntax hum) sing)((syntax case) dat)((syntax pers) 3)((syntrole d_obj) Marie) ((sere_role recipient) Marie)) )((N ((syntax num) sing)((syntax case) acc)((syntax pers) 3)((syntrole i d obj) Marie)((sem_role recipient) Marie))))... same information for Jan and Piet ...(zwemmen ((V ((syntax verbform) inf)((syntrole verb) zwemmen)((synt role subject))((synt_role d_obj) NONE)((syntrole i d obj) NONE)((sem_role action ) zwemmen))(laten ((V ((syntax verbform) inf)((syntrole verb)laten)syntrole d_obj) NONE)((syntrole i d obj) NONE)(((sem role action) laten)))(zag ((V ((syntax verbform) fin) ((syntax pers) 3)((syntax hum) sing)((syntrole verb) zagen)((synt_role d_obj) NONE)((synt_role i d obj) NONE)((sem_role action) zagen)))Figure 3: Specification rules for c~, 131 and 132 in Figure 13 169To get an impression of what that grammar does, onecan read all relations between father and sons in allinitial and auxiliary trees as context-free rules annotatedwith the corresponding specification rules.To realize this partial interpretation of specificationrules, the following sets for each node x are defined:l"x := the set of all specification rules with x father orbrother of the other mentioned node in that rule,Sx := the set of all specification rules, where x is a sonof the further mentioned node in that rule and0x := the set of all specification rules, where a value ofx is defined.It is easy to see that for each node these sets can beautomatically computed.
E.g, for the node 01 in c~, 1"01:= {(((00 fset)(01 fset)), ((01 fset)(02 fset))}, $01 :={(((01 fest)(012 fset))}, 001 := ~.
Vijay-Shanker andJoshi prefer to write the grammar in the 1" (TOP, orbriefly called t) and $ (BOTTOM, b) terminology,which allows slide differences in expressiveness, e.g., anon-empty TOP set of the root node of an auxiliary treecan be specified.The Unification Grammar, consisting of all rules builtby interpreting each father and all its sons in allelementary trees as context-free rules, together with allTOP sets, can be interpreted as described in section 2.2.But it is important to note, the two resulting rammarsare not equivalent, because the context-free grammardoesn't require the derivation of the whole tree, if onecontext-free rule out of it is in use.Considering this simple and intuitive interpretation f aUTAG, the problem of defining adjoining andunification directly for such a grammar becomesobvious.
Only the relations between father and sons orbrothers are interpreted directly, although there are linksdefined over a whole tree.
This is exactly the point,where the two defin~.tions differ.3.2 The Definition of Vijay-Shanker andJoshiThe definition of Vijay-Shanker and Joshi separates thislocal information (for a description of their approachsee, e.g., \[Vijay-Shanker 87\]).
It reminds us of theinterpretation f attributes after computing the context-free derivation tree for an Attribute Grammar (e.g., see\[Aho et al 86\]).In their approach, the 1" and $ sets remain isolated untilall adjoinings are made.
With this strategy it is clearthat the unification cannot be used to reduce the numberof structure trees, which are unificationally ill-formed.More formally spoken, the adjoining is defined asdescribed in Figure 4 (for the reason of uniquelyreferencing to the 1" and $ sets at each node X, t and bwith different bar levels are used).
After all adjoiningswere made, all 1" and $ sets at each node are unified.The disadvantage of this sequential interpretation ofadjoining and unification can be demonstrated by theexample grammar.
In the lexicon, all names, "Marie","Piet" and "Jan", have three different cases (nominative,dative and accusative).
Therefore, three structurallyequivalent trees are produced for each tree c?, \[~1 and ~2.These are structurally combined by adjoining.
Out ofthis collection, by the specification rule, whichdemands a subject, unification selects one correctreading.
But this is checked after building nine differentderivation trees.Figure 4: The adjoining definition for the approach ofVijay-Shanker and JoshiOne way to handle that problem is to use unificationwith disjunction to reduce the set of structurallyequivalent trees.
But this doesn't ackle the problemfundamentally, because it cannot reduce ambiguities,which only can be eliminated by interpreting thespecification rules at once.
This integration is realizedin our new approach.
The different approaches areabbreviated with SUTAG for the more sequentialapproach of Vijay-Shanker and Joshi, and IUTAG for amore integrated approach, which is presented now.3.3 All Integrated Definition for TAG andUnif icationThe basis for our definition is a UTAG given in thenotation as described in section 3.1.
For eachelementary tree, a set of specification rules is defined,which can be interpreted as unified DAGs over thewhole tree.
E.g., the path "fset sem_role action" of node01 has the value "zwemmen".If an adjoining should happen in a node X, for this nodethe sets '\['X, SX and <)X are computed because thisnode and with it "all links from its DAG to other DAGsare replaced by an auxiliary tree.
Structurally, theadjoining looks like the original one for TAGs (andsame as for SUTAGs).
In the case of an adjoining, anode in an (possibly modified) initial tree should bereplaced by a whole auxiliary tree \[3, and all links thatnode had have to be modified by the information of ~.You can imagine the new linked DAGs all over theadjoined Iree as being a filter for the former propagatedinformation.
E.g., information passing a node X, wherean adjoining will take place, must not be supported bythe path from the root to the foot node of the adjoinedauxiliary tree.
So the propagation is stopped somewherein the tree.More formally spoken, the definition of adjoining canbe given as described in Figure 5.
The DAG of thenode, in which the adjoining will take place, isrepresented by$ and $ sets.Here, r and f stand for the whole DAG of the root andfoot node of the auxiliary tree, which will be adjoined.But it is obvious that the 1" set of r is empty as well asthe $ set of f. This is clear because there exists nofather of the root and no son of the foot node wherethese links can end.Using the same terminology for the auxiliary tree as inFigure 4 (r is separated in t" and b', and f in t"  and b"),one can write instead of "UNIFY(t,r)" as well17o 4"UNIFY(t,b')" and for "UNIFY(b,f)" as well"UNIFY(b,t")".
What becomes obvious is that in the:cesulting m~e ach node has a DAG, which is connectedwith the DAGs of its neighbors in the tree.
This waslhe aim of the new definition, always to produce linkedDAGs all over the derivation tree to test for failure ofanification at once.~i  IFY(t'r)NIF?
(b, f)Figure 5: Tile adjoining definition for IUTAGs~ut this is not the complete definition; there are twothings to be added.
One is the concrete handling of theelimination of links and the second is the reintroductionof the value definition of the eliminated node.t~eginning with the elimination of links, the separationinto q" and $ at a node X, an adjoining will take place,means that all information propagated along the node Xis eliminated (e.g., one can imagine a reason mainte-nance system to keep track of that task, so that unifi-cation is no more commutative and independent fromthe time of introducing information).
E.g., informationt'rom a leaf is propagated to the root of the whole tree.This propagation can be interrupted, modit'ied or kepttmtouched if an adjoining takes place.
Intuitively, theadjoined tree can be imagined as a filter for the propa-?~ation.Some extra computation must be done for tile reintro-duction of 'din value inl\-)rmation (0X) in the followingway.
Since tim node, in which a value is defined, willbe eliminated in the case of an adjoining, the questionarises, what should happen to the value definition?tlere, it was decided to find a point for the reintro-duction of that information.
The first idea can be to say,i.~y definition add it to the root node.
But now a fail cant,,e produced in the case ltmt lhe adjoined tree adds parts~f the path to reach that value (e.g., if the valuedefinition in node X with the node number 01 is ((01ilset) val) and in tile root node (10) of the adjoined tree,dm specification rule exists ((10 fset next) (11 fset)), atail is produced because fset has at the same time afeature and a value as successo0.
To allow this propertyto be interpreted without failure, which is desirable forihe idea of defining a filter via adjoining, a computationt)f such paris of paths in the adjoined tree is done to findthe maximal extension of the path, behind which thevalue can be added without producing afail.in this process, called computation of the inheritancehistory, all maximal prefixes of paths in the adjoinedauxiliary tree are computed.
Out of this set, thosecandidates are chosen, which have the value definitionas prefix p. Behind these maximal paths the value isreintroduced.
Because this selection does not alwayshave a unique path at exactly one node as result (e.g., if~-oot and foot node add two different feature namesbehind p, but between both no propagation occurs), atthe end of both paths the value is reintroduced bydefinition.
It is clear that the computation of theinheritance history can be done once for all paths in allauxiliary trees, so that this part of the definition doesn'textend the execution time very much.
The mostelaborate work has to be done in reconstructing thecorrect links all over the derivation tree after anadjoining.
In the worst case, changes of propagation allover the derivation tree are required.To give an idea of how this definition works, in Figure6 the changes during the adjoining of \[31 and 132 in aare represented.
Here only the nominatve reading is inuse, because the lexical reading with case dative andaccusative produces a fail in unification with thevalency description of the verbs.
Concentrating on thefeature path "fset sere_role" (note, we don't claim thatthis is a serious semantics of the sentence!
), first themeaning of "Marie zwemmen" is produced (action is"zwemmen" and actor is "Marie"), which is modifiedduring the adjoining by "Piet laten" and "Jan zag".3.4 Tile Comparison of tile Properties ofSUTAG and IUTAGFinally, let's weigh the two approaches.
A firstimpression in reading both definitions can be that thedifferences are marginal.
It is simply a decision inordering processes.
But a second look offers that there,are more differences.
The ideas of what should berepresented by an adjoining are different.
A SUTAGsupports the monotone idea behind unification and theparallel and absolute presence of propagated knowledge(what is written in tile '1" and ,\[, sets should bepropagated exactly fiom that node all over the treewithot,t any more changes).
In a UTAG, the idea offiltering propagated information has the highestpriority.
Specification information should be revisableby new adjoinings.
Each of the two approaches worksmore efficient for different problem classes, whichcannot be characterized in more detail here.For SUTAGs, the main disadvantage is the lateinterpretation f the specifcation rules.
Especially herelies the motivation for the definition of IUTAGs.
In theabove mentioned example, the focus in describing theadvantage of online unification is demonstated by therepresentation f the intermediate states of the DAGs,but it is clear as well, how the lexical readings withcase equal dative or accusative for "Marie","Pict" and"Jan" are eliminated.Another distinguishing feature of IUTAGs is thatunification is not further a monotone process as it is inSUTAGs (same as for UGs).
Links, which have beeninstalled, can be eliminated.
This is the more formallycircumscribed effect of a filter, which is the intuitiveidea behind that definition.
It is obvious that therealization of that fact is more expensive than to waituntil all adjoinings are realized.
But it comes up with areduction of execution time for invalid readings.Actually, this is a trade off, which has more or lesseffect on the time complexity in the relation in whichspecification rules are used to subcategorize and restrictthe structural descriptions.
Therefore, both definitionsprobably have more lxzrfect application domains.A point which was mentioned as a disadvantage of theUnification formalism, was the Turing capacity.
Forboth definitions of UTAGs, the power is restricted in a5 i71way t!hat no path can be introduced via specificationswithout adding a piece of structure, because thedefinition of an elementary tree requires a non-emptyleaf.
Therefore, the defined unification process underliesthe constant growth property.
At the moment, it is notyet clear, what class of languages can exactly bedescribed with that formalism, but it is obvious that itis less powerful than Turing machines (e.g., languagessuch as a 2n are not describable).
But a result for anupper time bound of an algorithm for that formalism isyet unknown.by 1'(01) reaching 01 in cc by 1'(11) reaching 11 in ~1:and reintroduced at 11 (and reintroduced at 20~r  yd!oining ,of 131) ' , after adjoining of \[32) ntax- veroform- in!
~set'~" .
.
.
.
.
.
fset t-syntax- verbform- inf y\[It \[ule vero-zwemmen , ~, .^, .
.
.
.
.
.
a ~,^~~:1 i - .
d obj-NONE Ld_obj-NONE i d objgem role-actiontzwemmen / , 7.
- , .- ~,  sem_role,~ actlon-laten, - , ~ ~ ~ sent k ac_tj.oj3,, oy 4,(01) reacning 01 in cc - -  .
.
, .
. "
bv .$tl 1 ~ r e a c ~  (ano reintroouceo at 1121 .
.
.
.
.after adjoining of \[31) (and reintroduced at2_21~,fset rsyntax ~-uase-nom after adjoining of ~9)Ipers.
3 fset \[syntax i-ease-nSm-num-sg i ~pers-3 / / "\[synt_role--subject- Marie ~ num-sg \['sem role- ac tork , ,~~ }ynt role--subjeet-fPiet- - ~ " - ~  ~em-roleltactor ~~lep sent L ac t~information at the root of 7:fset, syntax-~erbform-fin' case -nom'pers-3~synt role~'verb-lzagen- ~subject-Jan| ~d _obj-NONEI 'i d__obj-NONE\ 'sem_role~action-laten\ \[actor-Jan\ Idep sent- ac tor - - "~\ \ dep_sen ~action .... " -~  !\[ N I "dep-sent aet?r ~)~ I~ i ~ - d e p  sent aet~Figure 6: Some intermediate states for an example demonstrating the adjoining definition for IUTAGs4 SummaryAlso the UTAG definition can be seen purely as atheoretical result, syntax description as the mostprominent application domain has influenced thedesign.
Therefore, our experience with an imple-mentation of the IUTAG definition running a naturallanguage grammar is mentioned here (for all technicaldetails ee \[Buschauer t al.
89\]).
The system is writtenin Common LISP on a Hewlett Packard machine of the9000 series with emphazise on efficiency.
E.g., theresponse time for a small test grammar and sentences ofa lertgth of about 10 words is less than 10 milli-seconds.
Presently, this pure parser is extended by tools(e.g., consistency check) to build a workbench forlinguists designing IUTAGs.On this basis, more empirical results should beproduced for that domain.
Currently, we work on furtherextensions of the definition (e.g., ID/LP for free wordorder in German).
Our main emphazise lies on theaspect of incrementality.
In this paper the interpretationdirection of the definitions was analysis.
But the otherdirection, the problems in generation are faced now,with the ambitious aim to verify that IUTAGs areappropriate for a bidirectional nd integrated descriptionof syntactic, semantic and pragmatic facts.Literature\[Aho et al 861.
A. V. Aho, R. Sethi, J. D.Ullman: Compilers: Principles, Techniques, andTools, Addison-Wesley, Reading, Massachusetts, 1986.\[Buschauer t al.
89\] B. Buschauer, P. Poller, A.Schauder, K. ttarbusch: Parser fiir TAGs mitUnifikation, "AI-Laboratory" Memo in press,Department of Computer Science, University of theSau'land, Saarbr~icken, FRG, 1989.~ ~  K. Harbusch:  Ef f i z ienteStrukturanalyse natiirlicher Sprache mit Tree AdjoiningGrammars, PhD Thesis, University of Saarland,Sa,'ubriicken, FRG, 1989.\ [ Jo~\ ]  A. K. Joshi: An lntroductior~ to TreeAdjoining Grammars, Technical Report MS-CIS-64,University of Pennsylvania,  Phi ladelphia,Pennsylvania, 1985.\[Josl\]i e t al.
75\] A. K. Joshi, L. S. Levy, M.Takahashi: Tree Adjunct Grammars, Journal of theComputer and System Sciences 10, 1975.\[Kroch, Joshi 85\] A. S. Kroch, A. K. 3oshi: TheLinguistic Relevance of Tree Adjoining Grammars,Technical Report MS-CIS-16, University ofPennsylvania, Philadelphia, Pennsylvania, 1985.\[Pullum 84.\] G. Pullum: On Two Recent Attemptsto Show That English is Not a CFL, ComputationalIJnguistics 10:4, 1984.\ [ ~  S. M. Shieber: Evidence against theContext-Freeness of Natural Langage, Linguistics andPhilosophy 8, 1985.\[Shieber 87_\] S. M. Shieber: An Introduction toUnification-Based Approaches to Grammar, CSLI-Lecture Notes 4, Stanford, California, 1987.\[Vijay-Shanker 87\] K. Vijay-Shanker: A Study ofTree Adjoining Grammars, PhD Thesis, University ofPennsylvania, Philadelphia, Pennsylvania, 1987.172 6
