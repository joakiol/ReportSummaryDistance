AN ISLAND PARSING INTERPRETER FOR THE FULL AUGMENTEDTRANSITION NETWORK FORMALISMJohn & CarrollUniversity of Cambridge Computer LaboratoryCorn Exchange StreetCambridge CB2 3QGEnglandABSTRACTIsland parsing is a powerful technique forparsing with Augmented ~ans i t ion  Networks (ATNs)which was developed and successfully applied in theHWIM speech understanding project.
The HWIMapplication grammar did not, however, exploit Woods'original full ATN specification.
This paperdescribes an island parsing interpreter based onHWIM, but containing substantial and importantextensions to enable it to interpret any grammarwhich conforms to that full specification of 1970.The most important contributions have been toeliminate the need for prior specification of scopeclauses, to provide more power by implementing LIFTRand SENDR actions within the island parsingframework, and to improve the efficiency of thetechniques used to merge together partially-builtislands within the utterance.This paper also presents some observations aboutisland parsing, based on the use of the parserdescribed, and some suggestions for futuredirections for island parsing research.I INTRODUCTIONA.
Island ParsingIn an ordinary ATN parser, the parsing of asentence is performed unidirectionally (normallyleft-to-right); the parser traverses each arc in thedirected graph of the grammar in the same direction,starting from the initial state.An island ATN parser, on the other hand, can startat any point in the transition network with a wordmatch from anywhere in the input string, not just atthe left end, and parse the rest of the stringworking outwards to the left and right, adding wordsto each end of the 'island' formed.
Indeed, any numberof islands can be built, the parser merging theislands together as their boundaries meet.
Clearly,in speech processing, island parsing is well suitedto gearing sentence processing to the most solidinputs from the acoustic anal yser.The main problems with previous implementationsof island parsing for ATNs have been with scopeclauses and LIFTR and SENDR actions; essentially,these problems arise because in island parsingstructure determination has to work from right-to-left as well as in the more usual left-to-rightdirection, i.e.
against the normal parsing flow.B.
Scope ClausesThe ATN formalism provides for actions on thearcs of the network which can set and modify thecontents of 'registers', and arbitrary tests on anarc to determine whether that arc is to be followed.In an island parser, an action or test is referred toas being context-sensitive when it either requiresthe value of a register that is set somewhere to theleft, or changes the value of a register that is usedsomewhere also to the left.
For each contextsensitive action or test, there exists a set ofstates to its left such that the action can safely beperformed if its execution is delayed until theparse has passed through one of these states.
Thislist of states must be expressed, and in the HWIMsystem (Woods, 1976), this is done when writing thegrammar by using a scope clause.
The form of a scopeclause is(SCOPE <scope specification><list of context-sensltive actions>)where the scope specification is the list ofprecursor states.
This requirement for priorspecification of scope clauses clearly adds to theburden of the grammar writer.I have implemented a more satisfactory treatmentof scope clauses.
This is described be lo~ followingthe discussion of LIFTR and SENDR actions, whichrequire special handling in scoping.II LIFTR AND SENDR ACTIONSTwo important actions (indeed it is difficult towrite a grammar of any substantial subset of Englishwithout them) defined by Woods (1970), namely LIFTRand SENDR, present implementation difficulties in anisland parsing interpreter.
These actions wereevidently excluded from the HWIM parser since thereis no mention of them by Woods (1976).The action LIFTR can occur on any arc in thenetwork, to transmit the value of a register up tothe next higher level in the network, whereas SENDRcan only occur on a PUSH arc, to transmit the valueof a register down to a lower level.101A.
LIFTRThe same mechanism can be used to implement LIFTRactions as is used to transmit the result of eachlower level computation up to the next higher levelas the value of the special register '*'.However, LIFTR presents problems with scopeclauses in an island parsing ATN interpreter: if anaction(LIFTR <register> ...)occurs in a sub-network, any action using thatregister in any higher sub-network that PUSHes forthe one containing the LIFTR must be scoped so thatthe action is not performed in a right-to-left parseat least until after the PUSH has been executed'.
Seefigure I.IPUSH//action using <register> here mustbe scoped to before the PUSH arc $\POP\?
(LIFTR <register> .
)Figtre I. Scoping LIFTR actions.So, for example, when parsing English from rightto left, tests that the verb and subject agree inperson and number (if this information is carried inregisters) must be postponed until the PUSH for thebeginning of the subject noun phrase.
Section IIIdescribes how my interpreter takes care of thisscoping problem.B.
SENDRI.
Treatment of actions using SENDRed re~istersSince in a right-to-left parse, lower level sub-networks are traversed before the PUSH to them isperformed, there is no way of knowing the value of aregister that is being SENDRed at least until afterthe PUSH.
Thus all actions involving registers whosevalues depend on the value of that register must hesaved to be executed at the higher level.I have dealt with this by putting such actionsinto SCOPE clauses containing a special new scopespecification, which I call scope SENDR.
Actions withscope SENDR are never executed at the current levelin the network, but are saved and incorporated intothe next higher level subnetwork (possibly with achanged scope specification) during processing ofthe PUSH at that higher level, as follows:-(I) The form on the FOP arc to be returned as thevalue of the special register '*' on return tothe next higher level is put into an explicitLIFTR action.
(2) The scopes of all the saved actions arechanged to the same as those of the SENDRactions on the PUSH arc.
(3) All LIFTR actions are changed to highlvl-setractions (see below).
(q) Scoped calls to lowlvl-start and lowlvl-finish (see below) are put respectivelybefore and after the saved actions.
(5) All the SENDR actions on the PUSH arc are putin front of the lower level saved actions.The rest of the actions on the PUSH are are thenprocessed as normal.
The purposes of the actionslowlvl-start and lowlvl-finish are to respectivelyset up and restore a stack of register contexts(hold-regs), each level in the stack holding theregister contents of one level in the network, withthe base of the stack representing the highest levelof saved actions.
The action highlvl-setr performs aSETR at the next higher level of register contextson the stack.2.
An ExampleA typical sequence of actions in a fragment of anATN network might be as in figure 2.\.----(SENDR regl 'nphrase)PUSH P~P with form\ (BUILDQI(NP +) reg2)/?
(SETR reg2 (GETR regl))F ig~e 2.
A typical fragment of a network.
(SENDR regl 'nphrase)(lowlvl-start)(SETR reg2 (GETR regl))(highlvl -setr * (BUILDQ (NP +) reg2))( lowlvl- finish)I regs :  ((regO pphrase)) lowlvl-regs : NIL hold-regs : NILlowlvl-regs <- ((regl nphrase))l hold-regs <- (((regO pphrase)))regs <- ((regl nphrase))lowlvl-regs <- NILregs <- ((reg2 nphrase) (regl nphrase))hold-regs <- ( ( ( ,  (NP nphrase)) (regO pphrase)))~ regs <- (( ,  (NP nphrase)) (regO pphrase)) hold-regs <- NILFigure 3.
Treatment of SENDR actions.102This would be translated into the list of savedactions on the left of figure 3, and when control hadpassed through a set of states such that the actions'scope specifications were satisfied, execution wouldproduce the sequence of operations shown on theright of the figure.3.
Scope ProblemsAs with LIFTR, SENDR actions need special scopingtreatment: since there can be any type of interactionon a lower level between registers SENDRed andregisters to be LIFTRed, the only safe execution timefor actions using these registers and for actionsreferencing registers whose values depend on them(without engaging in full symbolic execution) iswhen the higher level sub-network has been fullytraversed.
There is a special scope specificationfor th i s -  scope T.III AUTOMATIC SCOPE COMPUTATIONThe process of writing scope clauses into thegrammar for an island parser is laborious, andtherefore prone to error.
The implementationdescribed here can automatically detect all context-sensitive actions and tests and put them into scopeclauses containing suitable (and usually optimal)scope specifications.
Thus the parser can interpretstraight off an ATN grammar that has been writtenfor an ordinary left-to-right parser.The sooping algorithm consists of five passesover the grammar, the first four dealing with theexceptional scoping required by LIFTR and SENDRactions, and the fifth with the rest of the actionsand tests in the network.
Comments on the algorithmfollow the necessarily technical account of it.A.
The Scoping AlgorithmThe five passes of the scoping algorithm will nowbe described, actions and tests in the network beingtreated identically.I.
Pass  IPass one takes care of the scoping problem withLIFTR actions mentioned in the previous section -that a register being LIFTRed must be scoped back atthe higher level to at least before the PUSH arc.But if the register is used on the PUSH arcitself, the scoping algorithm should produce correctscope specifications without needing to treat thisas a special case.
Thus the solution I have adoptedis for the algorithm to check whether the registerappears on the PUSH arc, and i f  not, the dummy action(SETR <register> (GETR <register>))is added to the actions on the PUSH arc.2.
Pass 2The second pass finds, for each sub-network, thenames of all the registers whose values depend onother registers (for use in the subsequent scopingpasses).
It does this by finding the registers usedin each register-setting action (SETR, LIFTR, orSENDR), using knowledge of the register usage of eachfunction used, and for each register which is notbeing assigned to, it appends onto the property-listof the register the name of the register being set inthe current action, and a pointer to that register'sproperty-list.Thus in the end, each register is associated witha list of all the registers in the sub-network whichdepend on the value of that register.3.
Pass 3Pass three deals with scoping SENDR actions,giving them the treatment described at the end ofthe last section - it assigns the scopespecification T to all actions which referenceregisters whose values depend on any of theregisters used in actions on the same PUSH arc as aSENDR action.4.
Pass 4Pass four finds all actions that use registersthat have been passed down from a higher level by aSENDR, and also actions which use registersdependent on those SENDRed registers, giving theactions scope SENDR.5.
Pass 5The rest of the scoping is performed in pass five.Each action is considered in turn, collecting thenames of all registers it uses, and the names ofthose whose values depend on them.
The scopespecification is then computed depending on thecommon pert of all possible paths from the start ofthe current sub-network to any action which isdependent on the action under consideration.
Thislist of states ('left-states') is the intersection ofthe states to the left of each action which uses anyof the collected registers.The algorithm distinguishes the following fourcases for the contents of 'left-states':-(1) If NIL - there are at least two non-intersecting paths from the left to the arccontaining the action which referenceregisters dependent on those in the action,so return scope specification T.(2) All states in 'left-states' are in loops inthe network - it is very difficult to computethe optimal scope specification, so return T(which will always be correct though perhapsnot optimal).
The problem with loops is thatno register should be changed or referencedin a right-to-left parse until control hasfinally passed out of the loop.103(3) The left state o f  the arc containing theaction being scopad is in 'left-states', andthe state is not in a loop-  all dependentactions are to the right of the arc, so returnNIL.
(4) Otherwise - return as scope specification alist of all states in 'left-states' that arenot in loops.If an action does not use any registers, itobviously does not need scoping, and the algorithmbypasses it.
If a scope specification is returned foran action that is already scoped, whether the newscope 'overwrites' the old one depends on what isalready there:-scope SENDR overwrites scope Tscope T overwrites scope <list of states>scope <list of states> is appended to anexisting scope <list of states>B.
Discussion of the Scoping AlgorithmThe algorithm does not produce totally optimalscope specifications in all circumstances: that is,actions may sometimes be scoped so they are savedfor longer in the parse before they are executedthan may strictly be necessary.
The main shortcomingis in dealing with networks where there are two ormore alternative separate paths containing actionsusing registers computed to be interdependent; forexample in scoping the network fragment in figure 4,(NP/(JUMP NP/DET T)(CAT NPR T(SETH noun (BUILDQ (npr *)))(TO NP/POP)) )(NP/DET(CAT ADJ T ... (TO NP/DET))(CAT NOUN T(SETH noun *)(TO NP/POP)) )(NP/POP(POP ... ) )Figure 4.
Scoping with alternative paths.the two actions using register 'noun' are scoped(NP/) but the paths through them are independent andthe register is not used elsewhere, so the actions donot need to be scoped at all.
There does not seem tobe any way around this problem by modifying thealgorithm, but fortunately scope specifications thatare not entirely optimal (as in this case) shouldonly minimally affect the performance of theinterpreter ~hen parsing a sentence.configtvations 'Sconfigs 'I at the boundaries of eachisland that are compatible, and then splice thosethat completely cover a sub-network into as manysuccessively higher levels as possible (by callingWoods' 'Complete-right' function as many times aspossible).
In a real-time speech understandingsystem (depending on the strategy it employed), thetime saved by this method could be critical to thesuccess of the system.V OBSERVATIONS ON THE INTERPRETER IN USEThe parser has been tested (Carroll, 1982) withvarious sized (purely syntactic) grammars,simulating speech processing by the arbitraryselection of one or more words in a typed string asparsing starting points, and the arbitrary additionof words to the left and right of these.It has been observed that the more complex thestructure of the sentence being parsed, the moreSconfigs get generated, and consequently the longerthe parse takes.
There are, however, other lessobvious factors influencing the number of Sconfigsgenerated.Saved TestsSeonfigs tend to proliferate embarrassingly whenthere are many possible paths of JUMP arcs betweenstates on the same level of the grammar due to scopedtests having to be saved and not being immediatelyexecutable.If there are no BENDR actions down to the sub-network containing the JUMPs, then none of the savedtests will have to be carried up to a higher level,and so many of the Sconfigs will be filtered out whenthe POP arc st that level is processed.
But if thereare SENDR actions, the Sconfigs will not be filteredso effectively, will be carried up to higher levels,and at each higher level the number of Sconfigs willmultiply.This Sconfig proliferation and resultingcombinatorial explosion will always be associatedwith island parsing usinog large complex grammarsthat are purely syntact ic~; unfortunately LIFTR andSENDR actions aggravate the problem.
However, theutility of these actions more than outweighs theconsequent decrease in parse-time efficiency.IV MERGING PARTIALLY BUILT ISLANDSIn the HWIM system, to join together two adjacentislands to make one island covering them both, thesmaller island was broken up and the words from itadded onto the end of the larger.
This obviouslywastes all the effort expanded in building thesmaller island.A more efficient method of joining two islandswhich I have implemented, is to merge all the segmentI The state of the parse in an island parser is heldas a list of segment configurations, each of whichrepresents a partial parse covering one or morewords in the utterance.2 It seems that the HWIM parser also encounteredthese problems; their solution was to employsemantic grammars, with a large number of WRD arcs,to use both syntactic and semantic categories onCAT arcs, and to expand the set of constituentspushed for to include "semantic constituents".104B.
Differing Word-OrdersParsing the same sentence with differing ordersof adding the words in it to islands usually resultsin differing numbers of Sconflgs being created.
Forexample, two parses of the sentenceJOHN IS EAGER TO PLEASE.gave the results:-run I run 2Sconfigs generated 388 182parse time (secs.)
1.77 1.08The difference was caused by the fact that in thefirst run, 'IS' was used as an initial island, settingup expectations for more possible distinct finalsentence structures than in the second run, whichstarted with the word 'PLEASE'.
This difference inex pectatlon status reflects the differentstructuring potential of the two words.VI SOME FUTURE DIRECTIONS FOR RESEARCHA~ Parsing ConjunctionsIsland parsing appears to offer a promisingsolution to the problem of parsing written as wellas spoken sentences containing conjunctions;although the ATN formalism is quite powerful inexpressing natural language grammars, it facesproblems deal ing with sentences conta in ingconjunctions: (WRD AND ...) arcs need to be insertedalmost everywhere since AND can conjoin any twoconstituents of the same type.
Boguraev (1982) hassuggested that this problem might be overcome bybuilding islands at each conjunction and parsingoutwards from them.ATN.
For this reason, restrictions might have to beplaced on the ATN grammars used, but this requiresfurther investigation.VII ACKNOWLEDGEMENTSI would like to thank Bran Boguraev for hisguidance during the writing of the interpreter, andfor supplying the ATN grammars I have used.
Thanksalso to Karen Sparck Jones and John Tait for theircomments on earlier drafts of this paper.VIII REFERENCESBoguraev, B.
( 1982 ) personal communication.Carroll, J.
(1982) "An Island Parsing Interpreter forAugmented Transition Networks".
University ofCambridge Computer Laboratory Technical ReportNo .33.Woods, W. (1970) "Transition Network Grammars forNatural Language Analysis".
Communications of theACM, 13, 10, 591-606.Woods, W. et al (1976) ,,Parsers,' in "SpeechUnderstanding Systems".
Bolt, Beranek and Newman Inc.Report Ne.3438, Vol.4, 1-21.Woods, W. (1980) "Cascaded ATN Grammars".
AmericanJournal of Computational Linguistics, 6, I, 1-12.B.
Cascaded Island ParsersThe nuisance of the combinatorial explosion ofSconfig numbers when using large complex grammarsmight be amenable to solution with cascaded islandATN interpreters 3 ; several island parsers could beput on top of each other, each having a separatedomain of respon sib il ity and each passing upcompleted constituents to the next higher ATN.
In his1980 paper, Woods explains how cascading gains the,,factoring,, advantage of allowing alternativeconfigurations in the later stages of the cascade toshare common processing in the earlier stages.
Thisprocessing would otherwise have to be doneindependently - in the case of an island parser,producing duplicate Sconfigs which would contributeto a possible combinatorial explosion.SENDR actions might cause problems, however, ifscoping due to them caused the actions intended toform complete constituents to be saved so that theactions would not be completely performed before thetime came to pass the constituents up to the next3 The idea of cascading was first put forward byWoods (1980), but only in terms of ordinary left-to-right ATN parsers.105
