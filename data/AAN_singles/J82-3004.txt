Coping wi th  Syntact ic  Ambigu i tyorHow to Put the Block in the Box on the Table 1Kenneth ChurchRamesh PatilLaboratory  for  Computer  Sc ienceMassachuset ts  Ins t i tu te  of  Techno logyCambr idge ,  MA 02139Sentences are far more ambiguous than one might have thought.
There may behundreds, perhaps thousands, of syntactic parse trees for certain very natural sentences ofEnglish.
This fact has been a major problem confronting natural language processing,especially when a large percentage of the syntactic parse trees are enumerated duringsemantic/pragmatic processing.
In this paper we propose some methods for dealing withsyntactic ambiguity in ways that exploit certain regularities among alternative parse trees.These regularities will be expressed as linear combinations of ATN networks, and also assums and products of formal power series.
We believe that such encoding of ambiguity willenhance processing, whether syntactic and semantic constraints are processed separately insequence or interleaved together.Most  parsers f ind the set of parse trees by start ingwith the empty  set and adding to it each t ime they f inda new possibi l i ty.
We make the observat ion  that incertain s i tuat ions it would be much more ef f ic ient  towork  in the other  d irect ion,  start ing f rom the universalset (i.e, the set of all b inary  trees) and rul ing trees outwhen the parser  decides that  they cannot  be parses.Rul ing-out  is easier when the set of parse trees is clos-er to the universal  set and rul ing- in is easier when theset of parse trees is c loser to the empty  set.
Rul ing-out  is par t icu lar ly  su i ted for "'every way ambiguous"construct ions uch as prepos i t iona l  phrases that havejust as many parse trees as there are b inary  trees overthe terminal  elements.
Since every tree is a parse,  theparser  doesn ' t  have to rule any of them out.In some sense, this is a formal izat ion  of  an ideathat has been in the l i terature for some time.
That  is,it has been not iced for a long t ime that these sorts ofvery  ambiguous  const ruct ions  are very  di f f icult  for1 This research was supported (in part) by the National Insti-tutes of Health Grant No.
1 P01 LM 03374-02 from the NationalLibrary of Medicine, and by the Defense Advanced Research Pro-jects Agency (DOD) monitored by the Office of Naval Researchunder Contract No.
N00014-75-C-0661.most  pars ing algor i thms,  but  (apparent ly )  not  for peo-ple.
This observat ion  has led some researchers  tohypothes ize  add i t iona l  pars ing  mechan isms,  such aspseudo-at tachment  (Church  1980, pp.
65-71)  2 andpermanent  pred ic tab le  ambigu i ty  (Sager 1973),  so thatthe parser  could "a t tach  all ways"  in a single step.However ,  these mechanisms have always lacked a pre-cise interpretat ion;  we will present  a much more  for-mal way of coping with "every  way ambiguous"  gram-mars,  de f ined  in terms of  Catalan numbers (Knuth1975, pp.
388-389,  531-533) .1.
Ambiguity is a Practical ProblemSentences are far more  ambiguous than one mighthave thought.
Our  exper ience with the EQSP parser(Mart in ,  Church,  and Pati l  1981) indicates that theremay be hundreds ,  perhaps  thousands ,  of  syntact icparse trees for certa in very natura l  sentences of Eng-lish.
For  example ,  cons ider  the fo l lowing sentencewith two prepos i t iona l  phrases:2 The idea of pseudo-attachment was first proposed by Mar-cus (private communication), though Marcus does not accept heformulation in Church 1980.Copyright 1982 by the Association for Computational Linguistics.
Permission to copy without fee all or part of this material is grantedprovided that the copies are not made for direct commercial dvantage and the Journal reference and this copyright notice are included onthe first page.
To copy otherwise, or to republish, requires a fee and/or specific permission.0362-613X/82/030139-11  $03.00American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 139Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguity(1) Put the block in the box on the table.which has two interpretations:(2a) Put the block\[in the box on the table\](2b) Put \[the block in the box\] on the table.These syntactic ambiguities grow "combinator ia l ly"with the number of prepositional phrases.
For exam-ple, when a third PP is added to the sentence above,there are five interpretations:(3a) Put the block \[\[in the box on the table\] in thekitchen\].
(3b) Put the block \[in the box \[on the table in thekitchen\]\].
(3c) Put \[\[the block in the box\] on the table\] in thekitchen.
(3d) Put \[the block \[in the box on the table\]\] in thekitchen.
(3e) Put \[the block in the box\] \[on the table in thekitchen\].When a fourth PP is added, there are fourteen trees,and so on.
This sort of combinatoric ambiguity hasbeen a major problem confronting natural languageprocessing.
In this paper we propose some methodsfor dealing with syntactic ambiguity in ways that takeadvantage of regularities among the alternative parsetrees.In particular, we observe that enumerating theparse trees as above fails to capture the importantgeneral ization that preposit ional phrases are "everyway ambiguous," or more precisely, the set of parsetrees over i PPs is the same as the set of binary treesthat can be constructed over i terminal elements.
No-tice, for example, that there are two possible binarytrees over three elements,(4a) \[ ... block ... \[ ... box ... table ... \]\](4b) \[\[ ... block ... box ...\] ... table ... \]corresponding to (2a) and (2b), respectively, and thatthere are five binary trees over four elements corre-sponding to (3a)- (3c) ,  respectively.PPs, adjuncts, conjuncts, noun-noun modification,stack relative clauses, and other "every wayambiguous" constructions will be treated as primitiveobjects.
They can be combined in various ways toproduce composite constructions, such as lexical ambi-guity, which may also be very ambiguous but not nec-essarily "every way ambiguous."
Lexical ambiguity,for example, will be analyzed as the sum of its senses,or in flow graph terminology (Oppenheim and Schafer1975) as a parallel connection of its senses.
Structuralambiguity, on the other hand, will be analyzed as theproduct of its components, or in flow graph terminolo-gy as a series connection.2.
Formal Power  Ser iesThis section will make the linear systems analogymore precise by relating context- free grammars toformal power series (polynominals).
Formal powerseries are a well-known device in the formal languageliterature (e.g., Salomaa 1973) for developing the alge-braic properties of context-free grammars.
We intro-duce them here to establish a formal basis for ourupcoming discussion of processing issues.The power series for grammar (5a) is (5b).
(5a) NP -,.
John I NPandNP(5b) NP -- John + John and John+ 2John and John and John+ 5John and John and John and John+ 14John and John and John and Johnand John + ...Each term consists of a sentence generated by thegrammar and an ambiguity coeff icient 3 which countshow many ways the sentence can be generated.
Forexample, the sentence " John"  has one parse tree(6a) \[John\] 1 treebecause the zero-th coefficient of the power series isone.
Similarly, the sentence " John and John" also hasone tree because its coefficient is one,(6b) \[John and John\] 1 treeand " John and John and John" has two because itscoefficient is two,(6c) \[\[John and John\] and John\], 2 trees\[John and \[John and John\]\]and " John and John and John and John" has five,(6d) \[John and \[\[John and John\] and John\]\], 5 trees\[John and \[John and \[John and John\]\]\],\[\[\[John and John\], and John\] and John\],\[\[John and \[John and John\]\] and John\],\[\[John and John\] and \[John and John\]\]and so on.
The reader can verify for himself that" John and John and John and John and John"  hasfourteen trees.Note that the power series encapsulates the ambi-guity response of the system (grammar) to all possibleinput sentences.
In this way, the power series is ana-logous to the impulse response in electrical engineer-ing, which encapsulates the response of the system(circuit) to all possible input frequencies.
(Ambiguitycoefficients bear a strong resemblance to frequencycoefficients in Fourier analysis.)
All of these trans-formed representat ion systems (e.g., power series,impulse response, and Fourier series) provide a com-plete description of the system with no loss ofinformation 4 (and no heuristic approximations, forexample, search strategies (Kaplan 1972)).
Trans-3 The formal language literature (Harrison 1978, Salomaa1973) uses the term support instead of ambiguity coefficient.140 American Journal of Computat iona l  Linguistics, Vo lume 8, Number 3-4, Ju ly-December 1982Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguityforms are often very useful because they provide adifferent point of view.
Certain observations are moreeasily seen in the transform space than in the originalspace, and vice versa.This paper will discuss several ways to generate thepower series.
Initially let us consider successive ap-proximation.
Of all the techniques to be presentedhere, successive approximations most closely resemblesthe approach taken by most current chart parsers in-cluding EQSP (Martin, Church, and Patil 1981).
Thealternative approaches take advantage of certain regu-larities in the power series in order to produce thesame results more efficiently.Successive approximation works as follows.
Firstwe translate grammar (5a) into the equation:(7) NP = John + NP.
and.
NPwhere "+"  connects two ways of generating an NPand " . "
concatenates two parts of an NP.
In somesense, we want to "solve" this equation for NP.
Thiscan be accomplished by refining successive approxima-tions.
An initial approximation NP 0 is formed by tak-ing NP to be the empty language,(8a) NP 0 = 0Then we form the next approximation by substitutingthe previous approximation into equation (7), andsimplifying according to the usual rules of algebra(e.g., assuming distributivity, associativity, 5 identityelement, and zero element).
(8b) NP 1 = John -t- NP 0- and.
NP 0= John + 0. and.
0 = JohnWe continue refining the approximation i this way.
(8c) NP 2 = John + NP 1 ?
and.
NP 1= John + John and John(8d) NP 3 = John + NP 2 and NP 2= John + (John + John and John) .
and.
(John + John and John)= John + John and John+ John and John and John+ John and John and John+ John and John and John and John4 This needs a qualification.
It is true that the power seriesprovides a complete description of the ambiguity response to anyinput sentence.
However, the power series representation may belosing some information that would be useful for parsing.
In partic-ular, there might be some cases where it is impossible to recover theparse trees exactly, as we will see, though this may not be tooserious a problem for many practical applications.
That is, it isoften possible to recover most (if not all) of the structure, whichmay be adequate for many applications.5 The careful reader may correctly object to this assumption.We include it here for expository convenience, as it greatly simpli-fies the derivations though it should be noted that many of theresults could be derived without the assumption.
Furthermore, thisassumption is valid for counting ambiguity.
That is, I A " B I *IC I  = IA I  * IB " C I ,  where A ,B ,  and C are sets of trees andI A I denotes the number of members of A, and * is integer multi-plication.= John + John and John+ 2 John and John and John+ John and John and John and JohnEventually, we have NP expressed as an infinitely longpolynominal (5b) above.
This expression can be sim-plified by introducing a notation for exponentiation.Let x i be an abbreviation for multiplying x ?
x ?
... ?
x,i times.
(9) NP = John + John and John+ 2 John (and John) 2+ 5 John (and John) 3+ 14 John (and John) 4-1-  , .
.Note that parentheses are interpreted differently inalgebraic equations than in context- free rules.
Incontext- free rules, parentheses denote optionality,where in equations they denote precedence relationsamong algebraic operations.3.
Catalan NumbersAmbiguity coefficients take on an important practi-cal significance when we can model them directlywithout resorting to successive approximation asabove.
This can result in substantial time and spacesavings in certain special cases where there are muchmore efficient ways to compute the coefficients thansuccessive approximation (chart parsing).
Equation(9) is such a special case; the coefficients follow awel l -known combinator ic series called the CatalanNumbers (Knuth 1975, pp.
388-389, 531-533).
6 Thissection will describe Catalan numbers and their rela-tion to parsing.The first few Catalan numbers are 1, 1, 2, 5, 14,42, 132, 469, 1430, 4862.
They are generated by theclosed form expression: 7(10) Catn= (2n)  - (  2nn - l )This formula can be explained in terms of parenthes-ized expressions, which are equivalent o trees.
Cat nis the number of ways to parenthesize a formula oflength n. There are two conditions on parenthesiza-tion: (a) there must be the same number of open andclose parentheses, and (b) they must be properly nest-ed so that an open parenthesis precedes its matchingclose parenthesis.
The first term counts the number of6 This fact was first pointed out to us by V. Pratt.
We sus-pect that it is a generally well-known result in the formal languagecommunity, though its origin is unclear.7 (~) is known as a binominal coefficient.
It is equivalent o{a!/\[b!
(a-b)!\]},where a!
is equal to the product of all integers between 1 and a.Binomial coefficients are very common in eombinatories where theyare interpreted as the number of ways to pick b objects out of a setof a objects.American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 141Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguitysequences of 2n parentheses, such that there are thesame number of opens and closes.
The second termsubtracts cases violating condition (b).
This explana-tion is elaborated in Knuth 1975, p. 531.It is very useful to know that the ambiguity coeffi-cients are Catalan numbers because this observationenables us to replace equation (9) with (11), whereCat i denotes the i th Catalan number.
(All summationsrange from 0 to oo unless noted otherwise.
)(11) NP = E Cat i John (and John) tiThe i th Catalan number is the number of binary treesthat can be constructed over i phrases.
This theoreti-cal model correctly predicts our practical experiencewith EQSP.
EQSP found exactly the Catalan numberof parse trees for each sentence in the following se-quence.1 It1 It2 It5was the number.was the number of products.was the number of products of products.It was the number of products of productsof products.14 It was the number of products of productsof products of products.These predictions continue to hold with as many asnine prepositional phrases (4862 parse trees).4.
Table LookupWe could improve EQSP's performance on PPs ifwe could find a more efficient way to compute Cata-lan numbers than chart parsing, the method currentlyemployed by EQSP.
Let us propose two alternatives:table lookup and evaluating expression (10) directly.Both are very efficient over practical ranges of n, sayno more than 20 phrases or so.
8 In both cases, theambiguity of a sentence in grammar (5a) can be deter-mined by counting the number of occurrences of "andJohn" and then retrieving the Catalan of that number.These approaches both take linear time (over practicalranges of n), 9 whereas chart parsing requires cubictime to parse sentences in these grammars, a signifi-cant improvement.So far we have shown how to compute in lineartime the number of ambiguous interpretations of asentence in an "every way ambiguous" grammar.However,  we are really interested in finding parsetrees, not just the number of ambiguous interpreta-tions.
We could extend the table lookup algorithm tofind trees rather than ambiguity coefficients, by modif-ying the table to store trees instead of numbers.
Forparsing purposes, Cat i can be thought of as a pointerto the i th entry of the table.
So, for a sentence ingrammar (5a), for example, the machine could countthe number of occurrences of "and John"  and thenretrieve the table entry for that number.index trees0 {\[John\]}1 {\[John and John\]}2 {\[\[John and John\] and John\],\[John and \[John and John\]\]}The table would be more general if i t  did not specifythe lexical items at the leaves.
Let us replace the tableabove withindex trees0 {\[x\]}1 {Ix x\]}2 {\[\[x \] x\], \[x \[x x\]\]}and assume the machine can bind the x's to the appro-priate lexical items.There is a real problem with this table lookup ma-chine.
The parse trees may not be exactly correctbecause the power series computat ion assumed thatmultiplication was associative, which is an appropriateassumption for computing ambiguity, but inappropriatefor constructing trees.
For example, we observed thatprepositional phrases and conjunction are both "everyway ambiguous" grammars because their ambiguitycoefficients are Catalan numbers.
However,  it is notthe case that they generate exactly the same parsetrees.Nevertheless we present the table lookup pseudo-parser here because it seems to be a speculative newapproach with considerable promise.
It is often moreefficient than a real parser, and the trees that it findsmay be just as useful as the correct one for manypractical purposes.
For example, many speech recog-nition projects employ a parser to filter out syntacti-cally inappropriate hypotheses.
However,  a full parseris not really necessary for this task; a recognizer suchas this table lookup pseudo-parser may be perfectlyadequate for this task.
Furthermore, it is often possi-ble to recover the correct trees from the output of thepseudo-parser.
In particular, the difference betweenpreposit ional phrases and conjunction could be ac-counted for by modifying the interpretation of the PPcategory label, so that the trees would be interpretedcorrectly even though they are not exactly correct.8 The table lookup scheme ought to have a way to handle thetheoretical possibility that there are an unlimited number of prepo-sitional phrases.
The table lookup routine will employ a moretraditional parsing algorithm (e.g., Earley's algorithm) when thenumber of phrases in the input sentence is not stored in the table.9 The linear time result depends on the assumption that tablelookup (or closed form computation) can be performed in constanttime.
This may be a fair assumption over practical ranges of n, butit is not true in general?142 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982Kenneth Church and Ramesh Patil Coping with Syntactic AmbiguityThe table lookup approach works for primitivegrammars.
The next two sections show how to de-compose composite grammars into series and parallelcombinations of primitive grammars.
(12a) G = G 1 .G  2 series(12b) G = G 1 + G 2 parallel5.
Parallel Decompos i t ionParallel decomposition can be very useful for deal-ing with lexical ambiguity, as in(13) ...to total with products near profits...where "total"  can be taken as a noun or as a verb, asin"(14a) The accountant brought the daily sales to totalwith products near profits organized accordingto the new law.
noun(14b) The daily sales were ready for the accountantto total with products near profits organizedaccording to the new law.
verbThe analysis of these sentences makes use of theadditivity property of linear systems.
That is, eachcase, (14a) and (14b), is treated separately, and thenthe results are added together.
Assuming "total"  is anoun, there are three prepositional phrases contribut-ing Cat 3 bracketings, and assuming it is a verb, thereare two preposit ional phrases for Cat x ambiguities.Combining the two cases produces Cat 3 + Cat x = 5 +2 = 7 parses.
Adding another prepositional phraseyields Cat 4 + Cat 3 = 14 + 5 = 19 parses.
(EQSPbehaved as predicted in both cases.
)This behavior is generalized by the following powerseries:PN(15) { toV l~ (Cati+l + Cati)(P N)iwhich is the sum of the two cases:(16a) E Cati(P N) i = P N E Cati+i(P N) i nouni>0  i(16b) to V E Cati(P N) i verbiThis observation can be incorporated into the tablelookup pseudo-parser outlined above.
Recall that Cat iis interpreted as the i th index in a table containing allbinary trees dominating i leaves.
Similarly, Cat i +Cati+l will be interpreted as an instruction to"append"  the i th entry and i+1 th entry of the table, t0(17) (ADD-TREES(CAT-TABLE i)(CAT-TABLE(+ i 1)))Let us consider a system where syntactic processingstrictly precedes semantic and pragmatic processing.In such a system, how could we incorporate semantic10 This can be implemented efficiently, given an appropriaterepresentation f sets of trees.and pragmatic heuristics once we have already parsedthe input sentence and found that it was the sum oftwo Catalans?
The parser can simply subtract theinappropriate interpretations.
If the oracle says that"total"  is a verb, then (16a) would be subtracted fromthe combined sum, and if the oracle says that "tota l"is a noun, then (16b) would be subtracted.On the other hand, our analysis is also useful in asystem that interleaves yntactic processing with se-mantic and pragmatic processing.
Suppose that wehad a semantic routine that could disambiguate"total ,"  but only at a very high cost in execution time.We need a way to estimate the usefulness of executingthe semantic routine so that we don't  spend the time ifit is not likely to pay off.
The analysis above providesa very simple way to estimate the benefit of disambig-uating "total ."
If it turns out to be a verb, then (16a)trees have been ruled out, and if it turns out to be anoun, then (16b) trees have been ruled out.
We pref-er our declarative algebraic approach over proceduralheuristic search strategies (e.g., Kaplan 1972) becausewe do not have to specify the order of evaluation.
Wecan delay the binding of decisions until the most op-portune moment.6.
Series Decompos i t ionSuppose we have a non-terminal  S that is a seriescombination of two other non-terminals, NP and VP.By inspection, the power series of S i s :(18) S - -  NP .VPThis result is easily verified when there is an unmistak-able dividing point between the subject and the predi-cate.
For example, the verb " is"  separates the PPs inthe subject from those in the predicate in (19a), butnot in (19b).
(19a) The number of products over sales of ... is nearthe number of sales under ... clearly divided(19b) Is the number of products over sales of ... nearthe number of sales under ...?
not clearly dividedIn (19a), the total number of parse trees is the productof the number of ways of parsing the subject times thenumber of ways of parsing the predicate.
Both thesubject and the predicate produce a Catalan number ofparses, and hence the result is the product of two Ca-talan numbers, which was verified by EQSP (Martin,Church, and Patil 1981, p. 53).
This result can beformalized in terms of the power series:(20) (N  X Cati(P N) i) ( is X Catj(P N) j )i jwhich is formed by taking the product of the two sub-cases:(21a) N X Cati(P N) i subjecti(21b) is X. Catj(P N) j predicateJAmerican Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 143Kenneth Church and Ramesh Patil Coping with Syntactic AmbiguityThe power series says that the ambiguity of a par-ticular sentence is the product of Cat i and Catj, wherei is the number of PPs before " is" and j is the numberafter " is ."
This could be incorporated in the tablelookup parser as an instruction to "mult iply" the i thentry in the table by the jth entry.
Multiplication is across-product operation; L ?
R generates the set ofbinary trees whose left sub-tree 1 is from L and whoseright sub-tree r is from R,- -  m(22) LxR  = {(l ,r)  ll EL&reR}This is a formal definition.
For practical purposes, itmay be more useful for the parser to output the list inthe factored form:(23) (MULT IPLY-TREES(CAT-TABLE i)(CAT-TABLE j))which is much more concise than a list of trees.
It ispossible, for example, that semantic processing cantake advantage of factoring, capturing a semantic gen-eralization that holds across all subjects or all predi-cates.
Imagine, for example, that there is a semanticagreement constraint between predicates and argu-ments.
For example, subjects and predicates mighthave to agree on the feature +human.
Suppose thatwe were given sentences where this constraint wasviolated by all ambiguous interpretations of the sen-tence.
In this case, it would be more efficient to em-ploy a feature vector scheme (Dostert and Thompson1971) which propagates the features in factored form.That is, it computes a feature vector for the union ofall possible subjects, and a vector for the union of allpossible VPs, and then compares (intersects) thesevectors to check if there are any interpretations thatmeet the constraint.
A system such as this, whichkeeps the parses in factored form, is much more effi-cient than one that multiplies them out.
Even if se-mantics cannot take advantage of the factoring, thereis no harm in keeping the representation i factoredform, because it is straightforward to expand (23) intoa list of trees (though it may be somewhat slow).This example is relatively simple because " is"  helpsthe parser determine the value of i and j.
Now let usreturn to example (19b) where " is" does not separatethe two strings of PPs.
Again, we determine the pow-er series by multiplying the two subcases:(24) is (N  ~Cat i (PN)  i) (E. Catj(P N) j )i j= is N E E. Cat i Catj(P N)  l+Ji jHowever,  this form is not so useful for parsingbecause the parser cannot easily determine i and j, thenumber of prepositional phrases in the subject and thenumber in the predicate.
It appears the parser willhave to compute the product of two Catalans for eachway of picking i and j, which is somewhat expensive, itFortunately,  the Catalan function has some specialproperties o that it is possible algebraically to removethe references to i and j.
In the next section we showhow this expression can be reformulated in terms of n,the total number of PPs.6.1 Auto-Convolut ion of Catalan GrammarsSome readers may have noticed that expression(24) is in convolution form.
We will make use of thisin the reformulation.
Notice that the Catalan series isa fixed point under auto-convolution (except for ashift); that is, multiplying a Catalan power series (i.e.,1 + x + 2x 2 + 5x 3 + 14x 4 + ... Cati x i .
.
. )
with itselfproduces another polynomial with Catalan coeffi-cients.
12 The multiplication is worked out for the firstfew terms.1 + x + 2x 2 + 5x 3 + 14x 4 + ...?
1 + x + 2x 2 + 5x 3 + 14x 4 + ...-t-1 + x + 2x 2 + 5x 3 + 14x 4 + ...x + x 2 + 2x 3 -t- 5x 4 -t- ...2x 2 + 2x 3 + 4x 4 + ...5x 3 + 5x 4 -I- ...14x 4 + ...1 + 2x + 5X 2 + 14X 3 + 42X 4 -t- ...This property can be summarized as:(25) ~Cat  ix  i y .Cat j  x j = ECatn+ 1 x ni j nwhere n equals i+j.Intuitively, this equation says that if we have two"every way ambiguous" (Catalan) constructions, andwe combine them in every possible way (convolution),the result is an "every way ambiguous"  (Catalan)construction.
With this observation, equation (24)reduces to:(26) is (N  E. Cati(P N) i ) (E  Catj(P N) j )l j= is N ~ Catn+l(P  N) n nHence the number of parses in the auxiliary-invertedcase is the Catalan of one more than in the non-inverted cases.
As predicted, EQSP found the follow-ing inverted sentences to be more ambiguous thantheir non- inverted counterparts (previously discussedon page 142) by one Catalan number.11 Earley's algorithm and most other context-free parsingalgorithms actually work this way.12 The proof immediately follows from the z-transform of theCatalan series (Knuth 1975, p. 388): zB(z) 2 = B(z) - l.144 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguity1 Was the number?2 Was the number of products?5 Was the number of products of products?14 Was the number of products of productsof products?42 Was the number of products of productsof products of products?1 It was the number.1 It was the number of products.2 It was the number of products of products.5 It was the number of products of productsof products.14 It was the number of products of productsof products of products.How could this result be incorporated into the tablelookup pseudo-parser?
Recall that the pseudo-parserimplements Catalan grammars by returning an indexinto the Catalan table.
For example, if there were iPPs, the parser would return: (CAT-TABLE i).
Wenow extend the indexing scheme so that the parserimplements a series connection of two Catalan gram-mars by returning one higher index than it would for asimple Catalan grammar.
That is, if there were n PPs,the parser would return (CAT-TABLE (+ n 1)).Series connections of Catalan grammars are verycommon in every day natural language, as illustratedby the following two sentences, which have receivedconsiderable attention in the literature because theparser cannot separate the direct object from the pre-positional complement.
(27a) I saw the man on the hill with a telescope ...(27b) Put the block in the box on the table in thekitchen ...Both examples have a Catalan number of ambiguitiesbecause the auto-convolution of a Catalan series yieldsanother Catalan series.
13 This result can improveparsing performance because it suggests ways to re-organize (compile) the grammar so that there will befewer references to quantities that are not readilyavailable.
This re-organization will reap benefits thatchart parsers (e.g., Earley's algorithm) do not current-ly achieve because the re-organization is taking advan-tage of a number of combinatoric regularities, espe-cially convolution, that are not easily encoded into achart.
Section 9 presents an example of the re-organization.13 There is a difference between these two sentences because"put" subcategorizes for two objects unlike "see."
Suppose weanalyze "see" as lexically ambiguous between two senses, one thatselects for exactly two objects like "put" and one that selects forexactly one object as in "I saw it."
The first sense contributes thesame number of parses as "put" and the second sense contributesan additional Catalan factor.6.2 Chart ParsingPerhaps it is worthwhile to reformulate chart pars-ing in our terms in order to show which of the aboveresults can be captured by such an approach andwhich cannot.
Traditionally, chart parsers maintain achart (or matrix) M, whose entries Mij contain the setof category labels that span from position i to positionj in the input sentence.
This is accomplished by find-ing a position k between i and j such that there is aphrase from i to k that can combine with anotherphrase from k to j.
An implementation of the innerloop looks something like:(28) Mij := { }loop for k from i to j doMij := Mij u Mik * MkjEssentially, then, a chart parser is maintaining tlaeinvariant(29) Mij = ~k Mik ?
Mkjwhere addition and multiplication of matrix elements isrelated to parallel and series combination.
Thus chartparsers are able to process very ambiguous entencesin polynomial time, as opposed to exponential  (orCatalan) time.However,  the examples above illustrate cases wherechart parsers are not as efficient as they might be.
Inparticular, chart parsers implement convolution the"long way," by picking each possible dividing point k,and parsing from i to k and from k to j; they do notreduce the convolution of two Catalans as we didabove.
Similarly, chart parsers do not make use of the"every way ambiguous" generalization; given a Cata-lan grammar, chart parsers will eventually enumerateall possible values of i, j, and k.7.
Computing the Power Series Directly from theGrammarThus far, most of our derivations have been justi-fied in terms of successive approximation.
It is alsopossible to derive some interesting (and well-known)results directly from the grammar itself.
Suppose, forthe sake of discussion, that we choose to analyze ad-juncts with a right branching grammar, t4 (By conven-tion, terminal symbols appear in lower case.
)(30) ADJS ~ ad jADJS  I AFirst we translate the grammar into an equation in theusual way.
That is, ADJS is modeled as a parallelcombination of two subgrammars, adj ADJS and A.
(A, the empty string, is modeled as 1 because it is the14 A similar analysis of adjuncts is adopted in Kaplan andBresnan 1981.
This analysis can also be defended on performancegrounds as an efficiency approximation.
(This approximation is inthe spirit of pseudo-attachment (Church 1980).
)American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 145Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguityidentity element under series combination, i.e., multi-plication.
)(31a) ADJS -~ adj ADJS I A(31b) ADJS = adj .ADJS + 1We can simplify (31b) so the right hand side is ex-pressed in terminal symbols alone, with no referencesto non-terminals.
This is very useful for processingbecause it is much easier for the parser to determinethe presence or absence of terminals than of non-terminals.
That is, it is easier for the parser to deter-mine, for example, whether a word is an adj, than it isto decide whether a substring is an ADJS phrase.
Thesimplification moves all references to ADJS to the lefthand side, by subtracting from both sides,(31c) ADJS -ad j  .ADJS = 1factoring the left hand side,(31d) (1 - adj)ADJS = 1and dividing from both sides,(31e) ADJS = (1 -ad j )  -1By performing the long division, we observe that (31)has unit coefficients.adj adj 2(31f) .
1 - 1 + - -  = 1 + ad j  + - -1 - adj 1 - adj 1 - adj= 1 + adj + adj 2 + adj3 - - ~ adj n1-ad j  nGrammars like ADJS will sometimes be referred to as astep, by analogy to a unit step function in electricalengineering.8.
Comput ing the Power  Series from the ATNThis section will re-derive the power series for theunit step grammar directly from the ATN representa-tion by treating the networks as flow graphs(Oppenheim 1975).
The graph transformations pres-ented here are directly analogous to the algebraic sim-plifications employed in the previous section.First we translate the grammar into an ATN in theusual way (Woods 1970).
(32) ADJS-* adjADJS I A(33)ADJS: Cat adj ~_N..~Push ADJ .j...xpopJumpThis graph can be simplified by performing a compileroptimization call tail recursion (Church and Kaplan1981 and references therein).
This transformationreplaces the final push arc with a jump:Jump+Cztadj  ~ , (~Pop(34) ADJS: >JumpTail recursion corresponds directly to the algebraicoperations of moving the ADJS term to the left handside, factoring out the ADJS, and dividing from bothsides.Then we remove the top jump arc by series reduc-tion.
This step corresponds to multiplying by 1 since ajump arc is the ATN representation for the identityelement under series combination.
(35) ADJS:Cat adj ~PopJumpThe loop can be treated as an infinite series:(36) 1 + adj + adj 2 + adj 3 + ...where the zero-th term corresponds to zero iterationsaround the loop, the first term corresponds to a singleiteration, the second term to two iterations, and so on.Recall that (36) is equivalent to:(37) 11 --adjWith this observation, it is possible to open the loop:(38) ADJS: Q1/(l-adj) ~_~PopAfter one final series reduction, the ATN is equivalentto expression (31e) above.
(38g) ADJS: Q .
1/(1-adj) e. .~PopIntuitively, an ATN loop (or step grammar) is a divi-sion operator.
We now have composition operatorsfor parallel composition (addition), series composition(multiplication), and loops (division).An ATN loop can be implemented in terms of thetable lookup scheme discussed above.
First we refor-mulate the loop as an infinite sum:146 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982Kenneth Church and Ramesh Patil Coping with Syntactic Ambiguity(39) 1 = ~ adji1--adj iThen we construct a table so that the i th entry in thetable tells the parser how to parse i occurrences of adj.9.
An ExampleSuppose for example that we were given the fol-lowing grammar:(40a) S ~ NPVPADJS(40b) S --,.
V NP (PP) ADJS ADJS(40c) VP -~ V NP (PP) ADJS(40d) PP-~ PNP(40e) NP -~ N I NPPP(40f) ADJS -~ adj ADJS \] A(In this example we will assume no lexical ambiguityamong N, V, P, and adj.
)By inspection, we notice that NP and PP are Cata-lan grammars and that ADJS is a Step grammar.
(41a) PP = ~ Cat i (PN)  ii>0(41b) NP = N ~ Cati(P N) i1(41c) ADJS = ~ adj iiWith these observations, the parser can process PPs,NPs, and ADJSs by counting the number of occurrenc-es of terminal symbols and looking up those numbersin the appropriate tables.
We now substitute (41a-c)into (40c).
(42) VP = V NP (1 4- PP)ADJS= V (N .~ Cati(P N) i ) ( .~ Cati(P N) i ) (~  adj i)l l 1and simplify the convolution of the two Catalan func-tions(43) VP = V (N  ~.
Cati+l(P N)i)( .~ adj i)1 1so that the parser can also find VPs by just countingcoccurrences of terminal symbols.
Now we simplify(40a-b) so that S phrases can also be parsed by justcounting occurrences of terminal symbols.
First,translate (40a-b) into the equation:(44) S = NPVPADJS  + VNP ( I+PP)  ADJSADJSand then expand VP using (42)(45) S = NP (V NP ( I+PP)  ADJS) ADJS+ V NP ( I+PP)  ADJS ADJSand factor(46) S = (NP + 1) VNP ( I+PP)  ADJS 2That can be simplified considerably because(47) NP (1 + PP) = N .E Cati(P N) i ~ Cati(P N) i1 1--- N .~ Cati+l(P N) i1and(48) ADJS 2 = E adj i Y. adj i ___ ~ (i + 1)adj ii i iso that(49) S = (N .~Cat i (PN)  i + 1)1V N .~ Cati+l(P N) i1Y.
(i + 1)adj iiwhich has the following ATN realization:(50)N "~ Cati (p N)i V N "~ Cat i+l  (p N) iJump"~ (i + l)adj iThe entire example grammar has now been compiledinto a form that is easier for parsing.
This formulasays that sentences are all of the form:(51) S ~* (N(P  N)*) VN (P N)* adj*which could be recognized by the following finite statemachine:(52) S: Jump JumpJump~M.J Jump "~American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 147Kenneth Church and Ramesh Patil Coping with Syntactic AmbiguityFurthermore,  the number of parse trees for a giveninput sentence can be found by multiplying three num-bers: (a) the Catalan of the number of P N's beforethe verb, (b) the Catalan of one more than the num-ber of P N's after the verb, and (c) the ramp of thenumber of adj's.
For example, the sentence(53) The man on the hill saw the boy with a tele-scope yesterday in the morning.has Cat 1 * Cat 2 * 3 = 6 parses.
That is, there is oneway to parse "the man on the hill," two ways to parse"saw the boy with a telescope" ("telescope" is eithera complement of "see"  as in (54a-c) or is attached to"boy"  as in (54d-f)) ,  and three ways to parse theadjuncts (they could both attach to the S (54a,d), orthey could both attach to the VP (54b,e), or theycould split (54c,f)).
(54a)(54b)(54c)(54d)(54e)(54f)\[The man on the hill \[saw the boy with a tele-scope\] \[yesterday in the mornmg.\]\]The man on the hill \[\[saw the boy with a tele-scope\] \[yesterday in the morning.\]\]The man on the hill \[\[saw the boy with a tele-scope\] yesterday\] in the morning.\[The man on the hill saw \[the boy with a tele-scope\] \[yesterday in the morning.\]\]The man on the hill \[saw \[the boy with a tele-scope\] \[yesterday in the morning.\]\]The man on the hill \[saw \[the boy with a tele-scope\] yesterday\] in the morning.All and only these possibilities are permitted by thegrammar.10.
Conc lus ionWe began our discussion with the observation thatcertain grammars are "every way ambiguous" andsuggested that this observation could lead to improvedparsing performance.
Catalan grammars were thenintroduced to remedy the situation so that the proc-essor can delay attachment decisions until it discoverssome more useful constraints.
Until such time, theprocessor can do little more than note that the inputsentence is "every way ambiguous."
We suggestedthat a table lookup scheme might be an effective me-thod to implement such a processor.We then introduced rules for combining primitivegrammars, such as Catalan grammars, into compositegrammars.
This linear systems view "bundles up" allthe parse trees into a single concise description capa-ble of telling us everything we might want to knowabout the parses (including how much it might cost toask a particular question).
This abstract view of ambi-guity enables us to ask questions in the most conven-ient order, and to delay asking until it is clear that thepay-of f  will exceed the cost.
This abstraction wasvery strongly influenced by the notion of delayedbinding.We have presented combination rules in three dif-ferent representation systems: power series, ATNs, andcontext-free grammars, each of which contributed itsown insights.
Power series are convenient for definingthe algebraic operations, ATNs are most suited fordiscussing implementat ion issues, and context- freegrammars enable the shortest derivations.
Perhaps thefollowing quotation best summarizes our motivat ionfor alternating among these three representation sys-tems:A thing or idea seems meaningful only when we have severaldifferent ways to represent i - different perspectives and differ-ent associations.
Then you can turn it around in your mind, so tospeak; however, it seems at the moment you can see it anotherway; you never come to a full stop.
(Minsky 1981, p. 19)In each of these representation schemes, we haveintroduced five primitive grammars: Catalan, UnitStep, 1, and 0, and terminals; and four composit ionrules: addition, subtraction, multiplication, and divi-sion.
We have seen that it is often possible to employthese analytic tools in order to re-organize (compile)the grammar into a form more suitable for processingefficiently.
We have identified certain situationswhere the ambiguity is combinatoric,  and havesketched a few modifications to the grammar that ena-ble processing to proceed in a more efficient manner.In particular, we have observed it to be important forthe grammar to avoid referencing quantities that arenot easily determined, such as the dividing point be-tween a noun phrase and a prepositional phrase as in(55) Put the block in the box on the table in thekitchen ...We have seen that the desired re-organization can beachieved by taking advantage of the fact that the auto-convolution of a Catalan series produces another Ca-talan series.
This reduced processing time from O(n 3)to almost linear time.
Similar analyses have been dis-cussed for a number of lexically and structurally ambi-guous constructions, culminating with the example insection 9, where we transformed a grammar into aform that could be parsed by a single left-to-right passover the terminal elements.
Currently, these grammarreformulations have to be performed by hand.
Itought to be possible to automate this process so thatthe reformulations could be performed by a grammarcompiler.
We leave this project open for future re-search.11.
AcknowledgmentsWe would like to thank Jon Allen, Sarah Ferguson,Lowell Hawkinson, Kris Halvorsen, Bill Long, MitchMarcus, Rohit Parikh, and Peter Szolovits for theirvery useful comments on earlier drafts.
We would148 American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982especially like to thank Bill Martin for initiating theproject.ReferencesChurch, K. 1980 On Memory Limitations in Natural LanguageProcessing.
MIT/LCS/TR-245, and IULC.Church, K. and Kaplan, R. 1981 Removing Recursion from NaturalLanguage Processors Based on Phrase-Structure Grammars.
Paperpresented at Conference on Modeling Human Parsing Strate-gies, University of Texas at Austin.Dostert, B. and Thompson, F. 1971.
How Features Resolve Syn-tactic Ambiguity.
In Minker, J. and Rosenfeld, S., eds., Pro-ceedings of the Symposium on Information Storage and Retrieval.Earley, J.
1970 An Efficient Context-Free Parsing Algorithm,CACM 13:2.Harrison, M. 1978 Introduction to Formal Language Theory.
Addi-son Wesley.Kaplan, R. 1972 Augmented Transition Networks as PsychologicalModels of Sentence Comprehension, Artificial Intelligence,3:77-100.Kaplan, R. and Bresnan, J.
1981 Lexical-Functional Grammar: AFormal System for Grammatical Representation.
In Bresnan, J.,ed., The Mental Representation of Grammatical Relations.
MITPress.Knuth, D. 1975 The Art of Computer Programming.
Vol.
1: Funda-mental Algorithms.
Addison Wesley.Liu, C. and Liu, J.
1975 Linear Systems Analysis.
McGraw Hill.Malhotra, A.
1975 Design Criteria for a Knowledge-Based EnglishLanguage System for Management: An Experimental Analysis.MIT/LCS/TR-  146.Martin, W., Church, K., and Patil, R. 1981 Preliminary Analysis ofa Breadth-First Parsing Algorithm: Theoretical and ExperimentalResults.
MIT/LCS/TR-261.Minsky, M. 1981 Music, Mind, and Meaning.
MIT A.I.
Memo No.616.Oppenheim, A. and Schafer, R. 1975.
Digital Signal Processing.Prentice Hall.Sager, N. 1973 The String Parser for Scientific Literature.
InRustin, R., ed., Natural Language Processing.
Algorithmic Press.Salomaa, A.
1973 Formal Languages.
Academic PressWoods, W. 1970 Transition Network Grammars for Natural Lan-guage Analysis, CACM 13:10.American Journal of Computational Linguistics, Volume 8, Number 3-4, July-December 1982 149
